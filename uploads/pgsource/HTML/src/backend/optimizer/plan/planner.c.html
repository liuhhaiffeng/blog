<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\optimizer\plan\planner.c</title>
<LINK REL=StyleSheet HREF="../../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\optimizer\plan\planner.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:42 2017
</td></tr>
<tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * planner.c 
 *    The query optimizer external interface. 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * 
 * IDENTIFICATION 
 *    src/backend/optimizer/plan/planner.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span> 
<span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>&LT;limits.h&GT;</span> 
<span class='Keyword'>#include </span><span class='String'>&LT;math.h&GT;</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/htup_details.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/parallel.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/sysattr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/xact.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_constraint_fn.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_proc.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_type.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"executor/executor.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"executor/nodeAgg.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"foreign/fdwapi.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"miscadmin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"lib/bipartite_match.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"lib/knapsack.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/makefuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/nodeFuncs.h"</span> 
<span class='Directive'>#ifdef</span> OPTIMIZER_DEBUG 
<span class='Keyword'>#include </span><span class='String'>"nodes/print.h"</span> 
<span class='Directive'>#endif</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/clauses.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/cost.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/pathnode.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/paths.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/plancat.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/planmain.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/planner.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/prep.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/subselect.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/tlist.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/var.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/analyze.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parsetree.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_agg.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"rewrite/rewriteManip.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/dsm_impl.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/rel.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/selfuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/lsyscache.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/syscache.h"</span> 
 
 
<span class='Comment_Multi_Line'>/* GUC parameters */ 
</span><a name="LN61"></a><span class='Keyword'>double</span>      <span class='Declare_Var'>cursor_tuple_fraction</span> <span class='Operator'>= </span><a href="../../../include/optimizer/planmain.h.html#LN28"><span class='Ref_to_Const'>DEFAULT_CURSOR_TUPLE_FRACTION</span></a><span class='Delimiter'>; 
</span><a name="LN62"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>force_parallel_mode</span> <span class='Operator'>= </span><a href="../../../include/optimizer/planmain.h.html#LN22"><span class='Ref_to_EnumConst'>FORCE_PARALLEL_OFF</span></a><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Hook for plugins to get control in planner() */ 
</span><a name="LN65"></a><a href="../../../include/optimizer/planner.h.html#LN21"><span class='Ref_to_Typedef'>planner_hook_type</span></a> <span class='Declare_Var'>planner_hook</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Hook for plugins to get control when grouping_planner() plans upper rels */ 
</span><a name="LN68"></a><a href="../../../include/optimizer/planner.h.html#LN27"><span class='Ref_to_Typedef'>create_upper_paths_hook_type</span></a> <span class='Declare_Var'>create_upper_paths_hook</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* Expression kind codes for preprocess_expression */ 
</span><a name="LN72"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>EXPRKIND_QUAL</span>               <span class='Number'>0</span> 
<a name="LN73"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>EXPRKIND_TARGET</span>             <span class='Number'>1</span> 
<a name="LN74"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>EXPRKIND_RTFUNC</span>             <span class='Number'>2</span> 
<a name="LN75"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>EXPRKIND_RTFUNC_LATERAL</span>     <span class='Number'>3</span> 
<a name="LN76"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>EXPRKIND_VALUES</span>             <span class='Number'>4</span> 
<a name="LN77"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>EXPRKIND_VALUES_LATERAL</span>     <span class='Number'>5</span> 
<a name="LN78"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>EXPRKIND_LIMIT</span>              <span class='Number'>6</span> 
<a name="LN79"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>EXPRKIND_APPINFO</span>            <span class='Number'>7</span> 
<a name="LN80"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>EXPRKIND_PHV</span>                <span class='Number'>8</span> 
<a name="LN81"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>EXPRKIND_TABLESAMPLE</span>        <span class='Number'>9</span> 
<a name="LN82"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>EXPRKIND_ARBITER_ELEM</span>       <span class='Number'>10</span> 
<a name="LN83"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>EXPRKIND_TABLEFUNC</span>          <span class='Number'>11</span> 
<a name="LN84"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>EXPRKIND_TABLEFUNC_LATERAL</span>  <span class='Number'>12</span> 
 
<span class='Comment_Multi_Line'>/* Passthrough data for standard_qp_callback */ 
</span><span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN89"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>tlist</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* preprocessed query targetlist */ 
</span><a name="LN90"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>activeWindows</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* active windows, if any */ 
</span><a name="LN91"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>groupClause</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* overrides parse-&GT;groupClause */ 
</span><a name="LN92"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>standard_qp_extra</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Data specific to grouping sets 
 */ 
</span> 
<span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN100"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>rollups</span><span class='Delimiter'>; 
</span><a name="LN101"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>hash_sets_idx</span><span class='Delimiter'>; 
</span><a name="LN102"></a>    <span class='Keyword'>double</span>      <span class='Declare_Member'>dNumHashGroups</span><span class='Delimiter'>; 
</span><a name="LN103"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>any_hashable</span><span class='Delimiter'>; 
</span><a name="LN104"></a>    <a href="../../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>unsortable_refs</span><span class='Delimiter'>; 
</span><a name="LN105"></a>    <a href="../../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>unhashable_refs</span><span class='Delimiter'>; 
</span><a name="LN106"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>unsortable_sets</span><span class='Delimiter'>; 
</span><a name="LN107"></a>    <span class='Keyword'>int</span>        <span class='Operator'>*</span><span class='Declare_Member'>tleref_to_colnum_map</span><span class='Delimiter'>; 
</span><a name="LN108"></a>} <span class='Declare_Typedef'>grouping_sets_data</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Local functions */ 
</span><a name="LN111"></a><span class='Keyword'>static </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>preprocess_expression</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>expr</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>kind</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN112"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>preprocess_qual_conditions</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>jtnode</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN113"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>inheritance_planner</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN114"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>grouping_planner</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>inheritance_update</span><span class='Delimiter'>, 
</span><a name="LN115"></a>                 <span class='Keyword'>double </span><span class='Declare_Parameter'>tuple_fraction</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN116"></a><span class='Keyword'>static </span><a href="planner.c.html#LN98"><span class='Ref_to_Typedef'>grouping_sets_data</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>preprocess_grouping_sets</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN117"></a><span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>remap_to_groupclause_idx</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>groupClause</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>gsets</span><span class='Delimiter'>, 
</span><a name="LN118"></a>                         <span class='Keyword'>int </span><span class='Operator'>*</span><span class='Declare_Parameter'>tleref_to_colnum_map</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN119"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>preprocess_rowmarks</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN120"></a><span class='Keyword'>static double </span><span class='Declare_Prototype'>preprocess_limit</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN121"></a>                 <span class='Keyword'>double </span><span class='Declare_Parameter'>tuple_fraction</span><span class='Delimiter'>, 
</span><a name="LN122"></a>                 <a href="../../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>offset_est</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>count_est</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN123"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>limit_needed</span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>parse</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN124"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>remove_useless_groupby_columns</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN125"></a><span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>preprocess_groupclause</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>force</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN126"></a><span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>extract_rollup_sets</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>groupingSets</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN127"></a><span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>reorder_grouping_sets</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>groupingSets</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sortclause</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN128"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>standard_qp_callback</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>extra</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN129"></a><span class='Keyword'>static double </span><span class='Declare_Prototype'>get_number_of_groups</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN130"></a>                     <span class='Keyword'>double </span><span class='Declare_Parameter'>path_rows</span><span class='Delimiter'>, 
</span><a name="LN131"></a>                     <a href="planner.c.html#LN98"><span class='Ref_to_Typedef'>grouping_sets_data</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>gd</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN132"></a><span class='Keyword'>static </span><a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a> <span class='Declare_Prototype'>estimate_hashagg_tablesize</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, 
</span><a name="LN133"></a>                           <span class='Keyword'>const </span><a href="../../../include/nodes/relation.h.html#LN55"><span class='Ref_to_Struct'>AggClauseCosts</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>agg_costs</span><span class='Delimiter'>, 
</span><a name="LN134"></a>                           <span class='Keyword'>double </span><span class='Declare_Parameter'>dNumGroups</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN135"></a><span class='Keyword'>static </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>create_grouping_paths</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN136"></a>                      <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>input_rel</span><span class='Delimiter'>, 
</span><a name="LN137"></a>                      <a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>target</span><span class='Delimiter'>, 
</span><a name="LN138"></a>                      <span class='Keyword'>const </span><a href="../../../include/nodes/relation.h.html#LN55"><span class='Ref_to_Struct'>AggClauseCosts</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>agg_costs</span><span class='Delimiter'>, 
</span><a name="LN139"></a>                      <a href="planner.c.html#LN98"><span class='Ref_to_Typedef'>grouping_sets_data</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>gd</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN140"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>consider_groupingsets_paths</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN141"></a>                            <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>grouped_rel</span><span class='Delimiter'>, 
</span><a name="LN142"></a>                            <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, 
</span><a name="LN143"></a>                            <span class='Keyword'>bool </span><span class='Declare_Parameter'>is_sorted</span><span class='Delimiter'>, 
</span><a name="LN144"></a>                            <span class='Keyword'>bool </span><span class='Declare_Parameter'>can_hash</span><span class='Delimiter'>, 
</span><a name="LN145"></a>                            <a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>target</span><span class='Delimiter'>, 
</span><a name="LN146"></a>                            <a href="planner.c.html#LN98"><span class='Ref_to_Typedef'>grouping_sets_data</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>gd</span><span class='Delimiter'>, 
</span><a name="LN147"></a>                            <span class='Keyword'>const </span><a href="../../../include/nodes/relation.h.html#LN55"><span class='Ref_to_Struct'>AggClauseCosts</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>agg_costs</span><span class='Delimiter'>, 
</span><a name="LN148"></a>                            <span class='Keyword'>double </span><span class='Declare_Parameter'>dNumGroups</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN149"></a><span class='Keyword'>static </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>create_window_paths</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN150"></a>                    <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>input_rel</span><span class='Delimiter'>, 
</span><a name="LN151"></a>                    <a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>input_target</span><span class='Delimiter'>, 
</span><a name="LN152"></a>                    <a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>output_target</span><span class='Delimiter'>, 
</span><a name="LN153"></a>                    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tlist</span><span class='Delimiter'>, 
</span><a name="LN154"></a>                    <a href="../../../include/optimizer/clauses.h.html#LN22"><span class='Ref_to_Typedef'>WindowFuncLists</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>wflists</span><span class='Delimiter'>, 
</span><a name="LN155"></a>                    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>activeWindows</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN156"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>create_one_window_path</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN157"></a>                       <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>window_rel</span><span class='Delimiter'>, 
</span><a name="LN158"></a>                       <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, 
</span><a name="LN159"></a>                       <a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>input_target</span><span class='Delimiter'>, 
</span><a name="LN160"></a>                       <a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>output_target</span><span class='Delimiter'>, 
</span><a name="LN161"></a>                       <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tlist</span><span class='Delimiter'>, 
</span><a name="LN162"></a>                       <a href="../../../include/optimizer/clauses.h.html#LN22"><span class='Ref_to_Typedef'>WindowFuncLists</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>wflists</span><span class='Delimiter'>, 
</span><a name="LN163"></a>                       <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>activeWindows</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN164"></a><span class='Keyword'>static </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>create_distinct_paths</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN165"></a>                      <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>input_rel</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN166"></a><span class='Keyword'>static </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>create_ordered_paths</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN167"></a>                     <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>input_rel</span><span class='Delimiter'>, 
</span><a name="LN168"></a>                     <a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>target</span><span class='Delimiter'>, 
</span><a name="LN169"></a>                     <span class='Keyword'>double </span><span class='Declare_Parameter'>limit_tuples</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN170"></a><span class='Keyword'>static </span><a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>make_group_input_target</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN171"></a>                        <a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>final_target</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN172"></a><span class='Keyword'>static </span><a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>make_partial_grouping_target</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN173"></a>                             <a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>grouping_target</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN174"></a><span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>postprocess_setop_tlist</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>new_tlist</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>orig_tlist</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN175"></a><span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>select_active_windows</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/optimizer/clauses.h.html#LN22"><span class='Ref_to_Typedef'>WindowFuncLists</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>wflists</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN176"></a><span class='Keyword'>static </span><a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>make_window_input_target</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN177"></a>                         <a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>final_target</span><span class='Delimiter'>, 
</span><a name="LN178"></a>                         <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>activeWindows</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN179"></a><span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>make_pathkeys_for_window</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN1252"><span class='Ref_to_Struct'>WindowClause</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>wc</span><span class='Delimiter'>, 
</span><a name="LN180"></a>                         <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tlist</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN181"></a><span class='Keyword'>static </span><a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>make_sort_input_target</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN182"></a>                       <a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>final_target</span><span class='Delimiter'>, 
</span><a name="LN183"></a>                       <span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>have_postponed_srfs</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN184"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>adjust_paths_for_srfs</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN185"></a>                      <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>targets</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>targets_contain_srfs</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/***************************************************************************** 
 * 
 *     Query optimizer entry point 
 * 
 * To support loadable plugins that monitor or modify planner behavior, 
 * we provide a hook variable that lets a plugin get control before and 
 * after the standard planning process.  The plugin would normally call 
 * standard_planner(). 
 * 
 * Note to plugin authors: standard_planner() scribbles on its Query input, 
 * so you'd better copy that data structure if you want to plan more than once. 
 * 
 *****************************************************************************/ 
</span><a href="../../../include/nodes/plannodes.h.html#LN40"><span class='Ref_to_Struct'>PlannedStmt</span></a> <span class='Operator'>* 
</span><a name="LN202"></a><span class='Declare_Function'>planner</span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>parse</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>cursorOptions</span><span class='Delimiter'>, </span><a href="../../../include/nodes/params.h.html#LN61"><span class='Ref_to_Typedef'>ParamListInfo</span></a> <span class='Declare_Parameter'>boundParams</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN204"></a>    <a href="../../../include/nodes/plannodes.h.html#LN40"><span class='Ref_to_Struct'>PlannedStmt</span></a> <span class='Operator'>*</span><span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN65"><span class='Ref_to_Global_Var'>planner_hook</span></a><span class='Parentheses'>) 
</span>        <a href="planner.c.html#LN204"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="planner.c.html#LN65"><span class='Ref_to_Global_Var'>planner_hook</span></a><span class='Parentheses'>) (</span><a href="planner.c.html#LN202"><span class='Ref_to_Parameter'>parse</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN202"><span class='Ref_to_Parameter'>cursorOptions</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN202"><span class='Ref_to_Parameter'>boundParams</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="planner.c.html#LN204"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/planner.h.html#LN36"><span class='Ref_to_Proto'>standard_planner</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN202"><span class='Ref_to_Parameter'>parse</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN202"><span class='Ref_to_Parameter'>cursorOptions</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN202"><span class='Ref_to_Parameter'>boundParams</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="planner.c.html#LN204"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
} 
</span> 
<a href="../../../include/nodes/plannodes.h.html#LN40"><span class='Ref_to_Struct'>PlannedStmt</span></a> <span class='Operator'>* 
</span><a name="LN214"></a><span class='Declare_Function'>standard_planner</span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>parse</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>cursorOptions</span><span class='Delimiter'>, </span><a href="../../../include/nodes/params.h.html#LN61"><span class='Ref_to_Typedef'>ParamListInfo</span></a> <span class='Declare_Parameter'>boundParams</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN216"></a>    <a href="../../../include/nodes/plannodes.h.html#LN40"><span class='Ref_to_Struct'>PlannedStmt</span></a> <span class='Operator'>*</span><span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span><a name="LN217"></a>    <a href="../../../include/nodes/relation.h.html#LN91"><span class='Ref_to_Struct'>PlannerGlobal</span></a> <span class='Operator'>*</span><span class='Declare_Local'>glob</span><span class='Delimiter'>; 
</span><a name="LN218"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>tuple_fraction</span><span class='Delimiter'>; 
</span><a name="LN219"></a>    <a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>root</span><span class='Delimiter'>; 
</span><a name="LN220"></a>    <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>final_rel</span><span class='Delimiter'>; 
</span><a name="LN221"></a>    <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>best_path</span><span class='Delimiter'>; 
</span><a name="LN222"></a>    <a href="../../../include/nodes/plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>top_plan</span><span class='Delimiter'>; 
</span><a name="LN223"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lp</span><span class='Delimiter'>, 
</span><a name="LN224"></a>               <span class='Operator'>*</span><span class='Declare_Local'>lr</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Set up global state for this planner invocation.  This data is needed 
     * across all levels of sub-Query that might exist in the given command, 
     * so we keep it in a separate struct that's linked to by each per-Query 
     * PlannerInfo. 
     */ 
</span>    <a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN91"><span class='Ref_to_Struct'>PlannerGlobal</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN95"><span class='Ref_to_Member'>boundParams</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN214"><span class='Ref_to_Parameter'>boundParams</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN97"><span class='Ref_to_Member'>subplans</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN99"><span class='Ref_to_Member'>subroots</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN101"><span class='Ref_to_Member'>rewindPlanIDs</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN103"><span class='Ref_to_Member'>finalrtable</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN105"><span class='Ref_to_Member'>finalrowmarks</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN107"><span class='Ref_to_Member'>resultRelations</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN109"><span class='Ref_to_Member'>nonleafResultRelations</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN110"><span class='Ref_to_Member'>rootResultRelations</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN112"><span class='Ref_to_Member'>relationOids</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN114"><span class='Ref_to_Member'>invalItems</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN116"><span class='Ref_to_Member'>nParamExec</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN118"><span class='Ref_to_Member'>lastPHId</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN120"><span class='Ref_to_Member'>lastRowMarkId</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN122"><span class='Ref_to_Member'>lastPlanNodeId</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN124"><span class='Ref_to_Member'>transientPlan</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN126"><span class='Ref_to_Member'>dependsOnRole</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Assess whether it's feasible to use parallel mode for this query. We 
     * can't do this in a standalone backend, or if the command will try to 
     * modify any data, or if this is a cursor operation, or if GUCs are set 
     * to values that don't permit parallelism, or if parallel-unsafe 
     * functions are present in the query tree. 
     * 
     * For now, we don't try to use parallel mode if we're running inside a 
     * parallel worker.  We might eventually be able to relax this 
     * restriction, but for now it seems best not to have parallel workers 
     * trying to create their own parallel workers. 
     * 
     * We can't use parallelism in serializable mode because the predicate 
     * locking code is not parallel-aware.  It's not catastrophic if someone 
     * tries to run a parallel plan in serializable mode; it just won't get 
     * any workers and will run serially.  But it seems like a good heuristic 
     * to assume that the same serialization level will be in effect at plan 
     * time and execution time, so don't generate a parallel plan if we're in 
     * serializable mode. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="planner.c.html#LN214"><span class='Ref_to_Parameter'>cursorOptions</span></a> <span class='Operator'>& </span><a href="../../../include/nodes/parsenodes.h.html#LN2610"><span class='Ref_to_Const'>CURSOR_OPT_PARALLEL_OK</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span> <span class='Operator'>&& 
</span>        <a href="../../utils/init/globals.c.html#LN100"><span class='Ref_to_Global_Var'>IsUnderPostmaster</span></a> <span class='Operator'>&& 
</span>        <a href="../../storage/ipc/dsm_impl.c.html#LN111"><span class='Ref_to_Global_Var'>dynamic_shared_memory_type</span></a> <span class='Operator'>!= </span><a href="../../../include/storage/dsm_impl.h.html#LN16"><span class='Ref_to_Const'>DSM_IMPL_NONE</span></a> <span class='Operator'>&& 
</span>        <a href="planner.c.html#LN214"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN109"><span class='Ref_to_Member'>commandType</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN650"><span class='Ref_to_EnumConst'>CMD_SELECT</span></a> <span class='Operator'>&& 
</span>        <span class='Operator'>!</span><a href="planner.c.html#LN214"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN128"><span class='Ref_to_Member'>hasModifyingCTE</span></a> <span class='Operator'>&& 
</span>        <a href="../path/costsize.c.html#LN115"><span class='Ref_to_Global_Var'>max_parallel_workers_per_gather</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span> <span class='Operator'>&& 
</span>        <span class='Operator'>!</span><a href="../../../include/access/parallel.h.html#LN51"><span class='Ref_to_Macro'>IsParallelWorker</span></a><span class='Parentheses'>() </span><span class='Operator'>&& 
</span>        <span class='Operator'>!</span><a href="../../../include/access/xact.h.html#LN43"><span class='Ref_to_Macro'>IsolationIsSerializable</span></a><span class='Parentheses'>())</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* all the cheap tests pass, so scan the query tree */ 
</span>        <a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN132"><span class='Ref_to_Member'>maxParallelHazard</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/clauses.h.html#LN62"><span class='Ref_to_Proto'>max_parallel_hazard</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN214"><span class='Ref_to_Parameter'>parse</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN128"><span class='Ref_to_Member'>parallelModeOK</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN132"><span class='Ref_to_Member'>maxParallelHazard</span></a> <span class='Operator'>!= </span><a href="../../../include/catalog/pg_proc.h.html#LN5493"><span class='Ref_to_Const'>PROPARALLEL_UNSAFE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* skip the query tree scan, just assume it's unsafe */ 
</span>        <a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN132"><span class='Ref_to_Member'>maxParallelHazard</span></a> <span class='Operator'>= </span><a href="../../../include/catalog/pg_proc.h.html#LN5493"><span class='Ref_to_Const'>PROPARALLEL_UNSAFE</span></a><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN128"><span class='Ref_to_Member'>parallelModeOK</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * glob-&GT;parallelModeNeeded should tell us whether it's necessary to 
     * impose the parallel mode restrictions, but we don't actually want to 
     * impose them unless we choose a parallel plan, so it is normally set 
     * only if a parallel plan is chosen (see create_gather_plan).  That way, 
     * people who mislabel their functions but don't use parallelism anyway 
     * aren't harmed.  But when force_parallel_mode is set, we enable the 
     * restrictions whenever possible for testing purposes. 
     */ 
</span>    <a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN130"><span class='Ref_to_Member'>parallelModeNeeded</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN128"><span class='Ref_to_Member'>parallelModeOK</span></a> <span class='Operator'>&& 
</span>        <span class='Parentheses'>(</span><a href="planner.c.html#LN62"><span class='Ref_to_Global_Var'>force_parallel_mode</span></a> <span class='Operator'>!= </span><a href="../../../include/optimizer/planmain.h.html#LN22"><span class='Ref_to_EnumConst'>FORCE_PARALLEL_OFF</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Determine what fraction of the plan is likely to be scanned */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN214"><span class='Ref_to_Parameter'>cursorOptions</span></a> <span class='Operator'>& </span><a href="../../../include/nodes/parsenodes.h.html#LN2607"><span class='Ref_to_Const'>CURSOR_OPT_FAST_PLAN</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We have no real idea how many tuples the user will ultimately FETCH 
         * from a cursor, but it is often the case that he doesn't want 'em 
         * all, or would prefer a fast-start plan anyway so that he can 
         * process some of the tuples sooner.  Use a GUC parameter to decide 
         * what fraction to optimize for. 
         */ 
</span>        <a href="planner.c.html#LN218"><span class='Ref_To_Local'>tuple_fraction</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN61"><span class='Ref_to_Global_Var'>cursor_tuple_fraction</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We document cursor_tuple_fraction as simply being a fraction, which 
         * means the edge cases 0 and 1 have to be treated specially here.  We 
         * convert 1 to 0 ("all the tuples") and 0 to a very small fraction. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN218"><span class='Ref_To_Local'>tuple_fraction</span></a> <span class='Operator'>&GT;= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <a href="planner.c.html#LN218"><span class='Ref_To_Local'>tuple_fraction</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN218"><span class='Ref_To_Local'>tuple_fraction</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <a href="planner.c.html#LN218"><span class='Ref_To_Local'>tuple_fraction</span></a> <span class='Operator'>= </span><span class='Number'>1e</span><span class='Operator'>-</span><span class='Number'>10</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if cursorOptions&CURSOR_... &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Default assumption is we need all the tuples */ 
</span>        <a href="planner.c.html#LN218"><span class='Ref_To_Local'>tuple_fraction</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* primary planning entry point (may recurse for subqueries) */ 
</span>    <a href="planner.c.html#LN219"><span class='Ref_To_Local'>root</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/planner.h.html#LN39"><span class='Ref_to_Proto'>subquery_planner</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN214"><span class='Ref_to_Parameter'>parse</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                            <span class='Boolean'>false</span><span class='Delimiter'>, </span><a href="planner.c.html#LN218"><span class='Ref_To_Local'>tuple_fraction</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Select best Path and turn it into a Plan */ 
</span>    <a href="planner.c.html#LN220"><span class='Ref_To_Local'>final_rel</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/pathnode.h.html#LN270"><span class='Ref_to_Proto'>fetch_upper_rel</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN219"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN77"><span class='Ref_to_EnumConst'>UPPERREL_FINAL</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN221"><span class='Ref_To_Local'>best_path</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/planner.h.html#LN50"><span class='Ref_to_Proto'>get_cheapest_fractional_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN220"><span class='Ref_To_Local'>final_rel</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN218"><span class='Ref_To_Local'>tuple_fraction</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="planner.c.html#LN222"><span class='Ref_To_Local'>top_plan</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/planmain.h.html#LN49"><span class='Ref_to_Proto'>create_plan</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN219"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN221"><span class='Ref_To_Local'>best_path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If creating a plan for a scrollable cursor, make sure it can run 
     * backwards on demand.  Add a Material node at the top at need. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN214"><span class='Ref_to_Parameter'>cursorOptions</span></a> <span class='Operator'>& </span><a href="../../../include/nodes/parsenodes.h.html#LN2602"><span class='Ref_to_Const'>CURSOR_OPT_SCROLL</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/executor/executor.h.html#LN100"><span class='Ref_to_Proto'>ExecSupportsBackwardScan</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN222"><span class='Ref_To_Local'>top_plan</span></a><span class='Parentheses'>))</span> 
            <a href="planner.c.html#LN222"><span class='Ref_To_Local'>top_plan</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/planmain.h.html#LN54"><span class='Ref_to_Proto'>materialize_finished_plan</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN222"><span class='Ref_To_Local'>top_plan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Optionally add a Gather node for testing purposes, provided this is 
     * actually a safe thing to do. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN62"><span class='Ref_to_Global_Var'>force_parallel_mode</span></a> <span class='Operator'>!= </span><a href="../../../include/optimizer/planmain.h.html#LN22"><span class='Ref_to_EnumConst'>FORCE_PARALLEL_OFF</span></a> <span class='Operator'>&& </span><a href="planner.c.html#LN222"><span class='Ref_To_Local'>top_plan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN137"><span class='Ref_to_Member'>parallel_safe</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN358"></a>        <a href="../../../include/nodes/plannodes.h.html#LN831"><span class='Ref_to_Struct'>Gather</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>gather</span> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/plannodes.h.html#LN831"><span class='Ref_to_Struct'>Gather</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="planner.c.html#LN358"><span class='Ref_To_Local'>gather</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN833"><span class='Ref_to_Member'>plan</span></a><span class='Operator'>.</span><a href="../../../include/nodes/plannodes.h.html#LN143"><span class='Ref_to_Member'>targetlist</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN222"><span class='Ref_To_Local'>top_plan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN143"><span class='Ref_to_Member'>targetlist</span></a><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN358"><span class='Ref_To_Local'>gather</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN833"><span class='Ref_to_Member'>plan</span></a><span class='Operator'>.</span><a href="../../../include/nodes/plannodes.h.html#LN144"><span class='Ref_to_Member'>qual</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN358"><span class='Ref_To_Local'>gather</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN833"><span class='Ref_to_Member'>plan</span></a><span class='Operator'>.</span><a href="../../../include/nodes/plannodes.h.html#LN145"><span class='Ref_to_Member'>lefttree</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN222"><span class='Ref_To_Local'>top_plan</span></a><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN358"><span class='Ref_To_Local'>gather</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN833"><span class='Ref_to_Member'>plan</span></a><span class='Operator'>.</span><a href="../../../include/nodes/plannodes.h.html#LN146"><span class='Ref_to_Member'>righttree</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN358"><span class='Ref_To_Local'>gather</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN834"><span class='Ref_to_Member'>num_workers</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN358"><span class='Ref_To_Local'>gather</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN835"><span class='Ref_to_Member'>single_copy</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN358"><span class='Ref_To_Local'>gather</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN836"><span class='Ref_to_Member'>invisible</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="planner.c.html#LN62"><span class='Ref_to_Global_Var'>force_parallel_mode</span></a> <span class='Operator'>== </span><a href="../../../include/optimizer/planmain.h.html#LN24"><span class='Ref_to_EnumConst'>FORCE_PARALLEL_REGRESS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Ideally we'd use cost_gather here, but setting up dummy path data 
         * to satisfy it doesn't seem much cleaner than knowing what it does. 
         */ 
</span>        <a href="planner.c.html#LN358"><span class='Ref_To_Local'>gather</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN833"><span class='Ref_to_Member'>plan</span></a><span class='Operator'>.</span><a href="../../../include/nodes/plannodes.h.html#LN124"><span class='Ref_to_Member'>startup_cost</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN222"><span class='Ref_To_Local'>top_plan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN124"><span class='Ref_to_Member'>startup_cost</span></a> <span class='Operator'>+ 
</span>            <a href="../path/costsize.c.html#LN109"><span class='Ref_to_Global_Var'>parallel_setup_cost</span></a><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN358"><span class='Ref_To_Local'>gather</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN833"><span class='Ref_to_Member'>plan</span></a><span class='Operator'>.</span><a href="../../../include/nodes/plannodes.h.html#LN125"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN222"><span class='Ref_To_Local'>top_plan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN125"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>+ 
</span>            <a href="../path/costsize.c.html#LN109"><span class='Ref_to_Global_Var'>parallel_setup_cost</span></a> <span class='Operator'>+ </span><a href="../path/costsize.c.html#LN108"><span class='Ref_to_Global_Var'>parallel_tuple_cost</span></a> <span class='Operator'>* </span><a href="planner.c.html#LN222"><span class='Ref_To_Local'>top_plan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN130"><span class='Ref_to_Member'>plan_rows</span></a><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN358"><span class='Ref_To_Local'>gather</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN833"><span class='Ref_to_Member'>plan</span></a><span class='Operator'>.</span><a href="../../../include/nodes/plannodes.h.html#LN130"><span class='Ref_to_Member'>plan_rows</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN222"><span class='Ref_To_Local'>top_plan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN130"><span class='Ref_to_Member'>plan_rows</span></a><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN358"><span class='Ref_To_Local'>gather</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN833"><span class='Ref_to_Member'>plan</span></a><span class='Operator'>.</span><a href="../../../include/nodes/plannodes.h.html#LN131"><span class='Ref_to_Member'>plan_width</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN222"><span class='Ref_To_Local'>top_plan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN131"><span class='Ref_to_Member'>plan_width</span></a><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN358"><span class='Ref_To_Local'>gather</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN833"><span class='Ref_to_Member'>plan</span></a><span class='Operator'>.</span><a href="../../../include/nodes/plannodes.h.html#LN136"><span class='Ref_to_Member'>parallel_aware</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN358"><span class='Ref_To_Local'>gather</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN833"><span class='Ref_to_Member'>plan</span></a><span class='Operator'>.</span><a href="../../../include/nodes/plannodes.h.html#LN137"><span class='Ref_to_Member'>parallel_safe</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* use parallel mode for parallel plans. */ 
</span>        <a href="planner.c.html#LN219"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN156"><span class='Ref_to_Member'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN130"><span class='Ref_to_Member'>parallelModeNeeded</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
        <a href="planner.c.html#LN222"><span class='Ref_To_Local'>top_plan</span></a> <span class='Operator'>= &</span><a href="planner.c.html#LN358"><span class='Ref_To_Local'>gather</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN833"><span class='Ref_to_Member'>plan</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if force_parallel_mode!=... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * If any Params were generated, run through the plan tree and compute 
     * each plan node's extParam/allParam sets.  Ideally we'd merge this into 
     * set_plan_references' tree traversal, but for now it has to be separate 
     * because we need to visit subplans before not after main plan. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN116"><span class='Ref_to_Member'>nParamExec</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN97"><span class='Ref_to_Member'>subplans</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN99"><span class='Ref_to_Member'>subroots</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN179"><span class='Ref_to_Macro'>forboth</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN223"><span class='Ref_To_Local'>lp</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN97"><span class='Ref_to_Member'>subplans</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN224"><span class='Ref_To_Local'>lr</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN99"><span class='Ref_to_Member'>subroots</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN398"></a>            <a href="../../../include/nodes/plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>subplan</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN223"><span class='Ref_To_Local'>lp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN399"></a>            <a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>subroot</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN224"><span class='Ref_To_Local'>lr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/optimizer/subselect.h.html#LN30"><span class='Ref_to_Proto'>SS_finalize_plan</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN399"><span class='Ref_To_Local'>subroot</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN398"><span class='Ref_To_Local'>subplan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="../../../include/optimizer/subselect.h.html#LN30"><span class='Ref_to_Proto'>SS_finalize_plan</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN219"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN222"><span class='Ref_To_Local'>top_plan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* final cleanup of the plan */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN103"><span class='Ref_to_Member'>finalrtable</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN105"><span class='Ref_to_Member'>finalrowmarks</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN107"><span class='Ref_to_Member'>resultRelations</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN109"><span class='Ref_to_Member'>nonleafResultRelations</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN110"><span class='Ref_to_Member'>rootResultRelations</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN222"><span class='Ref_To_Local'>top_plan</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/planmain.h.html#LN115"><span class='Ref_to_Proto'>set_plan_references</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN219"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN222"><span class='Ref_To_Local'>top_plan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* ... and the subplans (both regular subplans and initplans) */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN97"><span class='Ref_to_Member'>subplans</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN99"><span class='Ref_to_Member'>subroots</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN179"><span class='Ref_to_Macro'>forboth</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN223"><span class='Ref_To_Local'>lp</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN97"><span class='Ref_to_Member'>subplans</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN224"><span class='Ref_To_Local'>lr</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN99"><span class='Ref_to_Member'>subroots</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN417"></a>        <a href="../../../include/nodes/plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>subplan</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN223"><span class='Ref_To_Local'>lp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN418"></a>        <a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>subroot</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN224"><span class='Ref_To_Local'>lr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN223"><span class='Ref_To_Local'>lp</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="../../../include/optimizer/planmain.h.html#LN115"><span class='Ref_to_Proto'>set_plan_references</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN418"><span class='Ref_To_Local'>subroot</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN417"><span class='Ref_To_Local'>subplan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* build the PlannedStmt result */ 
</span>    <a href="planner.c.html#LN216"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/plannodes.h.html#LN40"><span class='Ref_to_Struct'>PlannedStmt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="planner.c.html#LN216"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN44"><span class='Ref_to_Member'>commandType</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN214"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN109"><span class='Ref_to_Member'>commandType</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN216"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN46"><span class='Ref_to_Member'>queryId</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN214"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN113"><span class='Ref_to_Member'>queryId</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN216"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN48"><span class='Ref_to_Member'>hasReturning</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="planner.c.html#LN214"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN143"><span class='Ref_to_Member'>returningList</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN216"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN50"><span class='Ref_to_Member'>hasModifyingCTE</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN214"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN128"><span class='Ref_to_Member'>hasModifyingCTE</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN216"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN52"><span class='Ref_to_Member'>canSetTag</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN214"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN115"><span class='Ref_to_Member'>canSetTag</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN216"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN54"><span class='Ref_to_Member'>transientPlan</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN124"><span class='Ref_to_Member'>transientPlan</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN216"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN56"><span class='Ref_to_Member'>dependsOnRole</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN126"><span class='Ref_to_Member'>dependsOnRole</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN216"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN58"><span class='Ref_to_Member'>parallelModeNeeded</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN130"><span class='Ref_to_Member'>parallelModeNeeded</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN216"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN60"><span class='Ref_to_Member'>planTree</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN222"><span class='Ref_To_Local'>top_plan</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN216"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN62"><span class='Ref_to_Member'>rtable</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN103"><span class='Ref_to_Member'>finalrtable</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN216"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN65"><span class='Ref_to_Member'>resultRelations</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN107"><span class='Ref_to_Member'>resultRelations</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN216"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN71"><span class='Ref_to_Member'>nonleafResultRelations</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN109"><span class='Ref_to_Member'>nonleafResultRelations</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN216"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN78"><span class='Ref_to_Member'>rootResultRelations</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN110"><span class='Ref_to_Member'>rootResultRelations</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN216"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN80"><span class='Ref_to_Member'>subplans</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN97"><span class='Ref_to_Member'>subplans</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN216"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN83"><span class='Ref_to_Member'>rewindPlanIDs</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN101"><span class='Ref_to_Member'>rewindPlanIDs</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN216"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN85"><span class='Ref_to_Member'>rowMarks</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN105"><span class='Ref_to_Member'>finalrowmarks</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN216"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN87"><span class='Ref_to_Member'>relationOids</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN112"><span class='Ref_to_Member'>relationOids</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN216"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN89"><span class='Ref_to_Member'>invalItems</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN114"><span class='Ref_to_Member'>invalItems</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN216"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN91"><span class='Ref_to_Member'>nParamExec</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN217"><span class='Ref_To_Local'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN116"><span class='Ref_to_Member'>nParamExec</span></a><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* utilityStmt should be null, but we might as well copy it */ 
</span>    <a href="planner.c.html#LN216"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN93"><span class='Ref_to_Member'>utilityStmt</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN214"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN117"><span class='Ref_to_Member'>utilityStmt</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN216"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN96"><span class='Ref_to_Member'>stmt_location</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN214"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN179"><span class='Ref_to_Member'>stmt_location</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN216"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN97"><span class='Ref_to_Member'>stmt_len</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN214"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN180"><span class='Ref_to_Member'>stmt_len</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="planner.c.html#LN216"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end standard_planner &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/*-------------------- 
 * subquery_planner 
 *    Invokes the planner on a subquery.  We recurse to here for each 
 *    sub-SELECT found in the query tree. 
 * 
 * glob is the global state for the current planner run. 
 * parse is the querytree produced by the parser & rewriter. 
 * parent_root is the immediate parent Query's info (NULL at the top level). 
 * hasRecursion is true if this is a recursive WITH query. 
 * tuple_fraction is the fraction of tuples we expect will be retrieved. 
 * tuple_fraction is interpreted as explained for grouping_planner, below. 
 * 
 * Basically, this routine does the stuff that should only be done once 
 * per Query object.  It then calls grouping_planner.  At one time, 
 * grouping_planner could be invoked recursively on the same Query object; 
 * that's not currently true, but we keep the separation between the two 
 * routines anyway, in case we need it again someday. 
 * 
 * subquery_planner will be called recursively to handle sub-Query nodes 
 * found within the query's expressions and rangetable. 
 * 
 * Returns the PlannerInfo struct ("root") that contains all data generated 
 * while planning the subquery.  In particular, the Path(s) attached to 
 * the (UPPERREL_FINAL, NULL) upperrel represent our conclusions about the 
 * cheapest way(s) to implement the query.  The top level will select the 
 * best Path and pass it through createplan.c to produce a finished Plan. 
 *-------------------- 
 */ 
</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>* 
</span><a name="LN483"></a><span class='Declare_Function'>subquery_planner</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN91"><span class='Ref_to_Struct'>PlannerGlobal</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>glob</span><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>parse</span><span class='Delimiter'>, 
</span><a name="LN484"></a>                 <a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>parent_root</span><span class='Delimiter'>, 
</span><a name="LN485"></a>                 <span class='Keyword'>bool </span><span class='Declare_Parameter'>hasRecursion</span><span class='Delimiter'>, </span><span class='Keyword'>double </span><span class='Declare_Parameter'>tuple_fraction</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN487"></a>    <a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>root</span><span class='Delimiter'>; 
</span><a name="LN488"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>newWithCheckOptions</span><span class='Delimiter'>; 
</span><a name="LN489"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>newHaving</span><span class='Delimiter'>; 
</span><a name="LN490"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>hasOuterJoins</span><span class='Delimiter'>; 
</span><a name="LN491"></a>    <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>final_rel</span><span class='Delimiter'>; 
</span><a name="LN492"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Create a PlannerInfo data structure for this subquery */ 
</span>    <a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN156"><span class='Ref_to_Member'>glob</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>glob</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN158"><span class='Ref_to_Member'>query_level</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN484"><span class='Ref_to_Parameter'>parent_root</span></a> <span class='Operator'>? </span><a href="planner.c.html#LN484"><span class='Ref_to_Parameter'>parent_root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN158"><span class='Ref_to_Member'>query_level</span></a> <span class='Operator'>+ </span><span class='Number'>1</span> <span class='Operator'>: </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN160"><span class='Ref_to_Member'>parent_root</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN484"><span class='Ref_to_Parameter'>parent_root</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN168"><span class='Ref_to_Member'>plan_params</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN169"><span class='Ref_to_Member'>outer_params</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN286"><span class='Ref_to_Member'>planner_cxt</span></a> <span class='Operator'>= </span><a href="../../utils/mmgr/mcxt.c.html#LN36"><span class='Ref_to_Global_Var'>CurrentMemoryContext</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN227"><span class='Ref_to_Member'>init_plans</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN229"><span class='Ref_to_Member'>cte_plan_ids</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN231"><span class='Ref_to_Member'>multiexpr_params</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN234"><span class='Ref_to_Member'>eq_classes</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN251"><span class='Ref_to_Member'>append_rel_list</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN253"><span class='Ref_to_Member'>pcinfo_list</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN255"><span class='Ref_to_Member'>rowMarks</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    memset<span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN271"><span class='Ref_to_Member'>upper_rels</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN271"><span class='Ref_to_Member'>upper_rels</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    memset<span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN274"><span class='Ref_to_Member'>upper_targets</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN274"><span class='Ref_to_Member'>upper_targets</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN280"><span class='Ref_to_Member'>processed_tlist</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN283"><span class='Ref_to_Member'>grouping_map</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN284"><span class='Ref_to_Member'>minmax_aggs</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN293"><span class='Ref_to_Member'>qual_security_level</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN296"><span class='Ref_to_Member'>hasInheritedTarget</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN304"><span class='Ref_to_Member'>hasRecursion</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN485"><span class='Ref_to_Parameter'>hasRecursion</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN485"><span class='Ref_to_Parameter'>hasRecursion</span></a><span class='Parentheses'>) 
</span>        <a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN307"><span class='Ref_to_Member'>wt_param_id</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/subselect.h.html#LN40"><span class='Ref_to_Proto'>SS_assign_special_param</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN307"><span class='Ref_to_Member'>wt_param_id</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN308"><span class='Ref_to_Member'>non_recursive_path</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If there is a WITH list, process each WITH query and build an initplan 
     * SubPlan structure for it. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN132"><span class='Ref_to_Member'>cteList</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/optimizer/subselect.h.html#LN17"><span class='Ref_to_Proto'>SS_process_ctes</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Look for ANY and EXISTS SubLinks in WHERE and JOIN/ON clauses, and try 
     * to transform them into joins.  Note that this step does not descend 
     * into subqueries; if we pull up any subqueries below, their SubLinks are 
     * processed just before pulling them up. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN125"><span class='Ref_to_Member'>hasSubLinks</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/optimizer/prep.h.html#LN23"><span class='Ref_to_Proto'>pull_up_sublinks</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Scan the rangetable for set-returning functions, and inline them if 
     * possible (producing subqueries that might get pulled up next). 
     * Recursion issues here are handled in the same way as for SubLinks. 
     */ 
</span>    <a href="../../../include/optimizer/prep.h.html#LN24"><span class='Ref_to_Proto'>inline_set_returning_functions</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Check to see if any subqueries in the jointree can be merged into this 
     * query. 
     */ 
</span>    <a href="../../../include/optimizer/prep.h.html#LN25"><span class='Ref_to_Proto'>pull_up_subqueries</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If this is a simple UNION ALL query, flatten it into an appendrel. We 
     * do this now because it requires applying pull_up_subqueries to the leaf 
     * queries of the UNION ALL, which weren't touched above because they 
     * weren't referenced by the jointree (they will be after we do this). 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN162"><span class='Ref_to_Member'>setOperations</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/optimizer/prep.h.html#LN26"><span class='Ref_to_Proto'>flatten_simple_union_all</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Detect whether any rangetable entries are RTE_JOIN kind; if not, we can 
     * avoid the expense of doing flatten_join_alias_vars().  Also check for 
     * outer joins --- if none, we can skip reduce_outer_joins().  And check 
     * for LATERAL RTEs, too.  This must be done after we have done 
     * pull_up_subqueries(), of course. 
     */ 
</span>    <a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN298"><span class='Ref_to_Member'>hasJoinRTEs</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN299"><span class='Ref_to_Member'>hasLateralRTEs</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN490"><span class='Ref_To_Local'>hasOuterJoins</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN492"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN134"><span class='Ref_to_Member'>rtable</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN574"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN492"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN574"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN924"><span class='Ref_to_EnumConst'>RTE_JOIN</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN298"><span class='Ref_to_Member'>hasJoinRTEs</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN720"><span class='Ref_to_Macro'>IS_OUTER_JOIN</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN574"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN974"><span class='Ref_to_Member'>jointype</span></a><span class='Parentheses'>))</span> 
                <a href="planner.c.html#LN490"><span class='Ref_To_Local'>hasOuterJoins</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN574"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1024"><span class='Ref_to_Member'>lateral</span></a><span class='Parentheses'>) 
</span>            <a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN299"><span class='Ref_to_Member'>hasLateralRTEs</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Preprocess RowMark information.  We need to do this after subquery 
     * pullup (so that all non-inherited RTEs are present) and before 
     * inheritance expansion (so that the info is available for 
     * expand_inherited_tables to examine and modify). 
     */ 
</span>    <a href="planner.c.html#LN119"><span class='Ref_to_Proto'>preprocess_rowmarks</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Expand any rangetable entries that are inheritance sets into "append 
     * relations".  This can add entries to the rangetable, but they must be 
     * plain base relations not joins, so it's OK (and marginally more 
     * efficient) to do it after checking for join RTEs.  We must do it after 
     * pulling up subqueries, else we'd fail to handle inherited tables in 
     * subqueries. 
     */ 
</span>    <a href="../../../include/optimizer/prep.h.html#LN52"><span class='Ref_to_Proto'>expand_inherited_tables</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Set hasHavingQual to remember if HAVING clause is present.  Needed 
     * because preprocess_expression will reduce a constant-true condition to 
     * an empty qual list ... but "HAVING TRUE" is not a semantic no-op. 
     */ 
</span>    <a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN301"><span class='Ref_to_Member'>hasHavingQual</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Clear this flag; might get set in distribute_qual_to_rels */ 
</span>    <a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN302"><span class='Ref_to_Member'>hasPseudoConstantQuals</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Do expression preprocessing on targetlist and quals, as well as other 
     * random expressions in the querytree.  Note that we do not need to 
     * handle sort/group expressions explicitly, because they are actually 
     * part of the targetlist. 
     */ 
</span>    <a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>        <a href="planner.c.html#LN111"><span class='Ref_to_Proto'>preprocess_expression</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Delimiter'>, 
</span>                              <a href="planner.c.html#LN73"><span class='Ref_to_Const'>EXPRKIND_TARGET</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Constant-folding might have removed all set-returning functions */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN124"><span class='Ref_to_Member'>hasTargetSRFs</span></a><span class='Parentheses'>) 
</span>        <a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN124"><span class='Ref_to_Member'>hasTargetSRFs</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodeFuncs.h.html#LN36"><span class='Ref_to_Proto'>expression_returns_set</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="planner.c.html#LN488"><span class='Ref_To_Local'>newWithCheckOptions</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN492"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN168"><span class='Ref_to_Member'>withCheckOptions</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN631"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN1093"><span class='Ref_to_Struct'>WithCheckOption</span></a> <span class='Operator'>*</span><span class='Declare_Local'>wco</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1093"><span class='Ref_to_Struct'>WithCheckOption</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN492"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="planner.c.html#LN631"><span class='Ref_To_Local'>wco</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1099"><span class='Ref_to_Member'>qual</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN111"><span class='Ref_to_Proto'>preprocess_expression</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN631"><span class='Ref_To_Local'>wco</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1099"><span class='Ref_to_Member'>qual</span></a><span class='Delimiter'>, 
</span>                                          <a href="planner.c.html#LN72"><span class='Ref_to_Const'>EXPRKIND_QUAL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN631"><span class='Ref_To_Local'>wco</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1099"><span class='Ref_to_Member'>qual</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <a href="planner.c.html#LN488"><span class='Ref_To_Local'>newWithCheckOptions</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN488"><span class='Ref_To_Local'>newWithCheckOptions</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN631"><span class='Ref_To_Local'>wco</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN168"><span class='Ref_to_Member'>withCheckOptions</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN488"><span class='Ref_To_Local'>newWithCheckOptions</span></a><span class='Delimiter'>; 
</span> 
    <a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN143"><span class='Ref_to_Member'>returningList</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>        <a href="planner.c.html#LN111"><span class='Ref_to_Proto'>preprocess_expression</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN143"><span class='Ref_to_Member'>returningList</span></a><span class='Delimiter'>, 
</span>                              <a href="planner.c.html#LN73"><span class='Ref_to_Const'>EXPRKIND_TARGET</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="planner.c.html#LN112"><span class='Ref_to_Proto'>preprocess_qual_conditions</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN135"><span class='Ref_to_Member'>jointree</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN111"><span class='Ref_to_Proto'>preprocess_expression</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a><span class='Delimiter'>, 
</span>                                              <a href="planner.c.html#LN72"><span class='Ref_to_Const'>EXPRKIND_QUAL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN492"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN151"><span class='Ref_to_Member'>windowClause</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN651"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN1252"><span class='Ref_to_Struct'>WindowClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>wc</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1252"><span class='Ref_to_Struct'>WindowClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN492"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* partitionClause/orderClause are sort/group expressions */ 
</span>        <a href="planner.c.html#LN651"><span class='Ref_To_Local'>wc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1260"><span class='Ref_to_Member'>startOffset</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN111"><span class='Ref_to_Proto'>preprocess_expression</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN651"><span class='Ref_To_Local'>wc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1260"><span class='Ref_to_Member'>startOffset</span></a><span class='Delimiter'>, 
</span>                                                <a href="planner.c.html#LN78"><span class='Ref_to_Const'>EXPRKIND_LIMIT</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN651"><span class='Ref_To_Local'>wc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1261"><span class='Ref_to_Member'>endOffset</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN111"><span class='Ref_to_Proto'>preprocess_expression</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN651"><span class='Ref_To_Local'>wc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1261"><span class='Ref_to_Member'>endOffset</span></a><span class='Delimiter'>, 
</span>                                              <a href="planner.c.html#LN78"><span class='Ref_to_Const'>EXPRKIND_LIMIT</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN157"><span class='Ref_to_Member'>limitOffset</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN111"><span class='Ref_to_Proto'>preprocess_expression</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN157"><span class='Ref_to_Member'>limitOffset</span></a><span class='Delimiter'>, 
</span>                                               <a href="planner.c.html#LN78"><span class='Ref_to_Const'>EXPRKIND_LIMIT</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN158"><span class='Ref_to_Member'>limitCount</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN111"><span class='Ref_to_Proto'>preprocess_expression</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN158"><span class='Ref_to_Member'>limitCount</span></a><span class='Delimiter'>, 
</span>                                              <a href="planner.c.html#LN78"><span class='Ref_to_Const'>EXPRKIND_LIMIT</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN141"><span class='Ref_to_Member'>onConflict</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN141"><span class='Ref_to_Member'>onConflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1488"><span class='Ref_to_Member'>arbiterElems</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="planner.c.html#LN111"><span class='Ref_to_Proto'>preprocess_expression</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, 
</span>                                  <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN141"><span class='Ref_to_Member'>onConflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1488"><span class='Ref_to_Member'>arbiterElems</span></a><span class='Delimiter'>, 
</span>                                  <a href="planner.c.html#LN82"><span class='Ref_to_Const'>EXPRKIND_ARBITER_ELEM</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN141"><span class='Ref_to_Member'>onConflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1490"><span class='Ref_to_Member'>arbiterWhere</span></a> <span class='Operator'>= 
</span>            <a href="planner.c.html#LN111"><span class='Ref_to_Proto'>preprocess_expression</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, 
</span>                                  <a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN141"><span class='Ref_to_Member'>onConflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1490"><span class='Ref_to_Member'>arbiterWhere</span></a><span class='Delimiter'>, 
</span>                                  <a href="planner.c.html#LN72"><span class='Ref_to_Const'>EXPRKIND_QUAL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN141"><span class='Ref_to_Member'>onConflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1494"><span class='Ref_to_Member'>onConflictSet</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="planner.c.html#LN111"><span class='Ref_to_Proto'>preprocess_expression</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, 
</span>                                  <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN141"><span class='Ref_to_Member'>onConflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1494"><span class='Ref_to_Member'>onConflictSet</span></a><span class='Delimiter'>, 
</span>                                  <a href="planner.c.html#LN73"><span class='Ref_to_Const'>EXPRKIND_TARGET</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN141"><span class='Ref_to_Member'>onConflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1495"><span class='Ref_to_Member'>onConflictWhere</span></a> <span class='Operator'>= 
</span>            <a href="planner.c.html#LN111"><span class='Ref_to_Proto'>preprocess_expression</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, 
</span>                                  <a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN141"><span class='Ref_to_Member'>onConflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1495"><span class='Ref_to_Member'>onConflictWhere</span></a><span class='Delimiter'>, 
</span>                                  <a href="planner.c.html#LN72"><span class='Ref_to_Const'>EXPRKIND_QUAL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* exclRelTlist contains only Vars, so no preprocessing needed */ 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if parse-&GT;onConflict &raquo; </span> 
 
    <a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN251"><span class='Ref_to_Member'>append_rel_list</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>        <a href="planner.c.html#LN111"><span class='Ref_to_Proto'>preprocess_expression</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN251"><span class='Ref_to_Member'>append_rel_list</span></a><span class='Delimiter'>, 
</span>                              <a href="planner.c.html#LN79"><span class='Ref_to_Const'>EXPRKIND_APPINFO</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Also need to preprocess expressions within RTEs */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN492"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN134"><span class='Ref_to_Member'>rtable</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN693"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN492"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN694"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>kind</span><span class='Delimiter'>; 
</span><a name="LN695"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lcsq</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN693"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN922"><span class='Ref_to_EnumConst'>RTE_RELATION</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN693"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN949"><span class='Ref_to_Member'>tablesample</span></a><span class='Parentheses'>) 
</span>                <a href="planner.c.html#LN693"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN949"><span class='Ref_to_Member'>tablesample</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1071"><span class='Ref_to_Struct'>TableSampleClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                    <a href="planner.c.html#LN111"><span class='Ref_to_Proto'>preprocess_expression</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, 
</span>                                          <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN693"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN949"><span class='Ref_to_Member'>tablesample</span></a><span class='Delimiter'>, 
</span>                                          <a href="planner.c.html#LN81"><span class='Ref_to_Const'>EXPRKIND_TABLESAMPLE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN693"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN923"><span class='Ref_to_EnumConst'>RTE_SUBQUERY</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * We don't want to do all preprocessing yet on the subquery's 
             * expressions, since that will happen when we plan it.  But if it 
             * contains any join aliases of our level, those have to get 
             * expanded now, because planning of the subquery won't do it. 
             * That's only possible if the subquery is LATERAL. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN693"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1024"><span class='Ref_to_Member'>lateral</span></a> <span class='Operator'>&& </span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN298"><span class='Ref_to_Member'>hasJoinRTEs</span></a><span class='Parentheses'>) 
</span>                <a href="planner.c.html#LN693"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN954"><span class='Ref_to_Member'>subquery</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                    <a href="../../../include/optimizer/var.h.html#LN37"><span class='Ref_to_Proto'>flatten_join_alias_vars</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN693"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN954"><span class='Ref_to_Member'>subquery</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN693"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN925"><span class='Ref_to_EnumConst'>RTE_FUNCTION</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Preprocess the function expression(s) fully */ 
</span>            <a href="planner.c.html#LN694"><span class='Ref_To_Local'>kind</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN693"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1024"><span class='Ref_to_Member'>lateral</span></a> <span class='Operator'>? </span><a href="planner.c.html#LN75"><span class='Ref_to_Const'>EXPRKIND_RTFUNC_LATERAL</span></a> <span class='Operator'>: </span><a href="planner.c.html#LN74"><span class='Ref_to_Const'>EXPRKIND_RTFUNC</span></a><span class='Delimiter'>; 
</span>            <a href="planner.c.html#LN693"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN985"><span class='Ref_to_Member'>functions</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                <a href="planner.c.html#LN111"><span class='Ref_to_Proto'>preprocess_expression</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN693"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN985"><span class='Ref_to_Member'>functions</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN694"><span class='Ref_To_Local'>kind</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN693"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN926"><span class='Ref_to_EnumConst'>RTE_TABLEFUNC</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Preprocess the function expression(s) fully */ 
</span>            <a href="planner.c.html#LN694"><span class='Ref_To_Local'>kind</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN693"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1024"><span class='Ref_to_Member'>lateral</span></a> <span class='Operator'>? </span><a href="planner.c.html#LN84"><span class='Ref_to_Const'>EXPRKIND_TABLEFUNC_LATERAL</span></a> <span class='Operator'>: </span><a href="planner.c.html#LN83"><span class='Ref_to_Const'>EXPRKIND_TABLEFUNC</span></a><span class='Delimiter'>; 
</span>            <a href="planner.c.html#LN693"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN991"><span class='Ref_to_Member'>tablefunc</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN78"><span class='Ref_to_Struct'>TableFunc</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                <a href="planner.c.html#LN111"><span class='Ref_to_Proto'>preprocess_expression</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN693"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN991"><span class='Ref_to_Member'>tablefunc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN694"><span class='Ref_To_Local'>kind</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN693"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN927"><span class='Ref_to_EnumConst'>RTE_VALUES</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Preprocess the values lists fully */ 
</span>            <a href="planner.c.html#LN694"><span class='Ref_To_Local'>kind</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN693"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1024"><span class='Ref_to_Member'>lateral</span></a> <span class='Operator'>? </span><a href="planner.c.html#LN77"><span class='Ref_to_Const'>EXPRKIND_VALUES_LATERAL</span></a> <span class='Operator'>: </span><a href="planner.c.html#LN76"><span class='Ref_to_Const'>EXPRKIND_VALUES</span></a><span class='Delimiter'>; 
</span>            <a href="planner.c.html#LN693"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN996"><span class='Ref_to_Member'>values_lists</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                <a href="planner.c.html#LN111"><span class='Ref_to_Proto'>preprocess_expression</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN693"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN996"><span class='Ref_to_Member'>values_lists</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN694"><span class='Ref_To_Local'>kind</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Process each element of the securityQuals list as if it were a 
         * separate qual expression (as indeed it is).  We need to do it this 
         * way to get proper canonicalization of AND/OR structure.  Note that 
         * this converts each element into an implicit-AND sublist. 
         */ 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN695"><span class='Ref_To_Local'>lcsq</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN693"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1032"><span class='Ref_to_Member'>securityQuals</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN695"><span class='Ref_To_Local'>lcsq</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="planner.c.html#LN111"><span class='Ref_to_Proto'>preprocess_expression</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, 
</span>                                                 <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN695"><span class='Ref_To_Local'>lcsq</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                 <a href="planner.c.html#LN72"><span class='Ref_to_Const'>EXPRKIND_QUAL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * In some cases we may want to transfer a HAVING clause into WHERE. We 
     * cannot do so if the HAVING clause contains aggregates (obviously) or 
     * volatile functions (since a HAVING clause is supposed to be executed 
     * only once per group).  We also can't do this if there are any nonempty 
     * grouping sets; moving such a clause into WHERE would potentially change 
     * the results, if any referenced column isn't present in all the grouping 
     * sets.  (If there are only empty grouping sets, then the HAVING clause 
     * must be degenerate as discussed below.) 
     * 
     * Also, it may be that the clause is so expensive to execute that we're 
     * better off doing it only once per group, despite the loss of 
     * selectivity.  This is hard to estimate short of doing the entire 
     * planning process twice, so we use a heuristic: clauses containing 
     * subplans are left in HAVING.  Otherwise, we move or copy the HAVING 
     * clause into WHERE, in hopes of eliminating tuples before aggregation 
     * instead of after. 
     * 
     * If the query has explicit grouping then we can simply move such a 
     * clause into WHERE; any group that fails the clause will not be in the 
     * output because none of its tuples will reach the grouping or 
     * aggregation stage.  Otherwise we must have a degenerate (variable-free) 
     * HAVING clause, which we put in WHERE so that query_planner() can use it 
     * in a gating Result node, but also keep in HAVING to ensure that we 
     * don't emit a bogus aggregated row. (This could be done better, but it 
     * seems not worth optimizing.) 
     * 
     * Note that both havingQual and parse-&GT;jointree-&GT;quals are in 
     * implicitly-ANDed-list form at this point, even though they are declared 
     * as Node *. 
     */ 
</span>    <a href="planner.c.html#LN489"><span class='Ref_To_Local'>newHaving</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN492"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span><a name="LN788"></a>        <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>havingclause</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN492"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a> <span class='Operator'>&& </span><a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN147"><span class='Ref_to_Member'>groupingSets</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>            <a href="../../../include/optimizer/clauses.h.html#LN48"><span class='Ref_to_Proto'>contain_agg_clause</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN788"><span class='Ref_To_Local'>havingclause</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>            <a href="../../../include/optimizer/clauses.h.html#LN60"><span class='Ref_to_Proto'>contain_volatile_functions</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN788"><span class='Ref_To_Local'>havingclause</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>            <a href="../../../include/optimizer/clauses.h.html#LN57"><span class='Ref_to_Proto'>contain_subplans</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN788"><span class='Ref_To_Local'>havingclause</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* keep it in HAVING */ 
</span>            <a href="planner.c.html#LN489"><span class='Ref_To_Local'>newHaving</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN489"><span class='Ref_To_Local'>newHaving</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN788"><span class='Ref_To_Local'>havingclause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a> <span class='Operator'>&& !</span><a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN147"><span class='Ref_to_Member'>groupingSets</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* move it to WHERE */ 
</span>            <a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN135"><span class='Ref_to_Member'>jointree</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1470"><span class='Ref_to_Member'>quals</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                <a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN135"><span class='Ref_to_Member'>jointree</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1470"><span class='Ref_to_Member'>quals</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN788"><span class='Ref_To_Local'>havingclause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* put a copy in WHERE, keep it in HAVING */ 
</span>            <a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN135"><span class='Ref_to_Member'>jointree</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1470"><span class='Ref_to_Member'>quals</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                <a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN135"><span class='Ref_to_Member'>jointree</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1470"><span class='Ref_to_Member'>quals</span></a><span class='Delimiter'>, 
</span>                        <a href="../../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN788"><span class='Ref_To_Local'>havingclause</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="planner.c.html#LN489"><span class='Ref_To_Local'>newHaving</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN489"><span class='Ref_To_Local'>newHaving</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN788"><span class='Ref_To_Local'>havingclause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN489"><span class='Ref_To_Local'>newHaving</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Remove any redundant GROUP BY columns */ 
</span>    <a href="planner.c.html#LN124"><span class='Ref_to_Proto'>remove_useless_groupby_columns</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we have any outer joins, try to reduce them to plain inner joins. 
     * This step is most easily done after we've done expression 
     * preprocessing. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN490"><span class='Ref_To_Local'>hasOuterJoins</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/optimizer/prep.h.html#LN27"><span class='Ref_to_Proto'>reduce_outer_joins</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Do the main planning.  If we have an inherited target relation, that 
     * needs special processing, else go straight to grouping_planner. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN119"><span class='Ref_to_Member'>resultRelation</span></a> <span class='Operator'>&& 
</span>        <a href="../../../include/parser/parsetree.h.html#LN30"><span class='Ref_to_Macro'>rt_fetch</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN119"><span class='Ref_to_Member'>resultRelation</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN483"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN134"><span class='Ref_to_Member'>rtable</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>inh<span class='Parentheses'>)</span> 
        <a href="planner.c.html#LN113"><span class='Ref_to_Proto'>inheritance_planner</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="planner.c.html#LN114"><span class='Ref_to_Proto'>grouping_planner</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><a href="planner.c.html#LN485"><span class='Ref_to_Parameter'>tuple_fraction</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Capture the set of outer-level param IDs we have access to, for use in 
     * extParam/allParam calculations later. 
     */ 
</span>    <a href="../../../include/optimizer/subselect.h.html#LN27"><span class='Ref_to_Proto'>SS_identify_outer_params</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If any initPlans were created in this query level, adjust the surviving 
     * Paths' costs and parallel-safety flags to account for them.  The 
     * initPlans won't actually get attached to the plan tree till 
     * create_plan() runs, but we must include their effects now. 
     */ 
</span>    <a href="planner.c.html#LN491"><span class='Ref_To_Local'>final_rel</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/pathnode.h.html#LN270"><span class='Ref_to_Proto'>fetch_upper_rel</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN77"><span class='Ref_to_EnumConst'>UPPERREL_FINAL</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/optimizer/subselect.h.html#LN28"><span class='Ref_to_Proto'>SS_charge_for_initplans</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN491"><span class='Ref_To_Local'>final_rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Make sure we've identified the cheapest Path for the final rel.  (By 
     * doing this here not in grouping_planner, we include initPlan costs in 
     * the decision, though it's unlikely that will change anything.) 
     */ 
</span>    <a href="../../../include/optimizer/pathnode.h.html#LN26"><span class='Ref_to_Proto'>set_cheapest</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN491"><span class='Ref_To_Local'>final_rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="planner.c.html#LN487"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end subquery_planner &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * preprocess_expression 
 *      Do subquery_planner's preprocessing work for an expression, 
 *      which can be a targetlist, a WHERE clause (including JOIN/ON 
 *      conditions), a HAVING clause, or a few other things. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN868"></a><span class='Declare_Function'>preprocess_expression</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>expr</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>kind</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * Fall out quickly if expression is empty.  This occurs often enough to 
     * be worth checking.  Note that null-&GT;null is the correct conversion for 
     * implicit-AND result format, too. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN868"><span class='Ref_to_Parameter'>expr</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the query has any join RTEs, replace join alias variables with 
     * base-relation variables.  We must do this before sublink processing, 
     * else sublinks expanded out from join aliases would not get processed. 
     * We can skip it in non-lateral RTE functions, VALUES lists, and 
     * TABLESAMPLE clauses, however, since they can't contain any Vars of the 
     * current query level. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN868"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN298"><span class='Ref_to_Member'>hasJoinRTEs</span></a> <span class='Operator'>&& 
</span>        <span class='Operator'>!</span><span class='Parentheses'>(</span><a href="planner.c.html#LN868"><span class='Ref_to_Parameter'>kind</span></a> <span class='Operator'>== </span><a href="planner.c.html#LN74"><span class='Ref_to_Const'>EXPRKIND_RTFUNC</span></a> <span class='Operator'>|| 
</span>          <a href="planner.c.html#LN868"><span class='Ref_to_Parameter'>kind</span></a> <span class='Operator'>== </span><a href="planner.c.html#LN76"><span class='Ref_to_Const'>EXPRKIND_VALUES</span></a> <span class='Operator'>|| 
</span>          <a href="planner.c.html#LN868"><span class='Ref_to_Parameter'>kind</span></a> <span class='Operator'>== </span><a href="planner.c.html#LN81"><span class='Ref_to_Const'>EXPRKIND_TABLESAMPLE</span></a> <span class='Operator'>|| 
</span>          <a href="planner.c.html#LN868"><span class='Ref_to_Parameter'>kind</span></a> <span class='Operator'>== </span><a href="planner.c.html#LN83"><span class='Ref_to_Const'>EXPRKIND_TABLEFUNC</span></a><span class='Parentheses'>))</span> 
        <a href="planner.c.html#LN868"><span class='Ref_to_Parameter'>expr</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/var.h.html#LN37"><span class='Ref_to_Proto'>flatten_join_alias_vars</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN868"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN868"><span class='Ref_to_Parameter'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Simplify constant expressions. 
     * 
     * Note: an essential effect of this is to convert named-argument function 
     * calls to positional notation and insert the current actual values of 
     * any default arguments for functions.  To ensure that happens, we *must* 
     * process all expressions here.  Previous PG versions sometimes skipped 
     * const-simplification if it didn't seem worth the trouble, but we can't 
     * do that anymore. 
     * 
     * Note: this also flattens nested AND and OR expressions into N-argument 
     * form.  All processing of a qual expression after this point must be 
     * careful to maintain AND/OR flatness --- that is, do not generate a tree 
     * with AND directly under AND, nor OR directly under OR. 
     */ 
</span>    <a href="planner.c.html#LN868"><span class='Ref_to_Parameter'>expr</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/clauses.h.html#LN80"><span class='Ref_to_Proto'>eval_const_expressions</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN868"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN868"><span class='Ref_to_Parameter'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If it's a qual or havingQual, canonicalize it. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN868"><span class='Ref_to_Parameter'>kind</span></a> <span class='Operator'>== </span><a href="planner.c.html#LN72"><span class='Ref_to_Const'>EXPRKIND_QUAL</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="planner.c.html#LN868"><span class='Ref_to_Parameter'>expr</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/prep.h.html#LN35"><span class='Ref_to_Proto'>canonicalize_qual</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN868"><span class='Ref_to_Parameter'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> OPTIMIZER_DEBUG 
        <a href="../../../include/port.h.html#LN173"><span class='Ref_to_Macro'>printf</span></a><span class='Parentheses'>(</span><span class='String'>"After canonicalize_qual()\n"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/nodes/print.h.html#LN22"><span class='Ref_to_Proto'>pprint</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN868"><span class='Ref_to_Parameter'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Expand SubLinks to SubPlans */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN868"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN125"><span class='Ref_to_Member'>hasSubLinks</span></a><span class='Parentheses'>) 
</span>        <a href="planner.c.html#LN868"><span class='Ref_to_Parameter'>expr</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/subselect.h.html#LN26"><span class='Ref_to_Proto'>SS_process_sublinks</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN868"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN868"><span class='Ref_to_Parameter'>expr</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="planner.c.html#LN868"><span class='Ref_to_Parameter'>kind</span></a> <span class='Operator'>== </span><a href="planner.c.html#LN72"><span class='Ref_to_Const'>EXPRKIND_QUAL</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * XXX do not insert anything here unless you have grokked the comments in 
     * SS_replace_correlation_vars ... 
     */ 
</span> 
    <span class='Comment_Multi_Line'>/* Replace uplevel vars with Param nodes (this IS possible in VALUES) */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN868"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN158"><span class='Ref_to_Member'>query_level</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>        <a href="planner.c.html#LN868"><span class='Ref_to_Parameter'>expr</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/subselect.h.html#LN25"><span class='Ref_to_Proto'>SS_replace_correlation_vars</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN868"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN868"><span class='Ref_to_Parameter'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If it's a qual or havingQual, convert it to implicit-AND format. (We 
     * don't want to do this before eval_const_expressions, since the latter 
     * would be unable to simplify a top-level AND correctly. Also, 
     * SS_process_sublinks expects explicit-AND format.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN868"><span class='Ref_to_Parameter'>kind</span></a> <span class='Operator'>== </span><a href="planner.c.html#LN72"><span class='Ref_to_Const'>EXPRKIND_QUAL</span></a><span class='Parentheses'>) 
</span>        <a href="planner.c.html#LN868"><span class='Ref_to_Parameter'>expr</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/clauses.h.html#LN46"><span class='Ref_to_Proto'>make_ands_implicit</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN868"><span class='Ref_to_Parameter'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="planner.c.html#LN868"><span class='Ref_to_Parameter'>expr</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end preprocess_expression &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * preprocess_qual_conditions 
 *      Recursively scan the query's jointree and do subquery_planner's 
 *      preprocessing work on each qual condition found therein. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN954"></a><span class='Declare_Function'>preprocess_qual_conditions</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>jtnode</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN954"><span class='Ref_to_Parameter'>jtnode</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN954"><span class='Ref_to_Parameter'>jtnode</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1415"><span class='Ref_to_Struct'>RangeTblRef</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* nothing to do here */ 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN954"><span class='Ref_to_Parameter'>jtnode</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1466"><span class='Ref_to_Struct'>FromExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN964"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1466"><span class='Ref_to_Struct'>FromExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>f</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1466"><span class='Ref_to_Struct'>FromExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN954"><span class='Ref_to_Parameter'>jtnode</span></a><span class='Delimiter'>; 
</span><a name="LN965"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN965"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN964"><span class='Ref_To_Local'>f</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1469"><span class='Ref_to_Member'>fromlist</span></a><span class='Parentheses'>) 
</span><a name="LN968"></a>            <span class='Declare_Local'>preprocess_qual_conditions</span><span class='Parentheses'>(</span><a href="planner.c.html#LN954"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN965"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <a href="planner.c.html#LN964"><span class='Ref_To_Local'>f</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1470"><span class='Ref_to_Member'>quals</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN111"><span class='Ref_to_Proto'>preprocess_expression</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN954"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN964"><span class='Ref_To_Local'>f</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1470"><span class='Ref_to_Member'>quals</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN72"><span class='Ref_to_Const'>EXPRKIND_QUAL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN954"><span class='Ref_to_Parameter'>jtnode</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1444"><span class='Ref_to_Struct'>JoinExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN974"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1444"><span class='Ref_to_Struct'>JoinExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>j</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1444"><span class='Ref_to_Struct'>JoinExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN954"><span class='Ref_to_Parameter'>jtnode</span></a><span class='Delimiter'>; 
</span> 
        <a href="planner.c.html#LN112"><span class='Ref_to_Proto'>preprocess_qual_conditions</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN954"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN974"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1449"><span class='Ref_to_Member'>larg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN112"><span class='Ref_to_Proto'>preprocess_qual_conditions</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN954"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN974"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1450"><span class='Ref_to_Member'>rarg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="planner.c.html#LN974"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1452"><span class='Ref_to_Member'>quals</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN111"><span class='Ref_to_Proto'>preprocess_expression</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN954"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN974"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1452"><span class='Ref_to_Member'>quals</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN72"><span class='Ref_to_Const'>EXPRKIND_QUAL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized node type: %d"</span><span class='Delimiter'>, 
</span>             <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="../../../include/nodes/nodes.h.html#LN513"><span class='Ref_to_Macro'>nodeTag</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN954"><span class='Ref_to_Parameter'>jtnode</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end preprocess_qual_conditions &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * preprocess_phv_expression 
 *    Do preprocessing on a PlaceHolderVar expression that's been pulled up. 
 * 
 * If a LATERAL subquery references an output of another subquery, and that 
 * output must be wrapped in a PlaceHolderVar because of an intermediate outer 
 * join, then we'll push the PlaceHolderVar expression down into the subquery 
 * and later pull it back up during find_lateral_references, which runs after 
 * subquery_planner has preprocessed all the expressions that were in the 
 * current query level to start with.  So we need to preprocess it then. 
 */ 
</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>* 
</span><a name="LN998"></a><span class='Declare_Function'>preprocess_phv_expression</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>expr</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN111"><span class='Ref_to_Proto'>preprocess_expression</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN998"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN998"><span class='Ref_to_Parameter'>expr</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN80"><span class='Ref_to_Const'>EXPRKIND_PHV</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * inheritance_planner 
 *    Generate Paths in the case where the result relation is an 
 *    inheritance set. 
 * 
 * We have to handle this case differently from cases where a source relation 
 * is an inheritance set. Source inheritance is expanded at the bottom of the 
 * plan tree (see allpaths.c), but target inheritance has to be expanded at 
 * the top.  The reason is that for UPDATE, each target relation needs a 
 * different targetlist matching its own column set.  Fortunately, 
 * the UPDATE/DELETE target can never be the nullable side of an outer join, 
 * so it's OK to generate the plan this way. 
 * 
 * Returns nothing; the useful output is in the Paths we attach to 
 * the (UPPERREL_FINAL, NULL) upperrel stored in *root. 
 * 
 * Note that we have not done set_cheapest() on the final rel; it's convenient 
 * to leave this to the caller. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1023"></a><span class='Declare_Function'>inheritance_planner</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1025"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>parse</span> <span class='Operator'>= </span><a href="planner.c.html#LN1023"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Delimiter'>; 
</span><a name="LN1026"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>parentRTindex</span> <span class='Operator'>= </span><a href="planner.c.html#LN1025"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN119"><span class='Ref_to_Member'>resultRelation</span></a><span class='Delimiter'>; 
</span><a name="LN1027"></a>    <a href="../../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>subqueryRTindexes</span><span class='Delimiter'>; 
</span><a name="LN1028"></a>    <a href="../../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>modifiableARIindexes</span><span class='Delimiter'>; 
</span><a name="LN1029"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>nominalRelation</span> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span><a name="LN1030"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>final_rtable</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN1031"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>save_rel_array_size</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1032"></a>    <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>**</span><span class='Declare_Local'>save_rel_array</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN1033"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>subpaths</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN1034"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>subroots</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN1035"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>resultRelations</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN1036"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>withCheckOptionLists</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN1037"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>returningLists</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN1038"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>rowMarks</span><span class='Delimiter'>; 
</span><a name="LN1039"></a>    <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>final_rel</span><span class='Delimiter'>; 
</span><a name="LN1040"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span><a name="LN1041"></a>    <a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Local'>rti</span><span class='Delimiter'>; 
</span><a name="LN1042"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>parent_rte</span><span class='Delimiter'>; 
</span><a name="LN1043"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>partitioned_rels</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="planner.c.html#LN1025"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN109"><span class='Ref_to_Member'>commandType</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/nodes.h.html#LN652"><span class='Ref_to_EnumConst'>CMD_INSERT</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We generate a modified instance of the original Query for each target 
     * relation, plan that, and put all the plans into a list that will be 
     * controlled by a single ModifyTable node.  All the instances share the 
     * same rangetable, but each instance must have its own set of subquery 
     * RTEs within the finished rangetable because (1) they are likely to get 
     * scribbled on during planning, and (2) it's not inconceivable that 
     * subqueries could get planned differently in different cases.  We need 
     * not create duplicate copies of other RTE kinds, in particular not the 
     * target relations, because they don't have either of those issues.  Not 
     * having to duplicate the target relations is important because doing so 
     * (1) would result in a rangetable of length O(N^2) for N targets, with 
     * at least O(N^3) work expended here; and (2) would greatly complicate 
     * management of the rowMarks list. 
     * 
     * To begin with, generate a bitmapset of the relids of the subquery RTEs. 
     */ 
</span>    <a href="planner.c.html#LN1027"><span class='Ref_To_Local'>subqueryRTindexes</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN1041"><span class='Ref_To_Local'>rti</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1040"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1025"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN134"><span class='Ref_to_Member'>rtable</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1068"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1040"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1068"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN923"><span class='Ref_to_EnumConst'>RTE_SUBQUERY</span></a><span class='Parentheses'>) 
</span>            <a href="planner.c.html#LN1027"><span class='Ref_To_Local'>subqueryRTindexes</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN89"><span class='Ref_to_Proto'>bms_add_member</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1027"><span class='Ref_To_Local'>subqueryRTindexes</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1041"><span class='Ref_To_Local'>rti</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN1041"><span class='Ref_To_Local'>rti</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Next, we want to identify which AppendRelInfo items contain references 
     * to any of the aforesaid subquery RTEs.  These items will need to be 
     * copied and modified to adjust their subquery references; whereas the 
     * other ones need not be touched.  It's worth being tense over this 
     * because we can usually avoid processing most of the AppendRelInfo 
     * items, thereby saving O(N^2) space and time when the target is a large 
     * inheritance tree.  We can identify AppendRelInfo items by their 
     * child_relid, since that should be unique within the list. 
     */ 
</span>    <a href="planner.c.html#LN1028"><span class='Ref_To_Local'>modifiableARIindexes</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1027"><span class='Ref_To_Local'>subqueryRTindexes</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1040"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1023"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN251"><span class='Ref_to_Member'>append_rel_list</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1090"></a>            <a href="../../../include/nodes/relation.h.html#LN1964"><span class='Ref_to_Struct'>AppendRelInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>appinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1964"><span class='Ref_to_Struct'>AppendRelInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1040"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN75"><span class='Ref_to_Proto'>bms_is_member</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1090"><span class='Ref_To_Local'>appinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1974"><span class='Ref_to_Member'>parent_relid</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1027"><span class='Ref_To_Local'>subqueryRTindexes</span></a><span class='Parentheses'>)</span> <span class='Operator'>|| 
</span>                <a href="../../../include/nodes/bitmapset.h.html#LN75"><span class='Ref_to_Proto'>bms_is_member</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1090"><span class='Ref_To_Local'>appinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1975"><span class='Ref_to_Member'>child_relid</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1027"><span class='Ref_To_Local'>subqueryRTindexes</span></a><span class='Parentheses'>)</span> <span class='Operator'>|| 
</span>                <a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="../../../include/optimizer/var.h.html#LN29"><span class='Ref_to_Proto'>pull_varnos</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN1090"><span class='Ref_To_Local'>appinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2002"><span class='Ref_to_Member'>translated_vars</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                            <a href="planner.c.html#LN1027"><span class='Ref_To_Local'>subqueryRTindexes</span></a><span class='Parentheses'>))</span> 
                <a href="planner.c.html#LN1028"><span class='Ref_To_Local'>modifiableARIindexes</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN89"><span class='Ref_to_Proto'>bms_add_member</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1028"><span class='Ref_To_Local'>modifiableARIindexes</span></a><span class='Delimiter'>, 
</span>                                                      <a href="planner.c.html#LN1090"><span class='Ref_To_Local'>appinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1975"><span class='Ref_to_Member'>child_relid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the parent RTE is a partitioned table, we should use that as the 
     * nominal relation, because the RTEs added for partitioned tables 
     * (including the root parent) as child members of the inheritance set do 
     * not appear anywhere else in the plan.  The situation is exactly the 
     * opposite in the case of non-partitioned inheritance parent as described 
     * below. 
     */ 
</span>    <a href="planner.c.html#LN1042"><span class='Ref_To_Local'>parent_rte</span></a> <span class='Operator'>= </span><a href="../../../include/parser/parsetree.h.html#LN30"><span class='Ref_to_Macro'>rt_fetch</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1026"><span class='Ref_To_Local'>parentRTindex</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1023"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN134"><span class='Ref_to_Member'>rtable</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1042"><span class='Ref_To_Local'>parent_rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN948"><span class='Ref_to_Member'>relkind</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_class.h.html#LN167"><span class='Ref_to_Const'>RELKIND_PARTITIONED_TABLE</span></a><span class='Parentheses'>) 
</span>        <a href="planner.c.html#LN1029"><span class='Ref_To_Local'>nominalRelation</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN1026"><span class='Ref_To_Local'>parentRTindex</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * And now we can get on with generating a plan for each child table. 
     */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1040"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1023"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN251"><span class='Ref_to_Member'>append_rel_list</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1118"></a>        <a href="../../../include/nodes/relation.h.html#LN1964"><span class='Ref_to_Struct'>AppendRelInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>appinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1964"><span class='Ref_to_Struct'>AppendRelInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1040"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1119"></a>        <a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>subroot</span><span class='Delimiter'>; 
</span><a name="LN1120"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>child_rte</span><span class='Delimiter'>; 
</span><a name="LN1121"></a>        <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sub_final_rel</span><span class='Delimiter'>; 
</span><a name="LN1122"></a>        <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>subpath</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* append_rel_list contains all append rels; ignore others */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1118"><span class='Ref_To_Local'>appinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1974"><span class='Ref_to_Member'>parent_relid</span></a> <span class='Operator'>!= </span><a href="planner.c.html#LN1026"><span class='Ref_To_Local'>parentRTindex</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We need a working copy of the PlannerInfo so that we can control 
         * propagation of information back to the main copy. 
         */ 
</span>        <a href="planner.c.html#LN1119"><span class='Ref_To_Local'>subroot</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        memcpy<span class='Parentheses'>(</span><a href="planner.c.html#LN1119"><span class='Ref_To_Local'>subroot</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1023"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Generate modified query with this rel as target.  We first apply 
         * adjust_appendrel_attrs, which copies the Query and changes 
         * references to the parent RTE to refer to the current child RTE, 
         * then fool around with subquery RTEs. 
         */ 
</span>        <a href="planner.c.html#LN1119"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../../include/optimizer/prep.h.html#LN54"><span class='Ref_to_Proto'>adjust_appendrel_attrs</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1023"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                   <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN1025"><span class='Ref_To_Local'>parse</span></a><span class='Delimiter'>, 
</span>                                   <a href="planner.c.html#LN1118"><span class='Ref_To_Local'>appinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If there are securityQuals attached to the parent, move them to the 
         * child rel (they've already been transformed properly for that). 
         */ 
</span>        <a href="planner.c.html#LN1042"><span class='Ref_To_Local'>parent_rte</span></a> <span class='Operator'>= </span><a href="../../../include/parser/parsetree.h.html#LN30"><span class='Ref_to_Macro'>rt_fetch</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1026"><span class='Ref_To_Local'>parentRTindex</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1119"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN134"><span class='Ref_to_Member'>rtable</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN1120"><span class='Ref_To_Local'>child_rte</span></a> <span class='Operator'>= </span><a href="../../../include/parser/parsetree.h.html#LN30"><span class='Ref_to_Macro'>rt_fetch</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1118"><span class='Ref_To_Local'>appinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1975"><span class='Ref_to_Member'>child_relid</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1119"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN134"><span class='Ref_to_Member'>rtable</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN1120"><span class='Ref_To_Local'>child_rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1032"><span class='Ref_to_Member'>securityQuals</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN1042"><span class='Ref_To_Local'>parent_rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1032"><span class='Ref_to_Member'>securityQuals</span></a><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN1042"><span class='Ref_To_Local'>parent_rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1032"><span class='Ref_to_Member'>securityQuals</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * The rowMarks list might contain references to subquery RTEs, so 
         * make a copy that we can apply ChangeVarNodes to.  (Fortunately, the 
         * executor doesn't need to see the modified copies --- we can just 
         * pass it the original rowMarks list.) 
         */ 
</span>        <a href="planner.c.html#LN1119"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN255"><span class='Ref_to_Member'>rowMarks</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1023"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN255"><span class='Ref_to_Member'>rowMarks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * The append_rel_list likewise might contain references to subquery 
         * RTEs (if any subqueries were flattenable UNION ALLs).  So prepare 
         * to apply ChangeVarNodes to that, too.  As explained above, we only 
         * want to copy items that actually contain such references; the rest 
         * can just get linked into the subroot's append_rel_list. 
         * 
         * If we know there are no such references, we can just use the outer 
         * append_rel_list unmodified. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1028"><span class='Ref_To_Local'>modifiableARIindexes</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1175"></a>            <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc2</span><span class='Delimiter'>; 
</span> 
            <a href="planner.c.html#LN1119"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN251"><span class='Ref_to_Member'>append_rel_list</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>            <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1175"><span class='Ref_To_Local'>lc2</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1023"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN251"><span class='Ref_to_Member'>append_rel_list</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN1180"></a>                <a href="../../../include/nodes/relation.h.html#LN1964"><span class='Ref_to_Struct'>AppendRelInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>appinfo2</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1964"><span class='Ref_to_Struct'>AppendRelInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1175"><span class='Ref_To_Local'>lc2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN75"><span class='Ref_to_Proto'>bms_is_member</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1180"><span class='Ref_To_Local'>appinfo2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1975"><span class='Ref_to_Member'>child_relid</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1028"><span class='Ref_To_Local'>modifiableARIindexes</span></a><span class='Parentheses'>))</span> 
                    <a href="planner.c.html#LN1180"><span class='Ref_To_Local'>appinfo2</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1180"><span class='Ref_To_Local'>appinfo2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="planner.c.html#LN1119"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN251"><span class='Ref_to_Member'>append_rel_list</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1119"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN251"><span class='Ref_to_Member'>append_rel_list</span></a><span class='Delimiter'>, 
</span>                                                   <a href="planner.c.html#LN1180"><span class='Ref_To_Local'>appinfo2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Add placeholders to the child Query's rangetable list to fill the 
         * RT indexes already reserved for subqueries in previous children. 
         * These won't be referenced, so there's no need to make them very 
         * valid-looking. 
         */ 
</span>        <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1119"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN134"><span class='Ref_to_Member'>rtable</span></a><span class='Parentheses'>) </span><span class='Operator'>&LT; </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1030"><span class='Ref_To_Local'>final_rtable</span></a><span class='Parentheses'>))</span> 
            <a href="planner.c.html#LN1119"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN134"><span class='Ref_to_Member'>rtable</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1119"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN134"><span class='Ref_to_Member'>rtable</span></a><span class='Delimiter'>, 
</span>                                             <a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If this isn't the first child Query, generate duplicates of all 
         * subquery RTEs, and adjust Var numbering to reference the 
         * duplicates. To simplify the loop logic, we scan the original rtable 
         * not the copy just made by adjust_appendrel_attrs; that should be OK 
         * since subquery RTEs couldn't contain any references to the target 
         * rel. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1030"><span class='Ref_To_Local'>final_rtable</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>&& </span><a href="planner.c.html#LN1027"><span class='Ref_To_Local'>subqueryRTindexes</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1210"></a>            <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lr</span><span class='Delimiter'>; 
</span> 
            <a href="planner.c.html#LN1041"><span class='Ref_To_Local'>rti</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>            <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1210"><span class='Ref_To_Local'>lr</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1025"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN134"><span class='Ref_to_Member'>rtable</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN1215"></a>                <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1210"><span class='Ref_To_Local'>lr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN75"><span class='Ref_to_Proto'>bms_is_member</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1041"><span class='Ref_To_Local'>rti</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1027"><span class='Ref_To_Local'>subqueryRTindexes</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span><a name="LN1219"></a>                    <a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Local'>newrti</span><span class='Delimiter'>; 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * The RTE can't contain any references to its own RT 
                     * index, except in its securityQuals, so we can save a 
                     * few cycles by applying ChangeVarNodes to the rest of 
                     * the rangetable before we append the RTE to it. 
                     */ 
</span>                    <a href="planner.c.html#LN1219"><span class='Ref_To_Local'>newrti</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1119"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN134"><span class='Ref_to_Member'>rtable</span></a><span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>                    <a href="../../../include/rewrite/rewriteManip.h.html#LN42"><span class='Ref_to_Proto'>ChangeVarNodes</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN1119"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1041"><span class='Ref_To_Local'>rti</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1219"><span class='Ref_To_Local'>newrti</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../../../include/rewrite/rewriteManip.h.html#LN42"><span class='Ref_to_Proto'>ChangeVarNodes</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN1119"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN255"><span class='Ref_to_Member'>rowMarks</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1041"><span class='Ref_To_Local'>rti</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1219"><span class='Ref_To_Local'>newrti</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Comment_Multi_Line'>/* Skip processing unchanging parts of append_rel_list */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1028"><span class='Ref_To_Local'>modifiableARIindexes</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span><a name="LN1233"></a>                        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc2</span><span class='Delimiter'>; 
</span> 
                        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1233"><span class='Ref_To_Local'>lc2</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1119"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN251"><span class='Ref_to_Member'>append_rel_list</span></a><span class='Parentheses'>) 
</span>                        <span class='Delimiter'>{ 
</span><a name="LN1237"></a>                            <a href="../../../include/nodes/relation.h.html#LN1964"><span class='Ref_to_Struct'>AppendRelInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>appinfo2</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1964"><span class='Ref_to_Struct'>AppendRelInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1233"><span class='Ref_To_Local'>lc2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN75"><span class='Ref_to_Proto'>bms_is_member</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1237"><span class='Ref_To_Local'>appinfo2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1975"><span class='Ref_to_Member'>child_relid</span></a><span class='Delimiter'>, 
</span>                                              <a href="planner.c.html#LN1028"><span class='Ref_To_Local'>modifiableARIindexes</span></a><span class='Parentheses'>))</span> 
                                <a href="../../../include/rewrite/rewriteManip.h.html#LN42"><span class='Ref_to_Proto'>ChangeVarNodes</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN1237"><span class='Ref_To_Local'>appinfo2</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1041"><span class='Ref_To_Local'>rti</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1219"><span class='Ref_To_Local'>newrti</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                    <span class='Delimiter'>} 
</span>                    <a href="planner.c.html#LN1215"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1215"><span class='Ref_To_Local'>rte</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../../../include/rewrite/rewriteManip.h.html#LN42"><span class='Ref_to_Proto'>ChangeVarNodes</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN1215"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1032"><span class='Ref_to_Member'>securityQuals</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1041"><span class='Ref_To_Local'>rti</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1219"><span class='Ref_To_Local'>newrti</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="planner.c.html#LN1119"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN134"><span class='Ref_to_Member'>rtable</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1119"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN134"><span class='Ref_to_Member'>rtable</span></a><span class='Delimiter'>, 
</span>                                                     <a href="planner.c.html#LN1215"><span class='Ref_To_Local'>rte</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if bms_is_member(rti,sub... &raquo; </span> 
                <a href="planner.c.html#LN1041"><span class='Ref_To_Local'>rti</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if final_rtable!=NIL&&su... &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* There shouldn't be any OJ info to translate, as yet */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="planner.c.html#LN1119"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN249"><span class='Ref_to_Member'>join_info_list</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* and we haven't created PlaceHolderInfos, either */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="planner.c.html#LN1119"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN257"><span class='Ref_to_Member'>placeholder_list</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* hack to mark target relation as an inheritance partition */ 
</span>        <a href="planner.c.html#LN1119"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN296"><span class='Ref_to_Member'>hasInheritedTarget</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Generate Path(s) for accessing this result relation */ 
</span>        <a href="planner.c.html#LN114"><span class='Ref_to_Proto'>grouping_planner</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1119"><span class='Ref_To_Local'>subroot</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Comment_Multi_Line'>/* retrieve all tuples */ </span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Set the nomimal target relation of the ModifyTable node if not 
         * already done.  We use the inheritance parent RTE as the nominal 
         * target relation if it's a partitioned table (see just above this 
         * loop).  In the non-partitioned parent case, we'll use the first 
         * child relation (even if it's excluded) as the nominal target 
         * relation.  Because of the way expand_inherited_rtentry works, the 
         * latter should be the RTE representing the parent table in its role 
         * as a simple member of the inheritance set. 
         * 
         * It would be logically cleaner to *always* use the inheritance 
         * parent RTE as the nominal relation; but that RTE is not otherwise 
         * referenced in the plan in the non-partitioned inheritance case. 
         * Instead the duplicate child RTE created by expand_inherited_rtentry 
         * is used elsewhere in the plan, so using the original parent RTE 
         * would give rise to confusing use of multiple aliases in EXPLAIN 
         * output for what the user will think is the "same" table.  OTOH, 
         * it's not a problem in the partitioned inheritance case, because the 
         * duplicate child RTE added for the parent does not appear anywhere 
         * else in the plan tree. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1029"><span class='Ref_To_Local'>nominalRelation</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <a href="planner.c.html#LN1029"><span class='Ref_To_Local'>nominalRelation</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN1118"><span class='Ref_To_Local'>appinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1975"><span class='Ref_to_Member'>child_relid</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Select cheapest path in case there's more than one.  We always run 
         * modification queries to conclusion, so we care only for the 
         * cheapest-total path. 
         */ 
</span>        <a href="planner.c.html#LN1121"><span class='Ref_To_Local'>sub_final_rel</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/pathnode.h.html#LN270"><span class='Ref_to_Proto'>fetch_upper_rel</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1119"><span class='Ref_To_Local'>subroot</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN77"><span class='Ref_to_EnumConst'>UPPERREL_FINAL</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/optimizer/pathnode.h.html#LN26"><span class='Ref_to_Proto'>set_cheapest</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1121"><span class='Ref_To_Local'>sub_final_rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN1122"><span class='Ref_To_Local'>subpath</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN1121"><span class='Ref_To_Local'>sub_final_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN542"><span class='Ref_to_Member'>cheapest_total_path</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If this child rel was excluded by constraint exclusion, exclude it 
         * from the result plan. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1182"><span class='Ref_to_Macro'>IS_DUMMY_PATH</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1122"><span class='Ref_To_Local'>subpath</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If this is the first non-excluded child, its post-planning rtable 
         * becomes the initial contents of final_rtable; otherwise, append 
         * just its modified subquery RTEs to final_rtable. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1030"><span class='Ref_To_Local'>final_rtable</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>            <a href="planner.c.html#LN1030"><span class='Ref_To_Local'>final_rtable</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN1119"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN134"><span class='Ref_to_Member'>rtable</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="planner.c.html#LN1030"><span class='Ref_To_Local'>final_rtable</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1030"><span class='Ref_To_Local'>final_rtable</span></a><span class='Delimiter'>, 
</span>                                       <a href="../../../include/nodes/pg_list.h.html#LN269"><span class='Ref_to_Proto'>list_copy_tail</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1119"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN134"><span class='Ref_to_Member'>rtable</span></a><span class='Delimiter'>, 
</span>                                                 <a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1030"><span class='Ref_To_Local'>final_rtable</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We need to collect all the RelOptInfos from all child plans into 
         * the main PlannerInfo, since setrefs.c will need them.  We use the 
         * last child's simple_rel_array (previous ones are too short), so we 
         * have to propagate forward the RelOptInfos that were already built 
         * in previous children. 
         */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="planner.c.html#LN1119"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN179"><span class='Ref_to_Member'>simple_rel_array_size</span></a> <span class='Operator'>&GT;= </span><a href="planner.c.html#LN1031"><span class='Ref_To_Local'>save_rel_array_size</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1041"><span class='Ref_To_Local'>rti</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="planner.c.html#LN1041"><span class='Ref_To_Local'>rti</span></a> <span class='Operator'>&LT; </span><a href="planner.c.html#LN1031"><span class='Ref_To_Local'>save_rel_array_size</span></a><span class='Delimiter'>; </span><a href="planner.c.html#LN1041"><span class='Ref_To_Local'>rti</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1325"></a>            <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>brel</span> <span class='Operator'>= </span><a href="planner.c.html#LN1032"><span class='Ref_To_Local'>save_rel_array</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN1041"><span class='Ref_To_Local'>rti</span></a><span class='Delimiter'>]; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1325"><span class='Ref_To_Local'>brel</span></a><span class='Parentheses'>) 
</span>                <a href="planner.c.html#LN1119"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN178"><span class='Ref_to_Member'>simple_rel_array</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN1041"><span class='Ref_To_Local'>rti</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="planner.c.html#LN1325"><span class='Ref_To_Local'>brel</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="planner.c.html#LN1031"><span class='Ref_To_Local'>save_rel_array_size</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN1119"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN179"><span class='Ref_to_Member'>simple_rel_array_size</span></a><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN1032"><span class='Ref_To_Local'>save_rel_array</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN1119"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN178"><span class='Ref_to_Member'>simple_rel_array</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Make sure any initplans from this rel get into the outer list */ 
</span>        <a href="planner.c.html#LN1023"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN227"><span class='Ref_to_Member'>init_plans</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN1119"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN227"><span class='Ref_to_Member'>init_plans</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Build list of sub-paths */ 
</span>        <a href="planner.c.html#LN1033"><span class='Ref_To_Local'>subpaths</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1033"><span class='Ref_To_Local'>subpaths</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1122"><span class='Ref_To_Local'>subpath</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Build list of modified subroots, too */ 
</span>        <a href="planner.c.html#LN1034"><span class='Ref_To_Local'>subroots</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1034"><span class='Ref_To_Local'>subroots</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1119"><span class='Ref_To_Local'>subroot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Build list of target-relation RT indexes */ 
</span>        <a href="planner.c.html#LN1035"><span class='Ref_To_Local'>resultRelations</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN144"><span class='Ref_to_Func'>lappend_int</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1035"><span class='Ref_To_Local'>resultRelations</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1118"><span class='Ref_To_Local'>appinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1975"><span class='Ref_to_Member'>child_relid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Build lists of per-relation WCO and RETURNING targetlists */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1025"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN168"><span class='Ref_to_Member'>withCheckOptions</span></a><span class='Parentheses'>) 
</span>            <a href="planner.c.html#LN1036"><span class='Ref_To_Local'>withCheckOptionLists</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1036"><span class='Ref_To_Local'>withCheckOptionLists</span></a><span class='Delimiter'>, 
</span>                                           <a href="planner.c.html#LN1119"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN168"><span class='Ref_to_Member'>withCheckOptions</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1025"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN143"><span class='Ref_to_Member'>returningList</span></a><span class='Parentheses'>) 
</span>            <a href="planner.c.html#LN1037"><span class='Ref_To_Local'>returningLists</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1037"><span class='Ref_To_Local'>returningLists</span></a><span class='Delimiter'>, 
</span>                                     <a href="planner.c.html#LN1119"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN143"><span class='Ref_to_Member'>returningList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="planner.c.html#LN1025"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN141"><span class='Ref_to_Member'>onConflict</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1042"><span class='Ref_To_Local'>parent_rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN948"><span class='Ref_to_Member'>relkind</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_class.h.html#LN167"><span class='Ref_to_Const'>RELKIND_PARTITIONED_TABLE</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="planner.c.html#LN1043"><span class='Ref_To_Local'>partitioned_rels</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/planner.h.html#LN59"><span class='Ref_to_Proto'>get_partitioned_child_rels</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1023"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1026"><span class='Ref_To_Local'>parentRTindex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* The root partitioned table is included as a child rel */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1043"><span class='Ref_To_Local'>partitioned_rels</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT;= </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Result path must go into outer query's FINAL upperrel */ 
</span>    <a href="planner.c.html#LN1039"><span class='Ref_To_Local'>final_rel</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/pathnode.h.html#LN270"><span class='Ref_to_Proto'>fetch_upper_rel</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1023"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN77"><span class='Ref_to_EnumConst'>UPPERREL_FINAL</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We don't currently worry about setting final_rel's consider_parallel 
     * flag in this case, nor about allowing FDWs or create_upper_paths_hook 
     * to get control here. 
     */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we managed to exclude every child rel, return a dummy plan; it 
     * doesn't even need a ModifyTable node. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1033"><span class='Ref_To_Local'>subpaths</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/optimizer/paths.h.html#LN51"><span class='Ref_to_Proto'>set_dummy_rel_pathlist</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1039"><span class='Ref_To_Local'>final_rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Put back the final adjusted rtable into the master copy of the Query. 
     * (We mustn't do this if we found no non-excluded children.) 
     */ 
</span>    <a href="planner.c.html#LN1025"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN134"><span class='Ref_to_Member'>rtable</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN1030"><span class='Ref_To_Local'>final_rtable</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN1023"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN179"><span class='Ref_to_Member'>simple_rel_array_size</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN1031"><span class='Ref_To_Local'>save_rel_array_size</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN1023"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN178"><span class='Ref_to_Member'>simple_rel_array</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN1032"><span class='Ref_To_Local'>save_rel_array</span></a><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* Must reconstruct master's simple_rte_array, too */ 
</span>    <a href="planner.c.html#LN1023"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN187"><span class='Ref_to_Member'>simple_rte_array</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>**</span><span class='Parentheses'>) 
</span>        <a href="../../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1030"><span class='Ref_To_Local'>final_rtable</span></a><span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>)</span> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN1041"><span class='Ref_To_Local'>rti</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1040"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1030"><span class='Ref_To_Local'>final_rtable</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1395"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1040"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="planner.c.html#LN1023"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN187"><span class='Ref_to_Member'>simple_rte_array</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN1041"><span class='Ref_To_Local'>rti</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="planner.c.html#LN1395"><span class='Ref_To_Local'>rte</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If there was a FOR [KEY] UPDATE/SHARE clause, the LockRows node will 
     * have dealt with fetching non-locked marked rows, else we need to have 
     * ModifyTable do that. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1025"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN160"><span class='Ref_to_Member'>rowMarks</span></a><span class='Parentheses'>) 
</span>        <a href="planner.c.html#LN1038"><span class='Ref_To_Local'>rowMarks</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="planner.c.html#LN1038"><span class='Ref_To_Local'>rowMarks</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN1023"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN255"><span class='Ref_to_Member'>rowMarks</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Create Path representing a ModifyTable to do the UPDATE/DELETE work */ 
</span>    <a href="../../../include/optimizer/pathnode.h.html#LN27"><span class='Ref_to_Proto'>add_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1039"><span class='Ref_To_Local'>final_rel</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> 
             <a href="../../../include/optimizer/pathnode.h.html#LN233"><span class='Ref_to_Proto'>create_modifytable_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1023"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1039"><span class='Ref_To_Local'>final_rel</span></a><span class='Delimiter'>, 
</span>                                     <a href="planner.c.html#LN1025"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN109"><span class='Ref_to_Member'>commandType</span></a><span class='Delimiter'>, 
</span>                                     <a href="planner.c.html#LN1025"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN115"><span class='Ref_to_Member'>canSetTag</span></a><span class='Delimiter'>, 
</span>                                     <a href="planner.c.html#LN1029"><span class='Ref_To_Local'>nominalRelation</span></a><span class='Delimiter'>, 
</span>                                     <a href="planner.c.html#LN1043"><span class='Ref_To_Local'>partitioned_rels</span></a><span class='Delimiter'>, 
</span>                                     <a href="planner.c.html#LN1035"><span class='Ref_To_Local'>resultRelations</span></a><span class='Delimiter'>, 
</span>                                     <a href="planner.c.html#LN1033"><span class='Ref_To_Local'>subpaths</span></a><span class='Delimiter'>, 
</span>                                     <a href="planner.c.html#LN1034"><span class='Ref_To_Local'>subroots</span></a><span class='Delimiter'>, 
</span>                                     <a href="planner.c.html#LN1036"><span class='Ref_To_Local'>withCheckOptionLists</span></a><span class='Delimiter'>, 
</span>                                     <a href="planner.c.html#LN1037"><span class='Ref_To_Local'>returningLists</span></a><span class='Delimiter'>, 
</span>                                     <a href="planner.c.html#LN1038"><span class='Ref_To_Local'>rowMarks</span></a><span class='Delimiter'>, 
</span>                                     <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                     <a href="../../../include/optimizer/subselect.h.html#LN40"><span class='Ref_to_Proto'>SS_assign_special_param</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1023"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end inheritance_planner &raquo; </span> 
 
<span class='Comment_Multi_Line'>/*-------------------- 
 * grouping_planner 
 *    Perform planning steps related to grouping, aggregation, etc. 
 * 
 * This function adds all required top-level processing to the scan/join 
 * Path(s) produced by query_planner. 
 * 
 * If inheritance_update is true, we're being called from inheritance_planner 
 * and should not include a ModifyTable step in the resulting Path(s). 
 * (inheritance_planner will create a single ModifyTable node covering all the 
 * target tables.) 
 * 
 * tuple_fraction is the fraction of tuples we expect will be retrieved. 
 * tuple_fraction is interpreted as follows: 
 *    0: expect all tuples to be retrieved (normal case) 
 *    0 &LT; tuple_fraction &LT; 1: expect the given fraction of tuples available 
 *      from the plan to be retrieved 
 *    tuple_fraction &GT;= 1: tuple_fraction is the absolute number of tuples 
 *      expected to be retrieved (ie, a LIMIT specification) 
 * 
 * Returns nothing; the useful output is in the Paths we attach to the 
 * (UPPERREL_FINAL, NULL) upperrel in *root.  In addition, 
 * root-&GT;processed_tlist contains the final processed targetlist. 
 * 
 * Note that we have not done set_cheapest() on the final rel; it's convenient 
 * to leave this to the caller. 
 *-------------------- 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1456"></a><span class='Declare_Function'>grouping_planner</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>inheritance_update</span><span class='Delimiter'>, 
</span><a name="LN1457"></a>                 <span class='Keyword'>double </span><span class='Declare_Parameter'>tuple_fraction</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1459"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>parse</span> <span class='Operator'>= </span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Delimiter'>; 
</span><a name="LN1460"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>tlist</span> <span class='Operator'>= </span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Delimiter'>; 
</span><a name="LN1461"></a>    <a href="../../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a>       <span class='Declare_Local'>offset_est</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1462"></a>    <a href="../../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a>       <span class='Declare_Local'>count_est</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1463"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>limit_tuples</span> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1464"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>have_postponed_srfs</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN1465"></a>    <a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Local'>final_target</span><span class='Delimiter'>; 
</span><a name="LN1466"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>final_targets</span><span class='Delimiter'>; 
</span><a name="LN1467"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>final_targets_contain_srfs</span><span class='Delimiter'>; 
</span><a name="LN1468"></a>    <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>current_rel</span><span class='Delimiter'>; 
</span><a name="LN1469"></a>    <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>final_rel</span><span class='Delimiter'>; 
</span><a name="LN1470"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Tweak caller-supplied tuple_fraction if have LIMIT/OFFSET */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN158"><span class='Ref_to_Member'>limitCount</span></a> <span class='Operator'>|| </span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN157"><span class='Ref_to_Member'>limitOffset</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="planner.c.html#LN1457"><span class='Ref_to_Parameter'>tuple_fraction</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN120"><span class='Ref_to_Proto'>preprocess_limit</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1457"><span class='Ref_to_Parameter'>tuple_fraction</span></a><span class='Delimiter'>, 
</span>                                          <span class='Operator'>&</span><a href="planner.c.html#LN1461"><span class='Ref_To_Local'>offset_est</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="planner.c.html#LN1462"><span class='Ref_To_Local'>count_est</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If we have a known LIMIT, and don't have an unknown OFFSET, we can 
         * estimate the effects of using a bounded sort. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1462"><span class='Ref_To_Local'>count_est</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="planner.c.html#LN1461"><span class='Ref_To_Local'>offset_est</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <a href="planner.c.html#LN1463"><span class='Ref_To_Local'>limit_tuples</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="planner.c.html#LN1462"><span class='Ref_To_Local'>count_est</span></a> <span class='Operator'>+ </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="planner.c.html#LN1461"><span class='Ref_To_Local'>offset_est</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Make tuple_fraction accessible to lower-level routines */ 
</span>    <a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN290"><span class='Ref_to_Member'>tuple_fraction</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN1457"><span class='Ref_to_Parameter'>tuple_fraction</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN162"><span class='Ref_to_Member'>setOperations</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * If there's a top-level ORDER BY, assume we have to fetch all the 
         * tuples.  This might be too simplistic given all the hackery below 
         * to possibly avoid the sort; but the odds of accurate estimates here 
         * are pretty low anyway.  XXX try to get rid of this in favor of 
         * letting plan_set_operations generate both fast-start and 
         * cheapest-total paths. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN155"><span class='Ref_to_Member'>sortClause</span></a><span class='Parentheses'>) 
</span>            <a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN290"><span class='Ref_to_Member'>tuple_fraction</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Construct Paths for set operations.  The results will not need any 
         * work except perhaps a top-level sort and/or LIMIT.  Note that any 
         * special work for recursive unions is the responsibility of 
         * plan_set_operations. 
         */ 
</span>        <a href="planner.c.html#LN1468"><span class='Ref_To_Local'>current_rel</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/prep.h.html#LN50"><span class='Ref_to_Proto'>plan_set_operations</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We should not need to call preprocess_targetlist, since we must be 
         * in a SELECT query node.  Instead, use the targetlist returned by 
         * plan_set_operations (since this tells whether it returned any 
         * resjunk columns!), and transfer any sort key information from the 
         * original tlist. 
         */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN109"><span class='Ref_to_Member'>commandType</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN650"><span class='Ref_to_EnumConst'>CMD_SELECT</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="planner.c.html#LN1460"><span class='Ref_To_Local'>tlist</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN280"><span class='Ref_to_Member'>processed_tlist</span></a><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* from plan_set_operations */ 
</span> 
        <span class='Comment_Multi_Line'>/* for safety, copy processed_tlist instead of modifying in-place */ 
</span>        <a href="planner.c.html#LN1460"><span class='Ref_To_Local'>tlist</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN174"><span class='Ref_to_Proto'>postprocess_setop_tlist</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1460"><span class='Ref_To_Local'>tlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Save aside the final decorated tlist */ 
</span>        <a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN280"><span class='Ref_to_Member'>processed_tlist</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN1460"><span class='Ref_To_Local'>tlist</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Also extract the PathTarget form of the setop result tlist */ 
</span>        <a href="planner.c.html#LN1465"><span class='Ref_To_Local'>final_target</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN1468"><span class='Ref_To_Local'>current_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN542"><span class='Ref_to_Member'>cheapest_total_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* The setop result tlist couldn't contain any SRFs */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN124"><span class='Ref_to_Member'>hasTargetSRFs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN1466"><span class='Ref_To_Local'>final_targets</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN1467"><span class='Ref_To_Local'>final_targets_contain_srfs</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Can't handle FOR [KEY] UPDATE/SHARE here (parser should have 
         * checked already, but let's make sure). 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN160"><span class='Ref_to_Member'>rowMarks</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>            <span class='Comment_Multi_Line'>/*------ 
              translator: %s is a SQL row locking clause such as FOR UPDATE */ 
</span>                     <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"%s is not allowed with UNION/INTERSECT/EXCEPT"</span><span class='Delimiter'>, 
</span>                            <a href="../../../include/parser/analyze.h.html#LN39"><span class='Ref_to_Proto'>LCS_asString</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/parsenodes.h.html#LN1278"><span class='Ref_to_Struct'>RowMarkClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                                    <a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN160"><span class='Ref_to_Member'>rowMarks</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>strength<span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Calculate pathkeys that represent result ordering requirements 
         */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN153"><span class='Ref_to_Member'>distinctClause</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN266"><span class='Ref_to_Member'>sort_pathkeys</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/paths.h.html#LN205"><span class='Ref_to_Proto'>make_pathkeys_for_sortclauses</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                            <a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN155"><span class='Ref_to_Member'>sortClause</span></a><span class='Delimiter'>, 
</span>                                                            <a href="planner.c.html#LN1460"><span class='Ref_To_Local'>tlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if parse-&GT;setOperations &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* No set operations, do regular planning */ 
</span><a name="LN1558"></a>        <a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sort_input_target</span><span class='Delimiter'>; 
</span><a name="LN1559"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>sort_input_targets</span><span class='Delimiter'>; 
</span><a name="LN1560"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>sort_input_targets_contain_srfs</span><span class='Delimiter'>; 
</span><a name="LN1561"></a>        <a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Local'>grouping_target</span><span class='Delimiter'>; 
</span><a name="LN1562"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>grouping_targets</span><span class='Delimiter'>; 
</span><a name="LN1563"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>grouping_targets_contain_srfs</span><span class='Delimiter'>; 
</span><a name="LN1564"></a>        <a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Local'>scanjoin_target</span><span class='Delimiter'>; 
</span><a name="LN1565"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>scanjoin_targets</span><span class='Delimiter'>; 
</span><a name="LN1566"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>scanjoin_targets_contain_srfs</span><span class='Delimiter'>; 
</span><a name="LN1567"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>have_grouping</span><span class='Delimiter'>; 
</span><a name="LN1568"></a>        <a href="../../../include/nodes/relation.h.html#LN55"><span class='Ref_to_Struct'>AggClauseCosts</span></a> <span class='Declare_Local'>agg_costs</span><span class='Delimiter'>; 
</span><a name="LN1569"></a>        <a href="../../../include/optimizer/clauses.h.html#LN22"><span class='Ref_to_Typedef'>WindowFuncLists</span></a> <span class='Operator'>*</span><span class='Declare_Local'>wflists</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN1570"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>activeWindows</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN1571"></a>        <a href="planner.c.html#LN98"><span class='Ref_to_Typedef'>grouping_sets_data</span></a> <span class='Operator'>*</span><span class='Declare_Local'>gset_data</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN1572"></a>        <a href="planner.c.html#LN87"><span class='Ref_to_Typedef'>standard_qp_extra</span></a> <span class='Declare_Local'>qp_extra</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* A recursive query should always have setOperations */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN304"><span class='Ref_to_Member'>hasRecursion</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Preprocess grouping sets and GROUP BY clause, if any */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN147"><span class='Ref_to_Member'>groupingSets</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="planner.c.html#LN1571"><span class='Ref_To_Local'>gset_data</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN116"><span class='Ref_to_Proto'>preprocess_grouping_sets</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Preprocess regular GROUP BY clause, if any */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Parentheses'>) 
</span>                <a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN125"><span class='Ref_to_Proto'>preprocess_groupclause</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Preprocess targetlist */ 
</span>        <a href="planner.c.html#LN1460"><span class='Ref_To_Local'>tlist</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/prep.h.html#LN40"><span class='Ref_to_Proto'>preprocess_targetlist</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1460"><span class='Ref_To_Local'>tlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN141"><span class='Ref_to_Member'>onConflict</span></a><span class='Parentheses'>) 
</span>            <a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN141"><span class='Ref_to_Member'>onConflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1494"><span class='Ref_to_Member'>onConflictSet</span></a> <span class='Operator'>= 
</span>                <a href="../../../include/optimizer/prep.h.html#LN42"><span class='Ref_to_Proto'>preprocess_onconflict_targetlist</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN141"><span class='Ref_to_Member'>onConflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1494"><span class='Ref_to_Member'>onConflictSet</span></a><span class='Delimiter'>, 
</span>                                                 <a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN119"><span class='Ref_to_Member'>resultRelation</span></a><span class='Delimiter'>, 
</span>                                                 <a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN134"><span class='Ref_to_Member'>rtable</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We are now done hacking up the query's targetlist.  Most of the 
         * remaining planning work will be done with the PathTarget 
         * representation of tlists, but save aside the full representation so 
         * that we can transfer its decoration (resnames etc) to the topmost 
         * tlist of the finished Plan. 
         */ 
</span>        <a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN280"><span class='Ref_to_Member'>processed_tlist</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN1460"><span class='Ref_To_Local'>tlist</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Collect statistics about aggregates for estimating costs, and mark 
         * all the aggregates with resolved aggtranstypes.  We must do this 
         * before slicing and dicing the tlist into various pathtargets, else 
         * some copies of the Aggref nodes might escape being marked with the 
         * correct transtypes. 
         * 
         * Note: currently, we do not detect duplicate aggregates here.  This 
         * may result in somewhat-overestimated cost, which is fine for our 
         * purposes since all Paths will get charged the same.  But at some 
         * point we might wish to do that detection in the planner, rather 
         * than during executor startup. 
         */ 
</span>        <a href="../../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="planner.c.html#LN1568"><span class='Ref_To_Local'>agg_costs</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN55"><span class='Ref_to_Struct'>AggClauseCosts</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN122"><span class='Ref_to_Member'>hasAggs</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../../include/optimizer/clauses.h.html#LN49"><span class='Ref_to_Proto'>get_agg_clause_costs</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN1460"><span class='Ref_To_Local'>tlist</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN758"><span class='Ref_to_EnumConst'>AGGSPLIT_SIMPLE</span></a><span class='Delimiter'>, 
</span>                                 <span class='Operator'>&</span><a href="planner.c.html#LN1568"><span class='Ref_To_Local'>agg_costs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/optimizer/clauses.h.html#LN49"><span class='Ref_to_Proto'>get_agg_clause_costs</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN758"><span class='Ref_to_EnumConst'>AGGSPLIT_SIMPLE</span></a><span class='Delimiter'>, 
</span>                                 <span class='Operator'>&</span><a href="planner.c.html#LN1568"><span class='Ref_To_Local'>agg_costs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Locate any window functions in the tlist.  (We don't need to look 
         * anywhere else, since expressions used in ORDER BY will be in there 
         * too.)  Note that they could all have been eliminated by constant 
         * folding, in which case we don't need to do any more work. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN123"><span class='Ref_to_Member'>hasWindowFuncs</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="planner.c.html#LN1569"><span class='Ref_To_Local'>wflists</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/clauses.h.html#LN53"><span class='Ref_to_Proto'>find_window_functions</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN1460"><span class='Ref_To_Local'>tlist</span></a><span class='Delimiter'>, 
</span>                                            <a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN151"><span class='Ref_to_Member'>windowClause</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1569"><span class='Ref_To_Local'>wflists</span></a><span class='Operator'>-&GT;</span><a href="../../../include/optimizer/clauses.h.html#LN24"><span class='Ref_to_Member'>numWindowFuncs</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <a href="planner.c.html#LN1570"><span class='Ref_To_Local'>activeWindows</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN175"><span class='Ref_to_Proto'>select_active_windows</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1569"><span class='Ref_To_Local'>wflists</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN123"><span class='Ref_to_Member'>hasWindowFuncs</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Preprocess MIN/MAX aggregates, if any.  Note: be careful about 
         * adding logic between here and the query_planner() call.  Anything 
         * that is needed in MIN/MAX-optimizable cases will have to be 
         * duplicated in planagg.c. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN122"><span class='Ref_to_Member'>hasAggs</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/optimizer/planmain.h.html#LN44"><span class='Ref_to_Proto'>preprocess_minmax_aggregates</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1460"><span class='Ref_To_Local'>tlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Figure out whether there's a hard limit on the number of rows that 
         * query_planner's result subplan needs to return.  Even if we know a 
         * hard limit overall, it doesn't apply if the query has any 
         * grouping/aggregation operations, or SRFs in the tlist. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a> <span class='Operator'>|| 
</span>            <a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN147"><span class='Ref_to_Member'>groupingSets</span></a> <span class='Operator'>|| 
</span>            <a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN153"><span class='Ref_to_Member'>distinctClause</span></a> <span class='Operator'>|| 
</span>            <a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN122"><span class='Ref_to_Member'>hasAggs</span></a> <span class='Operator'>|| 
</span>            <a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN123"><span class='Ref_to_Member'>hasWindowFuncs</span></a> <span class='Operator'>|| 
</span>            <a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN124"><span class='Ref_to_Member'>hasTargetSRFs</span></a> <span class='Operator'>|| 
</span>            <a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN301"><span class='Ref_to_Member'>hasHavingQual</span></a><span class='Parentheses'>) 
</span>            <a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN291"><span class='Ref_to_Member'>limit_tuples</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN291"><span class='Ref_to_Member'>limit_tuples</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN1463"><span class='Ref_To_Local'>limit_tuples</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Set up data needed by standard_qp_callback */ 
</span>        <a href="planner.c.html#LN1572"><span class='Ref_To_Local'>qp_extra</span></a><span class='Operator'>.</span><a href="planner.c.html#LN89"><span class='Ref_to_Member'>tlist</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN1460"><span class='Ref_To_Local'>tlist</span></a><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN1572"><span class='Ref_To_Local'>qp_extra</span></a><span class='Operator'>.</span><a href="planner.c.html#LN90"><span class='Ref_to_Member'>activeWindows</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN1570"><span class='Ref_To_Local'>activeWindows</span></a><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN1572"><span class='Ref_To_Local'>qp_extra</span></a><span class='Operator'>.</span><a href="planner.c.html#LN91"><span class='Ref_to_Member'>groupClause</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="planner.c.html#LN1571"><span class='Ref_To_Local'>gset_data</span></a> 
                                <span class='Operator'>? </span><span class='Parentheses'>(</span><a href="planner.c.html#LN1571"><span class='Ref_To_Local'>gset_data</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN100"><span class='Ref_to_Member'>rollups</span></a> <span class='Operator'>? </span><span class='Parentheses'>((</span><a href="../../../include/nodes/relation.h.html#LN1478"><span class='Ref_to_Struct'>RollupData</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1571"><span class='Ref_To_Local'>gset_data</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN100"><span class='Ref_to_Member'>rollups</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>groupClause <span class='Operator'>: </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span> 
                                <span class='Operator'>: </span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Generate the best unsorted and presorted paths for the scan/join 
         * portion of this Query, ie the processing represented by the 
         * FROM/WHERE clauses.  (Note there may not be any presorted paths.) 
         * We also generate (in standard_qp_callback) pathkey representations 
         * of the query's sort clause, distinct clause, etc. 
         */ 
</span>        <a href="planner.c.html#LN1468"><span class='Ref_To_Local'>current_rel</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/planmain.h.html#LN38"><span class='Ref_to_Proto'>query_planner</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1460"><span class='Ref_To_Local'>tlist</span></a><span class='Delimiter'>, 
</span>                                    <a href="planner.c.html#LN128"><span class='Ref_to_Proto'>standard_qp_callback</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="planner.c.html#LN1572"><span class='Ref_To_Local'>qp_extra</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Convert the query's result tlist into PathTarget format. 
         * 
         * Note: it's desirable to not do this till after query_planner(), 
         * because the target width estimates can use per-Var width numbers 
         * that were obtained within query_planner(). 
         */ 
</span>        <a href="planner.c.html#LN1465"><span class='Ref_To_Local'>final_target</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/tlist.h.html#LN68"><span class='Ref_to_Macro'>create_pathtarget</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1460"><span class='Ref_To_Local'>tlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If ORDER BY was given, consider whether we should use a post-sort 
         * projection, and compute the adjusted target for preceding steps if 
         * so. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN155"><span class='Ref_to_Member'>sortClause</span></a><span class='Parentheses'>) 
</span>            <a href="planner.c.html#LN1558"><span class='Ref_To_Local'>sort_input_target</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN181"><span class='Ref_to_Proto'>make_sort_input_target</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                       <a href="planner.c.html#LN1465"><span class='Ref_To_Local'>final_target</span></a><span class='Delimiter'>, 
</span>                                                       <span class='Operator'>&</span><a href="planner.c.html#LN1464"><span class='Ref_To_Local'>have_postponed_srfs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="planner.c.html#LN1558"><span class='Ref_To_Local'>sort_input_target</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN1465"><span class='Ref_To_Local'>final_target</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If we have window functions to deal with, the output from any 
         * grouping step needs to be what the window functions want; 
         * otherwise, it should be sort_input_target. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1570"><span class='Ref_To_Local'>activeWindows</span></a><span class='Parentheses'>) 
</span>            <a href="planner.c.html#LN1561"><span class='Ref_To_Local'>grouping_target</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN176"><span class='Ref_to_Proto'>make_window_input_target</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                       <a href="planner.c.html#LN1465"><span class='Ref_To_Local'>final_target</span></a><span class='Delimiter'>, 
</span>                                                       <a href="planner.c.html#LN1570"><span class='Ref_To_Local'>activeWindows</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="planner.c.html#LN1561"><span class='Ref_To_Local'>grouping_target</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN1558"><span class='Ref_To_Local'>sort_input_target</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If we have grouping or aggregation to do, the topmost scan/join 
         * plan node must emit what the grouping step wants; otherwise, it 
         * should emit grouping_target. 
         */ 
</span>        <a href="planner.c.html#LN1567"><span class='Ref_To_Local'>have_grouping</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a> <span class='Operator'>|| </span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN147"><span class='Ref_to_Member'>groupingSets</span></a> <span class='Operator'>|| 
</span>                         <a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN122"><span class='Ref_to_Member'>hasAggs</span></a> <span class='Operator'>|| </span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN301"><span class='Ref_to_Member'>hasHavingQual</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1567"><span class='Ref_To_Local'>have_grouping</span></a><span class='Parentheses'>) 
</span>            <a href="planner.c.html#LN1564"><span class='Ref_To_Local'>scanjoin_target</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN170"><span class='Ref_to_Proto'>make_group_input_target</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1465"><span class='Ref_To_Local'>final_target</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="planner.c.html#LN1564"><span class='Ref_To_Local'>scanjoin_target</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN1561"><span class='Ref_To_Local'>grouping_target</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If there are any SRFs in the targetlist, we must separate each of 
         * these PathTargets into SRF-computing and SRF-free targets.  Replace 
         * each of the named targets with a SRF-free version, and remember the 
         * list of additional projection steps we need to add afterwards. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN124"><span class='Ref_to_Member'>hasTargetSRFs</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* final_target doesn't recompute any SRFs in sort_input_target */ 
</span>            <a href="../../../include/optimizer/tlist.h.html#LN63"><span class='Ref_to_Proto'>split_pathtarget_at_srfs</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1465"><span class='Ref_To_Local'>final_target</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1558"><span class='Ref_To_Local'>sort_input_target</span></a><span class='Delimiter'>, 
</span>                                     <span class='Operator'>&</span><a href="planner.c.html#LN1466"><span class='Ref_To_Local'>final_targets</span></a><span class='Delimiter'>, 
</span>                                     <span class='Operator'>&</span><a href="planner.c.html#LN1467"><span class='Ref_To_Local'>final_targets_contain_srfs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="planner.c.html#LN1465"><span class='Ref_To_Local'>final_target</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1466"><span class='Ref_To_Local'>final_targets</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/pg_list.h.html#LN111"><span class='Ref_to_Macro'>linitial_int</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1467"><span class='Ref_To_Local'>final_targets_contain_srfs</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* likewise for sort_input_target vs. grouping_target */ 
</span>            <a href="../../../include/optimizer/tlist.h.html#LN63"><span class='Ref_to_Proto'>split_pathtarget_at_srfs</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1558"><span class='Ref_To_Local'>sort_input_target</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1561"><span class='Ref_To_Local'>grouping_target</span></a><span class='Delimiter'>, 
</span>                                     <span class='Operator'>&</span><a href="planner.c.html#LN1559"><span class='Ref_To_Local'>sort_input_targets</span></a><span class='Delimiter'>, 
</span>                                     <span class='Operator'>&</span><a href="planner.c.html#LN1560"><span class='Ref_To_Local'>sort_input_targets_contain_srfs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="planner.c.html#LN1558"><span class='Ref_To_Local'>sort_input_target</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1559"><span class='Ref_To_Local'>sort_input_targets</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/pg_list.h.html#LN111"><span class='Ref_to_Macro'>linitial_int</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1560"><span class='Ref_To_Local'>sort_input_targets_contain_srfs</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* likewise for grouping_target vs. scanjoin_target */ 
</span>            <a href="../../../include/optimizer/tlist.h.html#LN63"><span class='Ref_to_Proto'>split_pathtarget_at_srfs</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1561"><span class='Ref_To_Local'>grouping_target</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1564"><span class='Ref_To_Local'>scanjoin_target</span></a><span class='Delimiter'>, 
</span>                                     <span class='Operator'>&</span><a href="planner.c.html#LN1562"><span class='Ref_To_Local'>grouping_targets</span></a><span class='Delimiter'>, 
</span>                                     <span class='Operator'>&</span><a href="planner.c.html#LN1563"><span class='Ref_To_Local'>grouping_targets_contain_srfs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="planner.c.html#LN1561"><span class='Ref_To_Local'>grouping_target</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1562"><span class='Ref_To_Local'>grouping_targets</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/pg_list.h.html#LN111"><span class='Ref_to_Macro'>linitial_int</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1563"><span class='Ref_To_Local'>grouping_targets_contain_srfs</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* scanjoin_target will not have any SRFs precomputed for it */ 
</span>            <a href="../../../include/optimizer/tlist.h.html#LN63"><span class='Ref_to_Proto'>split_pathtarget_at_srfs</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1564"><span class='Ref_To_Local'>scanjoin_target</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                     <span class='Operator'>&</span><a href="planner.c.html#LN1565"><span class='Ref_To_Local'>scanjoin_targets</span></a><span class='Delimiter'>, 
</span>                                     <span class='Operator'>&</span><a href="planner.c.html#LN1566"><span class='Ref_To_Local'>scanjoin_targets_contain_srfs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="planner.c.html#LN1564"><span class='Ref_To_Local'>scanjoin_target</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1565"><span class='Ref_To_Local'>scanjoin_targets</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/pg_list.h.html#LN111"><span class='Ref_to_Macro'>linitial_int</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1566"><span class='Ref_To_Local'>scanjoin_targets_contain_srfs</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if parse-&GT;hasTargetSRFs &raquo; </span> 
        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* initialize lists, just to keep compiler quiet */ 
</span>            <a href="planner.c.html#LN1466"><span class='Ref_To_Local'>final_targets</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN1467"><span class='Ref_To_Local'>final_targets_contain_srfs</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>            <a href="planner.c.html#LN1559"><span class='Ref_To_Local'>sort_input_targets</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN1560"><span class='Ref_To_Local'>sort_input_targets_contain_srfs</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>            <a href="planner.c.html#LN1562"><span class='Ref_To_Local'>grouping_targets</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN1563"><span class='Ref_To_Local'>grouping_targets_contain_srfs</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>            <a href="planner.c.html#LN1565"><span class='Ref_To_Local'>scanjoin_targets</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN1566"><span class='Ref_To_Local'>scanjoin_targets_contain_srfs</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Forcibly apply SRF-free scan/join target to all the Paths for the 
         * scan/join rel. 
         * 
         * In principle we should re-run set_cheapest() here to identify the 
         * cheapest path, but it seems unlikely that adding the same tlist 
         * eval costs to all the paths would change that, so we don't bother. 
         * Instead, just assume that the cheapest-startup and cheapest-total 
         * paths remain so.  (There should be no parameterized paths anymore, 
         * so we needn't worry about updating cheapest_parameterized_paths.) 
         */ 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1470"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1468"><span class='Ref_To_Local'>current_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN538"><span class='Ref_to_Member'>pathlist</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1788"></a>            <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>subpath</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1470"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1789"></a>            <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>path</span><span class='Delimiter'>; 
</span> 
            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="planner.c.html#LN1788"><span class='Ref_To_Local'>subpath</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN955"><span class='Ref_to_Member'>param_info</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="planner.c.html#LN1789"><span class='Ref_To_Local'>path</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/pathnode.h.html#LN157"><span class='Ref_to_Proto'>apply_projection_to_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1468"><span class='Ref_To_Local'>current_rel</span></a><span class='Delimiter'>, 
</span>                                            <a href="planner.c.html#LN1788"><span class='Ref_To_Local'>subpath</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1564"><span class='Ref_To_Local'>scanjoin_target</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* If we had to add a Result, path is different from subpath */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1789"><span class='Ref_To_Local'>path</span></a> <span class='Operator'>!= </span><a href="planner.c.html#LN1788"><span class='Ref_To_Local'>subpath</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1470"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="planner.c.html#LN1789"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1788"><span class='Ref_To_Local'>subpath</span></a> <span class='Operator'>== </span><a href="planner.c.html#LN1468"><span class='Ref_To_Local'>current_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN541"><span class='Ref_to_Member'>cheapest_startup_path</span></a><span class='Parentheses'>) 
</span>                    <a href="planner.c.html#LN1468"><span class='Ref_To_Local'>current_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN541"><span class='Ref_to_Member'>cheapest_startup_path</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN1789"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1788"><span class='Ref_To_Local'>subpath</span></a> <span class='Operator'>== </span><a href="planner.c.html#LN1468"><span class='Ref_To_Local'>current_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN542"><span class='Ref_to_Member'>cheapest_total_path</span></a><span class='Parentheses'>) 
</span>                    <a href="planner.c.html#LN1468"><span class='Ref_To_Local'>current_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN542"><span class='Ref_to_Member'>cheapest_total_path</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN1789"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Upper planning steps which make use of the top scan/join rel's 
         * partial pathlist will expect partial paths for that rel to produce 
         * the same output as complete paths ... and we just changed the 
         * output for the complete paths, so we'll need to do the same thing 
         * for partial paths.  But only parallel-safe expressions can be 
         * computed by partial paths. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1468"><span class='Ref_To_Local'>current_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN540"><span class='Ref_to_Member'>partial_pathlist</span></a> <span class='Operator'>&& 
</span>            <a href="../../../include/optimizer/clauses.h.html#LN63"><span class='Ref_to_Proto'>is_parallel_safe</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN1564"><span class='Ref_To_Local'>scanjoin_target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Apply the scan/join target to each partial path */ 
</span>            <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1470"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1468"><span class='Ref_To_Local'>current_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN540"><span class='Ref_to_Member'>partial_pathlist</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN1819"></a>                <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>subpath</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1470"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1820"></a>                <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>newpath</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* Shouldn't have any parameterized paths anymore */ 
</span>                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="planner.c.html#LN1819"><span class='Ref_To_Local'>subpath</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN955"><span class='Ref_to_Member'>param_info</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Don't use apply_projection_to_path() here, because there 
                 * could be other pointers to these paths, and therefore we 
                 * mustn't modify them in place. 
                 */ 
</span>                <a href="planner.c.html#LN1820"><span class='Ref_To_Local'>newpath</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/pathnode.h.html#LN153"><span class='Ref_to_Proto'>create_projection_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                          <a href="planner.c.html#LN1468"><span class='Ref_To_Local'>current_rel</span></a><span class='Delimiter'>, 
</span>                                                          <a href="planner.c.html#LN1819"><span class='Ref_To_Local'>subpath</span></a><span class='Delimiter'>, 
</span>                                                          <a href="planner.c.html#LN1564"><span class='Ref_To_Local'>scanjoin_target</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1470"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="planner.c.html#LN1820"><span class='Ref_To_Local'>newpath</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if current_rel-&GT;partial_... &raquo; </span> 
        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * In the unfortunate event that scanjoin_target is not 
             * parallel-safe, we can't apply it to the partial paths; in that 
             * case, we'll need to forget about the partial paths, which 
             * aren't valid input for upper planning steps. 
             */ 
</span>            <a href="planner.c.html#LN1468"><span class='Ref_To_Local'>current_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN540"><span class='Ref_to_Member'>partial_pathlist</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Now fix things up if scan/join target contains SRFs */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN124"><span class='Ref_to_Member'>hasTargetSRFs</span></a><span class='Parentheses'>) 
</span>            <a href="planner.c.html#LN184"><span class='Ref_to_Proto'>adjust_paths_for_srfs</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1468"><span class='Ref_To_Local'>current_rel</span></a><span class='Delimiter'>, 
</span>                                  <a href="planner.c.html#LN1565"><span class='Ref_To_Local'>scanjoin_targets</span></a><span class='Delimiter'>, 
</span>                                  <a href="planner.c.html#LN1566"><span class='Ref_To_Local'>scanjoin_targets_contain_srfs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Save the various upper-rel PathTargets we just computed into 
         * root-&GT;upper_targets[].  The core code doesn't use this, but it 
         * provides a convenient place for extensions to get at the info.  For 
         * consistency, we save all the intermediate targets, even though some 
         * of the corresponding upperrels might not be needed for this query. 
         */ 
</span>        <a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN274"><span class='Ref_to_Member'>upper_targets</span></a><span class='Delimiter'>[</span><a href="../../../include/nodes/relation.h.html#LN77"><span class='Ref_to_EnumConst'>UPPERREL_FINAL</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="planner.c.html#LN1465"><span class='Ref_To_Local'>final_target</span></a><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN274"><span class='Ref_to_Member'>upper_targets</span></a><span class='Delimiter'>[</span><a href="../../../include/nodes/relation.h.html#LN74"><span class='Ref_to_EnumConst'>UPPERREL_WINDOW</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="planner.c.html#LN1558"><span class='Ref_To_Local'>sort_input_target</span></a><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN274"><span class='Ref_to_Member'>upper_targets</span></a><span class='Delimiter'>[</span><a href="../../../include/nodes/relation.h.html#LN73"><span class='Ref_to_EnumConst'>UPPERREL_GROUP_AGG</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="planner.c.html#LN1561"><span class='Ref_To_Local'>grouping_target</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If we have grouping and/or aggregation, consider ways to implement 
         * that.  We build a new upperrel representing the output of this 
         * phase. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1567"><span class='Ref_To_Local'>have_grouping</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="planner.c.html#LN1468"><span class='Ref_To_Local'>current_rel</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN135"><span class='Ref_to_Proto'>create_grouping_paths</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                <a href="planner.c.html#LN1468"><span class='Ref_To_Local'>current_rel</span></a><span class='Delimiter'>, 
</span>                                                <a href="planner.c.html#LN1561"><span class='Ref_To_Local'>grouping_target</span></a><span class='Delimiter'>, 
</span>                                                <span class='Operator'>&</span><a href="planner.c.html#LN1568"><span class='Ref_To_Local'>agg_costs</span></a><span class='Delimiter'>, 
</span>                                                <a href="planner.c.html#LN1571"><span class='Ref_To_Local'>gset_data</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* Fix things up if grouping_target contains SRFs */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN124"><span class='Ref_to_Member'>hasTargetSRFs</span></a><span class='Parentheses'>) 
</span>                <a href="planner.c.html#LN184"><span class='Ref_to_Proto'>adjust_paths_for_srfs</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1468"><span class='Ref_To_Local'>current_rel</span></a><span class='Delimiter'>, 
</span>                                      <a href="planner.c.html#LN1562"><span class='Ref_To_Local'>grouping_targets</span></a><span class='Delimiter'>, 
</span>                                      <a href="planner.c.html#LN1563"><span class='Ref_To_Local'>grouping_targets_contain_srfs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If we have window functions, consider ways to implement those.  We 
         * build a new upperrel representing the output of this phase. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1570"><span class='Ref_To_Local'>activeWindows</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="planner.c.html#LN1468"><span class='Ref_To_Local'>current_rel</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN149"><span class='Ref_to_Proto'>create_window_paths</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                              <a href="planner.c.html#LN1468"><span class='Ref_To_Local'>current_rel</span></a><span class='Delimiter'>, 
</span>                                              <a href="planner.c.html#LN1561"><span class='Ref_To_Local'>grouping_target</span></a><span class='Delimiter'>, 
</span>                                              <a href="planner.c.html#LN1558"><span class='Ref_To_Local'>sort_input_target</span></a><span class='Delimiter'>, 
</span>                                              <a href="planner.c.html#LN1460"><span class='Ref_To_Local'>tlist</span></a><span class='Delimiter'>, 
</span>                                              <a href="planner.c.html#LN1569"><span class='Ref_To_Local'>wflists</span></a><span class='Delimiter'>, 
</span>                                              <a href="planner.c.html#LN1570"><span class='Ref_To_Local'>activeWindows</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* Fix things up if sort_input_target contains SRFs */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN124"><span class='Ref_to_Member'>hasTargetSRFs</span></a><span class='Parentheses'>) 
</span>                <a href="planner.c.html#LN184"><span class='Ref_to_Proto'>adjust_paths_for_srfs</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1468"><span class='Ref_To_Local'>current_rel</span></a><span class='Delimiter'>, 
</span>                                      <a href="planner.c.html#LN1559"><span class='Ref_To_Local'>sort_input_targets</span></a><span class='Delimiter'>, 
</span>                                      <a href="planner.c.html#LN1560"><span class='Ref_To_Local'>sort_input_targets_contain_srfs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If there is a DISTINCT clause, consider ways to implement that. We 
         * build a new upperrel representing the output of this phase. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN153"><span class='Ref_to_Member'>distinctClause</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="planner.c.html#LN1468"><span class='Ref_To_Local'>current_rel</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN164"><span class='Ref_to_Proto'>create_distinct_paths</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                <a href="planner.c.html#LN1468"><span class='Ref_To_Local'>current_rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span>                           <span class='Comment_Single_Line'>/* end of if (setOperations) */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If ORDER BY was given, consider ways to implement that, and generate a 
     * new upperrel containing only paths that emit the correct ordering and 
     * project the correct final_target.  We can apply the original 
     * limit_tuples limit in sort costing here, but only if there are no 
     * postponed SRFs. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN155"><span class='Ref_to_Member'>sortClause</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="planner.c.html#LN1468"><span class='Ref_To_Local'>current_rel</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN166"><span class='Ref_to_Proto'>create_ordered_paths</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                           <a href="planner.c.html#LN1468"><span class='Ref_To_Local'>current_rel</span></a><span class='Delimiter'>, 
</span>                                           <a href="planner.c.html#LN1465"><span class='Ref_To_Local'>final_target</span></a><span class='Delimiter'>, 
</span>                                           <a href="planner.c.html#LN1464"><span class='Ref_To_Local'>have_postponed_srfs</span></a> <span class='Operator'>? -</span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>: 
</span>                                           <a href="planner.c.html#LN1463"><span class='Ref_To_Local'>limit_tuples</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Fix things up if final_target contains SRFs */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN124"><span class='Ref_to_Member'>hasTargetSRFs</span></a><span class='Parentheses'>) 
</span>            <a href="planner.c.html#LN184"><span class='Ref_to_Proto'>adjust_paths_for_srfs</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1468"><span class='Ref_To_Local'>current_rel</span></a><span class='Delimiter'>, 
</span>                                  <a href="planner.c.html#LN1466"><span class='Ref_To_Local'>final_targets</span></a><span class='Delimiter'>, 
</span>                                  <a href="planner.c.html#LN1467"><span class='Ref_To_Local'>final_targets_contain_srfs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now we are prepared to build the final-output upperrel. 
     */ 
</span>    <a href="planner.c.html#LN1469"><span class='Ref_To_Local'>final_rel</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/pathnode.h.html#LN270"><span class='Ref_to_Proto'>fetch_upper_rel</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN77"><span class='Ref_to_EnumConst'>UPPERREL_FINAL</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the input rel is marked consider_parallel and there's nothing that's 
     * not parallel-safe in the LIMIT clause, then the final_rel can be marked 
     * consider_parallel as well.  Note that if the query has rowMarks or is 
     * not a SELECT, consider_parallel will be false for every relation in the 
     * query. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1468"><span class='Ref_To_Local'>current_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN532"><span class='Ref_to_Member'>consider_parallel</span></a> <span class='Operator'>&& 
</span>        <a href="../../../include/optimizer/clauses.h.html#LN63"><span class='Ref_to_Proto'>is_parallel_safe</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN157"><span class='Ref_to_Member'>limitOffset</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>        <a href="../../../include/optimizer/clauses.h.html#LN63"><span class='Ref_to_Proto'>is_parallel_safe</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN158"><span class='Ref_to_Member'>limitCount</span></a><span class='Parentheses'>))</span> 
        <a href="planner.c.html#LN1469"><span class='Ref_To_Local'>final_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN532"><span class='Ref_to_Member'>consider_parallel</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the current_rel belongs to a single FDW, so does the final_rel. 
     */ 
</span>    <a href="planner.c.html#LN1469"><span class='Ref_To_Local'>final_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN571"><span class='Ref_to_Member'>serverid</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN1468"><span class='Ref_To_Local'>current_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN571"><span class='Ref_to_Member'>serverid</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN1469"><span class='Ref_To_Local'>final_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN572"><span class='Ref_to_Member'>userid</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN1468"><span class='Ref_To_Local'>current_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN572"><span class='Ref_to_Member'>userid</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN1469"><span class='Ref_To_Local'>final_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN573"><span class='Ref_to_Member'>useridiscurrent</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN1468"><span class='Ref_To_Local'>current_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN573"><span class='Ref_to_Member'>useridiscurrent</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN1469"><span class='Ref_To_Local'>final_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN575"><span class='Ref_to_Member'>fdwroutine</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN1468"><span class='Ref_To_Local'>current_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN575"><span class='Ref_to_Member'>fdwroutine</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Generate paths for the final_rel.  Insert all surviving paths, with 
     * LockRows, Limit, and/or ModifyTable steps added if needed. 
     */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1470"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1468"><span class='Ref_To_Local'>current_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN538"><span class='Ref_to_Member'>pathlist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1967"></a>        <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>path</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1470"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If there is a FOR [KEY] UPDATE/SHARE clause, add the LockRows node. 
         * (Note: we intentionally test parse-&GT;rowMarks not root-&GT;rowMarks 
         * here.  If there are only non-locking rowmarks, they should be 
         * handled by the ModifyTable node instead.  However, root-&GT;rowMarks 
         * is what goes into the LockRows node.) 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN160"><span class='Ref_to_Member'>rowMarks</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="planner.c.html#LN1967"><span class='Ref_To_Local'>path</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/pathnode.h.html#LN231"><span class='Ref_to_Proto'>create_lockrows_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1469"><span class='Ref_To_Local'>final_rel</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1967"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, 
</span>                                                 <a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN255"><span class='Ref_to_Member'>rowMarks</span></a><span class='Delimiter'>, 
</span>                                              <a href="../../../include/optimizer/subselect.h.html#LN40"><span class='Ref_to_Proto'>SS_assign_special_param</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If there is a LIMIT/OFFSET clause, add the LIMIT node. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN123"><span class='Ref_to_Proto'>limit_needed</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="planner.c.html#LN1967"><span class='Ref_To_Local'>path</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/pathnode.h.html#LN242"><span class='Ref_to_Proto'>create_limit_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1469"><span class='Ref_To_Local'>final_rel</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1967"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, 
</span>                                              <a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN157"><span class='Ref_to_Member'>limitOffset</span></a><span class='Delimiter'>, 
</span>                                              <a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN158"><span class='Ref_to_Member'>limitCount</span></a><span class='Delimiter'>, 
</span>                                              <a href="planner.c.html#LN1461"><span class='Ref_To_Local'>offset_est</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1462"><span class='Ref_To_Local'>count_est</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If this is an INSERT/UPDATE/DELETE, and we're not being called from 
         * inheritance_planner, add the ModifyTable node. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN109"><span class='Ref_to_Member'>commandType</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/nodes.h.html#LN650"><span class='Ref_to_EnumConst'>CMD_SELECT</span></a> <span class='Operator'>&& !</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>inheritance_update</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN2000"></a>            <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>withCheckOptionLists</span><span class='Delimiter'>; 
</span><a name="LN2001"></a>            <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>returningLists</span><span class='Delimiter'>; 
</span><a name="LN2002"></a>            <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>rowMarks</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Set up the WITH CHECK OPTION and RETURNING lists-of-lists, if 
             * needed. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN168"><span class='Ref_to_Member'>withCheckOptions</span></a><span class='Parentheses'>) 
</span>                <a href="planner.c.html#LN2000"><span class='Ref_To_Local'>withCheckOptionLists</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN168"><span class='Ref_to_Member'>withCheckOptions</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="planner.c.html#LN2000"><span class='Ref_To_Local'>withCheckOptionLists</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN143"><span class='Ref_to_Member'>returningList</span></a><span class='Parentheses'>) 
</span>                <a href="planner.c.html#LN2001"><span class='Ref_To_Local'>returningLists</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN143"><span class='Ref_to_Member'>returningList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="planner.c.html#LN2001"><span class='Ref_To_Local'>returningLists</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * If there was a FOR [KEY] UPDATE/SHARE clause, the LockRows node 
             * will have dealt with fetching non-locked marked rows, else we 
             * need to have ModifyTable do that. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN160"><span class='Ref_to_Member'>rowMarks</span></a><span class='Parentheses'>) 
</span>                <a href="planner.c.html#LN2002"><span class='Ref_To_Local'>rowMarks</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="planner.c.html#LN2002"><span class='Ref_To_Local'>rowMarks</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN255"><span class='Ref_to_Member'>rowMarks</span></a><span class='Delimiter'>; 
</span> 
            <a href="planner.c.html#LN1967"><span class='Ref_To_Local'>path</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                <a href="../../../include/optimizer/pathnode.h.html#LN233"><span class='Ref_to_Proto'>create_modifytable_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1469"><span class='Ref_To_Local'>final_rel</span></a><span class='Delimiter'>, 
</span>                                        <a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN109"><span class='Ref_to_Member'>commandType</span></a><span class='Delimiter'>, 
</span>                                        <a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN115"><span class='Ref_to_Member'>canSetTag</span></a><span class='Delimiter'>, 
</span>                                        <a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN119"><span class='Ref_to_Member'>resultRelation</span></a><span class='Delimiter'>, 
</span>                                        <a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>, 
</span>                                        <a href="../../../include/nodes/pg_list.h.html#LN144"><span class='Ref_to_Macro'>list_make1_int</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN119"><span class='Ref_to_Member'>resultRelation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                        <a href="../../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1967"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                        <a href="../../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                        <a href="planner.c.html#LN2000"><span class='Ref_To_Local'>withCheckOptionLists</span></a><span class='Delimiter'>, 
</span>                                        <a href="planner.c.html#LN2001"><span class='Ref_To_Local'>returningLists</span></a><span class='Delimiter'>, 
</span>                                        <a href="planner.c.html#LN2002"><span class='Ref_To_Local'>rowMarks</span></a><span class='Delimiter'>, 
</span>                                        <a href="planner.c.html#LN1459"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN141"><span class='Ref_to_Member'>onConflict</span></a><span class='Delimiter'>, 
</span>                                        <a href="../../../include/optimizer/subselect.h.html#LN40"><span class='Ref_to_Proto'>SS_assign_special_param</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if parse-&GT;commandType!=C... &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* And shove it into final_rel */ 
</span>        <a href="../../../include/optimizer/pathnode.h.html#LN27"><span class='Ref_to_Proto'>add_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1469"><span class='Ref_To_Local'>final_rel</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1967"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If there is an FDW that's responsible for all baserels of the query, 
     * let it consider adding ForeignPaths. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN1469"><span class='Ref_To_Local'>final_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN575"><span class='Ref_to_Member'>fdwroutine</span></a> <span class='Operator'>&& 
</span>        <a href="planner.c.html#LN1469"><span class='Ref_To_Local'>final_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN575"><span class='Ref_to_Member'>fdwroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/foreign/fdwapi.h.html#LN190"><span class='Ref_to_Member'>GetForeignUpperPaths</span></a><span class='Parentheses'>) 
</span>        <a href="planner.c.html#LN1469"><span class='Ref_To_Local'>final_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN575"><span class='Ref_to_Member'>fdwroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/foreign/fdwapi.h.html#LN190"><span class='Ref_to_Member'>GetForeignUpperPaths</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN77"><span class='Ref_to_EnumConst'>UPPERREL_FINAL</span></a><span class='Delimiter'>, 
</span>                                                    <a href="planner.c.html#LN1468"><span class='Ref_To_Local'>current_rel</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1469"><span class='Ref_To_Local'>final_rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Let extensions possibly add some more paths */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN68"><span class='Ref_to_Global_Var'>create_upper_paths_hook</span></a><span class='Parentheses'>) 
</span>        <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="planner.c.html#LN68"><span class='Ref_to_Global_Var'>create_upper_paths_hook</span></a><span class='Parentheses'>) (</span><a href="planner.c.html#LN1456"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN77"><span class='Ref_to_EnumConst'>UPPERREL_FINAL</span></a><span class='Delimiter'>, 
</span>                                    <a href="planner.c.html#LN1468"><span class='Ref_To_Local'>current_rel</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN1469"><span class='Ref_To_Local'>final_rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Note: currently, we leave it to callers to do set_cheapest() */ 
</span><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end grouping_planner &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Do preprocessing for groupingSets clause and related data.  This handles the 
 * preliminary steps of expanding the grouping sets, organizing them into lists 
 * of rollups, and preparing annotations which will later be filled in with 
 * size estimates. 
 */ 
</span><span class='Keyword'>static </span><a href="planner.c.html#LN98"><span class='Ref_to_Typedef'>grouping_sets_data</span></a> <span class='Operator'>* 
</span><a name="LN2072"></a><span class='Declare_Function'>preprocess_grouping_sets</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2074"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>parse</span> <span class='Operator'>= </span><a href="planner.c.html#LN2072"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Delimiter'>; 
</span><a name="LN2075"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>sets</span><span class='Delimiter'>; 
</span><a name="LN2076"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>maxref</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN2077"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span><a name="LN2078"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc_set</span><span class='Delimiter'>; 
</span><a name="LN2079"></a>    <a href="planner.c.html#LN98"><span class='Ref_to_Typedef'>grouping_sets_data</span></a> <span class='Operator'>*</span><span class='Declare_Local'>gd</span> <span class='Operator'>= </span><a href="../../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="planner.c.html#LN98"><span class='Ref_to_Typedef'>grouping_sets_data</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="planner.c.html#LN2074"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN147"><span class='Ref_to_Member'>groupingSets</span></a> <span class='Operator'>= </span><a href="../../../include/parser/parse_agg.h.html#LN28"><span class='Ref_to_Proto'>expand_grouping_sets</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2074"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN147"><span class='Ref_to_Member'>groupingSets</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="planner.c.html#LN2079"><span class='Ref_To_Local'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN103"><span class='Ref_to_Member'>any_hashable</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN2079"><span class='Ref_To_Local'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN105"><span class='Ref_to_Member'>unhashable_refs</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN2079"><span class='Ref_To_Local'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN104"><span class='Ref_to_Member'>unsortable_refs</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN2079"><span class='Ref_To_Local'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN106"><span class='Ref_to_Member'>unsortable_sets</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2074"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2090"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2090"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2074"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN2094"></a>            <a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>gc</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2090"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2095"></a>            <a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Local'>ref</span> <span class='Operator'>= </span><a href="planner.c.html#LN2094"><span class='Ref_To_Local'>gc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1164"><span class='Ref_to_Member'>tleSortGroupRef</span></a><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Keyword'>ref </span><span class='Operator'>&GT; </span><a href="planner.c.html#LN2076"><span class='Ref_To_Local'>maxref</span></a><span class='Parentheses'>) 
</span>                <a href="planner.c.html#LN2076"><span class='Ref_To_Local'>maxref</span></a> <span class='Operator'>= </span><span class='Keyword'>ref</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="planner.c.html#LN2094"><span class='Ref_To_Local'>gc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1168"><span class='Ref_to_Member'>hashable</span></a><span class='Parentheses'>) 
</span>                <a href="planner.c.html#LN2079"><span class='Ref_To_Local'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN105"><span class='Ref_to_Member'>unhashable_refs</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN89"><span class='Ref_to_Proto'>bms_add_member</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2079"><span class='Ref_To_Local'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN105"><span class='Ref_to_Member'>unhashable_refs</span></a><span class='Delimiter'>, </span><span class='Keyword'>ref</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2094"><span class='Ref_To_Local'>gc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1166"><span class='Ref_to_Member'>sortop</span></a><span class='Parentheses'>))</span> 
                <a href="planner.c.html#LN2079"><span class='Ref_To_Local'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN104"><span class='Ref_to_Member'>unsortable_refs</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN89"><span class='Ref_to_Proto'>bms_add_member</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2079"><span class='Ref_To_Local'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN104"><span class='Ref_to_Member'>unsortable_refs</span></a><span class='Delimiter'>, </span><span class='Keyword'>ref</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Allocate workspace array for remapping */ 
</span>    <a href="planner.c.html#LN2079"><span class='Ref_To_Local'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN107"><span class='Ref_to_Member'>tleref_to_colnum_map</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>((</span><a href="planner.c.html#LN2076"><span class='Ref_To_Local'>maxref</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we have any unsortable sets, we must extract them before trying to 
     * prepare rollups. Unsortable sets don't go through 
     * reorder_grouping_sets, so we must apply the GroupingSetData annotation 
     * here. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN85"><span class='Ref_to_Proto'>bms_is_empty</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2079"><span class='Ref_To_Local'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN104"><span class='Ref_to_Member'>unsortable_refs</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN2119"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>sortable_sets</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2077"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2074"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN147"><span class='Ref_to_Member'>groupingSets</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN2123"></a>            <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>gset</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2077"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN77"><span class='Ref_to_Proto'>bms_overlap_list</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2079"><span class='Ref_To_Local'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN104"><span class='Ref_to_Member'>unsortable_refs</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2123"><span class='Ref_To_Local'>gset</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span><a name="LN2127"></a>                <a href="../../../include/nodes/relation.h.html#LN1471"><span class='Ref_to_Struct'>GroupingSetData</span></a> <span class='Operator'>*</span><span class='Declare_Local'>gs</span> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1471"><span class='Ref_to_Struct'>GroupingSetData</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="planner.c.html#LN2127"><span class='Ref_To_Local'>gs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1474"><span class='Ref_to_Member'>set</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN2123"><span class='Ref_To_Local'>gset</span></a><span class='Delimiter'>; 
</span>                <a href="planner.c.html#LN2079"><span class='Ref_To_Local'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN106"><span class='Ref_to_Member'>unsortable_sets</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2079"><span class='Ref_To_Local'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN106"><span class='Ref_to_Member'>unsortable_sets</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2127"><span class='Ref_To_Local'>gs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * We must enforce here that an unsortable set is hashable; 
                 * later code assumes this.  Parse analysis only checks that 
                 * every individual column is either hashable or sortable. 
                 * 
                 * Note that passing this test doesn't guarantee we can 
                 * generate a plan; there might be other showstoppers. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN77"><span class='Ref_to_Proto'>bms_overlap_list</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2079"><span class='Ref_To_Local'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN105"><span class='Ref_to_Member'>unhashable_refs</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2123"><span class='Ref_To_Local'>gset</span></a><span class='Parentheses'>))</span> 
                    <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not implement GROUP BY"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <a href="../../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"Some of the datatypes only support hashing, while others only support sorting."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if bms_overlap_list(gd-&GT;... &raquo; </span> 
            <span class='Control'>else</span> 
                <a href="planner.c.html#LN2119"><span class='Ref_To_Local'>sortable_sets</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2119"><span class='Ref_To_Local'>sortable_sets</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2123"><span class='Ref_To_Local'>gset</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2119"><span class='Ref_To_Local'>sortable_sets</span></a><span class='Parentheses'>) 
</span>            <a href="planner.c.html#LN2075"><span class='Ref_To_Local'>sets</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN126"><span class='Ref_to_Proto'>extract_rollup_sets</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2119"><span class='Ref_To_Local'>sortable_sets</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="planner.c.html#LN2075"><span class='Ref_To_Local'>sets</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !bms_is_empty(gd-&GT;uns... &raquo; </span> 
    <span class='Control'>else</span> 
        <a href="planner.c.html#LN2075"><span class='Ref_To_Local'>sets</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN126"><span class='Ref_to_Proto'>extract_rollup_sets</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2074"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN147"><span class='Ref_to_Member'>groupingSets</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2078"><span class='Ref_To_Local'>lc_set</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2075"><span class='Ref_To_Local'>sets</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2160"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>current_sets</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2078"><span class='Ref_To_Local'>lc_set</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2161"></a>        <a href="../../../include/nodes/relation.h.html#LN1478"><span class='Ref_to_Struct'>RollupData</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rollup</span> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1478"><span class='Ref_to_Struct'>RollupData</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2162"></a>        <a href="../../../include/nodes/relation.h.html#LN1471"><span class='Ref_to_Struct'>GroupingSetData</span></a> <span class='Operator'>*</span><span class='Declare_Local'>gs</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Reorder the current list of grouping sets into correct prefix 
         * order.  If only one aggregation pass is needed, try to make the 
         * list match the ORDER BY clause; if more than one pass is needed, we 
         * don't bother with that. 
         * 
         * Note that this reorders the sets from smallest-member-first to 
         * largest-member-first, and applies the GroupingSetData annotations, 
         * though the data will be filled in later. 
         */ 
</span>        <a href="planner.c.html#LN2160"><span class='Ref_To_Local'>current_sets</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN127"><span class='Ref_to_Proto'>reorder_grouping_sets</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2160"><span class='Ref_To_Local'>current_sets</span></a><span class='Delimiter'>, 
</span>                                             <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2075"><span class='Ref_To_Local'>sets</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>1</span> 
                                              <span class='Operator'>? </span><a href="planner.c.html#LN2074"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN155"><span class='Ref_to_Member'>sortClause</span></a> 
                                              <span class='Operator'>: </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Get the initial (and therefore largest) grouping set. 
         */ 
</span>        <a href="planner.c.html#LN2162"><span class='Ref_To_Local'>gs</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2160"><span class='Ref_To_Local'>current_sets</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Order the groupClause appropriately.  If the first grouping set is 
         * empty, then the groupClause must also be empty; otherwise we have 
         * to force the groupClause to match that grouping set's order. 
         * 
         * (The first grouping set can be empty even though parse-&GT;groupClause 
         * is not empty only if all non-empty grouping sets are unsortable. 
         * The groupClauses for hashed grouping sets are built later on.) 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2162"><span class='Ref_To_Local'>gs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1474"><span class='Ref_to_Member'>set</span></a><span class='Parentheses'>) 
</span>            <a href="planner.c.html#LN2161"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1481"><span class='Ref_to_Member'>groupClause</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN125"><span class='Ref_to_Proto'>preprocess_groupclause</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2072"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2162"><span class='Ref_To_Local'>gs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1474"><span class='Ref_to_Member'>set</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="planner.c.html#LN2161"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1481"><span class='Ref_to_Member'>groupClause</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Is it hashable? We pretend empty sets are hashable even though we 
         * actually force them not to be hashed later. But don't bother if 
         * there's nothing but empty sets (since in that case we can't hash 
         * anything). 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2162"><span class='Ref_To_Local'>gs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1474"><span class='Ref_to_Member'>set</span></a> <span class='Operator'>&& 
</span>            <span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN77"><span class='Ref_to_Proto'>bms_overlap_list</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2079"><span class='Ref_To_Local'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN105"><span class='Ref_to_Member'>unhashable_refs</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2162"><span class='Ref_To_Local'>gs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1474"><span class='Ref_to_Member'>set</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="planner.c.html#LN2161"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1485"><span class='Ref_to_Member'>hashable</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="planner.c.html#LN2079"><span class='Ref_To_Local'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN103"><span class='Ref_to_Member'>any_hashable</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Now that we've pinned down an order for the groupClause for this 
         * list of grouping sets, we need to remap the entries in the grouping 
         * sets from sortgrouprefs to plain indices (0-based) into the 
         * groupClause for this collection of grouping sets. We keep the 
         * original form for later use, though. 
         */ 
</span>        <a href="planner.c.html#LN2161"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1482"><span class='Ref_to_Member'>gsets</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN117"><span class='Ref_to_Proto'>remap_to_groupclause_idx</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2161"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1481"><span class='Ref_to_Member'>groupClause</span></a><span class='Delimiter'>, 
</span>                                                 <a href="planner.c.html#LN2160"><span class='Ref_To_Local'>current_sets</span></a><span class='Delimiter'>, 
</span>                                                 <a href="planner.c.html#LN2079"><span class='Ref_To_Local'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN107"><span class='Ref_to_Member'>tleref_to_colnum_map</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN2161"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1483"><span class='Ref_to_Member'>gsets_data</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN2160"><span class='Ref_To_Local'>current_sets</span></a><span class='Delimiter'>; 
</span> 
        <a href="planner.c.html#LN2079"><span class='Ref_To_Local'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN100"><span class='Ref_to_Member'>rollups</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2079"><span class='Ref_To_Local'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN100"><span class='Ref_to_Member'>rollups</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2161"><span class='Ref_To_Local'>rollup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2079"><span class='Ref_To_Local'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN106"><span class='Ref_to_Member'>unsortable_sets</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We have not yet pinned down a groupclause for this, but we will 
         * need index-based lists for estimation purposes. Construct 
         * hash_sets_idx based on the entire original groupclause for now. 
         */ 
</span>        <a href="planner.c.html#LN2079"><span class='Ref_To_Local'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN101"><span class='Ref_to_Member'>hash_sets_idx</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN117"><span class='Ref_to_Proto'>remap_to_groupclause_idx</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2074"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Delimiter'>, 
</span>                                                     <a href="planner.c.html#LN2079"><span class='Ref_To_Local'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN106"><span class='Ref_to_Member'>unsortable_sets</span></a><span class='Delimiter'>, 
</span>                                                   <a href="planner.c.html#LN2079"><span class='Ref_To_Local'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN107"><span class='Ref_to_Member'>tleref_to_colnum_map</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN2079"><span class='Ref_To_Local'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN103"><span class='Ref_to_Member'>any_hashable</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="planner.c.html#LN2079"><span class='Ref_To_Local'>gd</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end preprocess_grouping_sets &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Given a groupclause and a list of GroupingSetData, return equivalent sets 
 * (without annotation) mapped to indexes into the given groupclause. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN2247"></a><span class='Declare_Function'>remap_to_groupclause_idx</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>groupClause</span><span class='Delimiter'>, 
</span><a name="LN2248"></a>                         <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>gsets</span><span class='Delimiter'>, 
</span><a name="LN2249"></a>                         <span class='Keyword'>int </span><span class='Operator'>*</span><span class='Declare_Parameter'>tleref_to_colnum_map</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2251"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>ref</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN2252"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN2253"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2253"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2247"><span class='Ref_to_Parameter'>groupClause</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2257"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>gc</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2253"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="planner.c.html#LN2249"><span class='Ref_to_Parameter'>tleref_to_colnum_map</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN2257"><span class='Ref_To_Local'>gc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1164"><span class='Ref_to_Member'>tleSortGroupRef</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Keyword'>ref</span><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2253"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2248"><span class='Ref_to_Parameter'>gsets</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2264"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>set</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN2265"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc2</span><span class='Delimiter'>; 
</span><a name="LN2266"></a>        <a href="../../../include/nodes/relation.h.html#LN1471"><span class='Ref_to_Struct'>GroupingSetData</span></a> <span class='Operator'>*</span><span class='Declare_Local'>gs</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2253"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2265"><span class='Ref_To_Local'>lc2</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2266"><span class='Ref_To_Local'>gs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1474"><span class='Ref_to_Member'>set</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="planner.c.html#LN2264"><span class='Ref_To_Local'>set</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN144"><span class='Ref_to_Func'>lappend_int</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2264"><span class='Ref_To_Local'>set</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2249"><span class='Ref_to_Parameter'>tleref_to_colnum_map</span></a><span class='Delimiter'>[</span><a href="../../../include/nodes/pg_list.h.html#LN106"><span class='Ref_to_Macro'>lfirst_int</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2265"><span class='Ref_To_Local'>lc2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="planner.c.html#LN2252"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2252"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2264"><span class='Ref_To_Local'>set</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="planner.c.html#LN2252"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end remap_to_groupclause_idx &raquo; </span> 
 
 
 
<span class='Comment_Multi_Line'>/* 
 * Detect whether a plan node is a "dummy" plan created when a relation 
 * is deemed not to need scanning due to constraint exclusion. 
 * 
 * Currently, such dummy plans are Result nodes with constant FALSE 
 * filter quals (see set_dummy_rel_pathlist and create_append_plan). 
 * 
 * XXX this probably ought to be somewhere else, but not clear where. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN2291"></a><span class='Declare_Function'>is_dummy_plan</span><span class='Parentheses'>(</span><a href="../../../include/nodes/plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>plan</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2291"><span class='Ref_to_Parameter'>plan</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/plannodes.h.html#LN187"><span class='Ref_to_Struct'>Result</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN2295"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>rcqual</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) ((</span><a href="../../../include/nodes/plannodes.h.html#LN187"><span class='Ref_to_Struct'>Result</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN2291"><span class='Ref_to_Parameter'>plan</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>resconstantqual<span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2295"><span class='Ref_To_Local'>rcqual</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span><a name="LN2299"></a>            <a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>constqual</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2295"><span class='Ref_To_Local'>rcqual</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2299"><span class='Ref_To_Local'>constqual</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2299"><span class='Ref_To_Local'>constqual</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="planner.c.html#LN2299"><span class='Ref_To_Local'>constqual</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN196"><span class='Ref_to_Member'>constisnull</span></a> <span class='Operator'>&& 
</span>                    <span class='Operator'>!</span><a href="../../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2299"><span class='Ref_To_Local'>constqual</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Parentheses'>))</span> 
                    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end is_dummy_plan &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * preprocess_rowmarks - set up PlanRowMarks if needed 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2316"></a><span class='Declare_Function'>preprocess_rowmarks</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2318"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>parse</span> <span class='Operator'>= </span><a href="planner.c.html#LN2316"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Delimiter'>; 
</span><a name="LN2319"></a>    <a href="../../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>rels</span><span class='Delimiter'>; 
</span><a name="LN2320"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>prowmarks</span><span class='Delimiter'>; 
</span><a name="LN2321"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span><a name="LN2322"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2318"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN160"><span class='Ref_to_Member'>rowMarks</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We've got trouble if FOR [KEY] UPDATE/SHARE appears inside 
         * grouping, since grouping renders a reference to individual tuple 
         * CTIDs invalid.  This is also checked at parse time, but that's 
         * insufficient because of rule substitution, query pullup, etc. 
         */ 
</span>        <a href="../../../include/parser/analyze.h.html#LN40"><span class='Ref_to_Proto'>CheckSelectLocking</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2318"><span class='Ref_To_Local'>parse</span></a><span class='Delimiter'>, </span><span class='Parentheses'>((</span><a href="../../../include/nodes/parsenodes.h.html#LN1278"><span class='Ref_to_Struct'>RowMarkClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                                   <a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2318"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN160"><span class='Ref_to_Member'>rowMarks</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>strength<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We only need rowmarks for UPDATE, DELETE, or FOR [KEY] 
         * UPDATE/SHARE. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2318"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN109"><span class='Ref_to_Member'>commandType</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/nodes.h.html#LN651"><span class='Ref_to_EnumConst'>CMD_UPDATE</span></a> <span class='Operator'>&& 
</span>            <a href="planner.c.html#LN2318"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN109"><span class='Ref_to_Member'>commandType</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/nodes.h.html#LN653"><span class='Ref_to_EnumConst'>CMD_DELETE</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We need to have rowmarks for all base relations except the target. We 
     * make a bitmapset of all base rels and then remove the items we don't 
     * need or have FOR [KEY] UPDATE/SHARE marks for. 
     */ 
</span>    <a href="planner.c.html#LN2319"><span class='Ref_To_Local'>rels</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/prep.h.html#LN28"><span class='Ref_to_Proto'>get_relids_in_jointree</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN2318"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN135"><span class='Ref_to_Member'>jointree</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2318"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN119"><span class='Ref_to_Member'>resultRelation</span></a><span class='Parentheses'>) 
</span>        <a href="planner.c.html#LN2319"><span class='Ref_To_Local'>rels</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN90"><span class='Ref_to_Proto'>bms_del_member</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2319"><span class='Ref_To_Local'>rels</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2318"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN119"><span class='Ref_to_Member'>resultRelation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Convert RowMarkClauses to PlanRowMark representation. 
     */ 
</span>    <a href="planner.c.html#LN2320"><span class='Ref_To_Local'>prowmarks</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2321"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2318"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN160"><span class='Ref_to_Member'>rowMarks</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2361"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN1278"><span class='Ref_to_Struct'>RowMarkClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rc</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1278"><span class='Ref_to_Struct'>RowMarkClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2321"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2362"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span> <span class='Operator'>= </span><a href="../../../include/parser/parsetree.h.html#LN30"><span class='Ref_to_Macro'>rt_fetch</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2361"><span class='Ref_To_Local'>rc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1281"><span class='Ref_to_Member'>rti</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2318"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN134"><span class='Ref_to_Member'>rtable</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2363"></a>        <a href="../../../include/nodes/plannodes.h.html#LN1002"><span class='Ref_to_Struct'>PlanRowMark</span></a> <span class='Operator'>*</span><span class='Declare_Local'>newrc</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Currently, it is syntactically impossible to have FOR UPDATE et al 
         * applied to an update/delete target rel.  If that ever becomes 
         * possible, we should drop the target from the PlanRowMark list. 
         */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="planner.c.html#LN2361"><span class='Ref_To_Local'>rc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1281"><span class='Ref_to_Member'>rti</span></a> <span class='Operator'>!= </span><a href="planner.c.html#LN2318"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN119"><span class='Ref_to_Member'>resultRelation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Ignore RowMarkClauses for subqueries; they aren't real tables and 
         * can't support true locking.  Subqueries that got flattened into the 
         * main query should be ignored completely.  Any that didn't will get 
         * ROW_MARK_COPY items in the next loop. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2362"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/parsenodes.h.html#LN922"><span class='Ref_to_EnumConst'>RTE_RELATION</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <a href="planner.c.html#LN2319"><span class='Ref_To_Local'>rels</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN90"><span class='Ref_to_Proto'>bms_del_member</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2319"><span class='Ref_To_Local'>rels</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2361"><span class='Ref_To_Local'>rc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1281"><span class='Ref_to_Member'>rti</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="planner.c.html#LN2363"><span class='Ref_To_Local'>newrc</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/plannodes.h.html#LN1002"><span class='Ref_to_Struct'>PlanRowMark</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN2363"><span class='Ref_To_Local'>newrc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN1005"><span class='Ref_to_Member'>rti</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN2363"><span class='Ref_To_Local'>newrc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN1006"><span class='Ref_to_Member'>prti</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN2361"><span class='Ref_To_Local'>rc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1281"><span class='Ref_to_Member'>rti</span></a><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN2363"><span class='Ref_To_Local'>newrc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN1007"><span class='Ref_to_Member'>rowmarkId</span></a> <span class='Operator'>= ++</span><span class='Parentheses'>(</span><a href="planner.c.html#LN2316"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN156"><span class='Ref_to_Member'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN120"><span class='Ref_to_Member'>lastRowMarkId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN2363"><span class='Ref_To_Local'>newrc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN1008"><span class='Ref_to_Member'>markType</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/planner.h.html#LN45"><span class='Ref_to_Proto'>select_rowmark_type</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2362"><span class='Ref_To_Local'>rte</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2361"><span class='Ref_To_Local'>rc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1282"><span class='Ref_to_Member'>strength</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN2363"><span class='Ref_To_Local'>newrc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN1009"><span class='Ref_to_Member'>allMarkTypes</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Number'>1</span> <span class='Operator'>&LT;&LT; </span><a href="planner.c.html#LN2363"><span class='Ref_To_Local'>newrc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN1008"><span class='Ref_to_Member'>markType</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN2363"><span class='Ref_To_Local'>newrc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN1010"><span class='Ref_to_Member'>strength</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN2361"><span class='Ref_To_Local'>rc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1282"><span class='Ref_to_Member'>strength</span></a><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN2363"><span class='Ref_To_Local'>newrc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN1011"><span class='Ref_to_Member'>waitPolicy</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN2361"><span class='Ref_To_Local'>rc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1283"><span class='Ref_to_Member'>waitPolicy</span></a><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN2363"><span class='Ref_To_Local'>newrc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN1012"><span class='Ref_to_Member'>isParent</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
        <a href="planner.c.html#LN2320"><span class='Ref_To_Local'>prowmarks</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2320"><span class='Ref_To_Local'>prowmarks</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2363"><span class='Ref_To_Local'>newrc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now, add rowmarks for any non-target, non-locked base relations. 
     */ 
</span>    <a href="planner.c.html#LN2322"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2321"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2318"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN134"><span class='Ref_to_Member'>rtable</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2401"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2321"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2402"></a>        <a href="../../../include/nodes/plannodes.h.html#LN1002"><span class='Ref_to_Struct'>PlanRowMark</span></a> <span class='Operator'>*</span><span class='Declare_Local'>newrc</span><span class='Delimiter'>; 
</span> 
        <a href="planner.c.html#LN2322"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN75"><span class='Ref_to_Proto'>bms_is_member</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2322"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2319"><span class='Ref_To_Local'>rels</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <a href="planner.c.html#LN2402"><span class='Ref_To_Local'>newrc</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/plannodes.h.html#LN1002"><span class='Ref_to_Struct'>PlanRowMark</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN2402"><span class='Ref_To_Local'>newrc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN1005"><span class='Ref_to_Member'>rti</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN2402"><span class='Ref_To_Local'>newrc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN1006"><span class='Ref_to_Member'>prti</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN2322"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN2402"><span class='Ref_To_Local'>newrc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN1007"><span class='Ref_to_Member'>rowmarkId</span></a> <span class='Operator'>= ++</span><span class='Parentheses'>(</span><a href="planner.c.html#LN2316"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN156"><span class='Ref_to_Member'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN120"><span class='Ref_to_Member'>lastRowMarkId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN2402"><span class='Ref_To_Local'>newrc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN1008"><span class='Ref_to_Member'>markType</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/planner.h.html#LN45"><span class='Ref_to_Proto'>select_rowmark_type</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2401"><span class='Ref_To_Local'>rte</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/lockoptions.h.html#LN22"><span class='Ref_to_EnumConst'>LCS_NONE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN2402"><span class='Ref_To_Local'>newrc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN1009"><span class='Ref_to_Member'>allMarkTypes</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Number'>1</span> <span class='Operator'>&LT;&LT; </span><a href="planner.c.html#LN2402"><span class='Ref_To_Local'>newrc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN1008"><span class='Ref_to_Member'>markType</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN2402"><span class='Ref_To_Local'>newrc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN1010"><span class='Ref_to_Member'>strength</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/lockoptions.h.html#LN22"><span class='Ref_to_EnumConst'>LCS_NONE</span></a><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN2402"><span class='Ref_To_Local'>newrc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN1011"><span class='Ref_to_Member'>waitPolicy</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/lockoptions.h.html#LN38"><span class='Ref_to_EnumConst'>LockWaitBlock</span></a><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* doesn't matter */ 
</span>        <a href="planner.c.html#LN2402"><span class='Ref_To_Local'>newrc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN1012"><span class='Ref_to_Member'>isParent</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
        <a href="planner.c.html#LN2320"><span class='Ref_To_Local'>prowmarks</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2320"><span class='Ref_To_Local'>prowmarks</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2402"><span class='Ref_To_Local'>newrc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="planner.c.html#LN2316"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN255"><span class='Ref_to_Member'>rowMarks</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN2320"><span class='Ref_To_Local'>prowmarks</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end preprocess_rowmarks &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Select RowMarkType to use for a given table 
 */ 
</span><a href="../../../include/nodes/plannodes.h.html#LN951"><span class='Ref_to_Enum'>RowMarkType</span></a> 
<a name="LN2427"></a><span class='Declare_Function'>select_rowmark_type</span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Delimiter'>, </span><a href="../../../include/nodes/lockoptions.h.html#LN20"><span class='Ref_to_Enum'>LockClauseStrength</span></a> <span class='Declare_Parameter'>strength</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2427"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/parsenodes.h.html#LN922"><span class='Ref_to_EnumConst'>RTE_RELATION</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* If it's not a table at all, use ROW_MARK_COPY */ 
</span>        <span class='Control'>return</span> <a href="../../../include/nodes/plannodes.h.html#LN958"><span class='Ref_to_EnumConst'>ROW_MARK_COPY</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2427"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN948"><span class='Ref_to_Member'>relkind</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_class.h.html#LN166"><span class='Ref_to_Const'>RELKIND_FOREIGN_TABLE</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Let the FDW select the rowmark type, if it wants to */ 
</span><a name="LN2437"></a>        <a href="../../../include/foreign/fdwapi.h.html#LN168"><span class='Ref_to_Struct'>FdwRoutine</span></a> <span class='Operator'>*</span><span class='Declare_Local'>fdwroutine</span> <span class='Operator'>= </span><a href="../../../include/foreign/fdwapi.h.html#LN235"><span class='Ref_to_Proto'>GetFdwRoutineByRelId</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2427"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN947"><span class='Ref_to_Member'>relid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2437"><span class='Ref_To_Local'>fdwroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/foreign/fdwapi.h.html#LN207"><span class='Ref_to_Member'>GetForeignRowMarkType</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <a href="planner.c.html#LN2437"><span class='Ref_To_Local'>fdwroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/foreign/fdwapi.h.html#LN207"><span class='Ref_to_Member'>GetForeignRowMarkType</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2427"><span class='Ref_to_Parameter'>rte</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2427"><span class='Ref_to_Parameter'>strength</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Otherwise, use ROW_MARK_COPY by default */ 
</span>        <span class='Control'>return</span> <a href="../../../include/nodes/plannodes.h.html#LN958"><span class='Ref_to_EnumConst'>ROW_MARK_COPY</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Regular table, apply the appropriate lock type */ 
</span>        <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2427"><span class='Ref_to_Parameter'>strength</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/lockoptions.h.html#LN22"><span class='Ref_to_EnumConst'>LCS_NONE</span></a><span class='Operator'>: 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * We don't need a tuple lock, only the ability to re-fetch 
                 * the row. 
                 */ 
</span>                <span class='Control'>return</span> <a href="../../../include/nodes/plannodes.h.html#LN957"><span class='Ref_to_EnumConst'>ROW_MARK_REFERENCE</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/lockoptions.h.html#LN23"><span class='Ref_to_EnumConst'>LCS_FORKEYSHARE</span></a><span class='Operator'>: 
</span>                <span class='Control'>return</span> <a href="../../../include/nodes/plannodes.h.html#LN956"><span class='Ref_to_EnumConst'>ROW_MARK_KEYSHARE</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/lockoptions.h.html#LN24"><span class='Ref_to_EnumConst'>LCS_FORSHARE</span></a><span class='Operator'>: 
</span>                <span class='Control'>return</span> <a href="../../../include/nodes/plannodes.h.html#LN955"><span class='Ref_to_EnumConst'>ROW_MARK_SHARE</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/lockoptions.h.html#LN25"><span class='Ref_to_EnumConst'>LCS_FORNOKEYUPDATE</span></a><span class='Operator'>: 
</span>                <span class='Control'>return</span> <a href="../../../include/nodes/plannodes.h.html#LN954"><span class='Ref_to_EnumConst'>ROW_MARK_NOKEYEXCLUSIVE</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/lockoptions.h.html#LN26"><span class='Ref_to_EnumConst'>LCS_FORUPDATE</span></a><span class='Operator'>: 
</span>                <span class='Control'>return</span> <a href="../../../include/nodes/plannodes.h.html#LN953"><span class='Ref_to_EnumConst'>ROW_MARK_EXCLUSIVE</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch strength &raquo; </span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized LockClauseStrength %d"</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="planner.c.html#LN2427"><span class='Ref_to_Parameter'>strength</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <a href="../../../include/nodes/plannodes.h.html#LN953"><span class='Ref_to_EnumConst'>ROW_MARK_EXCLUSIVE</span></a><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end select_rowmark_type &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * preprocess_limit - do pre-estimation for LIMIT and/or OFFSET clauses 
 * 
 * We try to estimate the values of the LIMIT/OFFSET clauses, and pass the 
 * results back in *count_est and *offset_est.  These variables are set to 
 * 0 if the corresponding clause is not present, and -1 if it's present 
 * but we couldn't estimate the value for it.  (The "0" convention is OK 
 * for OFFSET but a little bit bogus for LIMIT: effectively we estimate 
 * LIMIT 0 as though it were LIMIT 1.  But this is in line with the planner's 
 * usual practice of never estimating less than one row.)  These values will 
 * be passed to create_limit_path, which see if you change this code. 
 * 
 * The return value is the suitably adjusted tuple_fraction to use for 
 * planning the query.  This adjustment is not overridable, since it reflects 
 * plan actions that grouping_planner() will certainly take, not assumptions 
 * about context. 
 */ 
</span><span class='Keyword'>static double 
</span><a name="LN2493"></a><span class='Declare_Function'>preprocess_limit</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><span class='Keyword'>double </span><span class='Declare_Parameter'>tuple_fraction</span><span class='Delimiter'>, 
</span><a name="LN2494"></a>                 <a href="../../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>offset_est</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>count_est</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2496"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>parse</span> <span class='Operator'>= </span><a href="planner.c.html#LN2493"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Delimiter'>; 
</span><a name="LN2497"></a>    <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>est</span><span class='Delimiter'>; 
</span><a name="LN2498"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>limit_fraction</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Should not be called unless LIMIT or OFFSET */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="planner.c.html#LN2496"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN158"><span class='Ref_to_Member'>limitCount</span></a> <span class='Operator'>|| </span><a href="planner.c.html#LN2496"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN157"><span class='Ref_to_Member'>limitOffset</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Try to obtain the clause values.  We use estimate_expression_value 
     * primarily because it can sometimes do something useful with Params. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2496"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN158"><span class='Ref_to_Member'>limitCount</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="planner.c.html#LN2497"><span class='Ref_To_Local'>est</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/clauses.h.html#LN82"><span class='Ref_to_Proto'>estimate_expression_value</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2493"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2496"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN158"><span class='Ref_to_Member'>limitCount</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2497"><span class='Ref_To_Local'>est</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2497"><span class='Ref_To_Local'>est</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN2497"><span class='Ref_To_Local'>est</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constisnull<span class='Parentheses'>)</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* NULL indicates LIMIT ALL, ie, no limit */ 
</span>                <span class='Operator'>*</span><a href="planner.c.html#LN2494"><span class='Ref_to_Parameter'>count_est</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* treat as not present */ 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Operator'>*</span><a href="planner.c.html#LN2494"><span class='Ref_to_Parameter'>count_est</span></a> <span class='Operator'>= </span><a href="../../../include/postgres.h.html#LN610"><span class='Ref_to_Macro'>DatumGetInt64</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN2497"><span class='Ref_To_Local'>est</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constvalue<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="planner.c.html#LN2494"><span class='Ref_to_Parameter'>count_est</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                    <span class='Operator'>*</span><a href="planner.c.html#LN2494"><span class='Ref_to_Parameter'>count_est</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* force to at least 1 */ 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <span class='Operator'>*</span><a href="planner.c.html#LN2494"><span class='Ref_to_Parameter'>count_est</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* can't estimate */ 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if parse-&GT;limitCount &raquo; </span> 
    <span class='Control'>else</span> 
        <span class='Operator'>*</span><a href="planner.c.html#LN2494"><span class='Ref_to_Parameter'>count_est</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* not present */ 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2496"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN157"><span class='Ref_to_Member'>limitOffset</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="planner.c.html#LN2497"><span class='Ref_To_Local'>est</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/clauses.h.html#LN82"><span class='Ref_to_Proto'>estimate_expression_value</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2493"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2496"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN157"><span class='Ref_to_Member'>limitOffset</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2497"><span class='Ref_To_Local'>est</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2497"><span class='Ref_To_Local'>est</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN2497"><span class='Ref_To_Local'>est</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constisnull<span class='Parentheses'>)</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Treat NULL as no offset; the executor will too */ 
</span>                <span class='Operator'>*</span><a href="planner.c.html#LN2494"><span class='Ref_to_Parameter'>offset_est</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* treat as not present */ 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Operator'>*</span><a href="planner.c.html#LN2494"><span class='Ref_to_Parameter'>offset_est</span></a> <span class='Operator'>= </span><a href="../../../include/postgres.h.html#LN610"><span class='Ref_to_Macro'>DatumGetInt64</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN2497"><span class='Ref_To_Local'>est</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constvalue<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="planner.c.html#LN2494"><span class='Ref_to_Parameter'>offset_est</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                    <span class='Operator'>*</span><a href="planner.c.html#LN2494"><span class='Ref_to_Parameter'>offset_est</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* treat as not present */ 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <span class='Operator'>*</span><a href="planner.c.html#LN2494"><span class='Ref_to_Parameter'>offset_est</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* can't estimate */ 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if parse-&GT;limitOffset &raquo; </span> 
    <span class='Control'>else</span> 
        <span class='Operator'>*</span><a href="planner.c.html#LN2494"><span class='Ref_to_Parameter'>offset_est</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* not present */ 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="planner.c.html#LN2494"><span class='Ref_to_Parameter'>count_est</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * A LIMIT clause limits the absolute number of tuples returned. 
         * However, if it's not a constant LIMIT then we have to guess; for 
         * lack of a better idea, assume 10% of the plan's result is wanted. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="planner.c.html#LN2494"><span class='Ref_to_Parameter'>count_est</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span> <span class='Operator'>|| *</span><a href="planner.c.html#LN2494"><span class='Ref_to_Parameter'>offset_est</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* LIMIT or OFFSET is an expression ... punt ... */ 
</span>            <a href="planner.c.html#LN2498"><span class='Ref_To_Local'>limit_fraction</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>10</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* LIMIT (plus OFFSET, if any) is max number of tuples needed */ 
</span>            <a href="planner.c.html#LN2498"><span class='Ref_To_Local'>limit_fraction</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><span class='Operator'>*</span><a href="planner.c.html#LN2494"><span class='Ref_to_Parameter'>count_est</span></a> <span class='Operator'>+ </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><span class='Operator'>*</span><a href="planner.c.html#LN2494"><span class='Ref_to_Parameter'>offset_est</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If we have absolute limits from both caller and LIMIT, use the 
         * smaller value; likewise if they are both fractional.  If one is 
         * fractional and the other absolute, we can't easily determine which 
         * is smaller, but we use the heuristic that the absolute will usually 
         * be smaller. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2493"><span class='Ref_to_Parameter'>tuple_fraction</span></a> <span class='Operator'>&GT;= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2498"><span class='Ref_To_Local'>limit_fraction</span></a> <span class='Operator'>&GT;= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* both absolute */ 
</span>                <a href="planner.c.html#LN2493"><span class='Ref_to_Parameter'>tuple_fraction</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN11"><span class='Ref_to_Macro'>Min</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2493"><span class='Ref_to_Parameter'>tuple_fraction</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2498"><span class='Ref_To_Local'>limit_fraction</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* caller absolute, limit fractional; use caller's value */ 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2493"><span class='Ref_to_Parameter'>tuple_fraction</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2498"><span class='Ref_To_Local'>limit_fraction</span></a> <span class='Operator'>&GT;= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* caller fractional, limit absolute; use limit */ 
</span>                <a href="planner.c.html#LN2493"><span class='Ref_to_Parameter'>tuple_fraction</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN2498"><span class='Ref_To_Local'>limit_fraction</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* both fractional */ 
</span>                <a href="planner.c.html#LN2493"><span class='Ref_to_Parameter'>tuple_fraction</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN11"><span class='Ref_to_Macro'>Min</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2493"><span class='Ref_to_Parameter'>tuple_fraction</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2498"><span class='Ref_To_Local'>limit_fraction</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* no info from caller, just use limit */ 
</span>            <a href="planner.c.html#LN2493"><span class='Ref_to_Parameter'>tuple_fraction</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN2498"><span class='Ref_To_Local'>limit_fraction</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if *count_est!=0 &raquo; </span> 
    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="planner.c.html#LN2494"><span class='Ref_to_Parameter'>offset_est</span></a> <span class='Operator'>!= </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="planner.c.html#LN2493"><span class='Ref_to_Parameter'>tuple_fraction</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We have an OFFSET but no LIMIT.  This acts entirely differently 
         * from the LIMIT case: here, we need to increase rather than decrease 
         * the caller's tuple_fraction, because the OFFSET acts to cause more 
         * tuples to be fetched instead of fewer.  This only matters if we got 
         * a tuple_fraction &GT; 0, however. 
         * 
         * As above, use 10% if OFFSET is present but unestimatable. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="planner.c.html#LN2494"><span class='Ref_to_Parameter'>offset_est</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <a href="planner.c.html#LN2498"><span class='Ref_To_Local'>limit_fraction</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>10</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="planner.c.html#LN2498"><span class='Ref_To_Local'>limit_fraction</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><span class='Operator'>*</span><a href="planner.c.html#LN2494"><span class='Ref_to_Parameter'>offset_est</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If we have absolute counts from both caller and OFFSET, add them 
         * together; likewise if they are both fractional.  If one is 
         * fractional and the other absolute, we want to take the larger, and 
         * we heuristically assume that's the fractional one. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2493"><span class='Ref_to_Parameter'>tuple_fraction</span></a> <span class='Operator'>&GT;= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2498"><span class='Ref_To_Local'>limit_fraction</span></a> <span class='Operator'>&GT;= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* both absolute, so add them together */ 
</span>                <a href="planner.c.html#LN2493"><span class='Ref_to_Parameter'>tuple_fraction</span></a> <span class='Operator'>+= </span><a href="planner.c.html#LN2498"><span class='Ref_To_Local'>limit_fraction</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* caller absolute, limit fractional; use limit */ 
</span>                <a href="planner.c.html#LN2493"><span class='Ref_to_Parameter'>tuple_fraction</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN2498"><span class='Ref_To_Local'>limit_fraction</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2498"><span class='Ref_To_Local'>limit_fraction</span></a> <span class='Operator'>&GT;= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* caller fractional, limit absolute; use caller's value */ 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* both fractional, so add them together */ 
</span>                <a href="planner.c.html#LN2493"><span class='Ref_to_Parameter'>tuple_fraction</span></a> <span class='Operator'>+= </span><a href="planner.c.html#LN2498"><span class='Ref_To_Local'>limit_fraction</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2493"><span class='Ref_to_Parameter'>tuple_fraction</span></a> <span class='Operator'>&GT;= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                    <a href="planner.c.html#LN2493"><span class='Ref_to_Parameter'>tuple_fraction</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* assume fetch all */ 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if *offset_est!=0&&tuple... &raquo; </span> 
 
    <span class='Control'>return</span> <a href="planner.c.html#LN2493"><span class='Ref_to_Parameter'>tuple_fraction</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end preprocess_limit &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * limit_needed - do we actually need a Limit plan node? 
 * 
 * If we have constant-zero OFFSET and constant-null LIMIT, we can skip adding 
 * a Limit node.  This is worth checking for because "OFFSET 0" is a common 
 * locution for an optimization fence.  (Because other places in the planner 
 * merely check whether parse-&GT;limitOffset isn't NULL, it will still work as 
 * an optimization fence --- we're just suppressing unnecessary run-time 
 * overhead.) 
 * 
 * This might look like it could be merged into preprocess_limit, but there's 
 * a key distinction: here we need hard constants in OFFSET/LIMIT, whereas 
 * in preprocess_limit it's good enough to consider estimated values. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN2678"></a><span class='Declare_Function'>limit_needed</span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>parse</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2680"></a>    <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>node</span><span class='Delimiter'>; 
</span> 
    <a href="planner.c.html#LN2680"><span class='Ref_To_Local'>node</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN2678"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN158"><span class='Ref_to_Member'>limitCount</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2680"><span class='Ref_To_Local'>node</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2680"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* NULL indicates LIMIT ALL, ie, no limit */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN2680"><span class='Ref_To_Local'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constisnull<span class='Parentheses'>)</span> 
                <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* LIMIT with a constant value */ 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* non-constant LIMIT */ 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="planner.c.html#LN2680"><span class='Ref_To_Local'>node</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN2678"><span class='Ref_to_Parameter'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN157"><span class='Ref_to_Member'>limitOffset</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2680"><span class='Ref_To_Local'>node</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2680"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Treat NULL as no offset; the executor would too */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN2680"><span class='Ref_To_Local'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constisnull<span class='Parentheses'>)</span> 
            <span class='Delimiter'>{ 
</span><a name="LN2703"></a>                <a href="../../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a>       <span class='Declare_Local'>offset</span> <span class='Operator'>= </span><a href="../../../include/postgres.h.html#LN610"><span class='Ref_to_Macro'>DatumGetInt64</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN2680"><span class='Ref_To_Local'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constvalue<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2703"><span class='Ref_To_Local'>offset</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* OFFSET with a nonzero value */ 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* non-constant OFFSET */ 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>               <span class='Comment_Single_Line'>/* don't need a Limit plan node */ 
</span><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end limit_needed &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * remove_useless_groupby_columns 
 *      Remove any columns in the GROUP BY clause that are redundant due to 
 *      being functionally dependent on other GROUP BY columns. 
 * 
 * Since some other DBMSes do not allow references to ungrouped columns, it's 
 * not unusual to find all columns listed in GROUP BY even though listing the 
 * primary-key columns would be sufficient.  Deleting such excess columns 
 * avoids redundant sorting work, so it's worth doing.  When we do this, we 
 * must mark the plan as dependent on the pkey constraint (compare the 
 * parser's check_ungrouped_columns() and check_functional_grouping()). 
 * 
 * In principle, we could treat any NOT-NULL columns appearing in a UNIQUE 
 * index as the determining columns.  But as with check_functional_grouping(), 
 * there's currently no way to represent dependency on a NOT NULL constraint, 
 * so we consider only the pkey for now. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2735"></a><span class='Declare_Function'>remove_useless_groupby_columns</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2737"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>parse</span> <span class='Operator'>= </span><a href="planner.c.html#LN2735"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Delimiter'>; 
</span><a name="LN2738"></a>    <a href="../../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a> <span class='Operator'>**</span><span class='Declare_Local'>groupbyattnos</span><span class='Delimiter'>; 
</span><a name="LN2739"></a>    <a href="../../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a> <span class='Operator'>**</span><span class='Declare_Local'>surplusvars</span><span class='Delimiter'>; 
</span><a name="LN2740"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span><a name="LN2741"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>relid</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* No chance to do anything if there are less than two GROUP BY items */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2737"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Parentheses'>) </span><span class='Operator'>&LT; </span><span class='Number'>2</span><span class='Parentheses'>)</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Don't fiddle with the GROUP BY clause if the query has grouping sets */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2737"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN147"><span class='Ref_to_Member'>groupingSets</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Scan the GROUP BY clause to find GROUP BY items that are simple Vars. 
     * Fill groupbyattnos[k] with a bitmapset of the column attnos of RTE k 
     * that are GROUP BY items. 
     */ 
</span>    <a href="planner.c.html#LN2738"><span class='Ref_To_Local'>groupbyattnos</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a> <span class='Operator'>**</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> <span class='Operator'>* 
</span>                                           <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2737"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN134"><span class='Ref_to_Member'>rtable</span></a><span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2740"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2737"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2760"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sgc</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2740"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2761"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span> <span class='Operator'>= </span><a href="../../../include/optimizer/tlist.h.html#LN37"><span class='Ref_to_Proto'>get_sortgroupclause_tle</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2760"><span class='Ref_To_Local'>sgc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2737"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2762"></a>        <a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>var</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN2761"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Ignore non-Vars and Vars from other query levels. 
         * 
         * XXX in principle, stable expressions containing Vars could also be 
         * removed, if all the Vars are functionally dependent on other GROUP 
         * BY items.  But it's not clear that such cases occur often enough to 
         * be worth troubling over. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2762"><span class='Ref_To_Local'>var</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>            <a href="planner.c.html#LN2762"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN172"><span class='Ref_to_Member'>varlevelsup</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* OK, remember we have this Var */ 
</span>        <a href="planner.c.html#LN2741"><span class='Ref_To_Local'>relid</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN2762"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN165"><span class='Ref_to_Member'>varno</span></a><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="planner.c.html#LN2741"><span class='Ref_To_Local'>relid</span></a> <span class='Operator'>&LT;= </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2737"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN134"><span class='Ref_to_Member'>rtable</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN2738"><span class='Ref_To_Local'>groupbyattnos</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN2741"><span class='Ref_To_Local'>relid</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN89"><span class='Ref_to_Proto'>bms_add_member</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2738"><span class='Ref_To_Local'>groupbyattnos</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN2741"><span class='Ref_To_Local'>relid</span></a><span class='Delimiter'>], 
</span>                         <a href="planner.c.html#LN2762"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a> <span class='Operator'>- </span><a href="../../../include/access/sysattr.h.html#LN27"><span class='Ref_to_Const'>FirstLowInvalidHeapAttributeNumber</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Consider each relation and see if it is possible to remove some of its 
     * Vars from GROUP BY.  For simplicity and speed, we do the actual removal 
     * in a separate pass.  Here, we just fill surplusvars[k] with a bitmapset 
     * of the column attnos of RTE k that are removable GROUP BY items. 
     */ 
</span>    <a href="planner.c.html#LN2739"><span class='Ref_To_Local'>surplusvars</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* don't allocate array unless required */ 
</span>    <a href="planner.c.html#LN2741"><span class='Ref_To_Local'>relid</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2740"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2737"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN134"><span class='Ref_to_Member'>rtable</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2793"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2740"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2794"></a>        <a href="../../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>relattnos</span><span class='Delimiter'>; 
</span><a name="LN2795"></a>        <a href="../../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>pkattnos</span><span class='Delimiter'>; 
</span><a name="LN2796"></a>        <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>constraintOid</span><span class='Delimiter'>; 
</span> 
        <a href="planner.c.html#LN2741"><span class='Ref_To_Local'>relid</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Only plain relations could have primary-key constraints */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2793"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/parsenodes.h.html#LN922"><span class='Ref_to_EnumConst'>RTE_RELATION</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Nothing to do unless this rel has multiple Vars in GROUP BY */ 
</span>        <a href="planner.c.html#LN2794"><span class='Ref_To_Local'>relattnos</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN2738"><span class='Ref_To_Local'>groupbyattnos</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN2741"><span class='Ref_To_Local'>relid</span></a><span class='Delimiter'>]; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN84"><span class='Ref_to_Proto'>bms_membership</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2794"><span class='Ref_To_Local'>relattnos</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="../../../include/nodes/bitmapset.h.html#LN57"><span class='Ref_to_EnumConst'>BMS_MULTIPLE</span></a><span class='Parentheses'>)</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Can't remove any columns for this rel if there is no suitable 
         * (i.e., nondeferrable) primary key constraint. 
         */ 
</span>        <a href="planner.c.html#LN2795"><span class='Ref_To_Local'>pkattnos</span></a> <span class='Operator'>= </span><a href="../../../include/catalog/pg_constraint_fn.h.html#LN73"><span class='Ref_to_Proto'>get_primary_key_attnos</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2793"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN947"><span class='Ref_to_Member'>relid</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="planner.c.html#LN2796"><span class='Ref_To_Local'>constraintOid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2795"><span class='Ref_To_Local'>pkattnos</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If the primary key is a proper subset of relattnos then we have 
         * some items in the GROUP BY that can be removed. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN74"><span class='Ref_to_Proto'>bms_subset_compare</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2795"><span class='Ref_To_Local'>pkattnos</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2794"><span class='Ref_To_Local'>relattnos</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="../../../include/nodes/bitmapset.h.html#LN47"><span class='Ref_to_EnumConst'>BMS_SUBSET1</span></a><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * To easily remember whether we've found anything to do, we don't 
             * allocate the surplusvars[] array until we find something. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2739"><span class='Ref_To_Local'>surplusvars</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>                <a href="planner.c.html#LN2739"><span class='Ref_To_Local'>surplusvars</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a> <span class='Operator'>**</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> <span class='Operator'>* 
</span>                                           <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2737"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN134"><span class='Ref_to_Member'>rtable</span></a><span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Remember the attnos of the removable columns */ 
</span>            <a href="planner.c.html#LN2739"><span class='Ref_To_Local'>surplusvars</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN2741"><span class='Ref_To_Local'>relid</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN72"><span class='Ref_to_Proto'>bms_difference</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2794"><span class='Ref_To_Local'>relattnos</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2795"><span class='Ref_To_Local'>pkattnos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Also, mark the resulting plan as dependent on this constraint */ 
</span>            <a href="planner.c.html#LN2737"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN165"><span class='Ref_to_Member'>constraintDeps</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN162"><span class='Ref_to_Func'>lappend_oid</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2737"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN165"><span class='Ref_to_Member'>constraintDeps</span></a><span class='Delimiter'>, 
</span>                                                <a href="planner.c.html#LN2796"><span class='Ref_To_Local'>constraintOid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we found any surplus Vars, build a new GROUP BY clause without them. 
     * (Note: this may leave some TLEs with unreferenced ressortgroupref 
     * markings, but that's harmless.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2739"><span class='Ref_To_Local'>surplusvars</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2847"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>new_groupby</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2740"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2737"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN2851"></a>            <a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sgc</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2740"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2852"></a>            <a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span> <span class='Operator'>= </span><a href="../../../include/optimizer/tlist.h.html#LN37"><span class='Ref_to_Proto'>get_sortgroupclause_tle</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2851"><span class='Ref_To_Local'>sgc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2737"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2853"></a>            <a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>var</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN2852"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * New list must include non-Vars, outer Vars, and anything not 
             * marked as surplus. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2853"><span class='Ref_To_Local'>var</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>                <a href="planner.c.html#LN2853"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN172"><span class='Ref_to_Member'>varlevelsup</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span> <span class='Operator'>|| 
</span>            <span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN75"><span class='Ref_to_Proto'>bms_is_member</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2853"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a> <span class='Operator'>- </span><a href="../../../include/access/sysattr.h.html#LN27"><span class='Ref_to_Const'>FirstLowInvalidHeapAttributeNumber</span></a><span class='Delimiter'>, 
</span>                           <a href="planner.c.html#LN2739"><span class='Ref_To_Local'>surplusvars</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN2853"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN165"><span class='Ref_to_Member'>varno</span></a><span class='Delimiter'>]</span><span class='Parentheses'>))</span> 
                <a href="planner.c.html#LN2847"><span class='Ref_To_Local'>new_groupby</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2847"><span class='Ref_To_Local'>new_groupby</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2851"><span class='Ref_To_Local'>sgc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="planner.c.html#LN2737"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN2847"><span class='Ref_To_Local'>new_groupby</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if surplusvars!=NULL &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end remove_useless_groupby_columns &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * preprocess_groupclause - do preparatory work on GROUP BY clause 
 * 
 * The idea here is to adjust the ordering of the GROUP BY elements 
 * (which in itself is semantically insignificant) to match ORDER BY, 
 * thereby allowing a single sort operation to both implement the ORDER BY 
 * requirement and set up for a Unique step that implements GROUP BY. 
 * 
 * In principle it might be interesting to consider other orderings of the 
 * GROUP BY elements, which could match the sort ordering of other 
 * possible plans (eg an indexscan) and thereby reduce cost.  We don't 
 * bother with that, though.  Hashed grouping will frequently win anyway. 
 * 
 * Note: we need no comparable processing of the distinctClause because 
 * the parser already enforced that that matches ORDER BY. 
 * 
 * For grouping sets, the order of items is instead forced to agree with that 
 * of the grouping set (and items not in the grouping set are skipped). The 
 * work of sorting the order of grouping set elements to match the ORDER BY if 
 * possible is done elsewhere. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN2892"></a><span class='Declare_Function'>preprocess_groupclause</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>force</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2894"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>parse</span> <span class='Operator'>= </span><a href="planner.c.html#LN2892"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Delimiter'>; 
</span><a name="LN2895"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>new_groupclause</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN2896"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>partial_match</span><span class='Delimiter'>; 
</span><a name="LN2897"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>sl</span><span class='Delimiter'>; 
</span><a name="LN2898"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>gl</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* For grouping sets, we need to force the ordering */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2892"><span class='Ref_to_Parameter'>force</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2897"><span class='Ref_To_Local'>sl</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2892"><span class='Ref_to_Parameter'>force</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN2905"></a>            <a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Local'>ref</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN106"><span class='Ref_to_Macro'>lfirst_int</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2897"><span class='Ref_To_Local'>sl</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2906"></a>            <a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>cl</span> <span class='Operator'>= </span><a href="../../../include/optimizer/tlist.h.html#LN44"><span class='Ref_to_Proto'>get_sortgroupref_clause</span></a><span class='Parentheses'>(</span><span class='Keyword'>ref</span><span class='Delimiter'>, </span><a href="planner.c.html#LN2894"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="planner.c.html#LN2895"><span class='Ref_To_Local'>new_groupclause</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2895"><span class='Ref_To_Local'>new_groupclause</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2906"><span class='Ref_To_Local'>cl</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>return</span> <a href="planner.c.html#LN2895"><span class='Ref_To_Local'>new_groupclause</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* If no ORDER BY, nothing useful to do here */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2894"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN155"><span class='Ref_to_Member'>sortClause</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="planner.c.html#LN2894"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Scan the ORDER BY clause and construct a list of matching GROUP BY 
     * items, but only as far as we can make a matching prefix. 
     * 
     * This code assumes that the sortClause contains no duplicate items. 
     */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2897"><span class='Ref_To_Local'>sl</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2894"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN155"><span class='Ref_to_Member'>sortClause</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2926"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sc</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2897"><span class='Ref_To_Local'>sl</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2898"><span class='Ref_To_Local'>gl</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2894"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN2930"></a>            <a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>gc</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2898"><span class='Ref_To_Local'>gl</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN626"><span class='Ref_to_Proto'>equal</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2930"><span class='Ref_To_Local'>gc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2926"><span class='Ref_To_Local'>sc</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="planner.c.html#LN2895"><span class='Ref_To_Local'>new_groupclause</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2895"><span class='Ref_To_Local'>new_groupclause</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2930"><span class='Ref_To_Local'>gc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2898"><span class='Ref_To_Local'>gl</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Control'>break</span><span class='Delimiter'>;</span>              <span class='Comment_Single_Line'>/* no match, so stop scanning */ 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Did we match all of the ORDER BY list, or just some of it? */ 
</span>    <a href="planner.c.html#LN2896"><span class='Ref_To_Local'>partial_match</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="planner.c.html#LN2897"><span class='Ref_To_Local'>sl</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If no match at all, no point in reordering GROUP BY */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2895"><span class='Ref_To_Local'>new_groupclause</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="planner.c.html#LN2894"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Add any remaining GROUP BY items to the new list, but only if we were 
     * able to make a complete match.  In other words, we only rearrange the 
     * GROUP BY list if the result is that one list is a prefix of the other 
     * --- otherwise there's no possibility of a common sort.  Also, give up 
     * if there are any non-sortable GROUP BY items, since then there's no 
     * hope anyway. 
     */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2898"><span class='Ref_To_Local'>gl</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2894"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2959"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>gc</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2898"><span class='Ref_To_Local'>gl</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN229"><span class='Ref_to_Proto'>list_member_ptr</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2895"><span class='Ref_To_Local'>new_groupclause</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2959"><span class='Ref_To_Local'>gc</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* it matched an ORDER BY item */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2896"><span class='Ref_To_Local'>partial_match</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <a href="planner.c.html#LN2894"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* give up, no common sort possible */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2959"><span class='Ref_To_Local'>gc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1166"><span class='Ref_to_Member'>sortop</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <a href="planner.c.html#LN2894"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* give up, GROUP BY can't be sorted */ 
</span>        <a href="planner.c.html#LN2895"><span class='Ref_To_Local'>new_groupclause</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2895"><span class='Ref_To_Local'>new_groupclause</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2959"><span class='Ref_To_Local'>gc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Success --- install the rearranged GROUP BY list */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2894"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2895"><span class='Ref_To_Local'>new_groupclause</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="planner.c.html#LN2895"><span class='Ref_To_Local'>new_groupclause</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end preprocess_groupclause &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Extract lists of grouping sets that can be implemented using a single 
 * rollup-type aggregate pass each. Returns a list of lists of grouping sets. 
 * 
 * Input must be sorted with smallest sets first. Result has each sublist 
 * sorted with smallest sets first. 
 * 
 * We want to produce the absolute minimum possible number of lists here to 
 * avoid excess sorts. Fortunately, there is an algorithm for this; the problem 
 * of finding the minimal partition of a partially-ordered set into chains 
 * (which is what we need, taking the list of grouping sets as a poset ordered 
 * by set inclusion) can be mapped to the problem of finding the maximum 
 * cardinality matching on a bipartite graph, which is solvable in polynomial 
 * time with a worst case of no worse than O(n^2.5) and usually much 
 * better. Since our N is at most 4096, we don't need to consider fallbacks to 
 * heuristic or approximate methods.  (Planning time for a 12-d cube is under 
 * half a second on my modest system even with optimization off and assertions 
 * on.) 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN2995"></a><span class='Declare_Function'>extract_rollup_sets</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>groupingSets</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2997"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>num_sets_raw</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2995"><span class='Ref_to_Parameter'>groupingSets</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2998"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>num_empty</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN2999"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>num_sets</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* distinct sets */ 
</span><a name="LN3000"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>num_chains</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN3001"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN3002"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>      <span class='Operator'>**</span><span class='Declare_Local'>results</span><span class='Delimiter'>; 
</span><a name="LN3003"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>      <span class='Operator'>**</span><span class='Declare_Local'>orig_sets</span><span class='Delimiter'>; 
</span><a name="LN3004"></a>    <a href="../../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a> <span class='Operator'>**</span><span class='Declare_Local'>set_masks</span><span class='Delimiter'>; 
</span><a name="LN3005"></a>    <span class='Keyword'>int</span>        <span class='Operator'>*</span><span class='Declare_Local'>chains</span><span class='Delimiter'>; 
</span><a name="LN3006"></a>    <span class='Keyword'>short</span>     <span class='Operator'>**</span><span class='Declare_Local'>adjacency</span><span class='Delimiter'>; 
</span><a name="LN3007"></a>    <span class='Keyword'>short</span>      <span class='Operator'>*</span><span class='Declare_Local'>adjacency_buf</span><span class='Delimiter'>; 
</span><a name="LN3008"></a>    <a href="../../../include/lib/bipartite_match.h.html#LN26"><span class='Ref_to_Struct'>BipartiteMatchState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>state</span><span class='Delimiter'>; 
</span><a name="LN3009"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN3010"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>j</span><span class='Delimiter'>; 
</span><a name="LN3011"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>j_size</span><span class='Delimiter'>; 
</span><a name="LN3012"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc1</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2995"><span class='Ref_to_Parameter'>groupingSets</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3013"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Start by stripping out empty sets.  The algorithm doesn't require this, 
     * but the planner currently needs all empty sets to be returned in the 
     * first list, so we strip them here and add them back after. 
     */ 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3012"><span class='Ref_To_Local'>lc1</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3012"><span class='Ref_To_Local'>lc1</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Operator'>++</span><a href="planner.c.html#LN2998"><span class='Ref_To_Local'>num_empty</span></a><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN3012"><span class='Ref_To_Local'>lc1</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3012"><span class='Ref_To_Local'>lc1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* bail out now if it turns out that all we had were empty sets. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="planner.c.html#LN3012"><span class='Ref_To_Local'>lc1</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="../../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2995"><span class='Ref_to_Parameter'>groupingSets</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/*---------- 
     * We don't strictly need to remove duplicate sets here, but if we don't, 
     * they tend to become scattered through the result, which is a bit 
     * confusing (and irritating if we ever decide to optimize them out). 
     * So we remove them here and add them back after. 
     * 
     * For each non-duplicate set, we fill in the following: 
     * 
     * orig_sets[i] = list of the original set lists 
     * set_masks[i] = bitmapset for testing inclusion 
     * adjacency[i] = array [n, v1, v2, ... vn] of adjacency indices 
     * 
     * chains[i] will be the result group this set is assigned to. 
     * 
     * We index all of these from 1 rather than 0 because it is convenient 
     * to leave 0 free for the NIL node in the graph algorithm. 
     *---------- 
     */ 
</span>    <a href="planner.c.html#LN3003"><span class='Ref_To_Local'>orig_sets</span></a> <span class='Operator'>= </span><a href="../../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>((</span><a href="planner.c.html#LN2997"><span class='Ref_To_Local'>num_sets_raw</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN3004"><span class='Ref_To_Local'>set_masks</span></a> <span class='Operator'>= </span><a href="../../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>((</span><a href="planner.c.html#LN2997"><span class='Ref_To_Local'>num_sets_raw</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a> <span class='Operator'>*</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN3006"><span class='Ref_To_Local'>adjacency</span></a> <span class='Operator'>= </span><a href="../../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>((</span><a href="planner.c.html#LN2997"><span class='Ref_To_Local'>num_sets_raw</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>short </span><span class='Operator'>*</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN3007"><span class='Ref_To_Local'>adjacency_buf</span></a> <span class='Operator'>= </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>((</span><a href="planner.c.html#LN2997"><span class='Ref_To_Local'>num_sets_raw</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>short</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="planner.c.html#LN3011"><span class='Ref_To_Local'>j_size</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN3010"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN3009"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN168"><span class='Ref_to_Macro'>for_each_cell</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3013"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN3012"><span class='Ref_To_Local'>lc1</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3059"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>candidate</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3013"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3060"></a>        <a href="../../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>candidate_set</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN3061"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc2</span><span class='Delimiter'>; 
</span><a name="LN3062"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>dup_of</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3061"><span class='Ref_To_Local'>lc2</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN3059"><span class='Ref_To_Local'>candidate</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="planner.c.html#LN3060"><span class='Ref_To_Local'>candidate_set</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN89"><span class='Ref_to_Proto'>bms_add_member</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3060"><span class='Ref_To_Local'>candidate_set</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN106"><span class='Ref_to_Macro'>lfirst_int</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3061"><span class='Ref_To_Local'>lc2</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* we can only be a dup if we're the same length as a previous set */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3011"><span class='Ref_To_Local'>j_size</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3059"><span class='Ref_To_Local'>candidate</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN3072"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>k</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3072"><span class='Ref_To_Local'>k</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN3010"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>; </span><a href="planner.c.html#LN3072"><span class='Ref_To_Local'>k</span></a> <span class='Operator'>&LT; </span><a href="planner.c.html#LN3009"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>; </span><span class='Operator'>++</span><a href="planner.c.html#LN3072"><span class='Ref_To_Local'>k</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN66"><span class='Ref_to_Proto'>bms_equal</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3004"><span class='Ref_To_Local'>set_masks</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN3072"><span class='Ref_To_Local'>k</span></a><span class='Delimiter'>], </span><a href="planner.c.html#LN3060"><span class='Ref_To_Local'>candidate_set</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <a href="planner.c.html#LN3062"><span class='Ref_To_Local'>dup_of</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN3072"><span class='Ref_To_Local'>k</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3011"><span class='Ref_To_Local'>j_size</span></a> <span class='Operator'>&LT; </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3059"><span class='Ref_To_Local'>candidate</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="planner.c.html#LN3011"><span class='Ref_To_Local'>j_size</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3059"><span class='Ref_To_Local'>candidate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="planner.c.html#LN3010"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN3009"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3062"><span class='Ref_To_Local'>dup_of</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="planner.c.html#LN3003"><span class='Ref_To_Local'>orig_sets</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN3062"><span class='Ref_To_Local'>dup_of</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3003"><span class='Ref_To_Local'>orig_sets</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN3062"><span class='Ref_To_Local'>dup_of</span></a><span class='Delimiter'>], </span><a href="planner.c.html#LN3059"><span class='Ref_To_Local'>candidate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/nodes/bitmapset.h.html#LN68"><span class='Ref_to_Proto'>bms_free</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3060"><span class='Ref_To_Local'>candidate_set</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span><a name="LN3096"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>k</span><span class='Delimiter'>; 
</span><a name="LN3097"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>n_adj</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
            <a href="planner.c.html#LN3003"><span class='Ref_To_Local'>orig_sets</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN3009"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3059"><span class='Ref_To_Local'>candidate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="planner.c.html#LN3004"><span class='Ref_To_Local'>set_masks</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN3009"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="planner.c.html#LN3060"><span class='Ref_To_Local'>candidate_set</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* fill in adjacency list; no need to compare equal-size sets */ 
</span> 
            <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3096"><span class='Ref_To_Local'>k</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN3010"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="planner.c.html#LN3096"><span class='Ref_To_Local'>k</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Delimiter'>; </span><span class='Operator'>--</span><a href="planner.c.html#LN3096"><span class='Ref_To_Local'>k</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3004"><span class='Ref_To_Local'>set_masks</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN3096"><span class='Ref_To_Local'>k</span></a><span class='Delimiter'>], </span><a href="planner.c.html#LN3060"><span class='Ref_To_Local'>candidate_set</span></a><span class='Parentheses'>))</span> 
                    <a href="planner.c.html#LN3007"><span class='Ref_To_Local'>adjacency_buf</span></a><span class='Delimiter'>[</span><span class='Operator'>++</span><a href="planner.c.html#LN3097"><span class='Ref_To_Local'>n_adj</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="planner.c.html#LN3096"><span class='Ref_To_Local'>k</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3097"><span class='Ref_To_Local'>n_adj</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="planner.c.html#LN3007"><span class='Ref_To_Local'>adjacency_buf</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="planner.c.html#LN3097"><span class='Ref_To_Local'>n_adj</span></a><span class='Delimiter'>; 
</span>                <a href="planner.c.html#LN3006"><span class='Ref_To_Local'>adjacency</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN3009"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>((</span><a href="planner.c.html#LN3097"><span class='Ref_To_Local'>n_adj</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>short</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                memcpy<span class='Parentheses'>(</span><a href="planner.c.html#LN3006"><span class='Ref_To_Local'>adjacency</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN3009"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], </span><a href="planner.c.html#LN3007"><span class='Ref_To_Local'>adjacency_buf</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="planner.c.html#LN3097"><span class='Ref_To_Local'>n_adj</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>short</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
                <a href="planner.c.html#LN3006"><span class='Ref_To_Local'>adjacency</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN3009"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
            <span class='Operator'>++</span><a href="planner.c.html#LN3009"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
    <span class='Delimiter'>} 
</span> 
    <a href="planner.c.html#LN2999"><span class='Ref_To_Local'>num_sets</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN3009"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Apply the graph matching algorithm to do the work. 
     */ 
</span>    <a href="planner.c.html#LN3008"><span class='Ref_To_Local'>state</span></a> <span class='Operator'>= </span><a href="../../lib/bipartite_match.c.html#LN37"><span class='Ref_to_Func'>BipartiteMatch</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN2999"><span class='Ref_To_Local'>num_sets</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN2999"><span class='Ref_To_Local'>num_sets</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN3006"><span class='Ref_To_Local'>adjacency</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now, the state-&GT;pair* fields have the info we need to assign sets to 
     * chains. Two sets (u,v) belong to the same chain if pair_uv[u] = v or 
     * pair_vu[v] = u (both will be true, but we check both so that we can do 
     * it in one pass) 
     */ 
</span>    <a href="planner.c.html#LN3005"><span class='Ref_To_Local'>chains</span></a> <span class='Operator'>= </span><a href="../../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>((</span><a href="planner.c.html#LN2999"><span class='Ref_To_Local'>num_sets</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3009"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="planner.c.html#LN3009"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT;= </span><a href="planner.c.html#LN2999"><span class='Ref_To_Local'>num_sets</span></a><span class='Delimiter'>; </span><span class='Operator'>++</span><a href="planner.c.html#LN3009"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3140"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>u</span> <span class='Operator'>= </span><a href="planner.c.html#LN3008"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="../../../include/lib/bipartite_match.h.html#LN35"><span class='Ref_to_Member'>pair_vu</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN3009"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span><a name="LN3141"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>v</span> <span class='Operator'>= </span><a href="planner.c.html#LN3008"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="../../../include/lib/bipartite_match.h.html#LN34"><span class='Ref_to_Member'>pair_uv</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN3009"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3140"><span class='Ref_To_Local'>u</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="planner.c.html#LN3140"><span class='Ref_To_Local'>u</span></a> <span class='Operator'>&LT; </span><a href="planner.c.html#LN3009"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>) 
</span>            <a href="planner.c.html#LN3005"><span class='Ref_To_Local'>chains</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN3009"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="planner.c.html#LN3005"><span class='Ref_To_Local'>chains</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN3140"><span class='Ref_To_Local'>u</span></a><span class='Delimiter'>]; 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3141"><span class='Ref_To_Local'>v</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="planner.c.html#LN3141"><span class='Ref_To_Local'>v</span></a> <span class='Operator'>&LT; </span><a href="planner.c.html#LN3009"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>) 
</span>            <a href="planner.c.html#LN3005"><span class='Ref_To_Local'>chains</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN3009"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="planner.c.html#LN3005"><span class='Ref_To_Local'>chains</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN3141"><span class='Ref_To_Local'>v</span></a><span class='Delimiter'>]; 
</span>        <span class='Control'>else</span> 
            <a href="planner.c.html#LN3005"><span class='Ref_To_Local'>chains</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN3009"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= ++</span><a href="planner.c.html#LN3000"><span class='Ref_To_Local'>num_chains</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* build result lists. */ 
</span>    <a href="planner.c.html#LN3002"><span class='Ref_To_Local'>results</span></a> <span class='Operator'>= </span><a href="../../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>((</span><a href="planner.c.html#LN3000"><span class='Ref_To_Local'>num_chains</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3009"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="planner.c.html#LN3009"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT;= </span><a href="planner.c.html#LN2999"><span class='Ref_To_Local'>num_sets</span></a><span class='Delimiter'>; </span><span class='Operator'>++</span><a href="planner.c.html#LN3009"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3156"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>c</span> <span class='Operator'>= </span><a href="planner.c.html#LN3005"><span class='Ref_To_Local'>chains</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN3009"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="planner.c.html#LN3156"><span class='Ref_To_Local'>c</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="planner.c.html#LN3002"><span class='Ref_To_Local'>results</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN3156"><span class='Ref_To_Local'>c</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3002"><span class='Ref_To_Local'>results</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN3156"><span class='Ref_To_Local'>c</span></a><span class='Delimiter'>], </span><a href="planner.c.html#LN3003"><span class='Ref_To_Local'>orig_sets</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN3009"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* push any empty sets back on the first list. */ 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN2998"><span class='Ref_To_Local'>num_empty</span></a><span class='Operator'>-- &GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="planner.c.html#LN3002"><span class='Ref_To_Local'>results</span></a><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN215"><span class='Ref_to_Proto'>lcons</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN3002"><span class='Ref_To_Local'>results</span></a><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* make result list */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3009"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="planner.c.html#LN3009"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT;= </span><a href="planner.c.html#LN3000"><span class='Ref_To_Local'>num_chains</span></a><span class='Delimiter'>; </span><span class='Operator'>++</span><a href="planner.c.html#LN3009"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>) 
</span>        <a href="planner.c.html#LN3001"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3001"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN3002"><span class='Ref_To_Local'>results</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN3009"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Free all the things. 
     * 
     * (This is over-fussy for small sets but for large sets we could have 
     * tied up a nontrivial amount of memory.) 
     */ 
</span>    <a href="../../../include/lib/bipartite_match.h.html#LN43"><span class='Ref_to_Proto'>BipartiteMatchFree</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3008"><span class='Ref_To_Local'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3002"><span class='Ref_To_Local'>results</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3005"><span class='Ref_To_Local'>chains</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3009"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="planner.c.html#LN3009"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT;= </span><a href="planner.c.html#LN2999"><span class='Ref_To_Local'>num_sets</span></a><span class='Delimiter'>; </span><span class='Operator'>++</span><a href="planner.c.html#LN3009"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3006"><span class='Ref_To_Local'>adjacency</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN3009"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>            <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3006"><span class='Ref_To_Local'>adjacency</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN3009"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3006"><span class='Ref_To_Local'>adjacency</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3007"><span class='Ref_To_Local'>adjacency_buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3003"><span class='Ref_To_Local'>orig_sets</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3009"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="planner.c.html#LN3009"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT;= </span><a href="planner.c.html#LN2999"><span class='Ref_To_Local'>num_sets</span></a><span class='Delimiter'>; </span><span class='Operator'>++</span><a href="planner.c.html#LN3009"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/nodes/bitmapset.h.html#LN68"><span class='Ref_to_Proto'>bms_free</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3004"><span class='Ref_To_Local'>set_masks</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN3009"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3004"><span class='Ref_To_Local'>set_masks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="planner.c.html#LN3001"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end extract_rollup_sets &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Reorder the elements of a list of grouping sets such that they have correct 
 * prefix relationships. Also inserts the GroupingSetData annotations. 
 * 
 * The input must be ordered with smallest sets first; the result is returned 
 * with largest sets first.  Note that the result shares no list substructure 
 * with the input, so it's safe for the caller to modify it later. 
 * 
 * If we're passed in a sortclause, we follow its order of columns to the 
 * extent possible, to minimize the chance that we add unnecessary sorts. 
 * (We're trying here to ensure that GROUPING SETS ((a,b,c),(c)) ORDER BY c,b,a 
 * gets implemented in one pass.) 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN3207"></a><span class='Declare_Function'>reorder_grouping_sets</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>groupingsets</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sortclause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3209"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span><a name="LN3210"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc2</span><span class='Delimiter'>; 
</span><a name="LN3211"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>previous</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN3212"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3209"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN3207"><span class='Ref_to_Parameter'>groupingsets</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3216"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>candidate</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3209"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3217"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>new_elems</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN252"><span class='Ref_to_Proto'>list_difference_int</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3216"><span class='Ref_To_Local'>candidate</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN3211"><span class='Ref_To_Local'>previous</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3218"></a>        <a href="../../../include/nodes/relation.h.html#LN1471"><span class='Ref_to_Struct'>GroupingSetData</span></a> <span class='Operator'>*</span><span class='Declare_Local'>gs</span> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1471"><span class='Ref_to_Struct'>GroupingSetData</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3217"><span class='Ref_To_Local'>new_elems</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3207"><span class='Ref_to_Parameter'>sortclause</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT; </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3211"><span class='Ref_To_Local'>previous</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span><a name="LN3224"></a>                <a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sc</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN223"><span class='Ref_to_Proto'>list_nth</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3207"><span class='Ref_to_Parameter'>sortclause</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3211"><span class='Ref_To_Local'>previous</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span><a name="LN3225"></a>                <span class='Keyword'>int</span>         <span class='Declare_Local'>ref</span> <span class='Operator'>= </span><a href="planner.c.html#LN3224"><span class='Ref_To_Local'>sc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1164"><span class='Ref_to_Member'>tleSortGroupRef</span></a><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN230"><span class='Ref_to_Proto'>list_member_int</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3217"><span class='Ref_To_Local'>new_elems</span></a><span class='Delimiter'>, </span><span class='Keyword'>ref</span><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <a href="planner.c.html#LN3211"><span class='Ref_To_Local'>previous</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN144"><span class='Ref_to_Func'>lappend_int</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3211"><span class='Ref_To_Local'>previous</span></a><span class='Delimiter'>, </span><span class='Keyword'>ref</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="planner.c.html#LN3217"><span class='Ref_To_Local'>new_elems</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN235"><span class='Ref_to_Proto'>list_delete_int</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3217"><span class='Ref_To_Local'>new_elems</span></a><span class='Delimiter'>, </span><span class='Keyword'>ref</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>else</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* diverged from the sortclause; give up on it */ 
</span>                    <a href="planner.c.html#LN3207"><span class='Ref_to_Parameter'>sortclause</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span> 
            <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3210"><span class='Ref_To_Local'>lc2</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN3217"><span class='Ref_To_Local'>new_elems</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="planner.c.html#LN3211"><span class='Ref_To_Local'>previous</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN144"><span class='Ref_to_Func'>lappend_int</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3211"><span class='Ref_To_Local'>previous</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN106"><span class='Ref_to_Macro'>lfirst_int</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3210"><span class='Ref_To_Local'>lc2</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if list_length(new_elems... &raquo; </span> 
 
        <a href="planner.c.html#LN3218"><span class='Ref_To_Local'>gs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1474"><span class='Ref_to_Member'>set</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN268"><span class='Ref_to_Proto'>list_copy</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3211"><span class='Ref_To_Local'>previous</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN3212"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN215"><span class='Ref_to_Proto'>lcons</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3218"><span class='Ref_To_Local'>gs</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN3212"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN265"><span class='Ref_to_Proto'>list_free</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3217"><span class='Ref_To_Local'>new_elems</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN265"><span class='Ref_to_Proto'>list_free</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3211"><span class='Ref_To_Local'>previous</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="planner.c.html#LN3212"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end reorder_grouping_sets &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Compute query_pathkeys and other pathkeys during plan generation 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3260"></a><span class='Declare_Function'>standard_qp_callback</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>extra</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3262"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>parse</span> <span class='Operator'>= </span><a href="planner.c.html#LN3260"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Delimiter'>; 
</span><a name="LN3263"></a>    <a href="planner.c.html#LN87"><span class='Ref_to_Typedef'>standard_qp_extra</span></a> <span class='Operator'>*</span><span class='Declare_Local'>qp_extra</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="planner.c.html#LN87"><span class='Ref_to_Typedef'>standard_qp_extra</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN3260"><span class='Ref_to_Parameter'>extra</span></a><span class='Delimiter'>; 
</span><a name="LN3264"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>tlist</span> <span class='Operator'>= </span><a href="planner.c.html#LN3263"><span class='Ref_To_Local'>qp_extra</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN89"><span class='Ref_to_Member'>tlist</span></a><span class='Delimiter'>; 
</span><a name="LN3265"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>activeWindows</span> <span class='Operator'>= </span><a href="planner.c.html#LN3263"><span class='Ref_To_Local'>qp_extra</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN90"><span class='Ref_to_Member'>activeWindows</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Calculate pathkeys that represent grouping/ordering requirements.  The 
     * sortClause is certainly sort-able, but GROUP BY and DISTINCT might not 
     * be, in which case we just leave their pathkeys empty. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3263"><span class='Ref_To_Local'>qp_extra</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN91"><span class='Ref_to_Member'>groupClause</span></a> <span class='Operator'>&& 
</span>        <a href="../../../include/optimizer/tlist.h.html#LN51"><span class='Ref_to_Proto'>grouping_is_sortable</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3263"><span class='Ref_To_Local'>qp_extra</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN91"><span class='Ref_to_Member'>groupClause</span></a><span class='Parentheses'>))</span> 
        <a href="planner.c.html#LN3260"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN263"><span class='Ref_to_Member'>group_pathkeys</span></a> <span class='Operator'>= 
</span>            <a href="../../../include/optimizer/paths.h.html#LN205"><span class='Ref_to_Proto'>make_pathkeys_for_sortclauses</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3260"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                          <a href="planner.c.html#LN3263"><span class='Ref_To_Local'>qp_extra</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN91"><span class='Ref_to_Member'>groupClause</span></a><span class='Delimiter'>, 
</span>                                          <a href="planner.c.html#LN3264"><span class='Ref_To_Local'>tlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="planner.c.html#LN3260"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN263"><span class='Ref_to_Member'>group_pathkeys</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* We consider only the first (bottom) window in pathkeys logic */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3265"><span class='Ref_To_Local'>activeWindows</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3284"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN1252"><span class='Ref_to_Struct'>WindowClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>wc</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1252"><span class='Ref_to_Struct'>WindowClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3265"><span class='Ref_To_Local'>activeWindows</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="planner.c.html#LN3260"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN264"><span class='Ref_to_Member'>window_pathkeys</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN179"><span class='Ref_to_Proto'>make_pathkeys_for_window</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3260"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                         <a href="planner.c.html#LN3284"><span class='Ref_To_Local'>wc</span></a><span class='Delimiter'>, 
</span>                                                         <a href="planner.c.html#LN3264"><span class='Ref_To_Local'>tlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
        <a href="planner.c.html#LN3260"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN264"><span class='Ref_to_Member'>window_pathkeys</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3262"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN153"><span class='Ref_to_Member'>distinctClause</span></a> <span class='Operator'>&& 
</span>        <a href="../../../include/optimizer/tlist.h.html#LN51"><span class='Ref_to_Proto'>grouping_is_sortable</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3262"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN153"><span class='Ref_to_Member'>distinctClause</span></a><span class='Parentheses'>))</span> 
        <a href="planner.c.html#LN3260"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN265"><span class='Ref_to_Member'>distinct_pathkeys</span></a> <span class='Operator'>= 
</span>            <a href="../../../include/optimizer/paths.h.html#LN205"><span class='Ref_to_Proto'>make_pathkeys_for_sortclauses</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3260"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                          <a href="planner.c.html#LN3262"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN153"><span class='Ref_to_Member'>distinctClause</span></a><span class='Delimiter'>, 
</span>                                          <a href="planner.c.html#LN3264"><span class='Ref_To_Local'>tlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="planner.c.html#LN3260"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN265"><span class='Ref_to_Member'>distinct_pathkeys</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <a href="planner.c.html#LN3260"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN266"><span class='Ref_to_Member'>sort_pathkeys</span></a> <span class='Operator'>= 
</span>        <a href="../../../include/optimizer/paths.h.html#LN205"><span class='Ref_to_Proto'>make_pathkeys_for_sortclauses</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3260"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                      <a href="planner.c.html#LN3262"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN155"><span class='Ref_to_Member'>sortClause</span></a><span class='Delimiter'>, 
</span>                                      <a href="planner.c.html#LN3264"><span class='Ref_To_Local'>tlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Figure out whether we want a sorted result from query_planner. 
     * 
     * If we have a sortable GROUP BY clause, then we want a result sorted 
     * properly for grouping.  Otherwise, if we have window functions to 
     * evaluate, we try to sort for the first window.  Otherwise, if there's a 
     * sortable DISTINCT clause that's more rigorous than the ORDER BY clause, 
     * we try to produce output that's sufficiently well sorted for the 
     * DISTINCT.  Otherwise, if there is an ORDER BY clause, we want to sort 
     * by the ORDER BY clause. 
     * 
     * Note: if we have both ORDER BY and GROUP BY, and ORDER BY is a superset 
     * of GROUP BY, it would be tempting to request sort by ORDER BY --- but 
     * that might just leave us failing to exploit an available sort order at 
     * all.  Needs more thought.  The choice for DISTINCT versus ORDER BY is 
     * much easier, since we know that the parser ensured that one is a 
     * superset of the other. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3260"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN263"><span class='Ref_to_Member'>group_pathkeys</span></a><span class='Parentheses'>) 
</span>        <a href="planner.c.html#LN3260"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN261"><span class='Ref_to_Member'>query_pathkeys</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN3260"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN263"><span class='Ref_to_Member'>group_pathkeys</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3260"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN264"><span class='Ref_to_Member'>window_pathkeys</span></a><span class='Parentheses'>) 
</span>        <a href="planner.c.html#LN3260"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN261"><span class='Ref_to_Member'>query_pathkeys</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN3260"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN264"><span class='Ref_to_Member'>window_pathkeys</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3260"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN265"><span class='Ref_to_Member'>distinct_pathkeys</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT; 
</span>             <a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3260"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN266"><span class='Ref_to_Member'>sort_pathkeys</span></a><span class='Parentheses'>))</span> 
        <a href="planner.c.html#LN3260"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN261"><span class='Ref_to_Member'>query_pathkeys</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN3260"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN265"><span class='Ref_to_Member'>distinct_pathkeys</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3260"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN266"><span class='Ref_to_Member'>sort_pathkeys</span></a><span class='Parentheses'>) 
</span>        <a href="planner.c.html#LN3260"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN261"><span class='Ref_to_Member'>query_pathkeys</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN3260"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN266"><span class='Ref_to_Member'>sort_pathkeys</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="planner.c.html#LN3260"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN261"><span class='Ref_to_Member'>query_pathkeys</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end standard_qp_callback &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Estimate number of groups produced by grouping clauses (1 if not grouping) 
 * 
 * path_rows: number of output rows from scan/join step 
 * gsets: grouping set data, or NULL if not doing grouping sets 
 * 
 * If doing grouping sets, we also annotate the gsets data with the estimates 
 * for each set and each individual rollup list, with a view to later 
 * determining whether some combination of them could be hashed instead. 
 */ 
</span><span class='Keyword'>static double 
</span><a name="LN3349"></a><span class='Declare_Function'>get_number_of_groups</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN3350"></a>                     <span class='Keyword'>double </span><span class='Declare_Parameter'>path_rows</span><span class='Delimiter'>, 
</span><a name="LN3351"></a>                     <a href="planner.c.html#LN98"><span class='Ref_to_Typedef'>grouping_sets_data</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>gd</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3353"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>parse</span> <span class='Operator'>= </span><a href="planner.c.html#LN3349"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Delimiter'>; 
</span><a name="LN3354"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>dNumGroups</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3353"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3358"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>groupExprs</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3353"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN147"><span class='Ref_to_Member'>groupingSets</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Add up the estimates for each grouping set */ 
</span><a name="LN3363"></a>            <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span><a name="LN3364"></a>            <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc2</span><span class='Delimiter'>; 
</span> 
            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="planner.c.html#LN3351"><span class='Ref_to_Parameter'>gd</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* keep Coverity happy */ 
</span> 
            <a href="planner.c.html#LN3354"><span class='Ref_To_Local'>dNumGroups</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3363"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN3351"><span class='Ref_to_Parameter'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN100"><span class='Ref_to_Member'>rollups</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN3372"></a>                <a href="../../../include/nodes/relation.h.html#LN1478"><span class='Ref_to_Struct'>RollupData</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rollup</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3373"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3373"></a>                <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
                <a href="planner.c.html#LN3358"><span class='Ref_To_Local'>groupExprs</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/tlist.h.html#LN41"><span class='Ref_to_Proto'>get_sortgrouplist_exprs</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3372"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1481"><span class='Ref_to_Member'>groupClause</span></a><span class='Delimiter'>, 
</span>                                                     <a href="planner.c.html#LN3353"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="planner.c.html#LN3372"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1484"><span class='Ref_to_Member'>numGroups</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
                <a href="../../../include/nodes/pg_list.h.html#LN179"><span class='Ref_to_Macro'>forboth</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3373"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN3372"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1482"><span class='Ref_to_Member'>gsets</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN3364"><span class='Ref_To_Local'>lc2</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN3372"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1483"><span class='Ref_to_Member'>gsets_data</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN3382"></a>                    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>gset</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3373"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3383"></a>                    <a href="../../../include/nodes/relation.h.html#LN1471"><span class='Ref_to_Struct'>GroupingSetData</span></a> <span class='Operator'>*</span><span class='Declare_Local'>gs</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3364"><span class='Ref_To_Local'>lc2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3384"></a>                    <span class='Keyword'>double</span>      <span class='Declare_Local'>numGroups</span> <span class='Operator'>= </span><a href="../../../include/utils/selfuncs.h.html#LN205"><span class='Ref_to_Proto'>estimate_num_groups</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3349"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                                <a href="planner.c.html#LN3358"><span class='Ref_To_Local'>groupExprs</span></a><span class='Delimiter'>, 
</span>                                                                <a href="planner.c.html#LN3350"><span class='Ref_to_Parameter'>path_rows</span></a><span class='Delimiter'>, 
</span>                                                                <span class='Operator'>&</span><a href="planner.c.html#LN3382"><span class='Ref_To_Local'>gset</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <a href="planner.c.html#LN3383"><span class='Ref_To_Local'>gs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1475"><span class='Ref_to_Member'>numGroups</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN3384"><span class='Ref_To_Local'>numGroups</span></a><span class='Delimiter'>; 
</span>                    <a href="planner.c.html#LN3372"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1484"><span class='Ref_to_Member'>numGroups</span></a> <span class='Operator'>+= </span><a href="planner.c.html#LN3384"><span class='Ref_To_Local'>numGroups</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
                <a href="planner.c.html#LN3354"><span class='Ref_To_Local'>dNumGroups</span></a> <span class='Operator'>+= </span><a href="planner.c.html#LN3372"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1484"><span class='Ref_to_Member'>numGroups</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3351"><span class='Ref_to_Parameter'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN101"><span class='Ref_to_Member'>hash_sets_idx</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN3398"></a>                <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
                <a href="planner.c.html#LN3351"><span class='Ref_to_Parameter'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN102"><span class='Ref_to_Member'>dNumHashGroups</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
                <a href="planner.c.html#LN3358"><span class='Ref_To_Local'>groupExprs</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/tlist.h.html#LN41"><span class='Ref_to_Proto'>get_sortgrouplist_exprs</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3353"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Delimiter'>, 
</span>                                                     <a href="planner.c.html#LN3353"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="../../../include/nodes/pg_list.h.html#LN179"><span class='Ref_to_Macro'>forboth</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3398"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN3351"><span class='Ref_to_Parameter'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN101"><span class='Ref_to_Member'>hash_sets_idx</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN3364"><span class='Ref_To_Local'>lc2</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN3351"><span class='Ref_to_Parameter'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN106"><span class='Ref_to_Member'>unsortable_sets</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN3407"></a>                    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>gset</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3398"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3408"></a>                    <a href="../../../include/nodes/relation.h.html#LN1471"><span class='Ref_to_Struct'>GroupingSetData</span></a> <span class='Operator'>*</span><span class='Declare_Local'>gs</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3364"><span class='Ref_To_Local'>lc2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3409"></a>                    <span class='Keyword'>double</span>      <span class='Declare_Local'>numGroups</span> <span class='Operator'>= </span><a href="../../../include/utils/selfuncs.h.html#LN205"><span class='Ref_to_Proto'>estimate_num_groups</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3349"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                                <a href="planner.c.html#LN3358"><span class='Ref_To_Local'>groupExprs</span></a><span class='Delimiter'>, 
</span>                                                                <a href="planner.c.html#LN3350"><span class='Ref_to_Parameter'>path_rows</span></a><span class='Delimiter'>, 
</span>                                                                <span class='Operator'>&</span><a href="planner.c.html#LN3407"><span class='Ref_To_Local'>gset</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <a href="planner.c.html#LN3408"><span class='Ref_To_Local'>gs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1475"><span class='Ref_to_Member'>numGroups</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN3409"><span class='Ref_To_Local'>numGroups</span></a><span class='Delimiter'>; 
</span>                    <a href="planner.c.html#LN3351"><span class='Ref_to_Parameter'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN102"><span class='Ref_to_Member'>dNumHashGroups</span></a> <span class='Operator'>+= </span><a href="planner.c.html#LN3409"><span class='Ref_To_Local'>numGroups</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
                <a href="planner.c.html#LN3354"><span class='Ref_To_Local'>dNumGroups</span></a> <span class='Operator'>+= </span><a href="planner.c.html#LN3351"><span class='Ref_to_Parameter'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN102"><span class='Ref_to_Member'>dNumHashGroups</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if gd-&GT;hash_sets_idx &raquo; </span> 
        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if parse-&GT;groupingSets &raquo; </span> 
        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Plain GROUP BY */ 
</span>            <a href="planner.c.html#LN3358"><span class='Ref_To_Local'>groupExprs</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/tlist.h.html#LN41"><span class='Ref_to_Proto'>get_sortgrouplist_exprs</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3353"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Delimiter'>, 
</span>                                                 <a href="planner.c.html#LN3353"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="planner.c.html#LN3354"><span class='Ref_To_Local'>dNumGroups</span></a> <span class='Operator'>= </span><a href="../../../include/utils/selfuncs.h.html#LN205"><span class='Ref_to_Proto'>estimate_num_groups</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3349"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN3358"><span class='Ref_To_Local'>groupExprs</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN3350"><span class='Ref_to_Parameter'>path_rows</span></a><span class='Delimiter'>, 
</span>                                             <span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if parse-&GT;groupClause &raquo; </span> 
    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3353"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN147"><span class='Ref_to_Member'>groupingSets</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Empty grouping sets ... one result row for each one */ 
</span>        <a href="planner.c.html#LN3354"><span class='Ref_To_Local'>dNumGroups</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3353"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN147"><span class='Ref_to_Member'>groupingSets</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3353"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN122"><span class='Ref_to_Member'>hasAggs</span></a> <span class='Operator'>|| </span><a href="planner.c.html#LN3349"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN301"><span class='Ref_to_Member'>hasHavingQual</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Plain aggregation, one result row */ 
</span>        <a href="planner.c.html#LN3354"><span class='Ref_To_Local'>dNumGroups</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Not grouping */ 
</span>        <a href="planner.c.html#LN3354"><span class='Ref_To_Local'>dNumGroups</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="planner.c.html#LN3354"><span class='Ref_To_Local'>dNumGroups</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end get_number_of_groups &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * estimate_hashagg_tablesize 
 *    estimate the number of bytes that a hash aggregate hashtable will 
 *    require based on the agg_costs, path width and dNumGroups. 
 * 
 * XXX this may be over-estimating the size now that hashagg knows to omit 
 * unneeded columns from the hashtable. Also for mixed-mode grouping sets, 
 * grouping columns not in the hashed set are counted here even though hashagg 
 * won't store them. Is this a problem? 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a> 
<a name="LN3461"></a><span class='Declare_Function'>estimate_hashagg_tablesize</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="../../../include/nodes/relation.h.html#LN55"><span class='Ref_to_Struct'>AggClauseCosts</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>agg_costs</span><span class='Delimiter'>, 
</span><a name="LN3462"></a>                           <span class='Keyword'>double </span><span class='Declare_Parameter'>dNumGroups</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3464"></a>    <a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Local'>hashentrysize</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Estimate per-hash-entry space at tuple width... */ 
</span>    <a href="planner.c.html#LN3464"><span class='Ref_To_Local'>hashentrysize</span></a> <span class='Operator'>= </span><a href="../../../include/c.h.html#LN587"><span class='Ref_to_Macro'>MAXALIGN</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3461"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN885"><span class='Ref_to_Member'>width</span></a><span class='Parentheses'>) </span><span class='Operator'>+ 
</span>        <a href="../../../include/c.h.html#LN587"><span class='Ref_to_Macro'>MAXALIGN</span></a><span class='Parentheses'>(</span><a href="../../../include/access/htup_details.h.html#LN649"><span class='Ref_to_Const'>SizeofMinimalTupleHeader</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* plus space for pass-by-ref transition values... */ 
</span>    <a href="planner.c.html#LN3464"><span class='Ref_To_Local'>hashentrysize</span></a> <span class='Operator'>+= </span><a href="planner.c.html#LN3461"><span class='Ref_to_Parameter'>agg_costs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN63"><span class='Ref_to_Member'>transitionSpace</span></a><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* plus the per-hash-entry overhead */ 
</span>    <a href="planner.c.html#LN3464"><span class='Ref_To_Local'>hashentrysize</span></a> <span class='Operator'>+= </span><a href="../../../include/executor/nodeAgg.h.html#LN23"><span class='Ref_to_Proto'>hash_agg_entry_size</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3461"><span class='Ref_to_Parameter'>agg_costs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN57"><span class='Ref_to_Member'>numAggs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Note that this disregards the effect of fill-factor and growth policy 
     * of the hash-table. That's probably ok, given default the default 
     * fill-factor is relatively high. It'd be hard to meaningfully factor in 
     * "double-in-size" growth policies here. 
     */ 
</span>    <span class='Control'>return</span> <a href="planner.c.html#LN3464"><span class='Ref_To_Local'>hashentrysize</span></a> <span class='Operator'>* </span><a href="planner.c.html#LN3462"><span class='Ref_to_Parameter'>dNumGroups</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end estimate_hashagg_tablesize &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * create_grouping_paths 
 * 
 * Build a new upperrel containing Paths for grouping and/or aggregation. 
 * 
 * input_rel: contains the source-data Paths 
 * target: the pathtarget for the result Paths to compute 
 * agg_costs: cost info about all aggregates in query (in AGGSPLIT_SIMPLE mode) 
 * rollup_lists: list of grouping sets, or NIL if not doing grouping sets 
 * rollup_groupclauses: list of grouping clauses for grouping sets, 
 *      or NIL if not doing grouping sets 
 * 
 * Note: all Paths in input_rel are expected to return the target computed 
 * by make_group_input_target. 
 * 
 * We need to consider sorted and hashed aggregation in the same function, 
 * because otherwise (1) it would be harder to throw an appropriate error 
 * message if neither way works, and (2) we should not allow hashtable size 
 * considerations to dissuade us from using hashing if sorting is not possible. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>* 
</span><a name="LN3505"></a><span class='Declare_Function'>create_grouping_paths</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN3506"></a>                      <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>input_rel</span><span class='Delimiter'>, 
</span><a name="LN3507"></a>                      <a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>target</span><span class='Delimiter'>, 
</span><a name="LN3508"></a>                      <span class='Keyword'>const </span><a href="../../../include/nodes/relation.h.html#LN55"><span class='Ref_to_Struct'>AggClauseCosts</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>agg_costs</span><span class='Delimiter'>, 
</span><a name="LN3509"></a>                      <a href="planner.c.html#LN98"><span class='Ref_to_Typedef'>grouping_sets_data</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>gd</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3511"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>parse</span> <span class='Operator'>= </span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Delimiter'>; 
</span><a name="LN3512"></a>    <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>cheapest_path</span> <span class='Operator'>= </span><a href="planner.c.html#LN3506"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN542"><span class='Ref_to_Member'>cheapest_total_path</span></a><span class='Delimiter'>; 
</span><a name="LN3513"></a>    <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>grouped_rel</span><span class='Delimiter'>; 
</span><a name="LN3514"></a>    <a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Local'>partial_grouping_target</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN3515"></a>    <a href="../../../include/nodes/relation.h.html#LN55"><span class='Ref_to_Struct'>AggClauseCosts</span></a> <span class='Declare_Local'>agg_partial_costs</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* parallel only */ 
</span><a name="LN3516"></a>    <a href="../../../include/nodes/relation.h.html#LN55"><span class='Ref_to_Struct'>AggClauseCosts</span></a> <span class='Declare_Local'>agg_final_costs</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* parallel only */ 
</span><a name="LN3517"></a>    <a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Local'>hashaggtablesize</span><span class='Delimiter'>; 
</span><a name="LN3518"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>dNumGroups</span><span class='Delimiter'>; 
</span><a name="LN3519"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>dNumPartialGroups</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN3520"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>can_hash</span><span class='Delimiter'>; 
</span><a name="LN3521"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>can_sort</span><span class='Delimiter'>; 
</span><a name="LN3522"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>try_parallel_aggregation</span><span class='Delimiter'>; 
</span> 
<a name="LN3524"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* For now, do all work in the (GROUP_AGG, NULL) upperrel */ 
</span>    <a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/pathnode.h.html#LN270"><span class='Ref_to_Proto'>fetch_upper_rel</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN73"><span class='Ref_to_EnumConst'>UPPERREL_GROUP_AGG</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the input relation is not parallel-safe, then the grouped relation 
     * can't be parallel-safe, either.  Otherwise, it's parallel-safe if the 
     * target list and HAVING quals are parallel-safe. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3506"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN532"><span class='Ref_to_Member'>consider_parallel</span></a> <span class='Operator'>&& 
</span>        <a href="../../../include/optimizer/clauses.h.html#LN63"><span class='Ref_to_Proto'>is_parallel_safe</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN3507"><span class='Ref_to_Parameter'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>        <a href="../../../include/optimizer/clauses.h.html#LN63"><span class='Ref_to_Proto'>is_parallel_safe</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a><span class='Parentheses'>))</span> 
        <a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN532"><span class='Ref_to_Member'>consider_parallel</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the input rel belongs to a single FDW, so does the grouped rel. 
     */ 
</span>    <a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN571"><span class='Ref_to_Member'>serverid</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN3506"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN571"><span class='Ref_to_Member'>serverid</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN572"><span class='Ref_to_Member'>userid</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN3506"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN572"><span class='Ref_to_Member'>userid</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN573"><span class='Ref_to_Member'>useridiscurrent</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN3506"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN573"><span class='Ref_to_Member'>useridiscurrent</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN575"><span class='Ref_to_Member'>fdwroutine</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN3506"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN575"><span class='Ref_to_Member'>fdwroutine</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Check for degenerate grouping. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN301"><span class='Ref_to_Member'>hasHavingQual</span></a> <span class='Operator'>|| </span><a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN147"><span class='Ref_to_Member'>groupingSets</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>        <span class='Operator'>!</span><a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN122"><span class='Ref_to_Member'>hasAggs</span></a> <span class='Operator'>&& </span><a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We have a HAVING qual and/or grouping sets, but no aggregates and 
         * no GROUP BY (which implies that the grouping sets are all empty). 
         * 
         * This is a degenerate case in which we are supposed to emit either 
         * zero or one row for each grouping set depending on whether HAVING 
         * succeeds.  Furthermore, there cannot be any variables in either 
         * HAVING or the targetlist, so we actually do not need the FROM table 
         * at all!  We can just throw away the plan-so-far and generate a 
         * Result node.  This is a sufficiently unusual corner case that it's 
         * not worth contorting the structure of this module to avoid having 
         * to generate the earlier paths in the first place. 
         */ 
</span><a name="LN3566"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>nrows</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN147"><span class='Ref_to_Member'>groupingSets</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3567"></a>        <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>path</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3566"><span class='Ref_To_Local'>nrows</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Doesn't seem worthwhile writing code to cons up a 
             * generate_series or a values scan to emit multiple rows. Instead 
             * just make N clones and append them.  (With a volatile HAVING 
             * clause, this means you might get between 0 and N output rows. 
             * Offhand I think that's desired.) 
             */ 
</span><a name="LN3578"></a>            <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>paths</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
            <span class='Control'>while</span> <span class='Parentheses'>(</span><span class='Operator'>--</span><a href="planner.c.html#LN3566"><span class='Ref_To_Local'>nrows</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="planner.c.html#LN3567"><span class='Ref_To_Local'>path</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                    <a href="../../../include/optimizer/pathnode.h.html#LN74"><span class='Ref_to_Proto'>create_result_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Delimiter'>, 
</span>                                       <a href="planner.c.html#LN3507"><span class='Ref_to_Parameter'>target</span></a><span class='Delimiter'>, 
</span>                                       <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="planner.c.html#LN3578"><span class='Ref_To_Local'>paths</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3578"><span class='Ref_To_Local'>paths</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN3567"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <a href="planner.c.html#LN3567"><span class='Ref_To_Local'>path</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                <a href="../../../include/optimizer/pathnode.h.html#LN65"><span class='Ref_to_Proto'>create_append_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Delimiter'>, 
</span>                                   <a href="planner.c.html#LN3578"><span class='Ref_To_Local'>paths</span></a><span class='Delimiter'>, 
</span>                                   <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                   <span class='Number'>0</span><span class='Delimiter'>, 
</span>                                   <a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="planner.c.html#LN3567"><span class='Ref_To_Local'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN3507"><span class='Ref_to_Parameter'>target</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if nrows&GT;1 &raquo; </span> 
        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* No grouping sets, or just one, so one output row */ 
</span>            <a href="planner.c.html#LN3567"><span class='Ref_To_Local'>path</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                <a href="../../../include/optimizer/pathnode.h.html#LN74"><span class='Ref_to_Proto'>create_result_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Delimiter'>, 
</span>                                   <a href="planner.c.html#LN3507"><span class='Ref_to_Parameter'>target</span></a><span class='Delimiter'>, 
</span>                                   <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="../../../include/optimizer/pathnode.h.html#LN27"><span class='Ref_to_Proto'>add_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN3567"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* No need to consider any other alternatives. */ 
</span>        <a href="../../../include/optimizer/pathnode.h.html#LN26"><span class='Ref_to_Proto'>set_cheapest</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>return</span> <a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if (root-&GT;hasHavingQual|... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Estimate number of groups. 
     */ 
</span>    <a href="planner.c.html#LN3518"><span class='Ref_To_Local'>dNumGroups</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN129"><span class='Ref_to_Proto'>get_number_of_groups</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                      <a href="planner.c.html#LN3512"><span class='Ref_To_Local'>cheapest_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>, 
</span>                                      <a href="planner.c.html#LN3509"><span class='Ref_to_Parameter'>gd</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Determine whether it's possible to perform sort-based implementations 
     * of grouping.  (Note that if groupClause is empty, 
     * grouping_is_sortable() is trivially true, and all the 
     * pathkeys_contained_in() tests will succeed too, so that we'll consider 
     * every surviving input path.) 
     * 
     * If we have grouping sets, we might be able to sort some but not all of 
     * them; in this case, we need can_sort to be true as long as we must 
     * consider any sorted-input plan. 
     */ 
</span>    <a href="planner.c.html#LN3521"><span class='Ref_To_Local'>can_sort</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="planner.c.html#LN3509"><span class='Ref_to_Parameter'>gd</span></a> <span class='Operator'>&& </span><a href="planner.c.html#LN3509"><span class='Ref_to_Parameter'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN100"><span class='Ref_to_Member'>rollups</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>|| </span><a href="../../../include/optimizer/tlist.h.html#LN51"><span class='Ref_to_Proto'>grouping_is_sortable</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Determine whether we should consider hash-based implementations of 
     * grouping. 
     * 
     * Hashed aggregation only applies if we're grouping. If we have grouping 
     * sets, some groups might be hashable but others not; in this case we set 
     * can_hash true as long as there is nothing globally preventing us from 
     * hashing (and we should therefore consider plans with hashes). 
     * 
     * Executor doesn't support hashed aggregation with DISTINCT or ORDER BY 
     * aggregates.  (Doing so would imply storing *all* the input values in 
     * the hash table, and/or running many sorts in parallel, either of which 
     * seems like a certain loser.)  We similarly don't support ordered-set 
     * aggregates in hashed aggregation, but that case is also included in the 
     * numOrderedAggs count. 
     * 
     * Note: grouping_is_hashable() is much more expensive to check than the 
     * other gating conditions, so we want to do it last. 
     */ 
</span>    <a href="planner.c.html#LN3520"><span class='Ref_To_Local'>can_hash</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>&& 
</span>                <a href="planner.c.html#LN3508"><span class='Ref_to_Parameter'>agg_costs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN58"><span class='Ref_to_Member'>numOrderedAggs</span></a> <span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>&& 
</span>         <span class='Parentheses'>(</span><a href="planner.c.html#LN3509"><span class='Ref_to_Parameter'>gd</span></a> <span class='Operator'>? </span><a href="planner.c.html#LN3509"><span class='Ref_to_Parameter'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN103"><span class='Ref_to_Member'>any_hashable</span></a> <span class='Operator'>: </span><a href="../../../include/optimizer/tlist.h.html#LN52"><span class='Ref_to_Proto'>grouping_is_hashable</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If grouped_rel-&GT;consider_parallel is true, then paths that we generate 
     * for this grouping relation could be run inside of a worker, but that 
     * doesn't mean we can actually use the PartialAggregate/FinalizeAggregate 
     * execution strategy.  Figure that out. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN532"><span class='Ref_to_Member'>consider_parallel</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Not even parallel-safe. */ 
</span>        <a href="planner.c.html#LN3522"><span class='Ref_To_Local'>try_parallel_aggregation</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3506"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN540"><span class='Ref_to_Member'>partial_pathlist</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Nothing to use as input for partial aggregate. */ 
</span>        <a href="planner.c.html#LN3522"><span class='Ref_To_Local'>try_parallel_aggregation</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN122"><span class='Ref_to_Member'>hasAggs</span></a> <span class='Operator'>&& </span><a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We don't know how to do parallel aggregation unless we have either 
         * some aggregates or a grouping clause. 
         */ 
</span>        <a href="planner.c.html#LN3522"><span class='Ref_To_Local'>try_parallel_aggregation</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN147"><span class='Ref_to_Member'>groupingSets</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* We don't know how to do grouping sets in parallel. */ 
</span>        <a href="planner.c.html#LN3522"><span class='Ref_To_Local'>try_parallel_aggregation</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3508"><span class='Ref_to_Parameter'>agg_costs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN59"><span class='Ref_to_Member'>hasNonPartial</span></a> <span class='Operator'>|| </span><a href="planner.c.html#LN3508"><span class='Ref_to_Parameter'>agg_costs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN60"><span class='Ref_to_Member'>hasNonSerial</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Insufficient support for partial mode. */ 
</span>        <a href="planner.c.html#LN3522"><span class='Ref_To_Local'>try_parallel_aggregation</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Everything looks good. */ 
</span>        <a href="planner.c.html#LN3522"><span class='Ref_To_Local'>try_parallel_aggregation</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Before generating paths for grouped_rel, we first generate any possible 
     * partial paths; that way, later code can easily consider both parallel 
     * and non-parallel approaches to grouping.  Note that the partial paths 
     * we generate here are also partially aggregated, so simply pushing a 
     * Gather node on top is insufficient to create a final path, as would be 
     * the case for a scan/join rel. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3522"><span class='Ref_To_Local'>try_parallel_aggregation</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3707"></a>        <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>cheapest_partial_path</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3506"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN540"><span class='Ref_to_Member'>partial_pathlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Build target list for partial aggregate paths.  These paths cannot 
         * just emit the same tlist as regular aggregate paths, because (1) we 
         * must include Vars and Aggrefs needed in HAVING, which might not 
         * appear in the result tlist, and (2) the Aggrefs must be set in 
         * partial mode. 
         */ 
</span>        <a href="planner.c.html#LN3514"><span class='Ref_To_Local'>partial_grouping_target</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN172"><span class='Ref_to_Proto'>make_partial_grouping_target</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN3507"><span class='Ref_to_Parameter'>target</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Estimate number of partial groups. */ 
</span>        <a href="planner.c.html#LN3519"><span class='Ref_To_Local'>dNumPartialGroups</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN129"><span class='Ref_to_Proto'>get_number_of_groups</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                 <a href="planner.c.html#LN3707"><span class='Ref_To_Local'>cheapest_partial_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>, 
</span>                                                 <a href="planner.c.html#LN3509"><span class='Ref_to_Parameter'>gd</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Collect statistics about aggregates for estimating costs of 
         * performing aggregation in parallel. 
         */ 
</span>        <a href="../../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="planner.c.html#LN3515"><span class='Ref_To_Local'>agg_partial_costs</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN55"><span class='Ref_to_Struct'>AggClauseCosts</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="../../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="planner.c.html#LN3516"><span class='Ref_To_Local'>agg_final_costs</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN55"><span class='Ref_to_Struct'>AggClauseCosts</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN122"><span class='Ref_to_Member'>hasAggs</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* partial phase */ 
</span>            <a href="../../../include/optimizer/clauses.h.html#LN49"><span class='Ref_to_Proto'>get_agg_clause_costs</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN3514"><span class='Ref_To_Local'>partial_grouping_target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a><span class='Delimiter'>, 
</span>                                 <a href="../../../include/nodes/nodes.h.html#LN760"><span class='Ref_to_EnumConst'>AGGSPLIT_INITIAL_SERIAL</span></a><span class='Delimiter'>, 
</span>                                 <span class='Operator'>&</span><a href="planner.c.html#LN3515"><span class='Ref_To_Local'>agg_partial_costs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* final phase */ 
</span>            <a href="../../../include/optimizer/clauses.h.html#LN49"><span class='Ref_to_Proto'>get_agg_clause_costs</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN3507"><span class='Ref_to_Parameter'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a><span class='Delimiter'>, 
</span>                                 <a href="../../../include/nodes/nodes.h.html#LN762"><span class='Ref_to_EnumConst'>AGGSPLIT_FINAL_DESERIAL</span></a><span class='Delimiter'>, 
</span>                                 <span class='Operator'>&</span><a href="planner.c.html#LN3516"><span class='Ref_To_Local'>agg_final_costs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/optimizer/clauses.h.html#LN49"><span class='Ref_to_Proto'>get_agg_clause_costs</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a><span class='Delimiter'>, 
</span>                                 <a href="../../../include/nodes/nodes.h.html#LN762"><span class='Ref_to_EnumConst'>AGGSPLIT_FINAL_DESERIAL</span></a><span class='Delimiter'>, 
</span>                                 <span class='Operator'>&</span><a href="planner.c.html#LN3516"><span class='Ref_To_Local'>agg_final_costs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3521"><span class='Ref_To_Local'>can_sort</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* This was checked before setting try_parallel_aggregation */ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN122"><span class='Ref_to_Member'>hasAggs</span></a> <span class='Operator'>|| </span><a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Use any available suitably-sorted path as input, and also 
             * consider sorting the cheapest partial path. 
             */ 
</span>            <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3524"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN3506"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN540"><span class='Ref_to_Member'>partial_pathlist</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN3756"></a>                <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>path</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3524"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3757"></a>                <span class='Keyword'>bool</span>        <span class='Declare_Local'>is_sorted</span><span class='Delimiter'>; 
</span> 
                <a href="planner.c.html#LN3757"><span class='Ref_To_Local'>is_sorted</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/paths.h.html#LN183"><span class='Ref_to_Proto'>pathkeys_contained_in</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN263"><span class='Ref_to_Member'>group_pathkeys</span></a><span class='Delimiter'>, 
</span>                                                  <a href="planner.c.html#LN3756"><span class='Ref_To_Local'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN967"><span class='Ref_to_Member'>pathkeys</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3756"><span class='Ref_To_Local'>path</span></a> <span class='Operator'>== </span><a href="planner.c.html#LN3707"><span class='Ref_To_Local'>cheapest_partial_path</span></a> <span class='Operator'>|| </span><a href="planner.c.html#LN3757"><span class='Ref_To_Local'>is_sorted</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* Sort the cheapest partial path, if it isn't already */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="planner.c.html#LN3757"><span class='Ref_To_Local'>is_sorted</span></a><span class='Parentheses'>) 
</span>                        <a href="planner.c.html#LN3756"><span class='Ref_To_Local'>path</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/pathnode.h.html#LN165"><span class='Ref_to_Proto'>create_sort_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                         <a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Delimiter'>, 
</span>                                                         <a href="planner.c.html#LN3756"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, 
</span>                                                         <a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN263"><span class='Ref_to_Member'>group_pathkeys</span></a><span class='Delimiter'>, 
</span>                                                         <span class='Operator'>-</span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN122"><span class='Ref_to_Member'>hasAggs</span></a><span class='Parentheses'>) 
</span>                        <a href="../../../include/optimizer/pathnode.h.html#LN31"><span class='Ref_to_Proto'>add_partial_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                                         <a href="../../../include/optimizer/pathnode.h.html#LN182"><span class='Ref_to_Proto'>create_agg_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                         <a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Delimiter'>, 
</span>                                                         <a href="planner.c.html#LN3756"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, 
</span>                                                     <a href="planner.c.html#LN3514"><span class='Ref_To_Local'>partial_grouping_target</span></a><span class='Delimiter'>, 
</span>                                 <a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a> <span class='Operator'>? </span><a href="../../../include/nodes/nodes.h.html#LN736"><span class='Ref_to_EnumConst'>AGG_SORTED</span></a> <span class='Operator'>: </span><a href="../../../include/nodes/nodes.h.html#LN735"><span class='Ref_to_EnumConst'>AGG_PLAIN</span></a><span class='Delimiter'>, 
</span>                                                     <a href="../../../include/nodes/nodes.h.html#LN760"><span class='Ref_to_EnumConst'>AGGSPLIT_INITIAL_SERIAL</span></a><span class='Delimiter'>, 
</span>                                                         <a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Delimiter'>, 
</span>                                                         <a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>, 
</span>                                                         <span class='Operator'>&</span><a href="planner.c.html#LN3515"><span class='Ref_To_Local'>agg_partial_costs</span></a><span class='Delimiter'>, 
</span>                                                         <a href="planner.c.html#LN3519"><span class='Ref_To_Local'>dNumPartialGroups</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                    <span class='Control'>else</span> 
                        <a href="../../../include/optimizer/pathnode.h.html#LN31"><span class='Ref_to_Proto'>add_partial_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                                         <a href="../../../include/optimizer/pathnode.h.html#LN170"><span class='Ref_to_Proto'>create_group_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                           <a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Delimiter'>, 
</span>                                                           <a href="planner.c.html#LN3756"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, 
</span>                                                     <a href="planner.c.html#LN3514"><span class='Ref_To_Local'>partial_grouping_target</span></a><span class='Delimiter'>, 
</span>                                                           <a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Delimiter'>, 
</span>                                                           <a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>, 
</span>                                                         <a href="planner.c.html#LN3519"><span class='Ref_To_Local'>dNumPartialGroups</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if path==cheapest_partia... &raquo; </span> 
            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if can_sort &raquo; </span> 
 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3520"><span class='Ref_To_Local'>can_hash</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Checked above */ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN122"><span class='Ref_to_Member'>hasAggs</span></a> <span class='Operator'>|| </span><a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="planner.c.html#LN3517"><span class='Ref_To_Local'>hashaggtablesize</span></a> <span class='Operator'>= 
</span>                <a href="planner.c.html#LN132"><span class='Ref_to_Proto'>estimate_hashagg_tablesize</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3707"><span class='Ref_To_Local'>cheapest_partial_path</span></a><span class='Delimiter'>, 
</span>                                           <span class='Operator'>&</span><a href="planner.c.html#LN3515"><span class='Ref_To_Local'>agg_partial_costs</span></a><span class='Delimiter'>, 
</span>                                           <a href="planner.c.html#LN3519"><span class='Ref_To_Local'>dNumPartialGroups</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Tentatively produce a partial HashAgg Path, depending on if it 
             * looks as if the hash table will fit in work_mem. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3517"><span class='Ref_To_Local'>hashaggtablesize</span></a> <span class='Operator'>&LT; </span><a href="../../utils/init/globals.c.html#LN112"><span class='Ref_to_Global_Var'>work_mem</span></a> <span class='Operator'>* </span><span class='Number'>1024L</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="../../../include/optimizer/pathnode.h.html#LN31"><span class='Ref_to_Proto'>add_partial_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                                 <a href="../../../include/optimizer/pathnode.h.html#LN182"><span class='Ref_to_Proto'>create_agg_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                 <a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Delimiter'>, 
</span>                                                 <a href="planner.c.html#LN3707"><span class='Ref_To_Local'>cheapest_partial_path</span></a><span class='Delimiter'>, 
</span>                                                 <a href="planner.c.html#LN3514"><span class='Ref_To_Local'>partial_grouping_target</span></a><span class='Delimiter'>, 
</span>                                                 <a href="../../../include/nodes/nodes.h.html#LN737"><span class='Ref_to_EnumConst'>AGG_HASHED</span></a><span class='Delimiter'>, 
</span>                                                 <a href="../../../include/nodes/nodes.h.html#LN760"><span class='Ref_to_EnumConst'>AGGSPLIT_INITIAL_SERIAL</span></a><span class='Delimiter'>, 
</span>                                                 <a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Delimiter'>, 
</span>                                                 <a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>, 
</span>                                                 <span class='Operator'>&</span><a href="planner.c.html#LN3515"><span class='Ref_To_Local'>agg_partial_costs</span></a><span class='Delimiter'>, 
</span>                                                 <a href="planner.c.html#LN3519"><span class='Ref_To_Local'>dNumPartialGroups</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if can_hash &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if try_parallel_aggregat... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Build final grouping paths */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3521"><span class='Ref_To_Local'>can_sort</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Use any available suitably-sorted path as input, and also consider 
         * sorting the cheapest-total path. 
         */ 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3524"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN3506"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN538"><span class='Ref_to_Member'>pathlist</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN3836"></a>            <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>path</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3524"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3837"></a>            <span class='Keyword'>bool</span>        <span class='Declare_Local'>is_sorted</span><span class='Delimiter'>; 
</span> 
            <a href="planner.c.html#LN3837"><span class='Ref_To_Local'>is_sorted</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/paths.h.html#LN183"><span class='Ref_to_Proto'>pathkeys_contained_in</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN263"><span class='Ref_to_Member'>group_pathkeys</span></a><span class='Delimiter'>, 
</span>                                              <a href="planner.c.html#LN3836"><span class='Ref_To_Local'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN967"><span class='Ref_to_Member'>pathkeys</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3836"><span class='Ref_To_Local'>path</span></a> <span class='Operator'>== </span><a href="planner.c.html#LN3512"><span class='Ref_To_Local'>cheapest_path</span></a> <span class='Operator'>|| </span><a href="planner.c.html#LN3837"><span class='Ref_To_Local'>is_sorted</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Sort the cheapest-total path if it isn't already sorted */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="planner.c.html#LN3837"><span class='Ref_To_Local'>is_sorted</span></a><span class='Parentheses'>) 
</span>                    <a href="planner.c.html#LN3836"><span class='Ref_To_Local'>path</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/pathnode.h.html#LN165"><span class='Ref_to_Proto'>create_sort_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                     <a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Delimiter'>, 
</span>                                                     <a href="planner.c.html#LN3836"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, 
</span>                                                     <a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN263"><span class='Ref_to_Member'>group_pathkeys</span></a><span class='Delimiter'>, 
</span>                                                     <span class='Operator'>-</span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* Now decide what to stick atop it */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN147"><span class='Ref_to_Member'>groupingSets</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <a href="planner.c.html#LN140"><span class='Ref_to_Proto'>consider_groupingsets_paths</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Delimiter'>, 
</span>                                                <a href="planner.c.html#LN3836"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><a href="planner.c.html#LN3520"><span class='Ref_To_Local'>can_hash</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN3507"><span class='Ref_to_Parameter'>target</span></a><span class='Delimiter'>, 
</span>                                                <a href="planner.c.html#LN3509"><span class='Ref_to_Parameter'>gd</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN3508"><span class='Ref_to_Parameter'>agg_costs</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN3518"><span class='Ref_To_Local'>dNumGroups</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN122"><span class='Ref_to_Member'>hasAggs</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* 
                     * We have aggregation, possibly with plain GROUP BY. Make 
                     * an AggPath. 
                     */ 
</span>                    <a href="../../../include/optimizer/pathnode.h.html#LN27"><span class='Ref_to_Proto'>add_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> 
                             <a href="../../../include/optimizer/pathnode.h.html#LN182"><span class='Ref_to_Proto'>create_agg_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                             <a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Delimiter'>, 
</span>                                             <a href="planner.c.html#LN3836"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, 
</span>                                             <a href="planner.c.html#LN3507"><span class='Ref_to_Parameter'>target</span></a><span class='Delimiter'>, 
</span>                                 <a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a> <span class='Operator'>? </span><a href="../../../include/nodes/nodes.h.html#LN736"><span class='Ref_to_EnumConst'>AGG_SORTED</span></a> <span class='Operator'>: </span><a href="../../../include/nodes/nodes.h.html#LN735"><span class='Ref_to_EnumConst'>AGG_PLAIN</span></a><span class='Delimiter'>, 
</span>                                             <a href="../../../include/nodes/nodes.h.html#LN758"><span class='Ref_to_EnumConst'>AGGSPLIT_SIMPLE</span></a><span class='Delimiter'>, 
</span>                                             <a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Delimiter'>, 
</span>                                             <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a><span class='Delimiter'>, 
</span>                                             <a href="planner.c.html#LN3508"><span class='Ref_to_Parameter'>agg_costs</span></a><span class='Delimiter'>, 
</span>                                             <a href="planner.c.html#LN3518"><span class='Ref_To_Local'>dNumGroups</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* 
                     * We have GROUP BY without aggregation or grouping sets. 
                     * Make a GroupPath. 
                     */ 
</span>                    <a href="../../../include/optimizer/pathnode.h.html#LN27"><span class='Ref_to_Proto'>add_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> 
                             <a href="../../../include/optimizer/pathnode.h.html#LN170"><span class='Ref_to_Proto'>create_group_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                               <a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Delimiter'>, 
</span>                                               <a href="planner.c.html#LN3836"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, 
</span>                                               <a href="planner.c.html#LN3507"><span class='Ref_to_Parameter'>target</span></a><span class='Delimiter'>, 
</span>                                               <a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Delimiter'>, 
</span>                                               <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a><span class='Delimiter'>, 
</span>                                               <a href="planner.c.html#LN3518"><span class='Ref_To_Local'>dNumGroups</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>else</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* Other cases should have been handled above */ 
</span>                    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if path==cheapest_path||... &raquo; </span> 
        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Now generate a complete GroupAgg Path atop of the cheapest partial 
         * path.  We can do this using either Gather or Gather Merge. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN540"><span class='Ref_to_Member'>partial_pathlist</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN3905"></a>            <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>path</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN540"><span class='Ref_to_Member'>partial_pathlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3906"></a>            <span class='Keyword'>double</span>      <span class='Declare_Local'>total_groups</span> <span class='Operator'>= </span><a href="planner.c.html#LN3905"><span class='Ref_To_Local'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>* </span><a href="planner.c.html#LN3905"><span class='Ref_To_Local'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN959"><span class='Ref_to_Member'>parallel_workers</span></a><span class='Delimiter'>; 
</span> 
            <a href="planner.c.html#LN3905"><span class='Ref_To_Local'>path</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/pathnode.h.html#LN79"><span class='Ref_to_Proto'>create_gather_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                               <a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Delimiter'>, 
</span>                                               <a href="planner.c.html#LN3905"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, 
</span>                                               <a href="planner.c.html#LN3514"><span class='Ref_To_Local'>partial_grouping_target</span></a><span class='Delimiter'>, 
</span>                                               <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                               <span class='Operator'>&</span><a href="planner.c.html#LN3906"><span class='Ref_To_Local'>total_groups</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Since Gather's output is always unsorted, we'll need to sort, 
             * unless there's no GROUP BY clause or a degenerate (constant) 
             * one, in which case there will only be a single group. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN263"><span class='Ref_to_Member'>group_pathkeys</span></a><span class='Parentheses'>) 
</span>                <a href="planner.c.html#LN3905"><span class='Ref_To_Local'>path</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/pathnode.h.html#LN165"><span class='Ref_to_Proto'>create_sort_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                 <a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Delimiter'>, 
</span>                                                 <a href="planner.c.html#LN3905"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, 
</span>                                                 <a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN263"><span class='Ref_to_Member'>group_pathkeys</span></a><span class='Delimiter'>, 
</span>                                                 <span class='Operator'>-</span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN122"><span class='Ref_to_Member'>hasAggs</span></a><span class='Parentheses'>) 
</span>                <a href="../../../include/optimizer/pathnode.h.html#LN27"><span class='Ref_to_Proto'>add_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> 
                         <a href="../../../include/optimizer/pathnode.h.html#LN182"><span class='Ref_to_Proto'>create_agg_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                         <a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Delimiter'>, 
</span>                                         <a href="planner.c.html#LN3905"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, 
</span>                                         <a href="planner.c.html#LN3507"><span class='Ref_to_Parameter'>target</span></a><span class='Delimiter'>, 
</span>                                 <a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a> <span class='Operator'>? </span><a href="../../../include/nodes/nodes.h.html#LN736"><span class='Ref_to_EnumConst'>AGG_SORTED</span></a> <span class='Operator'>: </span><a href="../../../include/nodes/nodes.h.html#LN735"><span class='Ref_to_EnumConst'>AGG_PLAIN</span></a><span class='Delimiter'>, 
</span>                                         <a href="../../../include/nodes/nodes.h.html#LN762"><span class='Ref_to_EnumConst'>AGGSPLIT_FINAL_DESERIAL</span></a><span class='Delimiter'>, 
</span>                                         <a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Delimiter'>, 
</span>                                         <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a><span class='Delimiter'>, 
</span>                                         <span class='Operator'>&</span><a href="planner.c.html#LN3516"><span class='Ref_To_Local'>agg_final_costs</span></a><span class='Delimiter'>, 
</span>                                         <a href="planner.c.html#LN3518"><span class='Ref_To_Local'>dNumGroups</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="../../../include/optimizer/pathnode.h.html#LN27"><span class='Ref_to_Proto'>add_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> 
                         <a href="../../../include/optimizer/pathnode.h.html#LN170"><span class='Ref_to_Proto'>create_group_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                           <a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Delimiter'>, 
</span>                                           <a href="planner.c.html#LN3905"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, 
</span>                                           <a href="planner.c.html#LN3507"><span class='Ref_to_Parameter'>target</span></a><span class='Delimiter'>, 
</span>                                           <a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Delimiter'>, 
</span>                                           <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a><span class='Delimiter'>, 
</span>                                           <a href="planner.c.html#LN3518"><span class='Ref_To_Local'>dNumGroups</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * The point of using Gather Merge rather than Gather is that it 
             * can preserve the ordering of the input path, so there's no 
             * reason to try it unless (1) it's possible to produce more than 
             * one output row and (2) we want the output path to be ordered. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>&& </span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN263"><span class='Ref_to_Member'>group_pathkeys</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3524"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN540"><span class='Ref_to_Member'>partial_pathlist</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN3959"></a>                    <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>subpath</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3524"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3960"></a>                    <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>gmpath</span><span class='Delimiter'>; 
</span><a name="LN3961"></a>                    <span class='Keyword'>double</span>      <span class='Declare_Local'>total_groups</span><span class='Delimiter'>; 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * It's useful to consider paths that are already properly 
                     * ordered for Gather Merge, because those don't need a 
                     * sort.  It's also useful to consider the cheapest path, 
                     * because sorting it in parallel and then doing Gather 
                     * Merge may be better than doing an unordered Gather 
                     * followed by a sort.  But there's no point in 
                     * considering non-cheapest paths that aren't already 
                     * sorted correctly. 
                     */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3905"><span class='Ref_To_Local'>path</span></a> <span class='Operator'>!= </span><a href="planner.c.html#LN3959"><span class='Ref_To_Local'>subpath</span></a> <span class='Operator'>&& 
</span>                        <span class='Operator'>!</span><a href="../../../include/optimizer/paths.h.html#LN183"><span class='Ref_to_Proto'>pathkeys_contained_in</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN263"><span class='Ref_to_Member'>group_pathkeys</span></a><span class='Delimiter'>, 
</span>                                               <a href="planner.c.html#LN3959"><span class='Ref_To_Local'>subpath</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN967"><span class='Ref_to_Member'>pathkeys</span></a><span class='Parentheses'>))</span> 
                        <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
                    <a href="planner.c.html#LN3961"><span class='Ref_To_Local'>total_groups</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN3959"><span class='Ref_To_Local'>subpath</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>* </span><a href="planner.c.html#LN3959"><span class='Ref_To_Local'>subpath</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN959"><span class='Ref_to_Member'>parallel_workers</span></a><span class='Delimiter'>; 
</span> 
                    <a href="planner.c.html#LN3960"><span class='Ref_To_Local'>gmpath</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                        <a href="../../../include/optimizer/pathnode.h.html#LN82"><span class='Ref_to_Proto'>create_gather_merge_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                 <a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Delimiter'>, 
</span>                                                 <a href="planner.c.html#LN3959"><span class='Ref_To_Local'>subpath</span></a><span class='Delimiter'>, 
</span>                                                 <a href="planner.c.html#LN3514"><span class='Ref_To_Local'>partial_grouping_target</span></a><span class='Delimiter'>, 
</span>                                                 <a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN263"><span class='Ref_to_Member'>group_pathkeys</span></a><span class='Delimiter'>, 
</span>                                                 <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                                 <span class='Operator'>&</span><a href="planner.c.html#LN3961"><span class='Ref_To_Local'>total_groups</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN122"><span class='Ref_to_Member'>hasAggs</span></a><span class='Parentheses'>) 
</span>                        <a href="../../../include/optimizer/pathnode.h.html#LN27"><span class='Ref_to_Proto'>add_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> 
                                 <a href="../../../include/optimizer/pathnode.h.html#LN182"><span class='Ref_to_Proto'>create_agg_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                 <a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Delimiter'>, 
</span>                                                 <a href="planner.c.html#LN3960"><span class='Ref_To_Local'>gmpath</span></a><span class='Delimiter'>, 
</span>                                                 <a href="planner.c.html#LN3507"><span class='Ref_to_Parameter'>target</span></a><span class='Delimiter'>, 
</span>                                 <a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a> <span class='Operator'>? </span><a href="../../../include/nodes/nodes.h.html#LN736"><span class='Ref_to_EnumConst'>AGG_SORTED</span></a> <span class='Operator'>: </span><a href="../../../include/nodes/nodes.h.html#LN735"><span class='Ref_to_EnumConst'>AGG_PLAIN</span></a><span class='Delimiter'>, 
</span>                                                 <a href="../../../include/nodes/nodes.h.html#LN762"><span class='Ref_to_EnumConst'>AGGSPLIT_FINAL_DESERIAL</span></a><span class='Delimiter'>, 
</span>                                                 <a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Delimiter'>, 
</span>                                                 <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a><span class='Delimiter'>, 
</span>                                                 <span class='Operator'>&</span><a href="planner.c.html#LN3516"><span class='Ref_To_Local'>agg_final_costs</span></a><span class='Delimiter'>, 
</span>                                                 <a href="planner.c.html#LN3518"><span class='Ref_To_Local'>dNumGroups</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                    <span class='Control'>else</span> 
                        <a href="../../../include/optimizer/pathnode.h.html#LN27"><span class='Ref_to_Proto'>add_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> 
                                 <a href="../../../include/optimizer/pathnode.h.html#LN170"><span class='Ref_to_Proto'>create_group_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                   <a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Delimiter'>, 
</span>                                                   <a href="planner.c.html#LN3960"><span class='Ref_To_Local'>gmpath</span></a><span class='Delimiter'>, 
</span>                                                   <a href="planner.c.html#LN3507"><span class='Ref_to_Parameter'>target</span></a><span class='Delimiter'>, 
</span>                                                   <a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Delimiter'>, 
</span>                                                   <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a><span class='Delimiter'>, 
</span>                                                   <a href="planner.c.html#LN3518"><span class='Ref_To_Local'>dNumGroups</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if parse-&GT;groupClause!=N... &raquo; </span> 
        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if grouped_rel-&GT;partial_... &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if can_sort &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3520"><span class='Ref_To_Local'>can_hash</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN147"><span class='Ref_to_Member'>groupingSets</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Try for a hash-only groupingsets path over unsorted input. 
             */ 
</span>            <a href="planner.c.html#LN140"><span class='Ref_to_Proto'>consider_groupingsets_paths</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Delimiter'>, 
</span>                                        <a href="planner.c.html#LN3512"><span class='Ref_To_Local'>cheapest_path</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><a href="planner.c.html#LN3507"><span class='Ref_to_Parameter'>target</span></a><span class='Delimiter'>, 
</span>                                        <a href="planner.c.html#LN3509"><span class='Ref_to_Parameter'>gd</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN3508"><span class='Ref_to_Parameter'>agg_costs</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN3518"><span class='Ref_To_Local'>dNumGroups</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="planner.c.html#LN3517"><span class='Ref_To_Local'>hashaggtablesize</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN132"><span class='Ref_to_Proto'>estimate_hashagg_tablesize</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3512"><span class='Ref_To_Local'>cheapest_path</span></a><span class='Delimiter'>, 
</span>                                                          <a href="planner.c.html#LN3508"><span class='Ref_to_Parameter'>agg_costs</span></a><span class='Delimiter'>, 
</span>                                                          <a href="planner.c.html#LN3518"><span class='Ref_To_Local'>dNumGroups</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Provided that the estimated size of the hashtable does not 
             * exceed work_mem, we'll generate a HashAgg Path, although if we 
             * were unable to sort above, then we'd better generate a Path, so 
             * that we at least have one. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3517"><span class='Ref_To_Local'>hashaggtablesize</span></a> <span class='Operator'>&LT; </span><a href="../../utils/init/globals.c.html#LN112"><span class='Ref_to_Global_Var'>work_mem</span></a> <span class='Operator'>* </span><span class='Number'>1024L</span> <span class='Operator'>|| 
</span>                <a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN538"><span class='Ref_to_Member'>pathlist</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * We just need an Agg over the cheapest-total input path, 
                 * since input order won't matter. 
                 */ 
</span>                <a href="../../../include/optimizer/pathnode.h.html#LN27"><span class='Ref_to_Proto'>add_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> 
                         <a href="../../../include/optimizer/pathnode.h.html#LN182"><span class='Ref_to_Proto'>create_agg_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Delimiter'>, 
</span>                                         <a href="planner.c.html#LN3512"><span class='Ref_To_Local'>cheapest_path</span></a><span class='Delimiter'>, 
</span>                                         <a href="planner.c.html#LN3507"><span class='Ref_to_Parameter'>target</span></a><span class='Delimiter'>, 
</span>                                         <a href="../../../include/nodes/nodes.h.html#LN737"><span class='Ref_to_EnumConst'>AGG_HASHED</span></a><span class='Delimiter'>, 
</span>                                         <a href="../../../include/nodes/nodes.h.html#LN758"><span class='Ref_to_EnumConst'>AGGSPLIT_SIMPLE</span></a><span class='Delimiter'>, 
</span>                                         <a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Delimiter'>, 
</span>                                         <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a><span class='Delimiter'>, 
</span>                                         <a href="planner.c.html#LN3508"><span class='Ref_to_Parameter'>agg_costs</span></a><span class='Delimiter'>, 
</span>                                         <a href="planner.c.html#LN3518"><span class='Ref_To_Local'>dNumGroups</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* 
         * Generate a HashAgg Path atop of the cheapest partial path. Once 
         * again, we'll only do this if it looks as though the hash table 
         * won't exceed work_mem. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN540"><span class='Ref_to_Member'>partial_pathlist</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN4065"></a>            <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>path</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN540"><span class='Ref_to_Member'>partial_pathlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="planner.c.html#LN3517"><span class='Ref_To_Local'>hashaggtablesize</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN132"><span class='Ref_to_Proto'>estimate_hashagg_tablesize</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4065"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, 
</span>                                                          <span class='Operator'>&</span><a href="planner.c.html#LN3516"><span class='Ref_To_Local'>agg_final_costs</span></a><span class='Delimiter'>, 
</span>                                                          <a href="planner.c.html#LN3518"><span class='Ref_To_Local'>dNumGroups</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3517"><span class='Ref_To_Local'>hashaggtablesize</span></a> <span class='Operator'>&LT; </span><a href="../../utils/init/globals.c.html#LN112"><span class='Ref_to_Global_Var'>work_mem</span></a> <span class='Operator'>* </span><span class='Number'>1024L</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN4073"></a>                <span class='Keyword'>double</span>      <span class='Declare_Local'>total_groups</span> <span class='Operator'>= </span><a href="planner.c.html#LN4065"><span class='Ref_To_Local'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>* </span><a href="planner.c.html#LN4065"><span class='Ref_To_Local'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN959"><span class='Ref_to_Member'>parallel_workers</span></a><span class='Delimiter'>; 
</span> 
                <a href="planner.c.html#LN4065"><span class='Ref_To_Local'>path</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/pathnode.h.html#LN79"><span class='Ref_to_Proto'>create_gather_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                   <a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Delimiter'>, 
</span>                                                   <a href="planner.c.html#LN4065"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, 
</span>                                                   <a href="planner.c.html#LN3514"><span class='Ref_To_Local'>partial_grouping_target</span></a><span class='Delimiter'>, 
</span>                                                   <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                                   <span class='Operator'>&</span><a href="planner.c.html#LN4073"><span class='Ref_To_Local'>total_groups</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="../../../include/optimizer/pathnode.h.html#LN27"><span class='Ref_to_Proto'>add_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> 
                         <a href="../../../include/optimizer/pathnode.h.html#LN182"><span class='Ref_to_Proto'>create_agg_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                         <a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Delimiter'>, 
</span>                                         <a href="planner.c.html#LN4065"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, 
</span>                                         <a href="planner.c.html#LN3507"><span class='Ref_to_Parameter'>target</span></a><span class='Delimiter'>, 
</span>                                         <a href="../../../include/nodes/nodes.h.html#LN737"><span class='Ref_to_EnumConst'>AGG_HASHED</span></a><span class='Delimiter'>, 
</span>                                         <a href="../../../include/nodes/nodes.h.html#LN762"><span class='Ref_to_EnumConst'>AGGSPLIT_FINAL_DESERIAL</span></a><span class='Delimiter'>, 
</span>                                         <a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Delimiter'>, 
</span>                                         <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN3511"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a><span class='Delimiter'>, 
</span>                                         <span class='Operator'>&</span><a href="planner.c.html#LN3516"><span class='Ref_To_Local'>agg_final_costs</span></a><span class='Delimiter'>, 
</span>                                         <a href="planner.c.html#LN3518"><span class='Ref_To_Local'>dNumGroups</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if hashaggtablesize&LT;work... &raquo; </span> 
        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if grouped_rel-&GT;partial_... &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if can_hash &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Give a helpful error if we failed to find any implementation */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN538"><span class='Ref_to_Member'>pathlist</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not implement GROUP BY"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"Some of the datatypes only support hashing, while others only support sorting."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If there is an FDW that's responsible for all baserels of the query, 
     * let it consider adding ForeignPaths. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN575"><span class='Ref_to_Member'>fdwroutine</span></a> <span class='Operator'>&& 
</span>        <a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN575"><span class='Ref_to_Member'>fdwroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/foreign/fdwapi.h.html#LN190"><span class='Ref_to_Member'>GetForeignUpperPaths</span></a><span class='Parentheses'>) 
</span>        <a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN575"><span class='Ref_to_Member'>fdwroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/foreign/fdwapi.h.html#LN190"><span class='Ref_to_Member'>GetForeignUpperPaths</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN73"><span class='Ref_to_EnumConst'>UPPERREL_GROUP_AGG</span></a><span class='Delimiter'>, 
</span>                                                      <a href="planner.c.html#LN3506"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Let extensions possibly add some more paths */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN68"><span class='Ref_to_Global_Var'>create_upper_paths_hook</span></a><span class='Parentheses'>) 
</span>        <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="planner.c.html#LN68"><span class='Ref_to_Global_Var'>create_upper_paths_hook</span></a><span class='Parentheses'>) (</span><a href="planner.c.html#LN3505"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN73"><span class='Ref_to_EnumConst'>UPPERREL_GROUP_AGG</span></a><span class='Delimiter'>, 
</span>                                    <a href="planner.c.html#LN3506"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Now choose the best path(s) */ 
</span>    <a href="../../../include/optimizer/pathnode.h.html#LN26"><span class='Ref_to_Proto'>set_cheapest</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We've been using the partial pathlist for the grouped relation to hold 
     * partially aggregated paths, but that's actually a little bit bogus 
     * because it's unsafe for later planning stages -- like ordered_rel --- 
     * to get the idea that they can use these partial paths as if they didn't 
     * need a FinalizeAggregate step.  Zap the partial pathlist at this stage 
     * so we don't get confused. 
     */ 
</span>    <a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN540"><span class='Ref_to_Member'>partial_pathlist</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="planner.c.html#LN3513"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end create_grouping_paths &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * For a given input path, consider the possible ways of doing grouping sets on 
 * it, by combinations of hashing and sorting.  This can be called multiple 
 * times, so it's important that it not scribble on input.  No result is 
 * returned, but any generated paths are added to grouped_rel. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN4142"></a><span class='Declare_Function'>consider_groupingsets_paths</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN4143"></a>                            <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>grouped_rel</span><span class='Delimiter'>, 
</span><a name="LN4144"></a>                            <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, 
</span><a name="LN4145"></a>                            <span class='Keyword'>bool </span><span class='Declare_Parameter'>is_sorted</span><span class='Delimiter'>, 
</span><a name="LN4146"></a>                            <span class='Keyword'>bool </span><span class='Declare_Parameter'>can_hash</span><span class='Delimiter'>, 
</span><a name="LN4147"></a>                            <a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>target</span><span class='Delimiter'>, 
</span><a name="LN4148"></a>                            <a href="planner.c.html#LN98"><span class='Ref_to_Typedef'>grouping_sets_data</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>gd</span><span class='Delimiter'>, 
</span><a name="LN4149"></a>                            <span class='Keyword'>const </span><a href="../../../include/nodes/relation.h.html#LN55"><span class='Ref_to_Struct'>AggClauseCosts</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>agg_costs</span><span class='Delimiter'>, 
</span><a name="LN4150"></a>                            <span class='Keyword'>double </span><span class='Declare_Parameter'>dNumGroups</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4152"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>parse</span> <span class='Operator'>= </span><a href="planner.c.html#LN4142"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we're not being offered sorted input, then only consider plans that 
     * can be done entirely by hashing. 
     * 
     * We can hash everything if it looks like it'll fit in work_mem. But if 
     * the input is actually sorted despite not being advertised as such, we 
     * prefer to make use of that in order to use less memory. 
     * 
     * If none of the grouping sets are sortable, then ignore the work_mem 
     * limit and generate a path anyway, since otherwise we'll just fail. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="planner.c.html#LN4145"><span class='Ref_to_Parameter'>is_sorted</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN4167"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>new_rollups</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN4168"></a>        <a href="../../../include/nodes/relation.h.html#LN1478"><span class='Ref_to_Struct'>RollupData</span></a> <span class='Operator'>*</span><span class='Declare_Local'>unhashed_rollup</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN4169"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>sets_data</span><span class='Delimiter'>; 
</span><a name="LN4170"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>empty_sets_data</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN4171"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>empty_sets</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN4172"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span><a name="LN4173"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l_start</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4148"><span class='Ref_to_Parameter'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN100"><span class='Ref_to_Member'>rollups</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN4174"></a>        <a href="../../../include/nodes/nodes.h.html#LN733"><span class='Ref_to_Enum'>AggStrategy</span></a> <span class='Declare_Local'>strat</span> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN737"><span class='Ref_to_EnumConst'>AGG_HASHED</span></a><span class='Delimiter'>; 
</span><a name="LN4175"></a>        <a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Local'>hashsize</span><span class='Delimiter'>; 
</span><a name="LN4176"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>exclude_groups</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="planner.c.html#LN4146"><span class='Ref_to_Parameter'>can_hash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/paths.h.html#LN183"><span class='Ref_to_Proto'>pathkeys_contained_in</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4142"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN263"><span class='Ref_to_Member'>group_pathkeys</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4144"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN967"><span class='Ref_to_Member'>pathkeys</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="planner.c.html#LN4168"><span class='Ref_To_Local'>unhashed_rollup</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4173"><span class='Ref_To_Local'>l_start</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="planner.c.html#LN4176"><span class='Ref_To_Local'>exclude_groups</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN4168"><span class='Ref_To_Local'>unhashed_rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1484"><span class='Ref_to_Member'>numGroups</span></a><span class='Delimiter'>; 
</span>            <a href="planner.c.html#LN4173"><span class='Ref_To_Local'>l_start</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4173"><span class='Ref_To_Local'>l_start</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="planner.c.html#LN4175"><span class='Ref_To_Local'>hashsize</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN132"><span class='Ref_to_Proto'>estimate_hashagg_tablesize</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4144"><span class='Ref_to_Parameter'>path</span></a><span class='Delimiter'>, 
</span>                                              <a href="planner.c.html#LN4149"><span class='Ref_to_Parameter'>agg_costs</span></a><span class='Delimiter'>, 
</span>                                              <a href="planner.c.html#LN4150"><span class='Ref_to_Parameter'>dNumGroups</span></a> <span class='Operator'>- </span><a href="planner.c.html#LN4176"><span class='Ref_To_Local'>exclude_groups</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * gd-&GT;rollups is empty if we have only unsortable columns to work 
         * with.  Override work_mem in that case; otherwise, we'll rely on the 
         * sorted-input case to generate usable mixed paths. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN4175"><span class='Ref_To_Local'>hashsize</span></a> <span class='Operator'>&GT; </span><a href="../../utils/init/globals.c.html#LN112"><span class='Ref_to_Global_Var'>work_mem</span></a> <span class='Operator'>* </span><span class='Number'>1024L</span> <span class='Operator'>&& </span><a href="planner.c.html#LN4148"><span class='Ref_to_Parameter'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN100"><span class='Ref_to_Member'>rollups</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* nope, won't fit */ 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We need to burst the existing rollups list into individual grouping 
         * sets and recompute a groupClause for each set. 
         */ 
</span>        <a href="planner.c.html#LN4169"><span class='Ref_To_Local'>sets_data</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN268"><span class='Ref_to_Proto'>list_copy</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4148"><span class='Ref_to_Parameter'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN106"><span class='Ref_to_Member'>unsortable_sets</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/nodes/pg_list.h.html#LN168"><span class='Ref_to_Macro'>for_each_cell</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4172"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4173"><span class='Ref_To_Local'>l_start</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN4207"></a>            <a href="../../../include/nodes/relation.h.html#LN1478"><span class='Ref_to_Struct'>RollupData</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rollup</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4172"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * If we find an unhashable rollup that's not been skipped by the 
             * "actually sorted" check above, we can't cope; we'd need sorted 
             * input (with a different sort order) but we can't get that here. 
             * So bail out; we'll get a valid path from the is_sorted case 
             * instead. 
             * 
             * The mere presence of empty grouping sets doesn't make a rollup 
             * unhashable (see preprocess_grouping_sets), we handle those 
             * specially below. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="planner.c.html#LN4207"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1485"><span class='Ref_to_Member'>hashable</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>return</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="planner.c.html#LN4169"><span class='Ref_To_Local'>sets_data</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4169"><span class='Ref_To_Local'>sets_data</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN268"><span class='Ref_to_Proto'>list_copy</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4207"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1483"><span class='Ref_to_Member'>gsets_data</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4172"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4169"><span class='Ref_To_Local'>sets_data</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN4227"></a>            <a href="../../../include/nodes/relation.h.html#LN1471"><span class='Ref_to_Struct'>GroupingSetData</span></a> <span class='Operator'>*</span><span class='Declare_Local'>gs</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4172"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN4228"></a>            <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>gset</span> <span class='Operator'>= </span><a href="planner.c.html#LN4227"><span class='Ref_To_Local'>gs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1474"><span class='Ref_to_Member'>set</span></a><span class='Delimiter'>; 
</span><a name="LN4229"></a>            <a href="../../../include/nodes/relation.h.html#LN1478"><span class='Ref_to_Struct'>RollupData</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rollup</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN4228"><span class='Ref_To_Local'>gset</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Empty grouping sets can't be hashed. */ 
</span>                <a href="planner.c.html#LN4170"><span class='Ref_To_Local'>empty_sets_data</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4170"><span class='Ref_To_Local'>empty_sets_data</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4227"><span class='Ref_To_Local'>gs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="planner.c.html#LN4171"><span class='Ref_To_Local'>empty_sets</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4171"><span class='Ref_To_Local'>empty_sets</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <a href="planner.c.html#LN4229"><span class='Ref_To_Local'>rollup</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1478"><span class='Ref_to_Struct'>RollupData</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="planner.c.html#LN4229"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1481"><span class='Ref_to_Member'>groupClause</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN125"><span class='Ref_to_Proto'>preprocess_groupclause</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4142"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4228"><span class='Ref_To_Local'>gset</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="planner.c.html#LN4229"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1483"><span class='Ref_to_Member'>gsets_data</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4227"><span class='Ref_To_Local'>gs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="planner.c.html#LN4229"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1482"><span class='Ref_to_Member'>gsets</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN117"><span class='Ref_to_Proto'>remap_to_groupclause_idx</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4229"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1481"><span class='Ref_to_Member'>groupClause</span></a><span class='Delimiter'>, 
</span>                                                         <a href="planner.c.html#LN4229"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1483"><span class='Ref_to_Member'>gsets_data</span></a><span class='Delimiter'>, 
</span>                                                   <a href="planner.c.html#LN4148"><span class='Ref_to_Parameter'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN107"><span class='Ref_to_Member'>tleref_to_colnum_map</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="planner.c.html#LN4229"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1484"><span class='Ref_to_Member'>numGroups</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN4227"><span class='Ref_To_Local'>gs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1475"><span class='Ref_to_Member'>numGroups</span></a><span class='Delimiter'>; 
</span>                <a href="planner.c.html#LN4229"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1485"><span class='Ref_to_Member'>hashable</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <a href="planner.c.html#LN4229"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1486"><span class='Ref_to_Member'>is_hashed</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <a href="planner.c.html#LN4167"><span class='Ref_To_Local'>new_rollups</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4167"><span class='Ref_To_Local'>new_rollups</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4229"><span class='Ref_To_Local'>rollup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If we didn't find anything nonempty to hash, then bail.  We'll 
         * generate a path from the is_sorted case. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN4167"><span class='Ref_To_Local'>new_rollups</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If there were empty grouping sets they should have been in the 
         * first rollup. 
         */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="planner.c.html#LN4168"><span class='Ref_To_Local'>unhashed_rollup</span></a> <span class='Operator'>|| !</span><a href="planner.c.html#LN4171"><span class='Ref_To_Local'>empty_sets</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN4168"><span class='Ref_To_Local'>unhashed_rollup</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="planner.c.html#LN4167"><span class='Ref_To_Local'>new_rollups</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4167"><span class='Ref_To_Local'>new_rollups</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4168"><span class='Ref_To_Local'>unhashed_rollup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="planner.c.html#LN4174"><span class='Ref_To_Local'>strat</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN738"><span class='Ref_to_EnumConst'>AGG_MIXED</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN4171"><span class='Ref_To_Local'>empty_sets</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN4273"></a>            <a href="../../../include/nodes/relation.h.html#LN1478"><span class='Ref_to_Struct'>RollupData</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rollup</span> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1478"><span class='Ref_to_Struct'>RollupData</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="planner.c.html#LN4273"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1481"><span class='Ref_to_Member'>groupClause</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>            <a href="planner.c.html#LN4273"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1483"><span class='Ref_to_Member'>gsets_data</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN4170"><span class='Ref_To_Local'>empty_sets_data</span></a><span class='Delimiter'>; 
</span>            <a href="planner.c.html#LN4273"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1482"><span class='Ref_to_Member'>gsets</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN4171"><span class='Ref_To_Local'>empty_sets</span></a><span class='Delimiter'>; 
</span>            <a href="planner.c.html#LN4273"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1484"><span class='Ref_to_Member'>numGroups</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4171"><span class='Ref_To_Local'>empty_sets</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="planner.c.html#LN4273"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1485"><span class='Ref_to_Member'>hashable</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="planner.c.html#LN4273"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1486"><span class='Ref_to_Member'>is_hashed</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="planner.c.html#LN4167"><span class='Ref_To_Local'>new_rollups</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4167"><span class='Ref_To_Local'>new_rollups</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4273"><span class='Ref_To_Local'>rollup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="planner.c.html#LN4174"><span class='Ref_To_Local'>strat</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN738"><span class='Ref_to_EnumConst'>AGG_MIXED</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="../../../include/optimizer/pathnode.h.html#LN27"><span class='Ref_to_Proto'>add_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4143"><span class='Ref_to_Parameter'>grouped_rel</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> 
                 <a href="../../../include/optimizer/pathnode.h.html#LN192"><span class='Ref_to_Proto'>create_groupingsets_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4142"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                          <a href="planner.c.html#LN4143"><span class='Ref_to_Parameter'>grouped_rel</span></a><span class='Delimiter'>, 
</span>                                          <a href="planner.c.html#LN4144"><span class='Ref_to_Parameter'>path</span></a><span class='Delimiter'>, 
</span>                                          <a href="planner.c.html#LN4147"><span class='Ref_to_Parameter'>target</span></a><span class='Delimiter'>, 
</span>                                          <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN4152"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a><span class='Delimiter'>, 
</span>                                          <a href="planner.c.html#LN4174"><span class='Ref_To_Local'>strat</span></a><span class='Delimiter'>, 
</span>                                          <a href="planner.c.html#LN4167"><span class='Ref_To_Local'>new_rollups</span></a><span class='Delimiter'>, 
</span>                                          <a href="planner.c.html#LN4149"><span class='Ref_to_Parameter'>agg_costs</span></a><span class='Delimiter'>, 
</span>                                          <a href="planner.c.html#LN4150"><span class='Ref_to_Parameter'>dNumGroups</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !is_sorted &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * If we have sorted input but nothing we can do with it, bail. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4148"><span class='Ref_to_Parameter'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN100"><span class='Ref_to_Member'>rollups</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Given sorted input, we try and make two paths: one sorted and one mixed 
     * sort/hash. (We need to try both because hashagg might be disabled, or 
     * some columns might not be sortable.) 
     * 
     * can_hash is passed in as false if some obstacle elsewhere (such as 
     * ordered aggs) means that we shouldn't consider hashing at all. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN4146"><span class='Ref_to_Parameter'>can_hash</span></a> <span class='Operator'>&& </span><a href="planner.c.html#LN4148"><span class='Ref_to_Parameter'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN103"><span class='Ref_to_Member'>any_hashable</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN4314"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>rollups</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN4315"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>hash_sets</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN268"><span class='Ref_to_Proto'>list_copy</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4148"><span class='Ref_to_Parameter'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN106"><span class='Ref_to_Member'>unsortable_sets</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN4316"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>availspace</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../utils/init/globals.c.html#LN112"><span class='Ref_to_Global_Var'>work_mem</span></a> <span class='Operator'>* </span><span class='Number'>1024</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN4317"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Account first for space needed for groups we can't sort at all. 
         */ 
</span>        <a href="planner.c.html#LN4316"><span class='Ref_To_Local'>availspace</span></a> <span class='Operator'>-= </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="planner.c.html#LN132"><span class='Ref_to_Proto'>estimate_hashagg_tablesize</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4144"><span class='Ref_to_Parameter'>path</span></a><span class='Delimiter'>, 
</span>                                                          <a href="planner.c.html#LN4149"><span class='Ref_to_Parameter'>agg_costs</span></a><span class='Delimiter'>, 
</span>                                                          <a href="planner.c.html#LN4148"><span class='Ref_to_Parameter'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN102"><span class='Ref_to_Member'>dNumHashGroups</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN4316"><span class='Ref_To_Local'>availspace</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4148"><span class='Ref_to_Parameter'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN100"><span class='Ref_to_Member'>rollups</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span><a name="LN4328"></a>            <span class='Keyword'>double</span>      <span class='Declare_Local'>scale</span><span class='Delimiter'>; 
</span><a name="LN4329"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>num_rollups</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4148"><span class='Ref_to_Parameter'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN100"><span class='Ref_to_Member'>rollups</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN4330"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>k_capacity</span><span class='Delimiter'>; 
</span><a name="LN4331"></a>            <span class='Keyword'>int</span>        <span class='Operator'>*</span><span class='Declare_Local'>k_weights</span> <span class='Operator'>= </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4329"><span class='Ref_To_Local'>num_rollups</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span><a name="LN4332"></a>            <a href="../../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>hash_items</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN4333"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * We treat this as a knapsack problem: the knapsack capacity 
             * represents work_mem, the item weights are the estimated memory 
             * usage of the hashtables needed to implement a single rollup, 
             * and we really ought to use the cost saving as the item value; 
             * however, currently the costs assigned to sort nodes don't 
             * reflect the comparison costs well, and so we treat all items as 
             * of equal value (each rollup we hash instead saves us one sort). 
             * 
             * To use the discrete knapsack, we need to scale the values to a 
             * reasonably small bounded range.  We choose to allow a 5% error 
             * margin; we have no more than 4096 rollups in the worst possible 
             * case, which with a 5% error margin will require a bit over 42MB 
             * of workspace. (Anyone wanting to plan queries that complex had 
             * better have the memory for it.  In more reasonable cases, with 
             * no more than a couple of dozen rollups, the memory usage will 
             * be negligible.) 
             * 
             * k_capacity is naturally bounded, but we clamp the values for 
             * scale and weight (below) to avoid overflows or underflows (or 
             * uselessly trying to use a scale factor less than 1 byte). 
             */ 
</span>            <a href="planner.c.html#LN4328"><span class='Ref_To_Local'>scale</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN10"><span class='Ref_to_Macro'>Max</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4316"><span class='Ref_To_Local'>availspace</span></a> <span class='Operator'>/ </span><span class='Parentheses'>(</span><span class='Number'>20</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>* </span><a href="planner.c.html#LN4329"><span class='Ref_To_Local'>num_rollups</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="planner.c.html#LN4330"><span class='Ref_To_Local'>k_capacity</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span>floor<span class='Parentheses'>(</span><a href="planner.c.html#LN4316"><span class='Ref_To_Local'>availspace</span></a> <span class='Operator'>/ </span><a href="planner.c.html#LN4328"><span class='Ref_To_Local'>scale</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * We leave the first rollup out of consideration since it's the 
             * one that matches the input sort order.  We assign indexes "i" 
             * to only those entries considered for hashing; the second loop, 
             * below, must use the same condition. 
             */ 
</span>            <a href="planner.c.html#LN4333"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <a href="../../../include/nodes/pg_list.h.html#LN168"><span class='Ref_to_Macro'>for_each_cell</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4317"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4148"><span class='Ref_to_Parameter'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN100"><span class='Ref_to_Member'>rollups</span></a><span class='Parentheses'>)))</span> 
            <span class='Delimiter'>{ 
</span><a name="LN4369"></a>                <a href="../../../include/nodes/relation.h.html#LN1478"><span class='Ref_to_Struct'>RollupData</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rollup</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4317"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN4369"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1485"><span class='Ref_to_Member'>hashable</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN4373"></a>                    <span class='Keyword'>double</span>      <span class='Declare_Local'>sz</span> <span class='Operator'>= </span><a href="planner.c.html#LN132"><span class='Ref_to_Proto'>estimate_hashagg_tablesize</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4144"><span class='Ref_to_Parameter'>path</span></a><span class='Delimiter'>, 
</span>                                                                <a href="planner.c.html#LN4149"><span class='Ref_to_Parameter'>agg_costs</span></a><span class='Delimiter'>, 
</span>                                                          <a href="planner.c.html#LN4369"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1484"><span class='Ref_to_Member'>numGroups</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * If sz is enormous, but work_mem (and hence scale) is 
                     * small, avoid integer overflow here. 
                     */ 
</span>                    <a href="planner.c.html#LN4331"><span class='Ref_To_Local'>k_weights</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN4333"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN11"><span class='Ref_to_Macro'>Min</span></a><span class='Parentheses'>(</span>floor<span class='Parentheses'>(</span><a href="planner.c.html#LN4373"><span class='Ref_To_Local'>sz</span></a> <span class='Operator'>/ </span><a href="planner.c.html#LN4328"><span class='Ref_To_Local'>scale</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                             <a href="planner.c.html#LN4330"><span class='Ref_To_Local'>k_capacity</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Operator'>++</span><a href="planner.c.html#LN4333"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Apply knapsack algorithm; compute the set of items which 
             * maximizes the value stored (in this case the number of sorts 
             * saved) while keeping the total size (approximately) within 
             * capacity. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN4333"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <a href="planner.c.html#LN4332"><span class='Ref_To_Local'>hash_items</span></a> <span class='Operator'>= </span><a href="../../../include/lib/knapsack.h.html#LN13"><span class='Ref_to_Proto'>DiscreteKnapsack</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4330"><span class='Ref_To_Local'>k_capacity</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4333"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4331"><span class='Ref_To_Local'>k_weights</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN85"><span class='Ref_to_Proto'>bms_is_empty</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4332"><span class='Ref_To_Local'>hash_items</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="planner.c.html#LN4314"><span class='Ref_To_Local'>rollups</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4148"><span class='Ref_to_Parameter'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN100"><span class='Ref_to_Member'>rollups</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
                <a href="planner.c.html#LN4333"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>                <a href="../../../include/nodes/pg_list.h.html#LN168"><span class='Ref_to_Macro'>for_each_cell</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4317"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4148"><span class='Ref_to_Parameter'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN100"><span class='Ref_to_Member'>rollups</span></a><span class='Parentheses'>)))</span> 
                <span class='Delimiter'>{ 
</span><a name="LN4403"></a>                    <a href="../../../include/nodes/relation.h.html#LN1478"><span class='Ref_to_Struct'>RollupData</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rollup</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4317"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN4403"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1485"><span class='Ref_to_Member'>hashable</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN75"><span class='Ref_to_Proto'>bms_is_member</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4333"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4332"><span class='Ref_To_Local'>hash_items</span></a><span class='Parentheses'>))</span> 
                            <a href="planner.c.html#LN4315"><span class='Ref_To_Local'>hash_sets</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4315"><span class='Ref_To_Local'>hash_sets</span></a><span class='Delimiter'>, 
</span>                                              <a href="../../../include/nodes/pg_list.h.html#LN268"><span class='Ref_to_Proto'>list_copy</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4403"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1483"><span class='Ref_to_Member'>gsets_data</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                        <span class='Control'>else</span> 
                            <a href="planner.c.html#LN4314"><span class='Ref_To_Local'>rollups</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4314"><span class='Ref_To_Local'>rollups</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4403"><span class='Ref_To_Local'>rollup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <span class='Operator'>++</span><a href="planner.c.html#LN4333"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <span class='Control'>else</span> 
                        <a href="planner.c.html#LN4314"><span class='Ref_To_Local'>rollups</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4314"><span class='Ref_To_Local'>rollups</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4403"><span class='Ref_To_Local'>rollup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !bms_is_empty(hash_it... &raquo; </span> 
        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if availspace&GT;0&&list_le... &raquo; </span> 
 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="planner.c.html#LN4314"><span class='Ref_To_Local'>rollups</span></a> <span class='Operator'>&& </span><a href="planner.c.html#LN4315"><span class='Ref_To_Local'>hash_sets</span></a><span class='Parentheses'>) 
</span>            <a href="planner.c.html#LN4314"><span class='Ref_To_Local'>rollups</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN268"><span class='Ref_to_Proto'>list_copy</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4148"><span class='Ref_to_Parameter'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN100"><span class='Ref_to_Member'>rollups</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4317"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4315"><span class='Ref_To_Local'>hash_sets</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN4425"></a>            <a href="../../../include/nodes/relation.h.html#LN1471"><span class='Ref_to_Struct'>GroupingSetData</span></a> <span class='Operator'>*</span><span class='Declare_Local'>gs</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4317"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN4426"></a>            <a href="../../../include/nodes/relation.h.html#LN1478"><span class='Ref_to_Struct'>RollupData</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rollup</span> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1478"><span class='Ref_to_Struct'>RollupData</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="planner.c.html#LN4425"><span class='Ref_To_Local'>gs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1474"><span class='Ref_to_Member'>set</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="planner.c.html#LN4426"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1481"><span class='Ref_to_Member'>groupClause</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN125"><span class='Ref_to_Proto'>preprocess_groupclause</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4142"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4425"><span class='Ref_To_Local'>gs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1474"><span class='Ref_to_Member'>set</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="planner.c.html#LN4426"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1483"><span class='Ref_to_Member'>gsets_data</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4425"><span class='Ref_To_Local'>gs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="planner.c.html#LN4426"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1482"><span class='Ref_to_Member'>gsets</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN117"><span class='Ref_to_Proto'>remap_to_groupclause_idx</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4426"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1481"><span class='Ref_to_Member'>groupClause</span></a><span class='Delimiter'>, 
</span>                                                     <a href="planner.c.html#LN4426"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1483"><span class='Ref_to_Member'>gsets_data</span></a><span class='Delimiter'>, 
</span>                                                   <a href="planner.c.html#LN4148"><span class='Ref_to_Parameter'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN107"><span class='Ref_to_Member'>tleref_to_colnum_map</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="planner.c.html#LN4426"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1484"><span class='Ref_to_Member'>numGroups</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN4425"><span class='Ref_To_Local'>gs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1475"><span class='Ref_to_Member'>numGroups</span></a><span class='Delimiter'>; 
</span>            <a href="planner.c.html#LN4426"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1485"><span class='Ref_to_Member'>hashable</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="planner.c.html#LN4426"><span class='Ref_To_Local'>rollup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1486"><span class='Ref_to_Member'>is_hashed</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="planner.c.html#LN4314"><span class='Ref_To_Local'>rollups</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN215"><span class='Ref_to_Proto'>lcons</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4426"><span class='Ref_To_Local'>rollup</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4314"><span class='Ref_To_Local'>rollups</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN4314"><span class='Ref_To_Local'>rollups</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../../include/optimizer/pathnode.h.html#LN27"><span class='Ref_to_Proto'>add_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4143"><span class='Ref_to_Parameter'>grouped_rel</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> 
                     <a href="../../../include/optimizer/pathnode.h.html#LN192"><span class='Ref_to_Proto'>create_groupingsets_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4142"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                              <a href="planner.c.html#LN4143"><span class='Ref_to_Parameter'>grouped_rel</span></a><span class='Delimiter'>, 
</span>                                              <a href="planner.c.html#LN4144"><span class='Ref_to_Parameter'>path</span></a><span class='Delimiter'>, 
</span>                                              <a href="planner.c.html#LN4147"><span class='Ref_to_Parameter'>target</span></a><span class='Delimiter'>, 
</span>                                              <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN4152"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a><span class='Delimiter'>, 
</span>                                              <a href="../../../include/nodes/nodes.h.html#LN738"><span class='Ref_to_EnumConst'>AGG_MIXED</span></a><span class='Delimiter'>, 
</span>                                              <a href="planner.c.html#LN4314"><span class='Ref_To_Local'>rollups</span></a><span class='Delimiter'>, 
</span>                                              <a href="planner.c.html#LN4149"><span class='Ref_to_Parameter'>agg_costs</span></a><span class='Delimiter'>, 
</span>                                              <a href="planner.c.html#LN4150"><span class='Ref_to_Parameter'>dNumGroups</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if can_hash&&gd-&GT;any_has... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Now try the simple sorted case. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="planner.c.html#LN4148"><span class='Ref_to_Parameter'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN106"><span class='Ref_to_Member'>unsortable_sets</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/optimizer/pathnode.h.html#LN27"><span class='Ref_to_Proto'>add_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4143"><span class='Ref_to_Parameter'>grouped_rel</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> 
                 <a href="../../../include/optimizer/pathnode.h.html#LN192"><span class='Ref_to_Proto'>create_groupingsets_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4142"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                          <a href="planner.c.html#LN4143"><span class='Ref_to_Parameter'>grouped_rel</span></a><span class='Delimiter'>, 
</span>                                          <a href="planner.c.html#LN4144"><span class='Ref_to_Parameter'>path</span></a><span class='Delimiter'>, 
</span>                                          <a href="planner.c.html#LN4147"><span class='Ref_to_Parameter'>target</span></a><span class='Delimiter'>, 
</span>                                          <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN4152"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a><span class='Delimiter'>, 
</span>                                          <a href="../../../include/nodes/nodes.h.html#LN736"><span class='Ref_to_EnumConst'>AGG_SORTED</span></a><span class='Delimiter'>, 
</span>                                          <a href="planner.c.html#LN4148"><span class='Ref_to_Parameter'>gd</span></a><span class='Operator'>-&GT;</span><a href="planner.c.html#LN100"><span class='Ref_to_Member'>rollups</span></a><span class='Delimiter'>, 
</span>                                          <a href="planner.c.html#LN4149"><span class='Ref_to_Parameter'>agg_costs</span></a><span class='Delimiter'>, 
</span>                                          <a href="planner.c.html#LN4150"><span class='Ref_to_Parameter'>dNumGroups</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end consider_groupingsets_paths &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * create_window_paths 
 * 
 * Build a new upperrel containing Paths for window-function evaluation. 
 * 
 * input_rel: contains the source-data Paths 
 * input_target: result of make_window_input_target 
 * output_target: what the topmost WindowAggPath should return 
 * tlist: query's target list (needed to look up pathkeys) 
 * wflists: result of find_window_functions 
 * activeWindows: result of select_active_windows 
 * 
 * Note: all Paths in input_rel are expected to return input_target. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>* 
</span><a name="LN4487"></a><span class='Declare_Function'>create_window_paths</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN4488"></a>                    <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>input_rel</span><span class='Delimiter'>, 
</span><a name="LN4489"></a>                    <a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>input_target</span><span class='Delimiter'>, 
</span><a name="LN4490"></a>                    <a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>output_target</span><span class='Delimiter'>, 
</span><a name="LN4491"></a>                    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tlist</span><span class='Delimiter'>, 
</span><a name="LN4492"></a>                    <a href="../../../include/optimizer/clauses.h.html#LN22"><span class='Ref_to_Typedef'>WindowFuncLists</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>wflists</span><span class='Delimiter'>, 
</span><a name="LN4493"></a>                    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>activeWindows</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4495"></a>    <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>window_rel</span><span class='Delimiter'>; 
</span><a name="LN4496"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* For now, do all work in the (WINDOW, NULL) upperrel */ 
</span>    <a href="planner.c.html#LN4495"><span class='Ref_To_Local'>window_rel</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/pathnode.h.html#LN270"><span class='Ref_to_Proto'>fetch_upper_rel</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4487"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN74"><span class='Ref_to_EnumConst'>UPPERREL_WINDOW</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the input relation is not parallel-safe, then the window relation 
     * can't be parallel-safe, either.  Otherwise, we need to examine the 
     * target list and active windows for non-parallel-safe constructs. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN4488"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN532"><span class='Ref_to_Member'>consider_parallel</span></a> <span class='Operator'>&& 
</span>        <a href="../../../include/optimizer/clauses.h.html#LN63"><span class='Ref_to_Proto'>is_parallel_safe</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4487"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN4490"><span class='Ref_to_Parameter'>output_target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>        <a href="../../../include/optimizer/clauses.h.html#LN63"><span class='Ref_to_Proto'>is_parallel_safe</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4487"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN4493"><span class='Ref_to_Parameter'>activeWindows</span></a><span class='Parentheses'>))</span> 
        <a href="planner.c.html#LN4495"><span class='Ref_To_Local'>window_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN532"><span class='Ref_to_Member'>consider_parallel</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the input rel belongs to a single FDW, so does the window rel. 
     */ 
</span>    <a href="planner.c.html#LN4495"><span class='Ref_To_Local'>window_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN571"><span class='Ref_to_Member'>serverid</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN4488"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN571"><span class='Ref_to_Member'>serverid</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN4495"><span class='Ref_To_Local'>window_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN572"><span class='Ref_to_Member'>userid</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN4488"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN572"><span class='Ref_to_Member'>userid</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN4495"><span class='Ref_To_Local'>window_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN573"><span class='Ref_to_Member'>useridiscurrent</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN4488"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN573"><span class='Ref_to_Member'>useridiscurrent</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN4495"><span class='Ref_To_Local'>window_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN575"><span class='Ref_to_Member'>fdwroutine</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN4488"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN575"><span class='Ref_to_Member'>fdwroutine</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Consider computing window functions starting from the existing 
     * cheapest-total path (which will likely require a sort) as well as any 
     * existing paths that satisfy root-&GT;window_pathkeys (which won't). 
     */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4496"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4488"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN538"><span class='Ref_to_Member'>pathlist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN4526"></a>        <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>path</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4496"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN4526"><span class='Ref_To_Local'>path</span></a> <span class='Operator'>== </span><a href="planner.c.html#LN4488"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN542"><span class='Ref_to_Member'>cheapest_total_path</span></a> <span class='Operator'>|| 
</span>            <a href="../../../include/optimizer/paths.h.html#LN183"><span class='Ref_to_Proto'>pathkeys_contained_in</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4487"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN264"><span class='Ref_to_Member'>window_pathkeys</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4526"><span class='Ref_To_Local'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN967"><span class='Ref_to_Member'>pathkeys</span></a><span class='Parentheses'>))</span> 
            <a href="planner.c.html#LN156"><span class='Ref_to_Proto'>create_one_window_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4487"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                   <a href="planner.c.html#LN4495"><span class='Ref_To_Local'>window_rel</span></a><span class='Delimiter'>, 
</span>                                   <a href="planner.c.html#LN4526"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, 
</span>                                   <a href="planner.c.html#LN4489"><span class='Ref_to_Parameter'>input_target</span></a><span class='Delimiter'>, 
</span>                                   <a href="planner.c.html#LN4490"><span class='Ref_to_Parameter'>output_target</span></a><span class='Delimiter'>, 
</span>                                   <a href="planner.c.html#LN4491"><span class='Ref_to_Parameter'>tlist</span></a><span class='Delimiter'>, 
</span>                                   <a href="planner.c.html#LN4492"><span class='Ref_to_Parameter'>wflists</span></a><span class='Delimiter'>, 
</span>                                   <a href="planner.c.html#LN4493"><span class='Ref_to_Parameter'>activeWindows</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If there is an FDW that's responsible for all baserels of the query, 
     * let it consider adding ForeignPaths. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN4495"><span class='Ref_To_Local'>window_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN575"><span class='Ref_to_Member'>fdwroutine</span></a> <span class='Operator'>&& 
</span>        <a href="planner.c.html#LN4495"><span class='Ref_To_Local'>window_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN575"><span class='Ref_to_Member'>fdwroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/foreign/fdwapi.h.html#LN190"><span class='Ref_to_Member'>GetForeignUpperPaths</span></a><span class='Parentheses'>) 
</span>        <a href="planner.c.html#LN4495"><span class='Ref_To_Local'>window_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN575"><span class='Ref_to_Member'>fdwroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/foreign/fdwapi.h.html#LN190"><span class='Ref_to_Member'>GetForeignUpperPaths</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4487"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN74"><span class='Ref_to_EnumConst'>UPPERREL_WINDOW</span></a><span class='Delimiter'>, 
</span>                                                     <a href="planner.c.html#LN4488"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4495"><span class='Ref_To_Local'>window_rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Let extensions possibly add some more paths */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN68"><span class='Ref_to_Global_Var'>create_upper_paths_hook</span></a><span class='Parentheses'>) 
</span>        <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="planner.c.html#LN68"><span class='Ref_to_Global_Var'>create_upper_paths_hook</span></a><span class='Parentheses'>) (</span><a href="planner.c.html#LN4487"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN74"><span class='Ref_to_EnumConst'>UPPERREL_WINDOW</span></a><span class='Delimiter'>, 
</span>                                    <a href="planner.c.html#LN4488"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4495"><span class='Ref_To_Local'>window_rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Now choose the best path(s) */ 
</span>    <a href="../../../include/optimizer/pathnode.h.html#LN26"><span class='Ref_to_Proto'>set_cheapest</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4495"><span class='Ref_To_Local'>window_rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="planner.c.html#LN4495"><span class='Ref_To_Local'>window_rel</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end create_window_paths &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Stack window-function implementation steps atop the given Path, and 
 * add the result to window_rel. 
 * 
 * window_rel: upperrel to contain result 
 * path: input Path to use (must return input_target) 
 * input_target: result of make_window_input_target 
 * output_target: what the topmost WindowAggPath should return 
 * tlist: query's target list (needed to look up pathkeys) 
 * wflists: result of find_window_functions 
 * activeWindows: result of select_active_windows 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN4573"></a><span class='Declare_Function'>create_one_window_path</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN4574"></a>                       <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>window_rel</span><span class='Delimiter'>, 
</span><a name="LN4575"></a>                       <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, 
</span><a name="LN4576"></a>                       <a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>input_target</span><span class='Delimiter'>, 
</span><a name="LN4577"></a>                       <a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>output_target</span><span class='Delimiter'>, 
</span><a name="LN4578"></a>                       <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tlist</span><span class='Delimiter'>, 
</span><a name="LN4579"></a>                       <a href="../../../include/optimizer/clauses.h.html#LN22"><span class='Ref_to_Typedef'>WindowFuncLists</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>wflists</span><span class='Delimiter'>, 
</span><a name="LN4580"></a>                       <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>activeWindows</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4582"></a>    <a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Local'>window_target</span><span class='Delimiter'>; 
</span><a name="LN4583"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Since each window clause could require a different sort order, we stack 
     * up a WindowAgg node for each clause, with sort steps between them as 
     * needed.  (We assume that select_active_windows chose a good order for 
     * executing the clauses in.) 
     * 
     * input_target should contain all Vars and Aggs needed for the result. 
     * (In some cases we wouldn't need to propagate all of these all the way 
     * to the top, since they might only be needed as inputs to WindowFuncs. 
     * It's probably not worth trying to optimize that though.)  It must also 
     * contain all window partitioning and sorting expressions, to ensure 
     * they're computed only once at the bottom of the stack (that's critical 
     * for volatile functions).  As we climb up the stack, we'll add outputs 
     * for the WindowFuncs computed at each level. 
     */ 
</span>    <a href="planner.c.html#LN4582"><span class='Ref_To_Local'>window_target</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN4576"><span class='Ref_to_Parameter'>input_target</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4583"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4580"><span class='Ref_to_Parameter'>activeWindows</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN4604"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN1252"><span class='Ref_to_Struct'>WindowClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>wc</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1252"><span class='Ref_to_Struct'>WindowClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4583"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN4605"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>window_pathkeys</span><span class='Delimiter'>; 
</span> 
        <a href="planner.c.html#LN4605"><span class='Ref_To_Local'>window_pathkeys</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN179"><span class='Ref_to_Proto'>make_pathkeys_for_window</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4573"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                   <a href="planner.c.html#LN4604"><span class='Ref_To_Local'>wc</span></a><span class='Delimiter'>, 
</span>                                                   <a href="planner.c.html#LN4578"><span class='Ref_to_Parameter'>tlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Sort if necessary */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/optimizer/paths.h.html#LN183"><span class='Ref_to_Proto'>pathkeys_contained_in</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4605"><span class='Ref_To_Local'>window_pathkeys</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4575"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN967"><span class='Ref_to_Member'>pathkeys</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="planner.c.html#LN4575"><span class='Ref_to_Parameter'>path</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/pathnode.h.html#LN165"><span class='Ref_to_Proto'>create_sort_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4573"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4574"><span class='Ref_to_Parameter'>window_rel</span></a><span class='Delimiter'>, 
</span>                                             <a href="planner.c.html#LN4575"><span class='Ref_to_Parameter'>path</span></a><span class='Delimiter'>, 
</span>                                             <a href="planner.c.html#LN4605"><span class='Ref_To_Local'>window_pathkeys</span></a><span class='Delimiter'>, 
</span>                                             <span class='Operator'>-</span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4583"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Add the current WindowFuncs to the output target for this 
             * intermediate WindowAggPath.  We must copy window_target to 
             * avoid changing the previous path's target. 
             * 
             * Note: a WindowFunc adds nothing to the target's eval costs; but 
             * we do need to account for the increase in tlist width. 
             */ 
</span><a name="LN4630"></a>            <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc2</span><span class='Delimiter'>; 
</span> 
            <a href="planner.c.html#LN4582"><span class='Ref_To_Local'>window_target</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/tlist.h.html#LN56"><span class='Ref_to_Proto'>copy_pathtarget</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4582"><span class='Ref_To_Local'>window_target</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4630"><span class='Ref_To_Local'>lc2</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4579"><span class='Ref_to_Parameter'>wflists</span></a><span class='Operator'>-&GT;</span><a href="../../../include/optimizer/clauses.h.html#LN26"><span class='Ref_to_Member'>windowFuncs</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN4604"><span class='Ref_To_Local'>wc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1262"><span class='Ref_to_Member'>winref</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN4635"></a>                <a href="../../../include/nodes/primnodes.h.html#LN351"><span class='Ref_to_Struct'>WindowFunc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>wfunc</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN108"><span class='Ref_to_Macro'>lfirst_node</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN351"><span class='Ref_to_Struct'>WindowFunc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4630"><span class='Ref_To_Local'>lc2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="../../../include/optimizer/tlist.h.html#LN58"><span class='Ref_to_Proto'>add_column_to_pathtarget</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4582"><span class='Ref_To_Local'>window_target</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN4635"><span class='Ref_To_Local'>wfunc</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="planner.c.html#LN4582"><span class='Ref_To_Local'>window_target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN885"><span class='Ref_to_Member'>width</span></a> <span class='Operator'>+= </span><a href="../../../include/utils/lsyscache.h.html#LN170"><span class='Ref_to_Proto'>get_typavgwidth</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4635"><span class='Ref_To_Local'>wfunc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN355"><span class='Ref_to_Member'>wintype</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if lnext(l) &raquo; </span> 
        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Install the goal target in the topmost WindowAgg */ 
</span>            <a href="planner.c.html#LN4582"><span class='Ref_To_Local'>window_target</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN4577"><span class='Ref_to_Parameter'>output_target</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="planner.c.html#LN4575"><span class='Ref_to_Parameter'>path</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../../include/optimizer/pathnode.h.html#LN206"><span class='Ref_to_Proto'>create_windowagg_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4573"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4574"><span class='Ref_to_Parameter'>window_rel</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4575"><span class='Ref_to_Parameter'>path</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4582"><span class='Ref_To_Local'>window_target</span></a><span class='Delimiter'>, 
</span>                                  <a href="planner.c.html#LN4579"><span class='Ref_to_Parameter'>wflists</span></a><span class='Operator'>-&GT;</span><a href="../../../include/optimizer/clauses.h.html#LN26"><span class='Ref_to_Member'>windowFuncs</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN4604"><span class='Ref_To_Local'>wc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1262"><span class='Ref_to_Member'>winref</span></a><span class='Delimiter'>], 
</span>                                  <a href="planner.c.html#LN4604"><span class='Ref_To_Local'>wc</span></a><span class='Delimiter'>, 
</span>                                  <a href="planner.c.html#LN4605"><span class='Ref_To_Local'>window_pathkeys</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/optimizer/pathnode.h.html#LN27"><span class='Ref_to_Proto'>add_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4574"><span class='Ref_to_Parameter'>window_rel</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4575"><span class='Ref_to_Parameter'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end create_one_window_path &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * create_distinct_paths 
 * 
 * Build a new upperrel containing Paths for SELECT DISTINCT evaluation. 
 * 
 * input_rel: contains the source-data Paths 
 * 
 * Note: input paths should already compute the desired pathtarget, since 
 * Sort/Unique won't project anything. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>* 
</span><a name="LN4668"></a><span class='Declare_Function'>create_distinct_paths</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN4669"></a>                      <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>input_rel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4671"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>parse</span> <span class='Operator'>= </span><a href="planner.c.html#LN4668"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Delimiter'>; 
</span><a name="LN4672"></a>    <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>cheapest_input_path</span> <span class='Operator'>= </span><a href="planner.c.html#LN4669"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN542"><span class='Ref_to_Member'>cheapest_total_path</span></a><span class='Delimiter'>; 
</span><a name="LN4673"></a>    <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>distinct_rel</span><span class='Delimiter'>; 
</span><a name="LN4674"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>numDistinctRows</span><span class='Delimiter'>; 
</span><a name="LN4675"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>allow_hash</span><span class='Delimiter'>; 
</span><a name="LN4676"></a>    <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>path</span><span class='Delimiter'>; 
</span><a name="LN4677"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* For now, do all work in the (DISTINCT, NULL) upperrel */ 
</span>    <a href="planner.c.html#LN4673"><span class='Ref_To_Local'>distinct_rel</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/pathnode.h.html#LN270"><span class='Ref_to_Proto'>fetch_upper_rel</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4668"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN75"><span class='Ref_to_EnumConst'>UPPERREL_DISTINCT</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We don't compute anything at this level, so distinct_rel will be 
     * parallel-safe if the input rel is parallel-safe.  In particular, if 
     * there is a DISTINCT ON (...) clause, any path for the input_rel will 
     * output those expressions, and will not be parallel-safe unless those 
     * expressions are parallel-safe. 
     */ 
</span>    <a href="planner.c.html#LN4673"><span class='Ref_To_Local'>distinct_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN532"><span class='Ref_to_Member'>consider_parallel</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN4669"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN532"><span class='Ref_to_Member'>consider_parallel</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the input rel belongs to a single FDW, so does the distinct_rel. 
     */ 
</span>    <a href="planner.c.html#LN4673"><span class='Ref_To_Local'>distinct_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN571"><span class='Ref_to_Member'>serverid</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN4669"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN571"><span class='Ref_to_Member'>serverid</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN4673"><span class='Ref_To_Local'>distinct_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN572"><span class='Ref_to_Member'>userid</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN4669"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN572"><span class='Ref_to_Member'>userid</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN4673"><span class='Ref_To_Local'>distinct_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN573"><span class='Ref_to_Member'>useridiscurrent</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN4669"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN573"><span class='Ref_to_Member'>useridiscurrent</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN4673"><span class='Ref_To_Local'>distinct_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN575"><span class='Ref_to_Member'>fdwroutine</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN4669"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN575"><span class='Ref_to_Member'>fdwroutine</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Estimate number of distinct rows there will be */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN4671"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a> <span class='Operator'>|| </span><a href="planner.c.html#LN4671"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN147"><span class='Ref_to_Member'>groupingSets</span></a> <span class='Operator'>|| </span><a href="planner.c.html#LN4671"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN122"><span class='Ref_to_Member'>hasAggs</span></a> <span class='Operator'>|| 
</span>        <a href="planner.c.html#LN4668"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN301"><span class='Ref_to_Member'>hasHavingQual</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * If there was grouping or aggregation, use the number of input rows 
         * as the estimated number of DISTINCT rows (ie, assume the input is 
         * already mostly unique). 
         */ 
</span>        <a href="planner.c.html#LN4674"><span class='Ref_To_Local'>numDistinctRows</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN4672"><span class='Ref_To_Local'>cheapest_input_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Otherwise, the UNIQUE filter has effects comparable to GROUP BY. 
         */ 
</span><a name="LN4715"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>distinctExprs</span><span class='Delimiter'>; 
</span> 
        <a href="planner.c.html#LN4715"><span class='Ref_To_Local'>distinctExprs</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/tlist.h.html#LN41"><span class='Ref_to_Proto'>get_sortgrouplist_exprs</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4671"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN153"><span class='Ref_to_Member'>distinctClause</span></a><span class='Delimiter'>, 
</span>                                                <a href="planner.c.html#LN4671"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN4674"><span class='Ref_To_Local'>numDistinctRows</span></a> <span class='Operator'>= </span><a href="../../../include/utils/selfuncs.h.html#LN205"><span class='Ref_to_Proto'>estimate_num_groups</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4668"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4715"><span class='Ref_To_Local'>distinctExprs</span></a><span class='Delimiter'>, 
</span>                                              <a href="planner.c.html#LN4672"><span class='Ref_To_Local'>cheapest_input_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>, 
</span>                                              <span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Consider sort-based implementations of DISTINCT, if possible. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/tlist.h.html#LN51"><span class='Ref_to_Proto'>grouping_is_sortable</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4671"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN153"><span class='Ref_to_Member'>distinctClause</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * First, if we have any adequately-presorted paths, just stick a 
         * Unique node on those.  Then consider doing an explicit sort of the 
         * cheapest input path and Unique'ing that. 
         * 
         * When we have DISTINCT ON, we must sort by the more rigorous of 
         * DISTINCT and ORDER BY, else it won't have the desired behavior. 
         * Also, if we do have to do an explicit sort, we might as well use 
         * the more rigorous ordering to avoid a second sort later.  (Note 
         * that the parser will have ensured that one clause is a prefix of 
         * the other.) 
         */ 
</span><a name="LN4741"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>needed_pathkeys</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN4671"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN126"><span class='Ref_to_Member'>hasDistinctOn</span></a> <span class='Operator'>&& 
</span>            <a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4668"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN265"><span class='Ref_to_Member'>distinct_pathkeys</span></a><span class='Parentheses'>) </span><span class='Operator'>&LT; 
</span>            <a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4668"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN266"><span class='Ref_to_Member'>sort_pathkeys</span></a><span class='Parentheses'>))</span> 
            <a href="planner.c.html#LN4741"><span class='Ref_To_Local'>needed_pathkeys</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN4668"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN266"><span class='Ref_to_Member'>sort_pathkeys</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="planner.c.html#LN4741"><span class='Ref_To_Local'>needed_pathkeys</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN4668"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN265"><span class='Ref_to_Member'>distinct_pathkeys</span></a><span class='Delimiter'>; 
</span> 
        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4677"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4669"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN538"><span class='Ref_to_Member'>pathlist</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN4752"></a>            <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>path</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4677"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/paths.h.html#LN183"><span class='Ref_to_Proto'>pathkeys_contained_in</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4741"><span class='Ref_To_Local'>needed_pathkeys</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4752"><span class='Ref_To_Local'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN967"><span class='Ref_to_Member'>pathkeys</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="../../../include/optimizer/pathnode.h.html#LN27"><span class='Ref_to_Proto'>add_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4673"><span class='Ref_To_Local'>distinct_rel</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> 
                         <a href="../../../include/optimizer/pathnode.h.html#LN177"><span class='Ref_to_Proto'>create_upper_unique_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4668"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4673"><span class='Ref_To_Local'>distinct_rel</span></a><span class='Delimiter'>, 
</span>                                                  <a href="planner.c.html#LN4752"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, 
</span>                                        <a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4668"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN265"><span class='Ref_to_Member'>distinct_pathkeys</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                  <a href="planner.c.html#LN4674"><span class='Ref_To_Local'>numDistinctRows</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* For explicit-sort case, always use the more rigorous clause */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4668"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN265"><span class='Ref_to_Member'>distinct_pathkeys</span></a><span class='Parentheses'>) </span><span class='Operator'>&LT; 
</span>            <a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4668"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN266"><span class='Ref_to_Member'>sort_pathkeys</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="planner.c.html#LN4741"><span class='Ref_To_Local'>needed_pathkeys</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN4668"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN266"><span class='Ref_to_Member'>sort_pathkeys</span></a><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* Assert checks that parser didn't mess up... */ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/optimizer/paths.h.html#LN183"><span class='Ref_to_Proto'>pathkeys_contained_in</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4668"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN265"><span class='Ref_to_Member'>distinct_pathkeys</span></a><span class='Delimiter'>, 
</span>                                         <a href="planner.c.html#LN4741"><span class='Ref_To_Local'>needed_pathkeys</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <a href="planner.c.html#LN4741"><span class='Ref_To_Local'>needed_pathkeys</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN4668"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN265"><span class='Ref_to_Member'>distinct_pathkeys</span></a><span class='Delimiter'>; 
</span> 
        <a href="planner.c.html#LN4676"><span class='Ref_To_Local'>path</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN4672"><span class='Ref_To_Local'>cheapest_input_path</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/optimizer/paths.h.html#LN183"><span class='Ref_to_Proto'>pathkeys_contained_in</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4741"><span class='Ref_To_Local'>needed_pathkeys</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4676"><span class='Ref_To_Local'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN967"><span class='Ref_to_Member'>pathkeys</span></a><span class='Parentheses'>))</span> 
            <a href="planner.c.html#LN4676"><span class='Ref_To_Local'>path</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/pathnode.h.html#LN165"><span class='Ref_to_Proto'>create_sort_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4668"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4673"><span class='Ref_To_Local'>distinct_rel</span></a><span class='Delimiter'>, 
</span>                                             <a href="planner.c.html#LN4676"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, 
</span>                                             <a href="planner.c.html#LN4741"><span class='Ref_To_Local'>needed_pathkeys</span></a><span class='Delimiter'>, 
</span>                                             <span class='Operator'>-</span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/optimizer/pathnode.h.html#LN27"><span class='Ref_to_Proto'>add_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4673"><span class='Ref_To_Local'>distinct_rel</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> 
                 <a href="../../../include/optimizer/pathnode.h.html#LN177"><span class='Ref_to_Proto'>create_upper_unique_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4668"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4673"><span class='Ref_To_Local'>distinct_rel</span></a><span class='Delimiter'>, 
</span>                                          <a href="planner.c.html#LN4676"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, 
</span>                                        <a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4668"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN265"><span class='Ref_to_Member'>distinct_pathkeys</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                          <a href="planner.c.html#LN4674"><span class='Ref_To_Local'>numDistinctRows</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if grouping_is_sortable(... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Consider hash-based implementations of DISTINCT, if possible. 
     * 
     * If we were not able to make any other types of path, we *must* hash or 
     * die trying.  If we do have other choices, there are several things that 
     * should prevent selection of hashing: if the query uses DISTINCT ON 
     * (because it won't really have the expected behavior if we hash), or if 
     * enable_hashagg is off, or if it looks like the hashtable will exceed 
     * work_mem. 
     * 
     * Note: grouping_is_hashable() is much more expensive to check than the 
     * other gating conditions, so we want to do it last. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN4673"><span class='Ref_To_Local'>distinct_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN538"><span class='Ref_to_Member'>pathlist</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <a href="planner.c.html#LN4675"><span class='Ref_To_Local'>allow_hash</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* we have no alternatives */ 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN4671"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN126"><span class='Ref_to_Member'>hasDistinctOn</span></a> <span class='Operator'>|| !</span><a href="../path/costsize.c.html#LN123"><span class='Ref_to_Global_Var'>enable_hashagg</span></a><span class='Parentheses'>) 
</span>        <a href="planner.c.html#LN4675"><span class='Ref_To_Local'>allow_hash</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* policy-based decision not to hash */ 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span><a name="LN4809"></a>        <a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Local'>hashentrysize</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Estimate per-hash-entry space at tuple width... */ 
</span>        <a href="planner.c.html#LN4809"><span class='Ref_To_Local'>hashentrysize</span></a> <span class='Operator'>= </span><a href="../../../include/c.h.html#LN587"><span class='Ref_to_Macro'>MAXALIGN</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4672"><span class='Ref_To_Local'>cheapest_input_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN885"><span class='Ref_to_Member'>width</span></a><span class='Parentheses'>) </span><span class='Operator'>+ 
</span>            <a href="../../../include/c.h.html#LN587"><span class='Ref_to_Macro'>MAXALIGN</span></a><span class='Parentheses'>(</span><a href="../../../include/access/htup_details.h.html#LN649"><span class='Ref_to_Const'>SizeofMinimalTupleHeader</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* plus the per-hash-entry overhead */ 
</span>        <a href="planner.c.html#LN4809"><span class='Ref_To_Local'>hashentrysize</span></a> <span class='Operator'>+= </span><a href="../../../include/executor/nodeAgg.h.html#LN23"><span class='Ref_to_Proto'>hash_agg_entry_size</span></a><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Allow hashing only if hashtable is predicted to fit in work_mem */ 
</span>        <a href="planner.c.html#LN4675"><span class='Ref_To_Local'>allow_hash</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="planner.c.html#LN4809"><span class='Ref_To_Local'>hashentrysize</span></a> <span class='Operator'>* </span><a href="planner.c.html#LN4674"><span class='Ref_To_Local'>numDistinctRows</span></a> <span class='Operator'>&LT;= </span><a href="../../utils/init/globals.c.html#LN112"><span class='Ref_to_Global_Var'>work_mem</span></a> <span class='Operator'>* </span><span class='Number'>1024L</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN4675"><span class='Ref_To_Local'>allow_hash</span></a> <span class='Operator'>&& </span><a href="../../../include/optimizer/tlist.h.html#LN52"><span class='Ref_to_Proto'>grouping_is_hashable</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4671"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN153"><span class='Ref_to_Member'>distinctClause</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Generate hashed aggregate path --- no sort needed */ 
</span>        <a href="../../../include/optimizer/pathnode.h.html#LN27"><span class='Ref_to_Proto'>add_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4673"><span class='Ref_To_Local'>distinct_rel</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                 <a href="../../../include/optimizer/pathnode.h.html#LN182"><span class='Ref_to_Proto'>create_agg_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4668"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                 <a href="planner.c.html#LN4673"><span class='Ref_To_Local'>distinct_rel</span></a><span class='Delimiter'>, 
</span>                                 <a href="planner.c.html#LN4672"><span class='Ref_To_Local'>cheapest_input_path</span></a><span class='Delimiter'>, 
</span>                                 <a href="planner.c.html#LN4672"><span class='Ref_To_Local'>cheapest_input_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Delimiter'>, 
</span>                                 <a href="../../../include/nodes/nodes.h.html#LN737"><span class='Ref_to_EnumConst'>AGG_HASHED</span></a><span class='Delimiter'>, 
</span>                                 <a href="../../../include/nodes/nodes.h.html#LN758"><span class='Ref_to_EnumConst'>AGGSPLIT_SIMPLE</span></a><span class='Delimiter'>, 
</span>                                 <a href="planner.c.html#LN4671"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN153"><span class='Ref_to_Member'>distinctClause</span></a><span class='Delimiter'>, 
</span>                                 <a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>, 
</span>                                 <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                 <a href="planner.c.html#LN4674"><span class='Ref_To_Local'>numDistinctRows</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Give a helpful error if we failed to find any implementation */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN4673"><span class='Ref_To_Local'>distinct_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN538"><span class='Ref_to_Member'>pathlist</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not implement DISTINCT"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"Some of the datatypes only support hashing, while others only support sorting."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If there is an FDW that's responsible for all baserels of the query, 
     * let it consider adding ForeignPaths. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN4673"><span class='Ref_To_Local'>distinct_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN575"><span class='Ref_to_Member'>fdwroutine</span></a> <span class='Operator'>&& 
</span>        <a href="planner.c.html#LN4673"><span class='Ref_To_Local'>distinct_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN575"><span class='Ref_to_Member'>fdwroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/foreign/fdwapi.h.html#LN190"><span class='Ref_to_Member'>GetForeignUpperPaths</span></a><span class='Parentheses'>) 
</span>        <a href="planner.c.html#LN4673"><span class='Ref_To_Local'>distinct_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN575"><span class='Ref_to_Member'>fdwroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/foreign/fdwapi.h.html#LN190"><span class='Ref_to_Member'>GetForeignUpperPaths</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4668"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN75"><span class='Ref_to_EnumConst'>UPPERREL_DISTINCT</span></a><span class='Delimiter'>, 
</span>                                                    <a href="planner.c.html#LN4669"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4673"><span class='Ref_To_Local'>distinct_rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Let extensions possibly add some more paths */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN68"><span class='Ref_to_Global_Var'>create_upper_paths_hook</span></a><span class='Parentheses'>) 
</span>        <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="planner.c.html#LN68"><span class='Ref_to_Global_Var'>create_upper_paths_hook</span></a><span class='Parentheses'>) (</span><a href="planner.c.html#LN4668"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN75"><span class='Ref_to_EnumConst'>UPPERREL_DISTINCT</span></a><span class='Delimiter'>, 
</span>                                    <a href="planner.c.html#LN4669"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4673"><span class='Ref_To_Local'>distinct_rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Now choose the best path(s) */ 
</span>    <a href="../../../include/optimizer/pathnode.h.html#LN26"><span class='Ref_to_Proto'>set_cheapest</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4673"><span class='Ref_To_Local'>distinct_rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="planner.c.html#LN4673"><span class='Ref_To_Local'>distinct_rel</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end create_distinct_paths &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * create_ordered_paths 
 * 
 * Build a new upperrel containing Paths for ORDER BY evaluation. 
 * 
 * All paths in the result must satisfy the ORDER BY ordering. 
 * The only new path we need consider is an explicit sort on the 
 * cheapest-total existing path. 
 * 
 * input_rel: contains the source-data Paths 
 * target: the output tlist the result Paths must emit 
 * limit_tuples: estimated bound on the number of output tuples, 
 *      or -1 if no LIMIT or couldn't estimate 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>* 
</span><a name="LN4879"></a><span class='Declare_Function'>create_ordered_paths</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN4880"></a>                     <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>input_rel</span><span class='Delimiter'>, 
</span><a name="LN4881"></a>                     <a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>target</span><span class='Delimiter'>, 
</span><a name="LN4882"></a>                     <span class='Keyword'>double </span><span class='Declare_Parameter'>limit_tuples</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4884"></a>    <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>cheapest_input_path</span> <span class='Operator'>= </span><a href="planner.c.html#LN4880"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN542"><span class='Ref_to_Member'>cheapest_total_path</span></a><span class='Delimiter'>; 
</span><a name="LN4885"></a>    <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>ordered_rel</span><span class='Delimiter'>; 
</span><a name="LN4886"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* For now, do all work in the (ORDERED, NULL) upperrel */ 
</span>    <a href="planner.c.html#LN4885"><span class='Ref_To_Local'>ordered_rel</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/pathnode.h.html#LN270"><span class='Ref_to_Proto'>fetch_upper_rel</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4879"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN76"><span class='Ref_to_EnumConst'>UPPERREL_ORDERED</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the input relation is not parallel-safe, then the ordered relation 
     * can't be parallel-safe, either.  Otherwise, it's parallel-safe if the 
     * target list is parallel-safe. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN4880"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN532"><span class='Ref_to_Member'>consider_parallel</span></a> <span class='Operator'>&& 
</span>        <a href="../../../include/optimizer/clauses.h.html#LN63"><span class='Ref_to_Proto'>is_parallel_safe</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4879"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN4881"><span class='Ref_to_Parameter'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a><span class='Parentheses'>))</span> 
        <a href="planner.c.html#LN4885"><span class='Ref_To_Local'>ordered_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN532"><span class='Ref_to_Member'>consider_parallel</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the input rel belongs to a single FDW, so does the ordered_rel. 
     */ 
</span>    <a href="planner.c.html#LN4885"><span class='Ref_To_Local'>ordered_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN571"><span class='Ref_to_Member'>serverid</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN4880"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN571"><span class='Ref_to_Member'>serverid</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN4885"><span class='Ref_To_Local'>ordered_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN572"><span class='Ref_to_Member'>userid</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN4880"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN572"><span class='Ref_to_Member'>userid</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN4885"><span class='Ref_To_Local'>ordered_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN573"><span class='Ref_to_Member'>useridiscurrent</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN4880"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN573"><span class='Ref_to_Member'>useridiscurrent</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN4885"><span class='Ref_To_Local'>ordered_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN575"><span class='Ref_to_Member'>fdwroutine</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN4880"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN575"><span class='Ref_to_Member'>fdwroutine</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4886"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4880"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN538"><span class='Ref_to_Member'>pathlist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN4910"></a>        <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>path</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4886"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN4911"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>is_sorted</span><span class='Delimiter'>; 
</span> 
        <a href="planner.c.html#LN4911"><span class='Ref_To_Local'>is_sorted</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/paths.h.html#LN183"><span class='Ref_to_Proto'>pathkeys_contained_in</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4879"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN266"><span class='Ref_to_Member'>sort_pathkeys</span></a><span class='Delimiter'>, 
</span>                                          <a href="planner.c.html#LN4910"><span class='Ref_To_Local'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN967"><span class='Ref_to_Member'>pathkeys</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN4910"><span class='Ref_To_Local'>path</span></a> <span class='Operator'>== </span><a href="planner.c.html#LN4884"><span class='Ref_To_Local'>cheapest_input_path</span></a> <span class='Operator'>|| </span><a href="planner.c.html#LN4911"><span class='Ref_To_Local'>is_sorted</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="planner.c.html#LN4911"><span class='Ref_To_Local'>is_sorted</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* An explicit sort here can take advantage of LIMIT */ 
</span>                <a href="planner.c.html#LN4910"><span class='Ref_To_Local'>path</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/pathnode.h.html#LN165"><span class='Ref_to_Proto'>create_sort_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4879"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                 <a href="planner.c.html#LN4885"><span class='Ref_To_Local'>ordered_rel</span></a><span class='Delimiter'>, 
</span>                                                 <a href="planner.c.html#LN4910"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, 
</span>                                                 <a href="planner.c.html#LN4879"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN266"><span class='Ref_to_Member'>sort_pathkeys</span></a><span class='Delimiter'>, 
</span>                                                 <a href="planner.c.html#LN4882"><span class='Ref_to_Parameter'>limit_tuples</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* Add projection step if needed */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN4910"><span class='Ref_To_Local'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a> <span class='Operator'>!= </span><a href="planner.c.html#LN4881"><span class='Ref_to_Parameter'>target</span></a><span class='Parentheses'>) 
</span>                <a href="planner.c.html#LN4910"><span class='Ref_To_Local'>path</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/pathnode.h.html#LN157"><span class='Ref_to_Proto'>apply_projection_to_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4879"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4885"><span class='Ref_To_Local'>ordered_rel</span></a><span class='Delimiter'>, 
</span>                                                <a href="planner.c.html#LN4910"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4881"><span class='Ref_to_Parameter'>target</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/optimizer/pathnode.h.html#LN27"><span class='Ref_to_Proto'>add_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4885"><span class='Ref_To_Local'>ordered_rel</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4910"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * generate_gather_paths() will have already generated a simple Gather 
     * path for the best parallel path, if any, and the loop above will have 
     * considered sorting it.  Similarly, generate_gather_paths() will also 
     * have generated order-preserving Gather Merge plans which can be used 
     * without sorting if they happen to match the sort_pathkeys, and the loop 
     * above will have handled those as well.  However, there's one more 
     * possibility: it may make sense to sort the cheapest partial path 
     * according to the required output order and then use Gather Merge. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN4885"><span class='Ref_To_Local'>ordered_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN532"><span class='Ref_to_Member'>consider_parallel</span></a> <span class='Operator'>&& </span><a href="planner.c.html#LN4879"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN266"><span class='Ref_to_Member'>sort_pathkeys</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>&& 
</span>        <a href="planner.c.html#LN4880"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN540"><span class='Ref_to_Member'>partial_pathlist</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN4949"></a>        <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>cheapest_partial_path</span><span class='Delimiter'>; 
</span> 
        <a href="planner.c.html#LN4949"><span class='Ref_To_Local'>cheapest_partial_path</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4880"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN540"><span class='Ref_to_Member'>partial_pathlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If cheapest partial path doesn't need a sort, this is redundant 
         * with what's already been tried. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/optimizer/paths.h.html#LN183"><span class='Ref_to_Proto'>pathkeys_contained_in</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4879"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN266"><span class='Ref_to_Member'>sort_pathkeys</span></a><span class='Delimiter'>, 
</span>                                   <a href="planner.c.html#LN4949"><span class='Ref_To_Local'>cheapest_partial_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN967"><span class='Ref_to_Member'>pathkeys</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN4960"></a>            <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>path</span><span class='Delimiter'>; 
</span><a name="LN4961"></a>            <span class='Keyword'>double</span>      <span class='Declare_Local'>total_groups</span><span class='Delimiter'>; 
</span> 
            <a href="planner.c.html#LN4960"><span class='Ref_To_Local'>path</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/pathnode.h.html#LN165"><span class='Ref_to_Proto'>create_sort_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4879"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                             <a href="planner.c.html#LN4885"><span class='Ref_To_Local'>ordered_rel</span></a><span class='Delimiter'>, 
</span>                                             <a href="planner.c.html#LN4949"><span class='Ref_To_Local'>cheapest_partial_path</span></a><span class='Delimiter'>, 
</span>                                             <a href="planner.c.html#LN4879"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN266"><span class='Ref_to_Member'>sort_pathkeys</span></a><span class='Delimiter'>, 
</span>                                             <span class='Operator'>-</span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="planner.c.html#LN4961"><span class='Ref_To_Local'>total_groups</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN4949"><span class='Ref_To_Local'>cheapest_partial_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>* 
</span>                <a href="planner.c.html#LN4949"><span class='Ref_To_Local'>cheapest_partial_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN959"><span class='Ref_to_Member'>parallel_workers</span></a><span class='Delimiter'>; 
</span>            <a href="planner.c.html#LN4960"><span class='Ref_To_Local'>path</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                <a href="../../../include/optimizer/pathnode.h.html#LN82"><span class='Ref_to_Proto'>create_gather_merge_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4879"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4885"><span class='Ref_To_Local'>ordered_rel</span></a><span class='Delimiter'>, 
</span>                                         <a href="planner.c.html#LN4960"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, 
</span>                                         <a href="planner.c.html#LN4881"><span class='Ref_to_Parameter'>target</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4879"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN266"><span class='Ref_to_Member'>sort_pathkeys</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                         <span class='Operator'>&</span><a href="planner.c.html#LN4961"><span class='Ref_To_Local'>total_groups</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Add projection step if needed */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN4960"><span class='Ref_To_Local'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a> <span class='Operator'>!= </span><a href="planner.c.html#LN4881"><span class='Ref_to_Parameter'>target</span></a><span class='Parentheses'>) 
</span>                <a href="planner.c.html#LN4960"><span class='Ref_To_Local'>path</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/pathnode.h.html#LN157"><span class='Ref_to_Proto'>apply_projection_to_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4879"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4885"><span class='Ref_To_Local'>ordered_rel</span></a><span class='Delimiter'>, 
</span>                                                <a href="planner.c.html#LN4960"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4881"><span class='Ref_to_Parameter'>target</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/optimizer/pathnode.h.html#LN27"><span class='Ref_to_Proto'>add_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4885"><span class='Ref_To_Local'>ordered_rel</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4960"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !pathkeys_contained_i... &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if ordered_rel-&GT;consider... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * If there is an FDW that's responsible for all baserels of the query, 
     * let it consider adding ForeignPaths. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN4885"><span class='Ref_To_Local'>ordered_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN575"><span class='Ref_to_Member'>fdwroutine</span></a> <span class='Operator'>&& 
</span>        <a href="planner.c.html#LN4885"><span class='Ref_To_Local'>ordered_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN575"><span class='Ref_to_Member'>fdwroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/foreign/fdwapi.h.html#LN190"><span class='Ref_to_Member'>GetForeignUpperPaths</span></a><span class='Parentheses'>) 
</span>        <a href="planner.c.html#LN4885"><span class='Ref_To_Local'>ordered_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN575"><span class='Ref_to_Member'>fdwroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/foreign/fdwapi.h.html#LN190"><span class='Ref_to_Member'>GetForeignUpperPaths</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN4879"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN76"><span class='Ref_to_EnumConst'>UPPERREL_ORDERED</span></a><span class='Delimiter'>, 
</span>                                                      <a href="planner.c.html#LN4880"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4885"><span class='Ref_To_Local'>ordered_rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Let extensions possibly add some more paths */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN68"><span class='Ref_to_Global_Var'>create_upper_paths_hook</span></a><span class='Parentheses'>) 
</span>        <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="planner.c.html#LN68"><span class='Ref_to_Global_Var'>create_upper_paths_hook</span></a><span class='Parentheses'>) (</span><a href="planner.c.html#LN4879"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN76"><span class='Ref_to_EnumConst'>UPPERREL_ORDERED</span></a><span class='Delimiter'>, 
</span>                                    <a href="planner.c.html#LN4880"><span class='Ref_to_Parameter'>input_rel</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN4885"><span class='Ref_To_Local'>ordered_rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * No need to bother with set_cheapest here; grouping_planner does not 
     * need us to do it. 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="planner.c.html#LN4885"><span class='Ref_To_Local'>ordered_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN538"><span class='Ref_to_Member'>pathlist</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="planner.c.html#LN4885"><span class='Ref_To_Local'>ordered_rel</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end create_ordered_paths &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * make_group_input_target 
 *    Generate appropriate PathTarget for initial input to grouping nodes. 
 * 
 * If there is grouping or aggregation, the scan/join subplan cannot emit 
 * the query's final targetlist; for example, it certainly can't emit any 
 * aggregate function calls.  This routine generates the correct target 
 * for the scan/join subplan. 
 * 
 * The query target list passed from the parser already contains entries 
 * for all ORDER BY and GROUP BY expressions, but it will not have entries 
 * for variables used only in HAVING clauses; so we need to add those 
 * variables to the subplan target list.  Also, we flatten all expressions 
 * except GROUP BY items into their component variables; other expressions 
 * will be computed by the upper plan nodes rather than by the subplan. 
 * For example, given a query like 
 *      SELECT a+b,SUM(c+d) FROM table GROUP BY a+b; 
 * we want to pass this targetlist to the subplan: 
 *      a+b,c,d 
 * where the a+b target will be used by the Sort/Group steps, and the 
 * other targets will be used for computing the final results. 
 * 
 * 'final_target' is the query's final target list (in PathTarget form) 
 * 
 * The result is the PathTarget to be computed by the Paths returned from 
 * query_planner(). 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>* 
</span><a name="LN5038"></a><span class='Declare_Function'>make_group_input_target</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>final_target</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN5040"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>parse</span> <span class='Operator'>= </span><a href="planner.c.html#LN5038"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Delimiter'>; 
</span><a name="LN5041"></a>    <a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Local'>input_target</span><span class='Delimiter'>; 
</span><a name="LN5042"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>non_group_cols</span><span class='Delimiter'>; 
</span><a name="LN5043"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>non_group_vars</span><span class='Delimiter'>; 
</span><a name="LN5044"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN5045"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We must build a target containing all grouping columns, plus any other 
     * Vars mentioned in the query's targetlist and HAVING qual. 
     */ 
</span>    <a href="planner.c.html#LN5041"><span class='Ref_To_Local'>input_target</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/tlist.h.html#LN57"><span class='Ref_to_Proto'>create_empty_pathtarget</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN5042"><span class='Ref_To_Local'>non_group_cols</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <a href="planner.c.html#LN5044"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5045"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5038"><span class='Ref_to_Parameter'>final_target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN5057"></a>        <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5045"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN5058"></a>        <a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Local'>sgref</span> <span class='Operator'>= </span><a href="../../../include/nodes/relation.h.html#LN889"><span class='Ref_to_Macro'>get_pathtarget_sortgroupref</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5038"><span class='Ref_to_Parameter'>final_target</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5044"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN5058"><span class='Ref_To_Local'>sgref</span></a> <span class='Operator'>&& </span><a href="planner.c.html#LN5040"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a> <span class='Operator'>&& 
</span>            <a href="../../../include/optimizer/tlist.h.html#LN46"><span class='Ref_to_Proto'>get_sortgroupref_clause_noerr</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5058"><span class='Ref_To_Local'>sgref</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5040"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * It's a grouping column, so add it to the input target as-is. 
             */ 
</span>            <a href="../../../include/optimizer/tlist.h.html#LN58"><span class='Ref_to_Proto'>add_column_to_pathtarget</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5041"><span class='Ref_To_Local'>input_target</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5057"><span class='Ref_To_Local'>expr</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5058"><span class='Ref_To_Local'>sgref</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Non-grouping column, so just remember the expression for later 
             * call to pull_var_clause. 
             */ 
</span>            <a href="planner.c.html#LN5042"><span class='Ref_To_Local'>non_group_cols</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5042"><span class='Ref_To_Local'>non_group_cols</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5057"><span class='Ref_To_Local'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="planner.c.html#LN5044"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If there's a HAVING clause, we'll need the Vars it uses, too. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN5040"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a><span class='Parentheses'>) 
</span>        <a href="planner.c.html#LN5042"><span class='Ref_To_Local'>non_group_cols</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5042"><span class='Ref_To_Local'>non_group_cols</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5040"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Pull out all the Vars mentioned in non-group cols (plus HAVING), and 
     * add them to the input target if not already present.  (A Var used 
     * directly as a GROUP BY item will be present already.)  Note this 
     * includes Vars used in resjunk items, so we are covering the needs of 
     * ORDER BY and window specifications.  Vars used within Aggrefs and 
     * WindowFuncs will be pulled out here, too. 
     */ 
</span>    <a href="planner.c.html#LN5043"><span class='Ref_To_Local'>non_group_vars</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/var.h.html#LN36"><span class='Ref_to_Proto'>pull_var_clause</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN5042"><span class='Ref_To_Local'>non_group_cols</span></a><span class='Delimiter'>, 
</span>                                     <a href="../../../include/optimizer/var.h.html#LN20"><span class='Ref_to_Const'>PVC_RECURSE_AGGREGATES</span></a> <span class='Operator'>| 
</span>                                     <a href="../../../include/optimizer/var.h.html#LN22"><span class='Ref_to_Const'>PVC_RECURSE_WINDOWFUNCS</span></a> <span class='Operator'>| 
</span>                                     <a href="../../../include/optimizer/var.h.html#LN23"><span class='Ref_to_Const'>PVC_INCLUDE_PLACEHOLDERS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/optimizer/tlist.h.html#LN61"><span class='Ref_to_Proto'>add_new_columns_to_pathtarget</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5041"><span class='Ref_To_Local'>input_target</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5043"><span class='Ref_To_Local'>non_group_vars</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* clean up cruft */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN265"><span class='Ref_to_Proto'>list_free</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5043"><span class='Ref_To_Local'>non_group_vars</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN265"><span class='Ref_to_Proto'>list_free</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5042"><span class='Ref_To_Local'>non_group_cols</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* XXX this causes some redundant cost calculation ... */ 
</span>    <span class='Control'>return</span> <a href="../../../include/optimizer/cost.h.html#LN189"><span class='Ref_to_Proto'>set_pathtarget_cost_width</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5038"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5041"><span class='Ref_To_Local'>input_target</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end make_group_input_target &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * make_partial_grouping_target 
 *    Generate appropriate PathTarget for output of partial aggregate 
 *    (or partial grouping, if there are no aggregates) nodes. 
 * 
 * A partial aggregation node needs to emit all the same aggregates that 
 * a regular aggregation node would, plus any aggregates used in HAVING; 
 * except that the Aggref nodes should be marked as partial aggregates. 
 * 
 * In addition, we'd better emit any Vars and PlaceholderVars that are 
 * used outside of Aggrefs in the aggregation tlist and HAVING.  (Presumably, 
 * these would be Vars that are grouped by or used in grouping expressions.) 
 * 
 * grouping_target is the tlist to be emitted by the topmost aggregation step. 
 * We get the HAVING clause out of *root. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>* 
</span><a name="LN5125"></a><span class='Declare_Function'>make_partial_grouping_target</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>grouping_target</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN5127"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>parse</span> <span class='Operator'>= </span><a href="planner.c.html#LN5125"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Delimiter'>; 
</span><a name="LN5128"></a>    <a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Local'>partial_target</span><span class='Delimiter'>; 
</span><a name="LN5129"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>non_group_cols</span><span class='Delimiter'>; 
</span><a name="LN5130"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>non_group_exprs</span><span class='Delimiter'>; 
</span><a name="LN5131"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN5132"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <a href="planner.c.html#LN5128"><span class='Ref_To_Local'>partial_target</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/tlist.h.html#LN57"><span class='Ref_to_Proto'>create_empty_pathtarget</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN5129"><span class='Ref_To_Local'>non_group_cols</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <a href="planner.c.html#LN5131"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5132"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5125"><span class='Ref_to_Parameter'>grouping_target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN5140"></a>        <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5132"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN5141"></a>        <a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Local'>sgref</span> <span class='Operator'>= </span><a href="../../../include/nodes/relation.h.html#LN889"><span class='Ref_to_Macro'>get_pathtarget_sortgroupref</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5125"><span class='Ref_to_Parameter'>grouping_target</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5131"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN5141"><span class='Ref_To_Local'>sgref</span></a> <span class='Operator'>&& </span><a href="planner.c.html#LN5127"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a> <span class='Operator'>&& 
</span>            <a href="../../../include/optimizer/tlist.h.html#LN46"><span class='Ref_to_Proto'>get_sortgroupref_clause_noerr</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5141"><span class='Ref_To_Local'>sgref</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5127"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * It's a grouping column, so add it to the partial_target as-is. 
             * (This allows the upper agg step to repeat the grouping calcs.) 
             */ 
</span>            <a href="../../../include/optimizer/tlist.h.html#LN58"><span class='Ref_to_Proto'>add_column_to_pathtarget</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5128"><span class='Ref_To_Local'>partial_target</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5140"><span class='Ref_To_Local'>expr</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5141"><span class='Ref_To_Local'>sgref</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Non-grouping column, so just remember the expression for later 
             * call to pull_var_clause. 
             */ 
</span>            <a href="planner.c.html#LN5129"><span class='Ref_To_Local'>non_group_cols</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5129"><span class='Ref_To_Local'>non_group_cols</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5140"><span class='Ref_To_Local'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="planner.c.html#LN5131"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If there's a HAVING clause, we'll need the Vars/Aggrefs it uses, too. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN5127"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a><span class='Parentheses'>) 
</span>        <a href="planner.c.html#LN5129"><span class='Ref_To_Local'>non_group_cols</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5129"><span class='Ref_To_Local'>non_group_cols</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5127"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Pull out all the Vars, PlaceHolderVars, and Aggrefs mentioned in 
     * non-group cols (plus HAVING), and add them to the partial_target if not 
     * already present.  (An expression used directly as a GROUP BY item will 
     * be present already.)  Note this includes Vars used in resjunk items, so 
     * we are covering the needs of ORDER BY and window specifications. 
     */ 
</span>    <a href="planner.c.html#LN5130"><span class='Ref_To_Local'>non_group_exprs</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/var.h.html#LN36"><span class='Ref_to_Proto'>pull_var_clause</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN5129"><span class='Ref_To_Local'>non_group_cols</span></a><span class='Delimiter'>, 
</span>                                      <a href="../../../include/optimizer/var.h.html#LN19"><span class='Ref_to_Const'>PVC_INCLUDE_AGGREGATES</span></a> <span class='Operator'>| 
</span>                                      <a href="../../../include/optimizer/var.h.html#LN22"><span class='Ref_to_Const'>PVC_RECURSE_WINDOWFUNCS</span></a> <span class='Operator'>| 
</span>                                      <a href="../../../include/optimizer/var.h.html#LN23"><span class='Ref_to_Const'>PVC_INCLUDE_PLACEHOLDERS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/optimizer/tlist.h.html#LN61"><span class='Ref_to_Proto'>add_new_columns_to_pathtarget</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5128"><span class='Ref_To_Local'>partial_target</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5130"><span class='Ref_To_Local'>non_group_exprs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Adjust Aggrefs to put them in partial mode.  At this point all Aggrefs 
     * are at the top level of the target list, so we can just scan the list 
     * rather than recursing through the expression trees. 
     */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5132"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5128"><span class='Ref_To_Local'>partial_target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN5191"></a>        <a href="../../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>aggref</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5132"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5191"><span class='Ref_To_Local'>aggref</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN5195"></a>            <a href="../../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>newaggref</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * We shouldn't need to copy the substructure of the Aggref node, 
             * but flat-copy the node itself to avoid damaging other trees. 
             */ 
</span>            <a href="planner.c.html#LN5195"><span class='Ref_To_Local'>newaggref</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            memcpy<span class='Parentheses'>(</span><a href="planner.c.html#LN5195"><span class='Ref_To_Local'>newaggref</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5191"><span class='Ref_To_Local'>aggref</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* For now, assume serialization is required */ 
</span>            <a href="../../../include/optimizer/planner.h.html#LN48"><span class='Ref_to_Proto'>mark_partial_aggref</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5195"><span class='Ref_To_Local'>newaggref</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN760"><span class='Ref_to_EnumConst'>AGGSPLIT_INITIAL_SERIAL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5132"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="planner.c.html#LN5195"><span class='Ref_To_Local'>newaggref</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* clean up cruft */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN265"><span class='Ref_to_Proto'>list_free</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5130"><span class='Ref_To_Local'>non_group_exprs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN265"><span class='Ref_to_Proto'>list_free</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5129"><span class='Ref_To_Local'>non_group_cols</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* XXX this causes some redundant cost calculation ... */ 
</span>    <span class='Control'>return</span> <a href="../../../include/optimizer/cost.h.html#LN189"><span class='Ref_to_Proto'>set_pathtarget_cost_width</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5125"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5128"><span class='Ref_To_Local'>partial_target</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end make_partial_grouping_target &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * mark_partial_aggref 
 *    Adjust an Aggref to make it represent a partial-aggregation step. 
 * 
 * The Aggref node is modified in-place; caller must do any copying required. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN5226"></a><span class='Declare_Function'>mark_partial_aggref</span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>agg</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN755"><span class='Ref_to_Enum'>AggSplit</span></a> <span class='Declare_Parameter'>aggsplit</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* aggtranstype should be computed by this point */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5226"><span class='Ref_to_Parameter'>agg</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN297"><span class='Ref_to_Member'>aggtranstype</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* ... but aggsplit should still be as the parser left it */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="planner.c.html#LN5226"><span class='Ref_to_Parameter'>agg</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN309"><span class='Ref_to_Member'>aggsplit</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN758"><span class='Ref_to_EnumConst'>AGGSPLIT_SIMPLE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Mark the Aggref with the intended partial-aggregation mode */ 
</span>    <a href="planner.c.html#LN5226"><span class='Ref_to_Parameter'>agg</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN309"><span class='Ref_to_Member'>aggsplit</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN5226"><span class='Ref_to_Parameter'>aggsplit</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Adjust result type if needed.  Normally, a partial aggregate returns 
     * the aggregate's transition type; but if that's INTERNAL and we're 
     * serializing, it returns BYTEA instead. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN767"><span class='Ref_to_Macro'>DO_AGGSPLIT_SKIPFINAL</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5226"><span class='Ref_to_Parameter'>aggsplit</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN5226"><span class='Ref_to_Parameter'>agg</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN297"><span class='Ref_to_Member'>aggtranstype</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_type.h.html#LN697"><span class='Ref_to_Const'>INTERNALOID</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN768"><span class='Ref_to_Macro'>DO_AGGSPLIT_SERIALIZE</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5226"><span class='Ref_to_Parameter'>aggsplit</span></a><span class='Parentheses'>))</span> 
            <a href="planner.c.html#LN5226"><span class='Ref_to_Parameter'>agg</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN294"><span class='Ref_to_Member'>aggtype</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN18"><span class='Ref_to_Const'>BYTEAOID</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="planner.c.html#LN5226"><span class='Ref_to_Parameter'>agg</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN294"><span class='Ref_to_Member'>aggtype</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN5226"><span class='Ref_to_Parameter'>agg</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN297"><span class='Ref_to_Member'>aggtranstype</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end mark_partial_aggref &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * postprocess_setop_tlist 
 *    Fix up targetlist returned by plan_set_operations(). 
 * 
 * We need to transpose sort key info from the orig_tlist into new_tlist. 
 * NOTE: this would not be good enough if we supported resjunk sort keys 
 * for results of set operations --- then, we'd need to project a whole 
 * new tlist to evaluate the resjunk columns.  For now, just ereport if we 
 * find any resjunk columns in orig_tlist. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN5261"></a><span class='Declare_Function'>postprocess_setop_tlist</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>new_tlist</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>orig_tlist</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN5263"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span><a name="LN5264"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>orig_tlist_item</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5261"><span class='Ref_to_Parameter'>orig_tlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5263"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5261"><span class='Ref_to_Parameter'>new_tlist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN5268"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>new_tle</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5263"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN5269"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>orig_tle</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* ignore resjunk columns in setop result */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN5268"><span class='Ref_To_Local'>new_tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1373"><span class='Ref_to_Member'>resjunk</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="planner.c.html#LN5264"><span class='Ref_To_Local'>orig_tlist_item</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN5269"><span class='Ref_To_Local'>orig_tle</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5264"><span class='Ref_To_Local'>orig_tlist_item</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN5264"><span class='Ref_To_Local'>orig_tlist_item</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5264"><span class='Ref_To_Local'>orig_tlist_item</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN5269"><span class='Ref_To_Local'>orig_tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1373"><span class='Ref_to_Member'>resjunk</span></a><span class='Parentheses'>)</span>  <span class='Comment_Single_Line'>/* should not happen */ 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"resjunk output columns are not implemented"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="planner.c.html#LN5268"><span class='Ref_To_Local'>new_tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1367"><span class='Ref_to_Member'>resno</span></a> <span class='Operator'>== </span><a href="planner.c.html#LN5269"><span class='Ref_To_Local'>orig_tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1367"><span class='Ref_to_Member'>resno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN5268"><span class='Ref_To_Local'>new_tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1369"><span class='Ref_to_Member'>ressortgroupref</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN5269"><span class='Ref_To_Local'>orig_tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1369"><span class='Ref_to_Member'>ressortgroupref</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN5264"><span class='Ref_To_Local'>orig_tlist_item</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"resjunk output columns are not implemented"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="planner.c.html#LN5261"><span class='Ref_to_Parameter'>new_tlist</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end postprocess_setop_tlist &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * select_active_windows 
 *      Create a list of the "active" window clauses (ie, those referenced 
 *      by non-deleted WindowFuncs) in the order they are to be executed. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN5294"></a><span class='Declare_Function'>select_active_windows</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/optimizer/clauses.h.html#LN22"><span class='Ref_to_Typedef'>WindowFuncLists</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>wflists</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN5296"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span><a name="LN5297"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>actives</span><span class='Delimiter'>; 
</span><a name="LN5298"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* First, make a list of the active windows */ 
</span>    <a href="planner.c.html#LN5297"><span class='Ref_To_Local'>actives</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5298"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5294"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN151"><span class='Ref_to_Member'>windowClause</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN5304"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN1252"><span class='Ref_to_Struct'>WindowClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>wc</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1252"><span class='Ref_to_Struct'>WindowClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5298"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* It's only active if wflists shows some related WindowFuncs */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="planner.c.html#LN5304"><span class='Ref_To_Local'>wc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1262"><span class='Ref_to_Member'>winref</span></a> <span class='Operator'>&LT;= </span><a href="planner.c.html#LN5294"><span class='Ref_to_Parameter'>wflists</span></a><span class='Operator'>-&GT;</span><a href="../../../include/optimizer/clauses.h.html#LN25"><span class='Ref_to_Member'>maxWinRef</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN5294"><span class='Ref_to_Parameter'>wflists</span></a><span class='Operator'>-&GT;</span><a href="../../../include/optimizer/clauses.h.html#LN26"><span class='Ref_to_Member'>windowFuncs</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN5304"><span class='Ref_To_Local'>wc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1262"><span class='Ref_to_Member'>winref</span></a><span class='Delimiter'>] </span><span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>            <a href="planner.c.html#LN5297"><span class='Ref_To_Local'>actives</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5297"><span class='Ref_To_Local'>actives</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5304"><span class='Ref_To_Local'>wc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now, ensure that windows with identical partitioning/ordering clauses 
     * are adjacent in the list.  This is required by the SQL standard, which 
     * says that only one sort is to be used for such windows, even if they 
     * are otherwise distinct (eg, different names or framing clauses). 
     * 
     * There is room to be much smarter here, for example detecting whether 
     * one window's sort keys are a prefix of another's (so that sorting for 
     * the latter would do for the former), or putting windows first that 
     * match a sort order available for the underlying query.  For the moment 
     * we are content with meeting the spec. 
     */ 
</span>    <a href="planner.c.html#LN5296"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN5297"><span class='Ref_To_Local'>actives</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN5327"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN1252"><span class='Ref_to_Struct'>WindowClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>wc</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1252"><span class='Ref_to_Struct'>WindowClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5297"><span class='Ref_To_Local'>actives</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN5328"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>prev</span><span class='Delimiter'>; 
</span><a name="LN5329"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>next</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Move wc from actives to result */ 
</span>        <a href="planner.c.html#LN5297"><span class='Ref_To_Local'>actives</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN237"><span class='Ref_to_Proto'>list_delete_first</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5297"><span class='Ref_To_Local'>actives</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="planner.c.html#LN5296"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5296"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5327"><span class='Ref_To_Local'>wc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Now move any matching windows from actives to result */ 
</span>        <a href="planner.c.html#LN5328"><span class='Ref_To_Local'>prev</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN5298"><span class='Ref_To_Local'>lc</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5297"><span class='Ref_To_Local'>actives</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; </span><a href="planner.c.html#LN5298"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>; </span><a href="planner.c.html#LN5298"><span class='Ref_To_Local'>lc</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN5329"><span class='Ref_To_Local'>next</span></a><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span><a name="LN5339"></a>            <a href="../../../include/nodes/parsenodes.h.html#LN1252"><span class='Ref_to_Struct'>WindowClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>wc2</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1252"><span class='Ref_to_Struct'>WindowClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5298"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="planner.c.html#LN5329"><span class='Ref_To_Local'>next</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5298"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* framing options are NOT to be compared here! */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN626"><span class='Ref_to_Proto'>equal</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5327"><span class='Ref_To_Local'>wc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1257"><span class='Ref_to_Member'>partitionClause</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5339"><span class='Ref_To_Local'>wc2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1257"><span class='Ref_to_Member'>partitionClause</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                <a href="../../../include/nodes/nodes.h.html#LN626"><span class='Ref_to_Proto'>equal</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5327"><span class='Ref_To_Local'>wc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1258"><span class='Ref_to_Member'>orderClause</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5339"><span class='Ref_To_Local'>wc2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1258"><span class='Ref_to_Member'>orderClause</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="planner.c.html#LN5297"><span class='Ref_To_Local'>actives</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN238"><span class='Ref_to_Proto'>list_delete_cell</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5297"><span class='Ref_To_Local'>actives</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5298"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5328"><span class='Ref_To_Local'>prev</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="planner.c.html#LN5296"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5296"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5339"><span class='Ref_To_Local'>wc2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
                <a href="planner.c.html#LN5328"><span class='Ref_To_Local'>prev</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN5298"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while actives!=NIL &raquo; </span> 
 
    <span class='Control'>return</span> <a href="planner.c.html#LN5296"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end select_active_windows &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * make_window_input_target 
 *    Generate appropriate PathTarget for initial input to WindowAgg nodes. 
 * 
 * When the query has window functions, this function computes the desired 
 * target to be computed by the node just below the first WindowAgg. 
 * This tlist must contain all values needed to evaluate the window functions, 
 * compute the final target list, and perform any required final sort step. 
 * If multiple WindowAggs are needed, each intermediate one adds its window 
 * function results onto this base tlist; only the topmost WindowAgg computes 
 * the actual desired target list. 
 * 
 * This function is much like make_group_input_target, though not quite enough 
 * like it to share code.  As in that function, we flatten most expressions 
 * into their component variables.  But we do not want to flatten window 
 * PARTITION BY/ORDER BY clauses, since that might result in multiple 
 * evaluations of them, which would be bad (possibly even resulting in 
 * inconsistent answers, if they contain volatile functions). 
 * Also, we must not flatten GROUP BY clauses that were left unflattened by 
 * make_group_input_target, because we may no longer have access to the 
 * individual Vars in them. 
 * 
 * Another key difference from make_group_input_target is that we don't 
 * flatten Aggref expressions, since those are to be computed below the 
 * window functions and just referenced like Vars above that. 
 * 
 * 'final_target' is the query's final target list (in PathTarget form) 
 * 'activeWindows' is the list of active windows previously identified by 
 *          select_active_windows. 
 * 
 * The result is the PathTarget to be computed by the plan node immediately 
 * below the first WindowAgg node. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>* 
</span><a name="LN5391"></a><span class='Declare_Function'>make_window_input_target</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN5392"></a>                         <a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>final_target</span><span class='Delimiter'>, 
</span><a name="LN5393"></a>                         <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>activeWindows</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN5395"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>parse</span> <span class='Operator'>= </span><a href="planner.c.html#LN5391"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Delimiter'>; 
</span><a name="LN5396"></a>    <a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Local'>input_target</span><span class='Delimiter'>; 
</span><a name="LN5397"></a>    <a href="../../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>sgrefs</span><span class='Delimiter'>; 
</span><a name="LN5398"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>flattenable_cols</span><span class='Delimiter'>; 
</span><a name="LN5399"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>flattenable_vars</span><span class='Delimiter'>; 
</span><a name="LN5400"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN5401"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="planner.c.html#LN5395"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN123"><span class='Ref_to_Member'>hasWindowFuncs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Collect the sortgroupref numbers of window PARTITION/ORDER BY clauses 
     * into a bitmapset for convenient reference below. 
     */ 
</span>    <a href="planner.c.html#LN5397"><span class='Ref_To_Local'>sgrefs</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5401"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5393"><span class='Ref_to_Parameter'>activeWindows</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN5412"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN1252"><span class='Ref_to_Struct'>WindowClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>wc</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1252"><span class='Ref_to_Struct'>WindowClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5401"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN5413"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc2</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5413"><span class='Ref_To_Local'>lc2</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5412"><span class='Ref_To_Local'>wc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1257"><span class='Ref_to_Member'>partitionClause</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN5417"></a>            <a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sortcl</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5413"><span class='Ref_To_Local'>lc2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="planner.c.html#LN5397"><span class='Ref_To_Local'>sgrefs</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN89"><span class='Ref_to_Proto'>bms_add_member</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5397"><span class='Ref_To_Local'>sgrefs</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5417"><span class='Ref_To_Local'>sortcl</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1164"><span class='Ref_to_Member'>tleSortGroupRef</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5413"><span class='Ref_To_Local'>lc2</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5412"><span class='Ref_To_Local'>wc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1258"><span class='Ref_to_Member'>orderClause</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN5423"></a>            <a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sortcl</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5413"><span class='Ref_To_Local'>lc2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="planner.c.html#LN5397"><span class='Ref_To_Local'>sgrefs</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN89"><span class='Ref_to_Proto'>bms_add_member</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5397"><span class='Ref_To_Local'>sgrefs</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5423"><span class='Ref_To_Local'>sortcl</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1164"><span class='Ref_to_Member'>tleSortGroupRef</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Add in sortgroupref numbers of GROUP BY clauses, too */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5401"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5395"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN5432"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>grpcl</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5401"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="planner.c.html#LN5397"><span class='Ref_To_Local'>sgrefs</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN89"><span class='Ref_to_Proto'>bms_add_member</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5397"><span class='Ref_To_Local'>sgrefs</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5432"><span class='Ref_To_Local'>grpcl</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1164"><span class='Ref_to_Member'>tleSortGroupRef</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Construct a target containing all the non-flattenable targetlist items, 
     * and save aside the others for a moment. 
     */ 
</span>    <a href="planner.c.html#LN5396"><span class='Ref_To_Local'>input_target</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/tlist.h.html#LN57"><span class='Ref_to_Proto'>create_empty_pathtarget</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN5398"><span class='Ref_To_Local'>flattenable_cols</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <a href="planner.c.html#LN5400"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5401"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5392"><span class='Ref_to_Parameter'>final_target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN5447"></a>        <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5401"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN5448"></a>        <a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Local'>sgref</span> <span class='Operator'>= </span><a href="../../../include/nodes/relation.h.html#LN889"><span class='Ref_to_Macro'>get_pathtarget_sortgroupref</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5392"><span class='Ref_to_Parameter'>final_target</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5400"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Don't want to deconstruct window clauses or GROUP BY items.  (Note 
         * that such items can't contain window functions, so it's okay to 
         * compute them below the WindowAgg nodes.) 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN5448"><span class='Ref_To_Local'>sgref</span></a> <span class='Operator'>!= </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="../../../include/nodes/bitmapset.h.html#LN75"><span class='Ref_to_Proto'>bms_is_member</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5448"><span class='Ref_To_Local'>sgref</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5397"><span class='Ref_To_Local'>sgrefs</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Don't want to deconstruct this value, so add it to the input 
             * target as-is. 
             */ 
</span>            <a href="../../../include/optimizer/tlist.h.html#LN58"><span class='Ref_to_Proto'>add_column_to_pathtarget</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5396"><span class='Ref_To_Local'>input_target</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5447"><span class='Ref_To_Local'>expr</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5448"><span class='Ref_To_Local'>sgref</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Column is to be flattened, so just remember the expression for 
             * later call to pull_var_clause. 
             */ 
</span>            <a href="planner.c.html#LN5398"><span class='Ref_To_Local'>flattenable_cols</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5398"><span class='Ref_To_Local'>flattenable_cols</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5447"><span class='Ref_To_Local'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="planner.c.html#LN5400"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Pull out all the Vars and Aggrefs mentioned in flattenable columns, and 
     * add them to the input target if not already present.  (Some might be 
     * there already because they're used directly as window/group clauses.) 
     * 
     * Note: it's essential to use PVC_INCLUDE_AGGREGATES here, so that any 
     * Aggrefs are placed in the Agg node's tlist and not left to be computed 
     * at higher levels.  On the other hand, we should recurse into 
     * WindowFuncs to make sure their input expressions are available. 
     */ 
</span>    <a href="planner.c.html#LN5399"><span class='Ref_To_Local'>flattenable_vars</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/var.h.html#LN36"><span class='Ref_to_Proto'>pull_var_clause</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN5398"><span class='Ref_To_Local'>flattenable_cols</span></a><span class='Delimiter'>, 
</span>                                       <a href="../../../include/optimizer/var.h.html#LN19"><span class='Ref_to_Const'>PVC_INCLUDE_AGGREGATES</span></a> <span class='Operator'>| 
</span>                                       <a href="../../../include/optimizer/var.h.html#LN22"><span class='Ref_to_Const'>PVC_RECURSE_WINDOWFUNCS</span></a> <span class='Operator'>| 
</span>                                       <a href="../../../include/optimizer/var.h.html#LN23"><span class='Ref_to_Const'>PVC_INCLUDE_PLACEHOLDERS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/optimizer/tlist.h.html#LN61"><span class='Ref_to_Proto'>add_new_columns_to_pathtarget</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5396"><span class='Ref_To_Local'>input_target</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5399"><span class='Ref_To_Local'>flattenable_vars</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* clean up cruft */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN265"><span class='Ref_to_Proto'>list_free</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5399"><span class='Ref_To_Local'>flattenable_vars</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN265"><span class='Ref_to_Proto'>list_free</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5398"><span class='Ref_To_Local'>flattenable_cols</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* XXX this causes some redundant cost calculation ... */ 
</span>    <span class='Control'>return</span> <a href="../../../include/optimizer/cost.h.html#LN189"><span class='Ref_to_Proto'>set_pathtarget_cost_width</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5391"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5396"><span class='Ref_To_Local'>input_target</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end make_window_input_target &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * make_pathkeys_for_window 
 *      Create a pathkeys list describing the required input ordering 
 *      for the given WindowClause. 
 * 
 * The required ordering is first the PARTITION keys, then the ORDER keys. 
 * In the future we might try to implement windowing using hashing, in which 
 * case the ordering could be relaxed, but for now we always sort. 
 * 
 * Caution: if you change this, see createplan.c's get_column_info_for_window! 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN5511"></a><span class='Declare_Function'>make_pathkeys_for_window</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN1252"><span class='Ref_to_Struct'>WindowClause</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>wc</span><span class='Delimiter'>, 
</span><a name="LN5512"></a>                         <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tlist</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN5514"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>window_pathkeys</span><span class='Delimiter'>; 
</span><a name="LN5515"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>window_sortclauses</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Throw error if can't sort */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/optimizer/tlist.h.html#LN51"><span class='Ref_to_Proto'>grouping_is_sortable</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5511"><span class='Ref_to_Parameter'>wc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1257"><span class='Ref_to_Member'>partitionClause</span></a><span class='Parentheses'>))</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not implement window PARTITION BY"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"Window partitioning columns must be of sortable datatypes."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/optimizer/tlist.h.html#LN51"><span class='Ref_to_Proto'>grouping_is_sortable</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5511"><span class='Ref_to_Parameter'>wc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1258"><span class='Ref_to_Member'>orderClause</span></a><span class='Parentheses'>))</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not implement window ORDER BY"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>        <a href="../../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"Window ordering columns must be of sortable datatypes."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Okay, make the combined pathkeys */ 
</span>    <a href="planner.c.html#LN5515"><span class='Ref_To_Local'>window_sortclauses</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN268"><span class='Ref_to_Proto'>list_copy</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5511"><span class='Ref_to_Parameter'>wc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1257"><span class='Ref_to_Member'>partitionClause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                     <a href="../../../include/nodes/pg_list.h.html#LN268"><span class='Ref_to_Proto'>list_copy</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5511"><span class='Ref_to_Parameter'>wc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1258"><span class='Ref_to_Member'>orderClause</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN5514"><span class='Ref_To_Local'>window_pathkeys</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/paths.h.html#LN205"><span class='Ref_to_Proto'>make_pathkeys_for_sortclauses</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5511"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                    <a href="planner.c.html#LN5515"><span class='Ref_To_Local'>window_sortclauses</span></a><span class='Delimiter'>, 
</span>                                                    <a href="planner.c.html#LN5512"><span class='Ref_to_Parameter'>tlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN265"><span class='Ref_to_Proto'>list_free</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5515"><span class='Ref_To_Local'>window_sortclauses</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="planner.c.html#LN5514"><span class='Ref_To_Local'>window_pathkeys</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end make_pathkeys_for_window &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * make_sort_input_target 
 *    Generate appropriate PathTarget for initial input to Sort step. 
 * 
 * If the query has ORDER BY, this function chooses the target to be computed 
 * by the node just below the Sort (and DISTINCT, if any, since Unique can't 
 * project) steps.  This might or might not be identical to the query's final 
 * output target. 
 * 
 * The main argument for keeping the sort-input tlist the same as the final 
 * is that we avoid a separate projection node (which will be needed if 
 * they're different, because Sort can't project).  However, there are also 
 * advantages to postponing tlist evaluation till after the Sort: it ensures 
 * a consistent order of evaluation for any volatile functions in the tlist, 
 * and if there's also a LIMIT, we can stop the query without ever computing 
 * tlist functions for later rows, which is beneficial for both volatile and 
 * expensive functions. 
 * 
 * Our current policy is to postpone volatile expressions till after the sort 
 * unconditionally (assuming that that's possible, ie they are in plain tlist 
 * columns and not ORDER BY/GROUP BY/DISTINCT columns).  We also prefer to 
 * postpone set-returning expressions, because running them beforehand would 
 * bloat the sort dataset, and because it might cause unexpected output order 
 * if the sort isn't stable.  However there's a constraint on that: all SRFs 
 * in the tlist should be evaluated at the same plan step, so that they can 
 * run in sync in nodeProjectSet.  So if any SRFs are in sort columns, we 
 * mustn't postpone any SRFs.  (Note that in principle that policy should 
 * probably get applied to the group/window input targetlists too, but we 
 * have not done that historically.)  Lastly, expensive expressions are 
 * postponed if there is a LIMIT, or if root-&GT;tuple_fraction shows that 
 * partial evaluation of the query is possible (if neither is true, we expect 
 * to have to evaluate the expressions for every row anyway), or if there are 
 * any volatile or set-returning expressions (since once we've put in a 
 * projection at all, it won't cost any more to postpone more stuff). 
 * 
 * Another issue that could potentially be considered here is that 
 * evaluating tlist expressions could result in data that's either wider 
 * or narrower than the input Vars, thus changing the volume of data that 
 * has to go through the Sort.  However, we usually have only a very bad 
 * idea of the output width of any expression more complex than a Var, 
 * so for now it seems too risky to try to optimize on that basis. 
 * 
 * Note that if we do produce a modified sort-input target, and then the 
 * query ends up not using an explicit Sort, no particular harm is done: 
 * we'll initially use the modified target for the preceding path nodes, 
 * but then change them to the final target with apply_projection_to_path. 
 * Moreover, in such a case the guarantees about evaluation order of 
 * volatile functions still hold, since the rows are sorted already. 
 * 
 * This function has some things in common with make_group_input_target and 
 * make_window_input_target, though the detailed rules for what to do are 
 * different.  We never flatten/postpone any grouping or ordering columns; 
 * those are needed before the sort.  If we do flatten a particular 
 * expression, we leave Aggref and WindowFunc nodes alone, since those were 
 * computed earlier. 
 * 
 * 'final_target' is the query's final target list (in PathTarget form) 
 * 'have_postponed_srfs' is an output argument, see below 
 * 
 * The result is the PathTarget to be computed by the plan node immediately 
 * below the Sort step (and the Distinct step, if any).  This will be 
 * exactly final_target if we decide a projection step wouldn't be helpful. 
 * 
 * In addition, *have_postponed_srfs is set to TRUE if we choose to postpone 
 * any set-returning functions to after the Sort. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>* 
</span><a name="LN5606"></a><span class='Declare_Function'>make_sort_input_target</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN5607"></a>                       <a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>final_target</span><span class='Delimiter'>, 
</span><a name="LN5608"></a>                       <span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>have_postponed_srfs</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN5610"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>parse</span> <span class='Operator'>= </span><a href="planner.c.html#LN5606"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Delimiter'>; 
</span><a name="LN5611"></a>    <a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Local'>input_target</span><span class='Delimiter'>; 
</span><a name="LN5612"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>ncols</span><span class='Delimiter'>; 
</span><a name="LN5613"></a>    <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Local'>col_is_srf</span><span class='Delimiter'>; 
</span><a name="LN5614"></a>    <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Local'>postpone_col</span><span class='Delimiter'>; 
</span><a name="LN5615"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>have_srf</span><span class='Delimiter'>; 
</span><a name="LN5616"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>have_volatile</span><span class='Delimiter'>; 
</span><a name="LN5617"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>have_expensive</span><span class='Delimiter'>; 
</span><a name="LN5618"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>have_srf_sortcols</span><span class='Delimiter'>; 
</span><a name="LN5619"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>postpone_srfs</span><span class='Delimiter'>; 
</span><a name="LN5620"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>postponable_cols</span><span class='Delimiter'>; 
</span><a name="LN5621"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>postponable_vars</span><span class='Delimiter'>; 
</span><a name="LN5622"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN5623"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Shouldn't get here unless query has ORDER BY */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="planner.c.html#LN5610"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN155"><span class='Ref_to_Member'>sortClause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Operator'>*</span><a href="planner.c.html#LN5608"><span class='Ref_to_Parameter'>have_postponed_srfs</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* default result */ 
</span> 
    <span class='Comment_Multi_Line'>/* Inspect tlist and collect per-column information */ 
</span>    <a href="planner.c.html#LN5612"><span class='Ref_To_Local'>ncols</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5607"><span class='Ref_to_Parameter'>final_target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN5613"><span class='Ref_To_Local'>col_is_srf</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5612"><span class='Ref_To_Local'>ncols</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>bool</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN5614"><span class='Ref_To_Local'>postpone_col</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5612"><span class='Ref_To_Local'>ncols</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>bool</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN5615"><span class='Ref_To_Local'>have_srf</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN5616"><span class='Ref_To_Local'>have_volatile</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN5617"><span class='Ref_To_Local'>have_expensive</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN5618"><span class='Ref_To_Local'>have_srf_sortcols</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <a href="planner.c.html#LN5622"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5623"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5607"><span class='Ref_to_Parameter'>final_target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN5639"></a>        <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5623"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If the column has a sortgroupref, assume it has to be evaluated 
         * before sorting.  Generally such columns would be ORDER BY, GROUP 
         * BY, etc targets.  One exception is columns that were removed from 
         * GROUP BY by remove_useless_groupby_columns() ... but those would 
         * only be Vars anyway.  There don't seem to be any cases where it 
         * would be worth the trouble to double-check. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN889"><span class='Ref_to_Macro'>get_pathtarget_sortgroupref</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5607"><span class='Ref_to_Parameter'>final_target</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5622"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Check for SRF or volatile functions.  Check the SRF case first 
             * because we must know whether we have any postponed SRFs. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN5610"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN124"><span class='Ref_to_Member'>hasTargetSRFs</span></a> <span class='Operator'>&& 
</span>                <a href="../../../include/nodes/nodeFuncs.h.html#LN36"><span class='Ref_to_Proto'>expression_returns_set</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN5639"><span class='Ref_To_Local'>expr</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* We'll decide below whether these are postponable */ 
</span>                <a href="planner.c.html#LN5613"><span class='Ref_To_Local'>col_is_srf</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN5622"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <a href="planner.c.html#LN5615"><span class='Ref_To_Local'>have_srf</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/clauses.h.html#LN60"><span class='Ref_to_Proto'>contain_volatile_functions</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN5639"><span class='Ref_To_Local'>expr</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Unconditionally postpone */ 
</span>                <a href="planner.c.html#LN5614"><span class='Ref_To_Local'>postpone_col</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN5622"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <a href="planner.c.html#LN5616"><span class='Ref_To_Local'>have_volatile</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * Else check the cost.  XXX it's annoying to have to do this 
                 * when set_pathtarget_cost_width() just did it.  Refactor to 
                 * allow sharing the work? 
                 */ 
</span><a name="LN5675"></a>                <a href="../../../include/nodes/relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a>    <span class='Declare_Local'>cost</span><span class='Delimiter'>; 
</span> 
                <a href="../../../include/optimizer/cost.h.html#LN158"><span class='Ref_to_Proto'>cost_qual_eval_node</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="planner.c.html#LN5675"><span class='Ref_To_Local'>cost</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN5639"><span class='Ref_To_Local'>expr</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5606"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * We arbitrarily define "expensive" as "more than 10X 
                 * cpu_operator_cost".  Note this will take in any PL function 
                 * with default cost. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN5675"><span class='Ref_To_Local'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>&GT; </span><span class='Number'>10</span> <span class='Operator'>* </span><a href="../path/costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <a href="planner.c.html#LN5614"><span class='Ref_To_Local'>postpone_col</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN5622"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                    <a href="planner.c.html#LN5617"><span class='Ref_To_Local'>have_expensive</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if get_pathtarget_sortgr... &raquo; </span> 
        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* For sortgroupref cols, just check if any contain SRFs */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="planner.c.html#LN5618"><span class='Ref_To_Local'>have_srf_sortcols</span></a> <span class='Operator'>&& 
</span>                <a href="planner.c.html#LN5610"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN124"><span class='Ref_to_Member'>hasTargetSRFs</span></a> <span class='Operator'>&& 
</span>                <a href="../../../include/nodes/nodeFuncs.h.html#LN36"><span class='Ref_to_Proto'>expression_returns_set</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN5639"><span class='Ref_To_Local'>expr</span></a><span class='Parentheses'>))</span> 
                <a href="planner.c.html#LN5618"><span class='Ref_To_Local'>have_srf_sortcols</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="planner.c.html#LN5622"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We can postpone SRFs if we have some but none are in sortgroupref cols. 
     */ 
</span>    <a href="planner.c.html#LN5619"><span class='Ref_To_Local'>postpone_srfs</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="planner.c.html#LN5615"><span class='Ref_To_Local'>have_srf</span></a> <span class='Operator'>&& !</span><a href="planner.c.html#LN5618"><span class='Ref_To_Local'>have_srf_sortcols</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we don't need a post-sort projection, just return final_target. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="planner.c.html#LN5619"><span class='Ref_To_Local'>postpone_srfs</span></a> <span class='Operator'>|| </span><a href="planner.c.html#LN5616"><span class='Ref_To_Local'>have_volatile</span></a> <span class='Operator'>|| 
</span>          <span class='Parentheses'>(</span><a href="planner.c.html#LN5617"><span class='Ref_To_Local'>have_expensive</span></a> <span class='Operator'>&& 
</span>           <span class='Parentheses'>(</span><a href="planner.c.html#LN5610"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN158"><span class='Ref_to_Member'>limitCount</span></a> <span class='Operator'>|| </span><a href="planner.c.html#LN5606"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN290"><span class='Ref_to_Member'>tuple_fraction</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>))))</span> 
        <span class='Control'>return</span> <a href="planner.c.html#LN5607"><span class='Ref_to_Parameter'>final_target</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Report whether the post-sort projection will contain set-returning 
     * functions.  This is important because it affects whether the Sort can 
     * rely on the query's LIMIT (if any) to bound the number of rows it needs 
     * to return. 
     */ 
</span>    <span class='Operator'>*</span><a href="planner.c.html#LN5608"><span class='Ref_to_Parameter'>have_postponed_srfs</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN5619"><span class='Ref_To_Local'>postpone_srfs</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Construct the sort-input target, taking all non-postponable columns and 
     * then adding Vars, PlaceHolderVars, Aggrefs, and WindowFuncs found in 
     * the postponable ones. 
     */ 
</span>    <a href="planner.c.html#LN5611"><span class='Ref_To_Local'>input_target</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/tlist.h.html#LN57"><span class='Ref_to_Proto'>create_empty_pathtarget</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN5620"><span class='Ref_To_Local'>postponable_cols</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <a href="planner.c.html#LN5622"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5623"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5607"><span class='Ref_to_Parameter'>final_target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN5735"></a>        <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5623"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN5614"><span class='Ref_To_Local'>postpone_col</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN5622"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>|| </span><span class='Parentheses'>(</span><a href="planner.c.html#LN5619"><span class='Ref_To_Local'>postpone_srfs</span></a> <span class='Operator'>&& </span><a href="planner.c.html#LN5613"><span class='Ref_To_Local'>col_is_srf</span></a><span class='Delimiter'>[</span><a href="planner.c.html#LN5622"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>))</span> 
            <a href="planner.c.html#LN5620"><span class='Ref_To_Local'>postponable_cols</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5620"><span class='Ref_To_Local'>postponable_cols</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5735"><span class='Ref_To_Local'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="../../../include/optimizer/tlist.h.html#LN58"><span class='Ref_to_Proto'>add_column_to_pathtarget</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5611"><span class='Ref_To_Local'>input_target</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5735"><span class='Ref_To_Local'>expr</span></a><span class='Delimiter'>, 
</span>                               <a href="../../../include/nodes/relation.h.html#LN889"><span class='Ref_to_Macro'>get_pathtarget_sortgroupref</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5607"><span class='Ref_to_Parameter'>final_target</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5622"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <a href="planner.c.html#LN5622"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Pull out all the Vars, Aggrefs, and WindowFuncs mentioned in 
     * postponable columns, and add them to the sort-input target if not 
     * already present.  (Some might be there already.)  We mustn't 
     * deconstruct Aggrefs or WindowFuncs here, since the projection node 
     * would be unable to recompute them. 
     */ 
</span>    <a href="planner.c.html#LN5621"><span class='Ref_To_Local'>postponable_vars</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/var.h.html#LN36"><span class='Ref_to_Proto'>pull_var_clause</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN5620"><span class='Ref_To_Local'>postponable_cols</span></a><span class='Delimiter'>, 
</span>                                       <a href="../../../include/optimizer/var.h.html#LN19"><span class='Ref_to_Const'>PVC_INCLUDE_AGGREGATES</span></a> <span class='Operator'>| 
</span>                                       <a href="../../../include/optimizer/var.h.html#LN21"><span class='Ref_to_Const'>PVC_INCLUDE_WINDOWFUNCS</span></a> <span class='Operator'>| 
</span>                                       <a href="../../../include/optimizer/var.h.html#LN23"><span class='Ref_to_Const'>PVC_INCLUDE_PLACEHOLDERS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/optimizer/tlist.h.html#LN61"><span class='Ref_to_Proto'>add_new_columns_to_pathtarget</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5611"><span class='Ref_To_Local'>input_target</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5621"><span class='Ref_To_Local'>postponable_vars</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* clean up cruft */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN265"><span class='Ref_to_Proto'>list_free</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5621"><span class='Ref_To_Local'>postponable_vars</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN265"><span class='Ref_to_Proto'>list_free</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5620"><span class='Ref_To_Local'>postponable_cols</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* XXX this represents even more redundant cost calculation ... */ 
</span>    <span class='Control'>return</span> <a href="../../../include/optimizer/cost.h.html#LN189"><span class='Ref_to_Proto'>set_pathtarget_cost_width</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5606"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5611"><span class='Ref_To_Local'>input_target</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end make_sort_input_target &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * get_cheapest_fractional_path 
 *    Find the cheapest path for retrieving a specified fraction of all 
 *    the tuples expected to be returned by the given relation. 
 * 
 * We interpret tuple_fraction the same way as grouping_planner. 
 * 
 * We assume set_cheapest() has been run on the given rel. 
 */ 
</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>* 
</span><a name="LN5777"></a><span class='Declare_Function'>get_cheapest_fractional_path</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, </span><span class='Keyword'>double </span><span class='Declare_Parameter'>tuple_fraction</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN5779"></a>    <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>best_path</span> <span class='Operator'>= </span><a href="planner.c.html#LN5777"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN542"><span class='Ref_to_Member'>cheapest_total_path</span></a><span class='Delimiter'>; 
</span><a name="LN5780"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If all tuples will be retrieved, just return the cheapest-total path */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN5777"><span class='Ref_to_Parameter'>tuple_fraction</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="planner.c.html#LN5779"><span class='Ref_To_Local'>best_path</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Convert absolute # of tuples to a fraction; no need to clamp to 0..1 */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN5777"><span class='Ref_to_Parameter'>tuple_fraction</span></a> <span class='Operator'>&GT;= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="planner.c.html#LN5779"><span class='Ref_To_Local'>best_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="planner.c.html#LN5777"><span class='Ref_to_Parameter'>tuple_fraction</span></a> <span class='Operator'>/= </span><a href="planner.c.html#LN5779"><span class='Ref_To_Local'>best_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5780"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5777"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN538"><span class='Ref_to_Member'>pathlist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN5792"></a>        <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>path</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5780"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN5792"><span class='Ref_To_Local'>path</span></a> <span class='Operator'>== </span><a href="planner.c.html#LN5777"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN542"><span class='Ref_to_Member'>cheapest_total_path</span></a> <span class='Operator'>|| 
</span>         <a href="../../../include/optimizer/pathnode.h.html#LN24"><span class='Ref_to_Proto'>compare_fractional_path_costs</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5779"><span class='Ref_To_Local'>best_path</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5792"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5777"><span class='Ref_to_Parameter'>tuple_fraction</span></a><span class='Parentheses'>) </span><span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <a href="planner.c.html#LN5779"><span class='Ref_To_Local'>best_path</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN5792"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="planner.c.html#LN5779"><span class='Ref_To_Local'>best_path</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end get_cheapest_fractional_path &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * adjust_paths_for_srfs 
 *      Fix up the Paths of the given upperrel to handle tSRFs properly. 
 * 
 * The executor can only handle set-returning functions that appear at the 
 * top level of the targetlist of a ProjectSet plan node.  If we have any SRFs 
 * that are not at top level, we need to split up the evaluation into multiple 
 * plan levels in which each level satisfies this constraint.  This function 
 * modifies each Path of an upperrel that (might) compute any SRFs in its 
 * output tlist to insert appropriate projection steps. 
 * 
 * The given targets and targets_contain_srfs lists are from 
 * split_pathtarget_at_srfs().  We assume the existing Paths emit the first 
 * target in targets. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN5820"></a><span class='Declare_Function'>adjust_paths_for_srfs</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN5821"></a>                      <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>targets</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>targets_contain_srfs</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN5823"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5821"><span class='Ref_to_Parameter'>targets</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5821"><span class='Ref_to_Parameter'>targets_contain_srfs</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/pg_list.h.html#LN111"><span class='Ref_to_Macro'>linitial_int</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5821"><span class='Ref_to_Parameter'>targets_contain_srfs</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If no SRFs appear at this plan level, nothing to do */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5821"><span class='Ref_to_Parameter'>targets</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Stack SRF-evaluation nodes atop each path for the rel. 
     * 
     * In principle we should re-run set_cheapest() here to identify the 
     * cheapest path, but it seems unlikely that adding the same tlist eval 
     * costs to all the paths would change that, so we don't bother. Instead, 
     * just assume that the cheapest-startup and cheapest-total paths remain 
     * so.  (There should be no parameterized paths anymore, so we needn't 
     * worry about updating cheapest_parameterized_paths.) 
     */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5823"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5820"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN538"><span class='Ref_to_Member'>pathlist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN5844"></a>        <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>subpath</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5823"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN5845"></a>        <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>newpath</span> <span class='Operator'>= </span><a href="planner.c.html#LN5844"><span class='Ref_To_Local'>subpath</span></a><span class='Delimiter'>; 
</span><a name="LN5846"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc1</span><span class='Delimiter'>, 
</span><a name="LN5847"></a>                   <span class='Operator'>*</span><span class='Declare_Local'>lc2</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="planner.c.html#LN5844"><span class='Ref_To_Local'>subpath</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN955"><span class='Ref_to_Member'>param_info</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN179"><span class='Ref_to_Macro'>forboth</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5846"><span class='Ref_To_Local'>lc1</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5821"><span class='Ref_to_Parameter'>targets</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5847"><span class='Ref_To_Local'>lc2</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5821"><span class='Ref_to_Parameter'>targets_contain_srfs</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN5852"></a>            <a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Local'>thistarget</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5846"><span class='Ref_To_Local'>lc1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN5853"></a>            <span class='Keyword'>bool</span>        <span class='Declare_Local'>contains_srfs</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>bool</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN106"><span class='Ref_to_Macro'>lfirst_int</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5847"><span class='Ref_To_Local'>lc2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* If this level doesn't contain SRFs, do regular projection */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN5853"><span class='Ref_To_Local'>contains_srfs</span></a><span class='Parentheses'>) 
</span>                <a href="planner.c.html#LN5845"><span class='Ref_To_Local'>newpath</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/pathnode.h.html#LN161"><span class='Ref_to_Proto'>create_set_projection_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5820"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                              <a href="planner.c.html#LN5820"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, 
</span>                                                              <a href="planner.c.html#LN5845"><span class='Ref_To_Local'>newpath</span></a><span class='Delimiter'>, 
</span>                                                              <a href="planner.c.html#LN5852"><span class='Ref_To_Local'>thistarget</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="planner.c.html#LN5845"><span class='Ref_To_Local'>newpath</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/pathnode.h.html#LN157"><span class='Ref_to_Proto'>apply_projection_to_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5820"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                            <a href="planner.c.html#LN5820"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, 
</span>                                                            <a href="planner.c.html#LN5845"><span class='Ref_To_Local'>newpath</span></a><span class='Delimiter'>, 
</span>                                                            <a href="planner.c.html#LN5852"><span class='Ref_To_Local'>thistarget</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5823"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="planner.c.html#LN5845"><span class='Ref_To_Local'>newpath</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN5844"><span class='Ref_To_Local'>subpath</span></a> <span class='Operator'>== </span><a href="planner.c.html#LN5820"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN541"><span class='Ref_to_Member'>cheapest_startup_path</span></a><span class='Parentheses'>) 
</span>            <a href="planner.c.html#LN5820"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN541"><span class='Ref_to_Member'>cheapest_startup_path</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN5845"><span class='Ref_To_Local'>newpath</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN5844"><span class='Ref_To_Local'>subpath</span></a> <span class='Operator'>== </span><a href="planner.c.html#LN5820"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN542"><span class='Ref_to_Member'>cheapest_total_path</span></a><span class='Parentheses'>) 
</span>            <a href="planner.c.html#LN5820"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN542"><span class='Ref_to_Member'>cheapest_total_path</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN5845"><span class='Ref_To_Local'>newpath</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Likewise for partial paths, if any */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5823"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5820"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN540"><span class='Ref_to_Member'>partial_pathlist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN5877"></a>        <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>subpath</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5823"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN5878"></a>        <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>newpath</span> <span class='Operator'>= </span><a href="planner.c.html#LN5877"><span class='Ref_To_Local'>subpath</span></a><span class='Delimiter'>; 
</span><a name="LN5879"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc1</span><span class='Delimiter'>, 
</span><a name="LN5880"></a>                   <span class='Operator'>*</span><span class='Declare_Local'>lc2</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="planner.c.html#LN5877"><span class='Ref_To_Local'>subpath</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN955"><span class='Ref_to_Member'>param_info</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN179"><span class='Ref_to_Macro'>forboth</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5879"><span class='Ref_To_Local'>lc1</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5821"><span class='Ref_to_Parameter'>targets</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5880"><span class='Ref_To_Local'>lc2</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5821"><span class='Ref_to_Parameter'>targets_contain_srfs</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN5885"></a>            <a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Local'>thistarget</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5879"><span class='Ref_To_Local'>lc1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN5886"></a>            <span class='Keyword'>bool</span>        <span class='Declare_Local'>contains_srfs</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>bool</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN106"><span class='Ref_to_Macro'>lfirst_int</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5880"><span class='Ref_To_Local'>lc2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* If this level doesn't contain SRFs, do regular projection */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN5886"><span class='Ref_To_Local'>contains_srfs</span></a><span class='Parentheses'>) 
</span>                <a href="planner.c.html#LN5878"><span class='Ref_To_Local'>newpath</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/pathnode.h.html#LN161"><span class='Ref_to_Proto'>create_set_projection_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5820"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                              <a href="planner.c.html#LN5820"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, 
</span>                                                              <a href="planner.c.html#LN5878"><span class='Ref_To_Local'>newpath</span></a><span class='Delimiter'>, 
</span>                                                              <a href="planner.c.html#LN5885"><span class='Ref_To_Local'>thistarget</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* avoid apply_projection_to_path, in case of multiple refs */ 
</span>                <a href="planner.c.html#LN5878"><span class='Ref_To_Local'>newpath</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/pathnode.h.html#LN153"><span class='Ref_to_Proto'>create_projection_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5820"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                          <a href="planner.c.html#LN5820"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, 
</span>                                                          <a href="planner.c.html#LN5878"><span class='Ref_To_Local'>newpath</span></a><span class='Delimiter'>, 
</span>                                                          <a href="planner.c.html#LN5885"><span class='Ref_To_Local'>thistarget</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5823"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="planner.c.html#LN5878"><span class='Ref_To_Local'>newpath</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end adjust_paths_for_srfs &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * expression_planner 
 *      Perform planner's transformations on a standalone expression. 
 * 
 * Various utility commands need to evaluate expressions that are not part 
 * of a plannable query.  They can do so using the executor's regular 
 * expression-execution machinery, but first the expression has to be fed 
 * through here to transform it from parser output to something executable. 
 * 
 * Currently, we disallow sublinks in standalone expressions, so there's no 
 * real "planning" involved here.  (That might not always be true though.) 
 * What we must do is run eval_const_expressions to ensure that any function 
 * calls are converted to positional notation and function default arguments 
 * get inserted.  The fact that constant subexpressions get simplified is a 
 * side-effect that is useful when the expression will get evaluated more than 
 * once.  Also, we must fix operator function IDs. 
 * 
 * Note: this must not make any damaging changes to the passed-in expression 
 * tree.  (It would actually be okay to apply fix_opfuncids to it, but since 
 * we first do an expression_tree_mutator-based walk, what is returned will 
 * be a new node tree.) 
 */ 
</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>* 
</span><a name="LN5930"></a><span class='Declare_Function'>expression_planner</span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>expr</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN5932"></a>    <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Convert named-argument function calls, insert default arguments and 
     * simplify constant subexprs 
     */ 
</span>    <a href="planner.c.html#LN5932"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/clauses.h.html#LN80"><span class='Ref_to_Proto'>eval_const_expressions</span></a><span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN5930"><span class='Ref_to_Parameter'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Fill in opfuncid values if missing */ 
</span>    <a href="../../../include/nodes/nodeFuncs.h.html#LN45"><span class='Ref_to_Proto'>fix_opfuncids</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5932"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planner.c.html#LN5932"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * plan_cluster_use_sort 
 *      Use the planner to decide how CLUSTER should implement sorting 
 * 
 * tableOid is the OID of a table to be clustered on its index indexOid 
 * (which is already known to be a btree index).  Decide whether it's 
 * cheaper to do an indexscan or a seqscan-plus-sort to execute the CLUSTER. 
 * Return TRUE to use sorting, FALSE to use an indexscan. 
 * 
 * Note: caller had better already hold some type of lock on the table. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN5959"></a><span class='Declare_Function'>plan_cluster_use_sort</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>tableOid</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>indexOid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN5961"></a>    <a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>root</span><span class='Delimiter'>; 
</span><a name="LN5962"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>query</span><span class='Delimiter'>; 
</span><a name="LN5963"></a>    <a href="../../../include/nodes/relation.h.html#LN91"><span class='Ref_to_Struct'>PlannerGlobal</span></a> <span class='Operator'>*</span><span class='Declare_Local'>glob</span><span class='Delimiter'>; 
</span><a name="LN5964"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span><span class='Delimiter'>; 
</span><a name="LN5965"></a>    <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rel</span><span class='Delimiter'>; 
</span><a name="LN5966"></a>    <a href="../../../include/nodes/relation.h.html#LN626"><span class='Ref_to_Struct'>IndexOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>indexInfo</span><span class='Delimiter'>; 
</span><a name="LN5967"></a>    <a href="../../../include/nodes/relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a>    <span class='Declare_Local'>indexExprCost</span><span class='Delimiter'>; 
</span><a name="LN5968"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>comparisonCost</span><span class='Delimiter'>; 
</span><a name="LN5969"></a>    <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>seqScanPath</span><span class='Delimiter'>; 
</span><a name="LN5970"></a>    <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>        <span class='Declare_Local'>seqScanAndSortPath</span><span class='Delimiter'>; 
</span><a name="LN5971"></a>    <a href="../../../include/nodes/relation.h.html#LN1027"><span class='Ref_to_Struct'>IndexPath</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>indexScanPath</span><span class='Delimiter'>; 
</span><a name="LN5972"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* We can short-circuit the cost comparison if indexscans are disabled */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../path/costsize.c.html#LN118"><span class='Ref_to_Global_Var'>enable_indexscan</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* use sort */ 
</span> 
    <span class='Comment_Multi_Line'>/* Set up mostly-dummy planner state */ 
</span>    <a href="planner.c.html#LN5962"><span class='Ref_To_Local'>query</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN5962"><span class='Ref_To_Local'>query</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN109"><span class='Ref_to_Member'>commandType</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN650"><span class='Ref_to_EnumConst'>CMD_SELECT</span></a><span class='Delimiter'>; 
</span> 
    <a href="planner.c.html#LN5963"><span class='Ref_To_Local'>glob</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN91"><span class='Ref_to_Struct'>PlannerGlobal</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="planner.c.html#LN5961"><span class='Ref_To_Local'>root</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN5961"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN5962"><span class='Ref_To_Local'>query</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN5961"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN156"><span class='Ref_to_Member'>glob</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN5963"><span class='Ref_To_Local'>glob</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN5961"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN158"><span class='Ref_to_Member'>query_level</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN5961"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN286"><span class='Ref_to_Member'>planner_cxt</span></a> <span class='Operator'>= </span><a href="../../utils/mmgr/mcxt.c.html#LN36"><span class='Ref_to_Global_Var'>CurrentMemoryContext</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN5961"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN307"><span class='Ref_to_Member'>wt_param_id</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Build a minimal RTE for the rel */ 
</span>    <a href="planner.c.html#LN5964"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN5964"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/parsenodes.h.html#LN922"><span class='Ref_to_EnumConst'>RTE_RELATION</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN5964"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN947"><span class='Ref_to_Member'>relid</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN5959"><span class='Ref_to_Parameter'>tableOid</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN5964"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN948"><span class='Ref_to_Member'>relkind</span></a> <span class='Operator'>= </span><a href="../../../include/catalog/pg_class.h.html#LN159"><span class='Ref_to_Const'>RELKIND_RELATION</span></a><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* Don't be too picky. */ 
</span>    <a href="planner.c.html#LN5964"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1024"><span class='Ref_to_Member'>lateral</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN5964"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1025"><span class='Ref_to_Member'>inh</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN5964"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1026"><span class='Ref_to_Member'>inFromCl</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN5962"><span class='Ref_To_Local'>query</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN134"><span class='Ref_to_Member'>rtable</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5964"><span class='Ref_To_Local'>rte</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Set up RTE/RelOptInfo arrays */ 
</span>    <a href="../util/relnode.c.html#LN60"><span class='Ref_to_Func'>setup_simple_rel_arrays</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5961"><span class='Ref_To_Local'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Build RelOptInfo */ 
</span>    <a href="planner.c.html#LN5965"><span class='Ref_To_Local'>rel</span></a> <span class='Operator'>= </span><a href="../util/relnode.c.html#LN89"><span class='Ref_to_Func'>build_simple_rel</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5961"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Locate IndexOptInfo for the target index */ 
</span>    <a href="planner.c.html#LN5966"><span class='Ref_To_Local'>indexInfo</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5972"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5965"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN561"><span class='Ref_to_Member'>indexlist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="planner.c.html#LN5966"><span class='Ref_To_Local'>indexInfo</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN626"><span class='Ref_to_Struct'>IndexOptInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5972"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN5966"><span class='Ref_To_Local'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN630"><span class='Ref_to_Member'>indexoid</span></a> <span class='Operator'>== </span><a href="planner.c.html#LN5959"><span class='Ref_to_Parameter'>indexOid</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * It's possible that get_relation_info did not generate an IndexOptInfo 
     * for the desired index; this could happen if it's not yet reached its 
     * indcheckxmin usability horizon, or if it's a system index and we're 
     * ignoring system indexes.  In such cases we should tell CLUSTER to not 
     * trust the index contents but use seqscan-and-sort. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN5972"><span class='Ref_To_Local'>lc</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span>             <span class='Comment_Single_Line'>/* not in the list? */ 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* use sort */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Rather than doing all the pushups that would be needed to use 
     * set_baserel_size_estimates, just do a quick hack for rows and width. 
     */ 
</span>    <a href="planner.c.html#LN5965"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN5965"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN5965"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN535"><span class='Ref_to_Member'>reltarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN885"><span class='Ref_to_Member'>width</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/plancat.h.html#LN35"><span class='Ref_to_Proto'>get_relation_data_width</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5959"><span class='Ref_to_Parameter'>tableOid</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="planner.c.html#LN5961"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN288"><span class='Ref_to_Member'>total_table_pages</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN5965"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN563"><span class='Ref_to_Member'>pages</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Determine eval cost of the index expressions, if any.  We need to 
     * charge twice that amount for each tuple comparison that happens during 
     * the sort, since tuplesort.c will have to re-evaluate the index 
     * expressions each time.  (XXX that's pretty inefficient...) 
     */ 
</span>    <a href="../../../include/optimizer/cost.h.html#LN157"><span class='Ref_to_Proto'>cost_qual_eval</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="planner.c.html#LN5967"><span class='Ref_To_Local'>indexExprCost</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5966"><span class='Ref_To_Local'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN652"><span class='Ref_to_Member'>indexprs</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5961"><span class='Ref_To_Local'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="planner.c.html#LN5968"><span class='Ref_To_Local'>comparisonCost</span></a> <span class='Operator'>= </span><span class='Number'>2</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>* </span><span class='Parentheses'>(</span><a href="planner.c.html#LN5967"><span class='Ref_To_Local'>indexExprCost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a> <span class='Operator'>+ </span><a href="planner.c.html#LN5967"><span class='Ref_To_Local'>indexExprCost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Estimate the cost of seq scan + sort */ 
</span>    <a href="planner.c.html#LN5969"><span class='Ref_To_Local'>seqScanPath</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/pathnode.h.html#LN35"><span class='Ref_to_Proto'>create_seqscan_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5961"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5965"><span class='Ref_To_Local'>rel</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/optimizer/cost.h.html#LN103"><span class='Ref_to_Proto'>cost_sort</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="planner.c.html#LN5970"><span class='Ref_To_Local'>seqScanAndSortPath</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5961"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>, 
</span>              <a href="planner.c.html#LN5969"><span class='Ref_To_Local'>seqScanPath</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5965"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5965"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN535"><span class='Ref_to_Member'>reltarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN885"><span class='Ref_to_Member'>width</span></a><span class='Delimiter'>, 
</span>              <a href="planner.c.html#LN5968"><span class='Ref_To_Local'>comparisonCost</span></a><span class='Delimiter'>, </span><a href="../../utils/init/globals.c.html#LN113"><span class='Ref_to_Global_Var'>maintenance_work_mem</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Estimate the cost of index scan */ 
</span>    <a href="planner.c.html#LN5971"><span class='Ref_To_Local'>indexScanPath</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/pathnode.h.html#LN39"><span class='Ref_to_Proto'>create_index_path</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN5961"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN5966"><span class='Ref_To_Local'>indexInfo</span></a><span class='Delimiter'>, 
</span>                                      <a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>, 
</span>                                      <a href="../../../include/access/sdir.h.html#LN25"><span class='Ref_to_EnumConst'>ForwardScanDirection</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                                      <span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN5970"><span class='Ref_To_Local'>seqScanAndSortPath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>&LT; </span><a href="planner.c.html#LN5971"><span class='Ref_To_Local'>indexScanPath</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1029"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end plan_cluster_use_sort &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * get_partitioned_child_rels 
 *      Returns a list of the RT indexes of the partitioned child relations 
 *      with rti as the root parent RT index. 
 * 
 * Note: Only call this function on RTEs known to be partitioned tables. 
 */ 
</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN6067"></a><span class='Declare_Function'>get_partitioned_child_rels</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> <span class='Declare_Parameter'>rti</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN6069"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN6070"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN6070"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="planner.c.html#LN6067"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN253"><span class='Ref_to_Member'>pcinfo_list</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN6074"></a>        <a href="../../../include/nodes/relation.h.html#LN2023"><span class='Ref_to_Struct'>PartitionedChildRelInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pc</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN6070"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planner.c.html#LN6074"><span class='Ref_To_Local'>pc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2027"><span class='Ref_to_Member'>parent_relid</span></a> <span class='Operator'>== </span><a href="planner.c.html#LN6067"><span class='Ref_to_Parameter'>rti</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="planner.c.html#LN6069"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="planner.c.html#LN6074"><span class='Ref_To_Local'>pc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2028"><span class='Ref_to_Member'>child_rels</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* The root partitioned table is included as a child rel */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planner.c.html#LN6069"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT;= </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="planner.c.html#LN6069"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end get_partitioned_child_rels &raquo; </span> 
</pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>