<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\optimizer\util\clauses.c</title>
<LINK REL=StyleSheet HREF="../../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\optimizer\util\clauses.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:42 2017
</td></tr>
<tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
</span><span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * clauses.c 
 *    routines to manipulate qualification clauses 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * 
 * IDENTIFICATION 
 *    src/backend/optimizer/util/clauses.c 
 * 
 * HISTORY 
 *    AUTHOR            DATE            MAJOR EVENT 
 *    Andrew Yu         Nov 3, 1994     clause.c and clauses.c combined 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span> 
<span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/htup_details.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_aggregate.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_class.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_language.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_operator.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_proc.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_type.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"executor/executor.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"executor/functions.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"funcapi.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"miscadmin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/makefuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/nodeFuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/clauses.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/cost.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/planmain.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/prep.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/var.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/analyze.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_agg.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_coerce.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_func.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"rewrite/rewriteManip.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"tcop/tcopprot.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/acl.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/builtins.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/datum.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/fmgroids.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/lsyscache.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/memutils.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/syscache.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/typcache.h"</span> 
 
 
<span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN57"></a>    <a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Member'>root</span><span class='Delimiter'>; 
</span><a name="LN58"></a>    <a href="../../../include/nodes/nodes.h.html#LN755"><span class='Ref_to_Enum'>AggSplit</span></a>    <span class='Declare_Member'>aggsplit</span><span class='Delimiter'>; 
</span><a name="LN59"></a>    <a href="../../../include/nodes/relation.h.html#LN55"><span class='Ref_to_Struct'>AggClauseCosts</span></a> <span class='Operator'>*</span><span class='Declare_Member'>costs</span><span class='Delimiter'>; 
</span><a name="LN60"></a>} <span class='Declare_Typedef'>get_agg_clause_costs_context</span><span class='Delimiter'>; 
</span> 
<span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN64"></a>    <a href="../../../include/nodes/params.h.html#LN61"><span class='Ref_to_Typedef'>ParamListInfo</span></a> <span class='Declare_Member'>boundParams</span><span class='Delimiter'>; 
</span><a name="LN65"></a>    <a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Member'>root</span><span class='Delimiter'>; 
</span><a name="LN66"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>active_fns</span><span class='Delimiter'>; 
</span><a name="LN67"></a>    <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>case_val</span><span class='Delimiter'>; 
</span><a name="LN68"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>estimate</span><span class='Delimiter'>; 
</span><a name="LN69"></a>} <span class='Declare_Typedef'>eval_const_expressions_context</span><span class='Delimiter'>; 
</span> 
<span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN73"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>nargs</span><span class='Delimiter'>; 
</span><a name="LN74"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>args</span><span class='Delimiter'>; 
</span><a name="LN75"></a>    <span class='Keyword'>int</span>        <span class='Operator'>*</span><span class='Declare_Member'>usecounts</span><span class='Delimiter'>; 
</span><a name="LN76"></a>} <span class='Declare_Typedef'>substitute_actual_parameters_context</span><span class='Delimiter'>; 
</span> 
<span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN80"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>nargs</span><span class='Delimiter'>; 
</span><a name="LN81"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>args</span><span class='Delimiter'>; 
</span><a name="LN82"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>sublevels_up</span><span class='Delimiter'>; 
</span><a name="LN83"></a>} <span class='Declare_Typedef'>substitute_actual_srf_parameters_context</span><span class='Delimiter'>; 
</span> 
<span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN87"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>proname</span><span class='Delimiter'>; 
</span><a name="LN88"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>prosrc</span><span class='Delimiter'>; 
</span><a name="LN89"></a>} <span class='Declare_Typedef'>inline_error_callback_arg</span><span class='Delimiter'>; 
</span> 
<span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN93"></a>    <span class='Keyword'>char</span>        <span class='Declare_Member'>max_hazard</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* worst proparallel hazard found so far */ 
</span><a name="LN94"></a>    <span class='Keyword'>char</span>        <span class='Declare_Member'>max_interesting</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* worst proparallel hazard of interest */ 
</span><a name="LN95"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>safe_param_ids</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* PARAM_EXEC Param IDs to treat as safe */ 
</span><a name="LN96"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>max_parallel_hazard_context</span><span class='Delimiter'>; 
</span> 
<a name="LN98"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>contain_agg_clause_walker</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN99"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>get_agg_clause_costs_walker</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, 
</span><a name="LN100"></a>                            <a href="clauses.c.html#LN55"><span class='Ref_to_Typedef'>get_agg_clause_costs_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN101"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>find_window_functions_walker</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><a href="../../../include/optimizer/clauses.h.html#LN22"><span class='Ref_to_Typedef'>WindowFuncLists</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>lists</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN102"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>contain_subplans_walker</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN103"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>contain_mutable_functions_walker</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN104"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>contain_volatile_functions_walker</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN105"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>contain_volatile_functions_not_nextval_walker</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN106"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>max_parallel_hazard_walker</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, 
</span><a name="LN107"></a>                           <a href="clauses.c.html#LN91"><span class='Ref_to_Typedef'>max_parallel_hazard_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN108"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>contain_nonstrict_functions_walker</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN109"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>contain_context_dependent_node</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN110"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>contain_context_dependent_node_walker</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Operator'>*</span><span class='Declare_Parameter'>flags</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN111"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>contain_leaked_vars_walker</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN112"></a><span class='Keyword'>static </span><a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Prototype'>find_nonnullable_rels_walker</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>top_level</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN113"></a><span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>find_nonnullable_vars_walker</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>top_level</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN114"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>is_strict_saop</span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN534"><span class='Ref_to_Struct'>ScalarArrayOpExpr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>expr</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>falseOK</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN115"></a><span class='Keyword'>static </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>eval_const_expressions_mutator</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, 
</span><a name="LN116"></a>                               <a href="clauses.c.html#LN62"><span class='Ref_to_Typedef'>eval_const_expressions_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN117"></a><span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>simplify_or_arguments</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>args</span><span class='Delimiter'>, 
</span><a name="LN118"></a>                      <a href="clauses.c.html#LN62"><span class='Ref_to_Typedef'>eval_const_expressions_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Delimiter'>, 
</span><a name="LN119"></a>                      <span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>haveNull</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>forceTrue</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN120"></a><span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>simplify_and_arguments</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>args</span><span class='Delimiter'>, 
</span><a name="LN121"></a>                       <a href="clauses.c.html#LN62"><span class='Ref_to_Typedef'>eval_const_expressions_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Delimiter'>, 
</span><a name="LN122"></a>                       <span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>haveNull</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>forceFalse</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN123"></a><span class='Keyword'>static </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>simplify_boolean_equality</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>opno</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>args</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN124"></a><span class='Keyword'>static </span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>simplify_function</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>funcid</span><span class='Delimiter'>, 
</span><a name="LN125"></a>                  <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>result_type</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a> <span class='Declare_Parameter'>result_typmod</span><span class='Delimiter'>, 
</span><a name="LN126"></a>                  <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>result_collid</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>input_collid</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>args_p</span><span class='Delimiter'>, 
</span><a name="LN127"></a>                  <span class='Keyword'>bool </span><span class='Declare_Parameter'>funcvariadic</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>process_args</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>allow_non_const</span><span class='Delimiter'>, 
</span><a name="LN128"></a>                  <a href="clauses.c.html#LN62"><span class='Ref_to_Typedef'>eval_const_expressions_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN129"></a><span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>expand_function_arguments</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>args</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>result_type</span><span class='Delimiter'>, 
</span><a name="LN130"></a>                          <a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> <span class='Declare_Parameter'>func_tuple</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN131"></a><span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>reorder_function_arguments</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>args</span><span class='Delimiter'>, </span><a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> <span class='Declare_Parameter'>func_tuple</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN132"></a><span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>add_function_defaults</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>args</span><span class='Delimiter'>, </span><a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> <span class='Declare_Parameter'>func_tuple</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN133"></a><span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>fetch_function_defaults</span><span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> <span class='Declare_Parameter'>func_tuple</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN134"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>recheck_cast_function_args</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>args</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>result_type</span><span class='Delimiter'>, 
</span><a name="LN135"></a>                           <a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> <span class='Declare_Parameter'>func_tuple</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN136"></a><span class='Keyword'>static </span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>evaluate_function</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>funcid</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>result_type</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a> <span class='Declare_Parameter'>result_typmod</span><span class='Delimiter'>, 
</span><a name="LN137"></a>                  <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>result_collid</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>input_collid</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>args</span><span class='Delimiter'>, 
</span><a name="LN138"></a>                  <span class='Keyword'>bool </span><span class='Declare_Parameter'>funcvariadic</span><span class='Delimiter'>, 
</span><a name="LN139"></a>                  <a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> <span class='Declare_Parameter'>func_tuple</span><span class='Delimiter'>, 
</span><a name="LN140"></a>                  <a href="clauses.c.html#LN62"><span class='Ref_to_Typedef'>eval_const_expressions_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN141"></a><span class='Keyword'>static </span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>inline_function</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>funcid</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>result_type</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>result_collid</span><span class='Delimiter'>, 
</span><a name="LN142"></a>                <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>input_collid</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>args</span><span class='Delimiter'>, 
</span><a name="LN143"></a>                <span class='Keyword'>bool </span><span class='Declare_Parameter'>funcvariadic</span><span class='Delimiter'>, 
</span><a name="LN144"></a>                <a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> <span class='Declare_Parameter'>func_tuple</span><span class='Delimiter'>, 
</span><a name="LN145"></a>                <a href="clauses.c.html#LN62"><span class='Ref_to_Typedef'>eval_const_expressions_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN146"></a><span class='Keyword'>static </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>substitute_actual_parameters</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>expr</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>nargs</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>args</span><span class='Delimiter'>, 
</span><a name="LN147"></a>                             <span class='Keyword'>int </span><span class='Operator'>*</span><span class='Declare_Parameter'>usecounts</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN148"></a><span class='Keyword'>static </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>substitute_actual_parameters_mutator</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, 
</span><a name="LN149"></a>                              <a href="clauses.c.html#LN71"><span class='Ref_to_Typedef'>substitute_actual_parameters_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN150"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>sql_inline_error_callback</span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>arg</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN151"></a><span class='Keyword'>static </span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>evaluate_expr</span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>expr</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>result_type</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a> <span class='Declare_Parameter'>result_typmod</span><span class='Delimiter'>, 
</span><a name="LN152"></a>              <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>result_collation</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN153"></a><span class='Keyword'>static </span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>substitute_actual_srf_parameters</span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>expr</span><span class='Delimiter'>, 
</span><a name="LN154"></a>                                 <span class='Keyword'>int </span><span class='Declare_Parameter'>nargs</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>args</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN155"></a><span class='Keyword'>static </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>substitute_actual_srf_parameters_mutator</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, 
</span><a name="LN156"></a>                          <a href="clauses.c.html#LN78"><span class='Ref_to_Typedef'>substitute_actual_srf_parameters_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN157"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>tlist_matches_coltypelist</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tlist</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>coltypelist</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/***************************************************************************** 
 *      OPERATOR clause functions 
 *****************************************************************************/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * make_opclause 
 *    Creates an operator clause given its operator info, left operand 
 *    and right operand (pass NULL to create single-operand clause), 
 *    and collation info. 
 */ 
</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>* 
</span><a name="LN171"></a><span class='Declare_Function'>make_opclause</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>opno</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>opresulttype</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>opretset</span><span class='Delimiter'>, 
</span><a name="LN172"></a>              <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>leftop</span><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rightop</span><span class='Delimiter'>, 
</span><a name="LN173"></a>              <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>opcollid</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>inputcollid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN175"></a>    <a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="clauses.c.html#LN175"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN494"><span class='Ref_to_Member'>opno</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN171"><span class='Ref_to_Parameter'>opno</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN175"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN495"><span class='Ref_to_Member'>opfuncid</span></a> <span class='Operator'>= </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN175"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN496"><span class='Ref_to_Member'>opresulttype</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN171"><span class='Ref_to_Parameter'>opresulttype</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN175"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN497"><span class='Ref_to_Member'>opretset</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN171"><span class='Ref_to_Parameter'>opretset</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN175"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN498"><span class='Ref_to_Member'>opcollid</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN173"><span class='Ref_to_Parameter'>opcollid</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN175"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN499"><span class='Ref_to_Member'>inputcollid</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN173"><span class='Ref_to_Parameter'>inputcollid</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN172"><span class='Ref_to_Parameter'>rightop</span></a><span class='Parentheses'>) 
</span>        <a href="clauses.c.html#LN175"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN500"><span class='Ref_to_Member'>args</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN139"><span class='Ref_to_Macro'>list_make2</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN172"><span class='Ref_to_Parameter'>leftop</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN172"><span class='Ref_to_Parameter'>rightop</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="clauses.c.html#LN175"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN500"><span class='Ref_to_Member'>args</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN172"><span class='Ref_to_Parameter'>leftop</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN175"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN501"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN175"><span class='Ref_To_Local'>expr</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end make_opclause &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * get_leftop 
 * 
 * Returns the left operand of a clause of the form (op expr expr) 
 *      or (op expr) 
 */ 
</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN198"></a><span class='Declare_Function'>get_leftop</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN200"></a>    <span class='Keyword'>const </span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN198"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN200"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN500"><span class='Ref_to_Member'>args</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN200"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN500"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * get_rightop 
 * 
 * Returns the right operand in a clause of the form (op expr expr). 
 * NB: result will be NULL if applied to a unary op clause. 
 */ 
</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN215"></a><span class='Declare_Function'>get_rightop</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN217"></a>    <span class='Keyword'>const </span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN215"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN217"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN500"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT;= </span><span class='Number'>2</span><span class='Parentheses'>)</span> 
        <span class='Control'>return</span> <a href="../../../include/nodes/pg_list.h.html#LN115"><span class='Ref_to_Macro'>lsecond</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN217"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN500"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/***************************************************************************** 
 *      NOT clause functions 
 *****************************************************************************/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * not_clause 
 * 
 * Returns t iff this is a 'not' clause: (NOT expr). 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN235"></a><span class='Declare_Function'>not_clause</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN235"><span class='Ref_to_Parameter'>clause</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL </span><span class='Operator'>&& 
</span>            <a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN235"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>            <span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN235"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>boolop <span class='Operator'>== </span><a href="../../../include/nodes/primnodes.h.html#LN554"><span class='Ref_to_EnumConst'>NOT_EXPR</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * make_notclause 
 * 
 * Create a 'not' clause given the expression to be negated. 
 */ 
</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>* 
</span><a name="LN248"></a><span class='Declare_Function'>make_notclause</span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>notclause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN250"></a>    <a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="clauses.c.html#LN250"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN560"><span class='Ref_to_Member'>boolop</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/primnodes.h.html#LN554"><span class='Ref_to_EnumConst'>NOT_EXPR</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN250"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN561"><span class='Ref_to_Member'>args</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN248"><span class='Ref_to_Parameter'>notclause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN250"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN562"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN250"><span class='Ref_To_Local'>expr</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * get_notclausearg 
 * 
 * Retrieve the clause within a 'not' clause 
 */ 
</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>* 
</span><a name="LN264"></a><span class='Declare_Function'>get_notclausearg</span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>notclause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN264"><span class='Ref_to_Parameter'>notclause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>args<span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/***************************************************************************** 
 *      OR clause functions 
 *****************************************************************************/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * or_clause 
 * 
 * Returns t iff the clause is an 'or' clause: (OR { expr }). 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN279"></a><span class='Declare_Function'>or_clause</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN279"><span class='Ref_to_Parameter'>clause</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL </span><span class='Operator'>&& 
</span>            <a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN279"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>            <span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN279"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>boolop <span class='Operator'>== </span><a href="../../../include/nodes/primnodes.h.html#LN554"><span class='Ref_to_EnumConst'>OR_EXPR</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * make_orclause 
 * 
 * Creates an 'or' clause given a list of its subclauses. 
 */ 
</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>* 
</span><a name="LN292"></a><span class='Declare_Function'>make_orclause</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>orclauses</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN294"></a>    <a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="clauses.c.html#LN294"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN560"><span class='Ref_to_Member'>boolop</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/primnodes.h.html#LN554"><span class='Ref_to_EnumConst'>OR_EXPR</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN294"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN561"><span class='Ref_to_Member'>args</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN292"><span class='Ref_to_Parameter'>orclauses</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN294"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN562"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN294"><span class='Ref_To_Local'>expr</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/***************************************************************************** 
 *      AND clause functions 
 *****************************************************************************/ 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * and_clause 
 * 
 * Returns t iff its argument is an 'and' clause: (AND { expr }). 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN313"></a><span class='Declare_Function'>and_clause</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN313"><span class='Ref_to_Parameter'>clause</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL </span><span class='Operator'>&& 
</span>            <a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN313"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>            <span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN313"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>boolop <span class='Operator'>== </span><a href="../../../include/nodes/primnodes.h.html#LN554"><span class='Ref_to_EnumConst'>AND_EXPR</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * make_andclause 
 * 
 * Creates an 'and' clause given a list of its subclauses. 
 */ 
</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>* 
</span><a name="LN326"></a><span class='Declare_Function'>make_andclause</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>andclauses</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN328"></a>    <a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="clauses.c.html#LN328"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN560"><span class='Ref_to_Member'>boolop</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/primnodes.h.html#LN554"><span class='Ref_to_EnumConst'>AND_EXPR</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN328"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN561"><span class='Ref_to_Member'>args</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN326"><span class='Ref_to_Parameter'>andclauses</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN328"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN562"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN328"><span class='Ref_To_Local'>expr</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * make_and_qual 
 * 
 * Variant of make_andclause for ANDing two qual conditions together. 
 * Qual conditions have the property that a NULL nodetree is interpreted 
 * as 'true'. 
 * 
 * NB: this makes no attempt to preserve AND/OR flatness; so it should not 
 * be used on a qual that has already been run through prepqual.c. 
 */ 
</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN347"></a><span class='Declare_Function'>make_and_qual</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>qual1</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>qual2</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN347"><span class='Ref_to_Parameter'>qual1</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="clauses.c.html#LN347"><span class='Ref_to_Parameter'>qual2</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN347"><span class='Ref_to_Parameter'>qual2</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="clauses.c.html#LN347"><span class='Ref_to_Parameter'>qual1</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/clauses.h.html#LN43"><span class='Ref_to_Proto'>make_andclause</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN139"><span class='Ref_to_Macro'>list_make2</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN347"><span class='Ref_to_Parameter'>qual1</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN347"><span class='Ref_to_Parameter'>qual2</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * The planner frequently prefers to represent qualification expressions 
 * as lists of boolean expressions with implicit AND semantics. 
 * 
 * These functions convert between an AND-semantics expression list and the 
 * ordinary representation of a boolean expression. 
 * 
 * Note that an empty list is considered equivalent to TRUE. 
 */ 
</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>* 
</span><a name="LN366"></a><span class='Declare_Function'>make_ands_explicit</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>andclauses</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN366"><span class='Ref_to_Parameter'>andclauses</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/makefuncs.h.html#LN59"><span class='Ref_to_Proto'>makeBoolConst</span></a><span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN366"><span class='Ref_to_Parameter'>andclauses</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
        <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN366"><span class='Ref_to_Parameter'>andclauses</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <span class='Control'>return</span> <a href="../../../include/optimizer/clauses.h.html#LN43"><span class='Ref_to_Proto'>make_andclause</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN366"><span class='Ref_to_Parameter'>andclauses</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN377"></a><span class='Declare_Function'>make_ands_implicit</span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * NB: because the parser sets the qual field to NULL in a query that has 
     * no WHERE clause, we must consider a NULL input clause as TRUE, even 
     * though one might more reasonably think it FALSE.  Grumble. If this 
     * causes trouble, consider changing the parser's behavior. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN377"><span class='Ref_to_Parameter'>clause</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* NULL -&GT; NIL list == TRUE */ 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/clauses.h.html#LN42"><span class='Ref_to_Proto'>and_clause</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN377"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN377"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>args<span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN377"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>             <span class='Operator'>!</span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> <a href="clauses.c.html#LN377"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constisnull <span class='Operator'>&& 
</span>             <a href="../../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN377"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constvalue<span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* constant TRUE input -&GT; NIL list */ 
</span>    <span class='Control'>else</span> 
        <span class='Control'>return</span> <a href="../../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN377"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end make_ands_implicit &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/***************************************************************************** 
 *      Aggregate-function clause manipulation 
 *****************************************************************************/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * contain_agg_clause 
 *    Recursively search for Aggref/GroupingFunc nodes within a clause. 
 * 
 *    Returns true if any aggregate found. 
 * 
 * This does not descend into subqueries, and so should be used only after 
 * reduction of sublinks to subplans, or in contexts where it's known there 
 * are no subqueries.  There mustn't be outer-aggregate references either. 
 * 
 * (If you want something like this but able to deal with subqueries, 
 * see rewriteManip.c's contain_aggs_of_level().) 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN416"></a><span class='Declare_Function'>contain_agg_clause</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="clauses.c.html#LN98"><span class='Ref_to_Proto'>contain_agg_clause_walker</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN416"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static bool 
</span><a name="LN422"></a><span class='Declare_Function'>contain_agg_clause_walker</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN422"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN422"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN422"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>agglevelsup <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* abort the tree traversal and return true */ 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN422"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN337"><span class='Ref_to_Struct'>GroupingFunc</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN337"><span class='Ref_to_Struct'>GroupingFunc</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN422"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>agglevelsup <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* abort the tree traversal and return true */ 
</span>    <span class='Delimiter'>} 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN422"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN629"><span class='Ref_to_Struct'>SubLink</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="../../../include/nodes/nodeFuncs.h.html#LN52"><span class='Ref_to_Proto'>expression_tree_walker</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN422"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN98"><span class='Ref_to_Proto'>contain_agg_clause_walker</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN422"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * get_agg_clause_costs 
 *    Recursively find the Aggref nodes in an expression tree, and 
 *    accumulate cost information about them. 
 * 
 * 'aggsplit' tells us the expected partial-aggregation mode, which affects 
 * the cost estimates. 
 * 
 * NOTE that the counts/costs are ADDED to those already in *costs ... so 
 * the caller is responsible for zeroing the struct initially. 
 * 
 * We count the nodes, estimate their execution costs, and estimate the total 
 * space needed for their transition state values if all are evaluated in 
 * parallel (as would be done in a HashAgg plan).  Also, we check whether 
 * partial aggregation is feasible.  See AggClauseCosts for the exact set 
 * of statistics collected. 
 * 
 * In addition, we mark Aggref nodes with the correct aggtranstype, so 
 * that that doesn't need to be done repeatedly.  (That makes this function's 
 * name a bit of a misnomer.) 
 * 
 * This does not descend into subqueries, and so should be used only after 
 * reduction of sublinks to subplans, or in contexts where it's known there 
 * are no subqueries.  There mustn't be outer-aggregate references either. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN466"></a><span class='Declare_Function'>get_agg_clause_costs</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN755"><span class='Ref_to_Enum'>AggSplit</span></a> <span class='Declare_Parameter'>aggsplit</span><span class='Delimiter'>, 
</span><a name="LN467"></a>                     <a href="../../../include/nodes/relation.h.html#LN55"><span class='Ref_to_Struct'>AggClauseCosts</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>costs</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN469"></a>    <a href="clauses.c.html#LN55"><span class='Ref_to_Typedef'>get_agg_clause_costs_context</span></a> <span class='Declare_Local'>context</span><span class='Delimiter'>; 
</span> 
    <a href="clauses.c.html#LN469"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="clauses.c.html#LN57"><span class='Ref_to_Member'>root</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN466"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN469"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="clauses.c.html#LN58"><span class='Ref_to_Member'>aggsplit</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN466"><span class='Ref_to_Parameter'>aggsplit</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN469"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="clauses.c.html#LN59"><span class='Ref_to_Member'>costs</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN467"><span class='Ref_to_Parameter'>costs</span></a><span class='Delimiter'>; 
</span>    <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN99"><span class='Ref_to_Proto'>get_agg_clause_costs_walker</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN466"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="clauses.c.html#LN469"><span class='Ref_To_Local'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static bool 
</span><a name="LN478"></a><span class='Declare_Function'>get_agg_clause_costs_walker</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><a href="clauses.c.html#LN55"><span class='Ref_to_Typedef'>get_agg_clause_costs_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN478"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN478"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN484"></a>        <a href="../../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>aggref</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN478"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span><a name="LN485"></a>        <a href="../../../include/nodes/relation.h.html#LN55"><span class='Ref_to_Struct'>AggClauseCosts</span></a> <span class='Operator'>*</span><span class='Declare_Local'>costs</span> <span class='Operator'>= </span><a href="clauses.c.html#LN478"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN59"><span class='Ref_to_Member'>costs</span></a><span class='Delimiter'>; 
</span><a name="LN486"></a>        <a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>aggTuple</span><span class='Delimiter'>; 
</span><a name="LN487"></a>        <a href="../../../include/catalog/pg_aggregate.h.html#LN86"><span class='Ref_to_Typedef'>Form_pg_aggregate</span></a> <span class='Declare_Local'>aggform</span><span class='Delimiter'>; 
</span><a name="LN488"></a>        <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>aggtransfn</span><span class='Delimiter'>; 
</span><a name="LN489"></a>        <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>aggfinalfn</span><span class='Delimiter'>; 
</span><a name="LN490"></a>        <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>aggcombinefn</span><span class='Delimiter'>; 
</span><a name="LN491"></a>        <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>aggserialfn</span><span class='Delimiter'>; 
</span><a name="LN492"></a>        <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>aggdeserialfn</span><span class='Delimiter'>; 
</span><a name="LN493"></a>        <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>aggtranstype</span><span class='Delimiter'>; 
</span><a name="LN494"></a>        <a href="../../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>aggtransspace</span><span class='Delimiter'>; 
</span><a name="LN495"></a>        <a href="../../../include/nodes/relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a>    <span class='Declare_Local'>argcosts</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="clauses.c.html#LN484"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN308"><span class='Ref_to_Member'>agglevelsup</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Fetch info about aggregate from pg_aggregate.  Note it's correct to 
         * ignore the moving-aggregate variant, since what we're concerned 
         * with here is aggregates not window functions. 
         */ 
</span>        <a href="clauses.c.html#LN486"><span class='Ref_To_Local'>aggTuple</span></a> <span class='Operator'>= </span><a href="../../../include/utils/syscache.h.html#LN155"><span class='Ref_to_Macro'>SearchSysCache1</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/syscache.h.html#LN33"><span class='Ref_to_EnumConst'>AGGFNOID</span></a><span class='Delimiter'>, 
</span>                                   <a href="../../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN484"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN293"><span class='Ref_to_Member'>aggfnoid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN486"><span class='Ref_To_Local'>aggTuple</span></a><span class='Parentheses'>))</span> 
            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for aggregate %u"</span><span class='Delimiter'>, 
</span>                 <a href="clauses.c.html#LN484"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN293"><span class='Ref_to_Member'>aggfnoid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="clauses.c.html#LN487"><span class='Ref_To_Local'>aggform</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_aggregate.h.html#LN86"><span class='Ref_to_Typedef'>Form_pg_aggregate</span></a><span class='Parentheses'>) </span><a href="../../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN486"><span class='Ref_To_Local'>aggTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="clauses.c.html#LN488"><span class='Ref_To_Local'>aggtransfn</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN487"><span class='Ref_To_Local'>aggform</span></a><span class='Operator'>-&GT;</span>aggtransfn<span class='Delimiter'>; 
</span>        <a href="clauses.c.html#LN489"><span class='Ref_To_Local'>aggfinalfn</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN487"><span class='Ref_To_Local'>aggform</span></a><span class='Operator'>-&GT;</span>aggfinalfn<span class='Delimiter'>; 
</span>        <a href="clauses.c.html#LN490"><span class='Ref_To_Local'>aggcombinefn</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN487"><span class='Ref_To_Local'>aggform</span></a><span class='Operator'>-&GT;</span>aggcombinefn<span class='Delimiter'>; 
</span>        <a href="clauses.c.html#LN491"><span class='Ref_To_Local'>aggserialfn</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN487"><span class='Ref_To_Local'>aggform</span></a><span class='Operator'>-&GT;</span>aggserialfn<span class='Delimiter'>; 
</span>        <a href="clauses.c.html#LN492"><span class='Ref_To_Local'>aggdeserialfn</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN487"><span class='Ref_To_Local'>aggform</span></a><span class='Operator'>-&GT;</span>aggdeserialfn<span class='Delimiter'>; 
</span>        <a href="clauses.c.html#LN493"><span class='Ref_To_Local'>aggtranstype</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN487"><span class='Ref_To_Local'>aggform</span></a><span class='Operator'>-&GT;</span>aggtranstype<span class='Delimiter'>; 
</span>        <a href="clauses.c.html#LN494"><span class='Ref_To_Local'>aggtransspace</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN487"><span class='Ref_To_Local'>aggform</span></a><span class='Operator'>-&GT;</span>aggtransspace<span class='Delimiter'>; 
</span>        <a href="../../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN486"><span class='Ref_To_Local'>aggTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Resolve the possibly-polymorphic aggregate transition type, unless 
         * already done in a previous pass over the expression. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN484"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN297"><span class='Ref_to_Member'>aggtranstype</span></a><span class='Parentheses'>))</span> 
            <a href="clauses.c.html#LN493"><span class='Ref_To_Local'>aggtranstype</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN484"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN297"><span class='Ref_to_Member'>aggtranstype</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span><a name="LN527"></a>            <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>inputTypes</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN36"><span class='Ref_to_Const'>FUNC_MAX_ARGS</span></a><span class='Delimiter'>]; 
</span><a name="LN528"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>numArguments</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* extract argument types (ignoring any ORDER BY expressions) */ 
</span>            <a href="clauses.c.html#LN528"><span class='Ref_To_Local'>numArguments</span></a> <span class='Operator'>= </span><a href="../../../include/parser/parse_agg.h.html#LN30"><span class='Ref_to_Proto'>get_aggregate_argtypes</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN484"><span class='Ref_To_Local'>aggref</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN527"><span class='Ref_To_Local'>inputTypes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* resolve actual type of transition state, if polymorphic */ 
</span>            <a href="clauses.c.html#LN493"><span class='Ref_To_Local'>aggtranstype</span></a> <span class='Operator'>= </span><a href="../../../include/parser/parse_agg.h.html#LN32"><span class='Ref_to_Proto'>resolve_aggregate_transtype</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN484"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN293"><span class='Ref_to_Member'>aggfnoid</span></a><span class='Delimiter'>, 
</span>                                                       <a href="clauses.c.html#LN493"><span class='Ref_To_Local'>aggtranstype</span></a><span class='Delimiter'>, 
</span>                                                       <a href="clauses.c.html#LN527"><span class='Ref_To_Local'>inputTypes</span></a><span class='Delimiter'>, 
</span>                                                       <a href="clauses.c.html#LN528"><span class='Ref_To_Local'>numArguments</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="clauses.c.html#LN484"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN297"><span class='Ref_to_Member'>aggtranstype</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN493"><span class='Ref_To_Local'>aggtranstype</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Count it, and check for cases requiring ordered input.  Note that 
         * ordered-set aggs always have nonempty aggorder.  Any ordered-input 
         * case also defeats partial aggregation. 
         */ 
</span>        <a href="clauses.c.html#LN485"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN57"><span class='Ref_to_Member'>numAggs</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN484"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN301"><span class='Ref_to_Member'>aggorder</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>|| </span><a href="clauses.c.html#LN484"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN302"><span class='Ref_to_Member'>aggdistinct</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="clauses.c.html#LN485"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN58"><span class='Ref_to_Member'>numOrderedAggs</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <a href="clauses.c.html#LN485"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN59"><span class='Ref_to_Member'>hasNonPartial</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Check whether partial aggregation is feasible, unless we already 
         * found out that we can't do it. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="clauses.c.html#LN485"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN59"><span class='Ref_to_Member'>hasNonPartial</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * If there is no combine function, then partial aggregation is 
             * not possible. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN490"><span class='Ref_To_Local'>aggcombinefn</span></a><span class='Parentheses'>))</span> 
                <a href="clauses.c.html#LN485"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN59"><span class='Ref_to_Member'>hasNonPartial</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * If we have any aggs with transtype INTERNAL then we must check 
             * whether they have serialization/deserialization functions; if 
             * not, we can't serialize partial-aggregation results. 
             */ 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN493"><span class='Ref_To_Local'>aggtranstype</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_type.h.html#LN697"><span class='Ref_to_Const'>INTERNALOID</span></a> <span class='Operator'>&& 
</span>                     <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN491"><span class='Ref_To_Local'>aggserialfn</span></a><span class='Parentheses'>) </span><span class='Operator'>|| !</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN492"><span class='Ref_To_Local'>aggdeserialfn</span></a><span class='Parentheses'>)))</span> 
                <a href="clauses.c.html#LN485"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN60"><span class='Ref_to_Member'>hasNonSerial</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Add the appropriate component function execution costs to 
         * appropriate totals. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN766"><span class='Ref_to_Macro'>DO_AGGSPLIT_COMBINE</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN478"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN58"><span class='Ref_to_Member'>aggsplit</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* charge for combining previously aggregated states */ 
</span>            <a href="clauses.c.html#LN485"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN61"><span class='Ref_to_Member'>transCost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>+= </span><a href="../../../include/utils/lsyscache.h.html#LN121"><span class='Ref_to_Proto'>get_func_cost</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN490"><span class='Ref_To_Local'>aggcombinefn</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="../path/costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <a href="clauses.c.html#LN485"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN61"><span class='Ref_to_Member'>transCost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>+= </span><a href="../../../include/utils/lsyscache.h.html#LN121"><span class='Ref_to_Proto'>get_func_cost</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN488"><span class='Ref_To_Local'>aggtransfn</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="../path/costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN769"><span class='Ref_to_Macro'>DO_AGGSPLIT_DESERIALIZE</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN478"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN58"><span class='Ref_to_Member'>aggsplit</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>            <a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN492"><span class='Ref_To_Local'>aggdeserialfn</span></a><span class='Parentheses'>))</span> 
            <a href="clauses.c.html#LN485"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN61"><span class='Ref_to_Member'>transCost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>+= </span><a href="../../../include/utils/lsyscache.h.html#LN121"><span class='Ref_to_Proto'>get_func_cost</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN492"><span class='Ref_To_Local'>aggdeserialfn</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="../path/costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN768"><span class='Ref_to_Macro'>DO_AGGSPLIT_SERIALIZE</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN478"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN58"><span class='Ref_to_Member'>aggsplit</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>            <a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN491"><span class='Ref_To_Local'>aggserialfn</span></a><span class='Parentheses'>))</span> 
            <a href="clauses.c.html#LN485"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN62"><span class='Ref_to_Member'>finalCost</span></a> <span class='Operator'>+= </span><a href="../../../include/utils/lsyscache.h.html#LN121"><span class='Ref_to_Proto'>get_func_cost</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN491"><span class='Ref_To_Local'>aggserialfn</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="../path/costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/nodes.h.html#LN767"><span class='Ref_to_Macro'>DO_AGGSPLIT_SKIPFINAL</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN478"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN58"><span class='Ref_to_Member'>aggsplit</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>            <a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN489"><span class='Ref_To_Local'>aggfinalfn</span></a><span class='Parentheses'>))</span> 
            <a href="clauses.c.html#LN485"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN62"><span class='Ref_to_Member'>finalCost</span></a> <span class='Operator'>+= </span><a href="../../../include/utils/lsyscache.h.html#LN121"><span class='Ref_to_Proto'>get_func_cost</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN489"><span class='Ref_To_Local'>aggfinalfn</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="../path/costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * These costs are incurred only by the initial aggregate node, so we 
         * mustn't include them again at upper levels. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/nodes.h.html#LN766"><span class='Ref_to_Macro'>DO_AGGSPLIT_COMBINE</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN478"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN58"><span class='Ref_to_Member'>aggsplit</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* add the input expressions' cost to per-input-row costs */ 
</span>            <a href="../../../include/optimizer/cost.h.html#LN158"><span class='Ref_to_Proto'>cost_qual_eval_node</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="clauses.c.html#LN495"><span class='Ref_To_Local'>argcosts</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN484"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN300"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN478"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN57"><span class='Ref_to_Member'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="clauses.c.html#LN485"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN61"><span class='Ref_to_Member'>transCost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a> <span class='Operator'>+= </span><a href="clauses.c.html#LN495"><span class='Ref_To_Local'>argcosts</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>            <a href="clauses.c.html#LN485"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN61"><span class='Ref_to_Member'>transCost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>+= </span><a href="clauses.c.html#LN495"><span class='Ref_To_Local'>argcosts</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Add any filter's cost to per-input-row costs. 
             * 
             * XXX Ideally we should reduce input expression costs according 
             * to filter selectivity, but it's not clear it's worth the 
             * trouble. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN484"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN303"><span class='Ref_to_Member'>aggfilter</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="../../../include/optimizer/cost.h.html#LN158"><span class='Ref_to_Proto'>cost_qual_eval_node</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="clauses.c.html#LN495"><span class='Ref_To_Local'>argcosts</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN484"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN303"><span class='Ref_to_Member'>aggfilter</span></a><span class='Delimiter'>, 
</span>                                    <a href="clauses.c.html#LN478"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN57"><span class='Ref_to_Member'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN485"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN61"><span class='Ref_to_Member'>transCost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a> <span class='Operator'>+= </span><a href="clauses.c.html#LN495"><span class='Ref_To_Local'>argcosts</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN485"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN61"><span class='Ref_to_Member'>transCost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>+= </span><a href="clauses.c.html#LN495"><span class='Ref_To_Local'>argcosts</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !DO_AGGSPLIT_COMBINE(... &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* 
         * If there are direct arguments, treat their evaluation cost like the 
         * cost of the finalfn. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN484"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN299"><span class='Ref_to_Member'>aggdirectargs</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../../include/optimizer/cost.h.html#LN158"><span class='Ref_to_Proto'>cost_qual_eval_node</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="clauses.c.html#LN495"><span class='Ref_To_Local'>argcosts</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN484"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN299"><span class='Ref_to_Member'>aggdirectargs</span></a><span class='Delimiter'>, 
</span>                                <a href="clauses.c.html#LN478"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN57"><span class='Ref_to_Member'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="clauses.c.html#LN485"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN61"><span class='Ref_to_Member'>transCost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a> <span class='Operator'>+= </span><a href="clauses.c.html#LN495"><span class='Ref_To_Local'>argcosts</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>            <a href="clauses.c.html#LN485"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN62"><span class='Ref_to_Member'>finalCost</span></a> <span class='Operator'>+= </span><a href="clauses.c.html#LN495"><span class='Ref_To_Local'>argcosts</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If the transition type is pass-by-value then it doesn't add 
         * anything to the required size of the hashtable.  If it is 
         * pass-by-reference then we have to add the estimated size of the 
         * value itself, plus palloc overhead. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/utils/lsyscache.h.html#LN134"><span class='Ref_to_Proto'>get_typbyval</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN493"><span class='Ref_To_Local'>aggtranstype</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN644"></a>            <a href="../../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>avgwidth</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Use average width if aggregate definition gave one */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN494"><span class='Ref_To_Local'>aggtransspace</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <a href="clauses.c.html#LN644"><span class='Ref_To_Local'>avgwidth</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN494"><span class='Ref_To_Local'>aggtransspace</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN488"><span class='Ref_To_Local'>aggtransfn</span></a> <span class='Operator'>== </span>F_ARRAY_APPEND<span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * If the transition function is array_append(), it'll use an 
                 * expanded array as transvalue, which will occupy at least 
                 * ALLOCSET_SMALL_INITSIZE and possibly more.  Use that as the 
                 * estimate for lack of a better idea. 
                 */ 
</span>                <a href="clauses.c.html#LN644"><span class='Ref_To_Local'>avgwidth</span></a> <span class='Operator'>= </span><a href="../../../include/utils/memutils.h.html#LN172"><span class='Ref_to_Const'>ALLOCSET_SMALL_INITSIZE</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * If transition state is of same type as first aggregated 
                 * input, assume it's the same typmod (same width) as well. 
                 * This works for cases like MAX/MIN and is probably somewhat 
                 * reasonable otherwise. 
                 */ 
</span><a name="LN667"></a>                <a href="../../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>aggtranstypmod</span> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN484"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN300"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN671"></a>                    <a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN484"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN300"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN493"><span class='Ref_To_Local'>aggtranstype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN671"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Parentheses'>))</span> 
                        <a href="clauses.c.html#LN667"><span class='Ref_To_Local'>aggtranstypmod</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodeFuncs.h.html#LN32"><span class='Ref_to_Proto'>exprTypmod</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN671"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
                <a href="clauses.c.html#LN644"><span class='Ref_To_Local'>avgwidth</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN170"><span class='Ref_to_Proto'>get_typavgwidth</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN493"><span class='Ref_To_Local'>aggtranstype</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN667"><span class='Ref_To_Local'>aggtranstypmod</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
            <a href="clauses.c.html#LN644"><span class='Ref_To_Local'>avgwidth</span></a> <span class='Operator'>= </span><a href="../../../include/c.h.html#LN587"><span class='Ref_to_Macro'>MAXALIGN</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN644"><span class='Ref_To_Local'>avgwidth</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="clauses.c.html#LN485"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN63"><span class='Ref_to_Member'>transitionSpace</span></a> <span class='Operator'>+= </span><a href="clauses.c.html#LN644"><span class='Ref_To_Local'>avgwidth</span></a> <span class='Operator'>+ </span><span class='Number'>2</span> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !get_typbyval(aggtran... &raquo; </span> 
        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN493"><span class='Ref_To_Local'>aggtranstype</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_type.h.html#LN697"><span class='Ref_to_Const'>INTERNALOID</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * INTERNAL transition type is a special case: although INTERNAL 
             * is pass-by-value, it's almost certainly being used as a pointer 
             * to some large data structure.  The aggregate definition can 
             * provide an estimate of the size.  If it doesn't, then we assume 
             * ALLOCSET_DEFAULT_INITSIZE, which is a good guess if the data is 
             * being kept in a private memory context, as is done by 
             * array_agg() for instance. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN494"><span class='Ref_To_Local'>aggtransspace</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <a href="clauses.c.html#LN485"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN63"><span class='Ref_to_Member'>transitionSpace</span></a> <span class='Operator'>+= </span><a href="clauses.c.html#LN494"><span class='Ref_To_Local'>aggtransspace</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="clauses.c.html#LN485"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN63"><span class='Ref_to_Member'>transitionSpace</span></a> <span class='Operator'>+= </span><a href="../../../include/utils/memutils.h.html#LN162"><span class='Ref_to_Const'>ALLOCSET_DEFAULT_INITSIZE</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We assume that the parser checked that there are no aggregates (of 
         * this level anyway) in the aggregated arguments, direct arguments, 
         * or filter clause.  Hence, we need not recurse into any of them. 
         */ 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IsA(node,Aggref) &raquo; </span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN478"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN629"><span class='Ref_to_Struct'>SubLink</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="../../../include/nodes/nodeFuncs.h.html#LN52"><span class='Ref_to_Proto'>expression_tree_walker</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN478"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN99"><span class='Ref_to_Proto'>get_agg_clause_costs_walker</span></a><span class='Delimiter'>, 
</span>                                  <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN478"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end get_agg_clause_costs_walker &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/***************************************************************************** 
 *      Window-function clause manipulation 
 *****************************************************************************/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * contain_window_function 
 *    Recursively search for WindowFunc nodes within a clause. 
 * 
 * Since window functions don't have level fields, but are hard-wired to 
 * be associated with the current query level, this is just the same as 
 * rewriteManip.c's function. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN726"></a><span class='Declare_Function'>contain_window_function</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="../../../include/rewrite/rewriteManip.h.html#LN59"><span class='Ref_to_Proto'>contain_windowfuncs</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN726"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * find_window_functions 
 *    Locate all the WindowFunc nodes in an expression tree, and organize 
 *    them by winref ID number. 
 * 
 * Caller must provide an upper bound on the winref IDs expected in the tree. 
 */ 
</span><a href="../../../include/optimizer/clauses.h.html#LN22"><span class='Ref_to_Typedef'>WindowFuncLists</span></a> <span class='Operator'>* 
</span><a name="LN739"></a><span class='Declare_Function'>find_window_functions</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> <span class='Declare_Parameter'>maxWinRef</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN741"></a>    <a href="../../../include/optimizer/clauses.h.html#LN22"><span class='Ref_to_Typedef'>WindowFuncLists</span></a> <span class='Operator'>*</span><span class='Declare_Local'>lists</span> <span class='Operator'>= </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/optimizer/clauses.h.html#LN22"><span class='Ref_to_Typedef'>WindowFuncLists</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="clauses.c.html#LN741"><span class='Ref_To_Local'>lists</span></a><span class='Operator'>-&GT;</span><a href="../../../include/optimizer/clauses.h.html#LN24"><span class='Ref_to_Member'>numWindowFuncs</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN741"><span class='Ref_To_Local'>lists</span></a><span class='Operator'>-&GT;</span><a href="../../../include/optimizer/clauses.h.html#LN25"><span class='Ref_to_Member'>maxWinRef</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN739"><span class='Ref_to_Parameter'>maxWinRef</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN741"><span class='Ref_To_Local'>lists</span></a><span class='Operator'>-&GT;</span><a href="../../../include/optimizer/clauses.h.html#LN26"><span class='Ref_to_Member'>windowFuncs</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>((</span><a href="clauses.c.html#LN739"><span class='Ref_to_Parameter'>maxWinRef</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN101"><span class='Ref_to_Proto'>find_window_functions_walker</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN739"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN741"><span class='Ref_To_Local'>lists</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="clauses.c.html#LN741"><span class='Ref_To_Local'>lists</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static bool 
</span><a name="LN751"></a><span class='Declare_Function'>find_window_functions_walker</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><a href="../../../include/optimizer/clauses.h.html#LN22"><span class='Ref_to_Typedef'>WindowFuncLists</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>lists</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN751"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN751"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN351"><span class='Ref_to_Struct'>WindowFunc</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN757"></a>        <a href="../../../include/nodes/primnodes.h.html#LN351"><span class='Ref_to_Struct'>WindowFunc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>wfunc</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN351"><span class='Ref_to_Struct'>WindowFunc</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN751"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* winref is unsigned, so one-sided test is OK */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN757"><span class='Ref_To_Local'>wfunc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN360"><span class='Ref_to_Member'>winref</span></a> <span class='Operator'>&GT; </span><a href="clauses.c.html#LN751"><span class='Ref_to_Parameter'>lists</span></a><span class='Operator'>-&GT;</span><a href="../../../include/optimizer/clauses.h.html#LN25"><span class='Ref_to_Member'>maxWinRef</span></a><span class='Parentheses'>) 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"WindowFunc contains out-of-range winref %u"</span><span class='Delimiter'>, 
</span>                 <a href="clauses.c.html#LN757"><span class='Ref_To_Local'>wfunc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN360"><span class='Ref_to_Member'>winref</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* eliminate duplicates, so that we avoid repeated computation */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/pg_list.h.html#LN228"><span class='Ref_to_Proto'>list_member</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN751"><span class='Ref_to_Parameter'>lists</span></a><span class='Operator'>-&GT;</span><a href="../../../include/optimizer/clauses.h.html#LN26"><span class='Ref_to_Member'>windowFuncs</span></a><span class='Delimiter'>[</span><a href="clauses.c.html#LN757"><span class='Ref_To_Local'>wfunc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN360"><span class='Ref_to_Member'>winref</span></a><span class='Delimiter'>], </span><a href="clauses.c.html#LN757"><span class='Ref_To_Local'>wfunc</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="clauses.c.html#LN751"><span class='Ref_to_Parameter'>lists</span></a><span class='Operator'>-&GT;</span><a href="../../../include/optimizer/clauses.h.html#LN26"><span class='Ref_to_Member'>windowFuncs</span></a><span class='Delimiter'>[</span><a href="clauses.c.html#LN757"><span class='Ref_To_Local'>wfunc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN360"><span class='Ref_to_Member'>winref</span></a><span class='Delimiter'>] </span><span class='Operator'>= 
</span>                <a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN751"><span class='Ref_to_Parameter'>lists</span></a><span class='Operator'>-&GT;</span><a href="../../../include/optimizer/clauses.h.html#LN26"><span class='Ref_to_Member'>windowFuncs</span></a><span class='Delimiter'>[</span><a href="clauses.c.html#LN757"><span class='Ref_To_Local'>wfunc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN360"><span class='Ref_to_Member'>winref</span></a><span class='Delimiter'>], </span><a href="clauses.c.html#LN757"><span class='Ref_To_Local'>wfunc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="clauses.c.html#LN751"><span class='Ref_to_Parameter'>lists</span></a><span class='Operator'>-&GT;</span><a href="../../../include/optimizer/clauses.h.html#LN24"><span class='Ref_to_Member'>numWindowFuncs</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We assume that the parser checked that there are no window 
         * functions in the arguments or filter clause.  Hence, we need not 
         * recurse into them.  (If either the parser or the planner screws up 
         * on this point, the executor will still catch it; see ExecInitExpr.) 
         */ 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IsA(node,WindowFunc) &raquo; </span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN751"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN629"><span class='Ref_to_Struct'>SubLink</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="../../../include/nodes/nodeFuncs.h.html#LN52"><span class='Ref_to_Proto'>expression_tree_walker</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN751"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN101"><span class='Ref_to_Proto'>find_window_functions_walker</span></a><span class='Delimiter'>, 
</span>                                  <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN751"><span class='Ref_to_Parameter'>lists</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end find_window_functions_walker &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/***************************************************************************** 
 *      Support for expressions returning sets 
 *****************************************************************************/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * expression_returns_set_rows 
 *    Estimate the number of rows returned by a set-returning expression. 
 *    The result is 1 if it's not a set-returning expression. 
 * 
 * We should only examine the top-level function or operator; it used to be 
 * appropriate to recurse, but not anymore.  (Even if there are more SRFs in 
 * the function's inputs, their multipliers are accounted for separately.) 
 * 
 * Note: keep this in sync with expression_returns_set() in nodes/nodeFuncs.c. 
 */ 
</span><span class='Keyword'>double 
</span><a name="LN801"></a><span class='Declare_Function'>expression_returns_set_rows</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN801"><span class='Ref_to_Parameter'>clause</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN801"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN807"></a>        <a href="../../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN801"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN807"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN449"><span class='Ref_to_Member'>funcretset</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <a href="../../../include/optimizer/cost.h.html#LN71"><span class='Ref_to_Proto'>clamp_row_est</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/lsyscache.h.html#LN122"><span class='Ref_to_Proto'>get_func_rows</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN807"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN447"><span class='Ref_to_Member'>funcid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN801"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN814"></a>        <a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN801"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN814"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN497"><span class='Ref_to_Member'>opretset</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../../include/nodes/nodeFuncs.h.html#LN46"><span class='Ref_to_Proto'>set_opfuncid</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN814"><span class='Ref_To_Local'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <a href="../../../include/optimizer/cost.h.html#LN71"><span class='Ref_to_Proto'>clamp_row_est</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/lsyscache.h.html#LN122"><span class='Ref_to_Proto'>get_func_rows</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN814"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN495"><span class='Ref_to_Member'>opfuncid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end expression_returns_set_rows &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/***************************************************************************** 
 *      Subplan clause manipulation 
 *****************************************************************************/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * contain_subplans 
 *    Recursively search for subplan nodes within a clause. 
 * 
 * If we see a SubLink node, we will return TRUE.  This is only possible if 
 * the expression tree hasn't yet been transformed by subselect.c.  We do not 
 * know whether the node will produce a true subplan or just an initplan, 
 * but we make the conservative assumption that it will be a subplan. 
 * 
 * Returns true if any subplan found. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN842"></a><span class='Declare_Function'>contain_subplans</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="clauses.c.html#LN102"><span class='Ref_to_Proto'>contain_subplans_walker</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN842"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static bool 
</span><a name="LN848"></a><span class='Declare_Function'>contain_subplans_walker</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN848"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN848"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN678"><span class='Ref_to_Struct'>SubPlan</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN848"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN722"><span class='Ref_to_Struct'>AlternativeSubPlan</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN848"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN629"><span class='Ref_to_Struct'>SubLink</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* abort the tree traversal and return true */ 
</span>    <span class='Control'>return</span> <a href="../../../include/nodes/nodeFuncs.h.html#LN52"><span class='Ref_to_Proto'>expression_tree_walker</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN848"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN102"><span class='Ref_to_Proto'>contain_subplans_walker</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN848"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/***************************************************************************** 
 *      Check clauses for mutable functions 
 *****************************************************************************/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * contain_mutable_functions 
 *    Recursively search for mutable functions within a clause. 
 * 
 * Returns true if any mutable function (or operator implemented by a 
 * mutable function) is found.  This test is needed so that we don't 
 * mistakenly think that something like "WHERE random() &LT; 0.5" can be treated 
 * as a constant qualification. 
 * 
 * We will recursively look into Query nodes (i.e., SubLink sub-selects) 
 * but not into SubPlans.  See comments for contain_volatile_functions(). 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN877"></a><span class='Declare_Function'>contain_mutable_functions</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="clauses.c.html#LN103"><span class='Ref_to_Proto'>contain_mutable_functions_walker</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN877"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static bool 
</span><a name="LN883"></a><span class='Declare_Function'>contain_mutable_functions_checker</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>func_id</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/utils/lsyscache.h.html#LN118"><span class='Ref_to_Proto'>func_volatile</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN883"><span class='Ref_to_Parameter'>func_id</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="../../../include/catalog/pg_proc.h.html#LN5482"><span class='Ref_to_Const'>PROVOLATILE_IMMUTABLE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static bool 
</span><a name="LN889"></a><span class='Declare_Function'>contain_mutable_functions_walker</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN889"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* Check for mutable functions in node itself */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodeFuncs.h.html#LN49"><span class='Ref_to_Proto'>check_functions_in_node</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN889"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN882"><span class='Ref_to_Func'>contain_mutable_functions_checker</span></a><span class='Delimiter'>, 
</span>                                <a href="clauses.c.html#LN889"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN889"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1099"><span class='Ref_to_Struct'>SQLValueFunction</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* all variants of SQLValueFunction are stable */ 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * It should be safe to treat MinMaxExpr as immutable, because it will 
     * depend on a non-cross-type btree comparison function, and those should 
     * always be immutable.  Treating XmlExpr as immutable is more dubious, 
     * and treating CoerceToDomain as immutable is outright dangerous.  But we 
     * have done so historically, and changing this would probably cause more 
     * problems than it would fix.  In practice, if you have a non-immutable 
     * domain constraint you are in for pain anyhow. 
     */ 
</span> 
    <span class='Comment_Multi_Line'>/* Recurse to check arguments */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN889"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Recurse into subselects */ 
</span>        <span class='Control'>return</span> <a href="../../../include/nodes/nodeFuncs.h.html#LN57"><span class='Ref_to_Proto'>query_tree_walker</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN889"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, 
</span>                                 <a href="clauses.c.html#LN103"><span class='Ref_to_Proto'>contain_mutable_functions_walker</span></a><span class='Delimiter'>, 
</span>                                 <a href="clauses.c.html#LN889"><span class='Ref_to_Parameter'>context</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <a href="../../../include/nodes/nodeFuncs.h.html#LN52"><span class='Ref_to_Proto'>expression_tree_walker</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN889"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN103"><span class='Ref_to_Proto'>contain_mutable_functions_walker</span></a><span class='Delimiter'>, 
</span>                                  <a href="clauses.c.html#LN889"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end contain_mutable_functions_walker &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/***************************************************************************** 
 *      Check clauses for volatile functions 
 *****************************************************************************/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * contain_volatile_functions 
 *    Recursively search for volatile functions within a clause. 
 * 
 * Returns true if any volatile function (or operator implemented by a 
 * volatile function) is found. This test prevents, for example, 
 * invalid conversions of volatile expressions into indexscan quals. 
 * 
 * We will recursively look into Query nodes (i.e., SubLink sub-selects) 
 * but not into SubPlans.  This is a bit odd, but intentional.  If we are 
 * looking at a SubLink, we are probably deciding whether a query tree 
 * transformation is safe, and a contained sub-select should affect that; 
 * for example, duplicating a sub-select containing a volatile function 
 * would be bad.  However, once we've got to the stage of having SubPlans, 
 * subsequent planning need not consider volatility within those, since 
 * the executor won't change its evaluation rules for a SubPlan based on 
 * volatility. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN950"></a><span class='Declare_Function'>contain_volatile_functions</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="clauses.c.html#LN104"><span class='Ref_to_Proto'>contain_volatile_functions_walker</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN950"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static bool 
</span><a name="LN956"></a><span class='Declare_Function'>contain_volatile_functions_checker</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>func_id</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/utils/lsyscache.h.html#LN118"><span class='Ref_to_Proto'>func_volatile</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN956"><span class='Ref_to_Parameter'>func_id</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="../../../include/catalog/pg_proc.h.html#LN5484"><span class='Ref_to_Const'>PROVOLATILE_VOLATILE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static bool 
</span><a name="LN962"></a><span class='Declare_Function'>contain_volatile_functions_walker</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN962"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* Check for volatile functions in node itself */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodeFuncs.h.html#LN49"><span class='Ref_to_Proto'>check_functions_in_node</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN962"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN955"><span class='Ref_to_Func'>contain_volatile_functions_checker</span></a><span class='Delimiter'>, 
</span>                                <a href="clauses.c.html#LN962"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * See notes in contain_mutable_functions_walker about why we treat 
     * MinMaxExpr, XmlExpr, and CoerceToDomain as immutable, while 
     * SQLValueFunction is stable.  Hence, none of them are of interest here. 
     */ 
</span> 
    <span class='Comment_Multi_Line'>/* Recurse to check arguments */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN962"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Recurse into subselects */ 
</span>        <span class='Control'>return</span> <a href="../../../include/nodes/nodeFuncs.h.html#LN57"><span class='Ref_to_Proto'>query_tree_walker</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN962"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, 
</span>                                 <a href="clauses.c.html#LN104"><span class='Ref_to_Proto'>contain_volatile_functions_walker</span></a><span class='Delimiter'>, 
</span>                                 <a href="clauses.c.html#LN962"><span class='Ref_to_Parameter'>context</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <a href="../../../include/nodes/nodeFuncs.h.html#LN52"><span class='Ref_to_Proto'>expression_tree_walker</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN962"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN104"><span class='Ref_to_Proto'>contain_volatile_functions_walker</span></a><span class='Delimiter'>, 
</span>                                  <a href="clauses.c.html#LN962"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end contain_volatile_functions_walker &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Special purpose version of contain_volatile_functions() for use in COPY: 
 * ignore nextval(), but treat all other functions normally. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN994"></a><span class='Declare_Function'>contain_volatile_functions_not_nextval</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="clauses.c.html#LN105"><span class='Ref_to_Proto'>contain_volatile_functions_not_nextval_walker</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN994"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static bool 
</span><a name="LN1000"></a><span class='Declare_Function'>contain_volatile_functions_not_nextval_checker</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>func_id</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN1000"><span class='Ref_to_Parameter'>func_id</span></a> <span class='Operator'>!= </span>F_NEXTVAL_OID <span class='Operator'>&& 
</span>            <a href="../../../include/utils/lsyscache.h.html#LN118"><span class='Ref_to_Proto'>func_volatile</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1000"><span class='Ref_to_Parameter'>func_id</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="../../../include/catalog/pg_proc.h.html#LN5484"><span class='Ref_to_Const'>PROVOLATILE_VOLATILE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static bool 
</span><a name="LN1007"></a><span class='Declare_Function'>contain_volatile_functions_not_nextval_walker</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN1007"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* Check for volatile functions in node itself */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodeFuncs.h.html#LN49"><span class='Ref_to_Proto'>check_functions_in_node</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1007"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, 
</span>                              <a href="clauses.c.html#LN999"><span class='Ref_to_Func'>contain_volatile_functions_not_nextval_checker</span></a><span class='Delimiter'>, 
</span>                                <a href="clauses.c.html#LN1007"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * See notes in contain_mutable_functions_walker about why we treat 
     * MinMaxExpr, XmlExpr, and CoerceToDomain as immutable, while 
     * SQLValueFunction is stable.  Hence, none of them are of interest here. 
     */ 
</span> 
    <span class='Comment_Multi_Line'>/* Recurse to check arguments */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1007"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Recurse into subselects */ 
</span>        <span class='Control'>return</span> <a href="../../../include/nodes/nodeFuncs.h.html#LN57"><span class='Ref_to_Proto'>query_tree_walker</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1007"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, 
</span>                               <a href="clauses.c.html#LN105"><span class='Ref_to_Proto'>contain_volatile_functions_not_nextval_walker</span></a><span class='Delimiter'>, 
</span>                                 <a href="clauses.c.html#LN1007"><span class='Ref_to_Parameter'>context</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <a href="../../../include/nodes/nodeFuncs.h.html#LN52"><span class='Ref_to_Proto'>expression_tree_walker</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1007"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, 
</span>                               <a href="clauses.c.html#LN105"><span class='Ref_to_Proto'>contain_volatile_functions_not_nextval_walker</span></a><span class='Delimiter'>, 
</span>                                  <a href="clauses.c.html#LN1007"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end contain_volatile_functions_not_nextval_walker &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/***************************************************************************** 
 *      Check queries for parallel unsafe and/or restricted constructs 
 *****************************************************************************/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * max_parallel_hazard 
 *      Find the worst parallel-hazard level in the given query 
 * 
 * Returns the worst function hazard property (the earliest in this list: 
 * PROPARALLEL_UNSAFE, PROPARALLEL_RESTRICTED, PROPARALLEL_SAFE) that can 
 * be found in the given parsetree.  We use this to find out whether the query 
 * can be parallelized at all.  The caller will also save the result in 
 * PlannerGlobal so as to short-circuit checks of portions of the querytree 
 * later, in the common case where everything is SAFE. 
 */ 
</span><span class='Keyword'>char 
</span><a name="LN1053"></a><span class='Declare_Function'>max_parallel_hazard</span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>parse</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1055"></a>    <a href="clauses.c.html#LN91"><span class='Ref_to_Typedef'>max_parallel_hazard_context</span></a> <span class='Declare_Local'>context</span><span class='Delimiter'>; 
</span> 
    <a href="clauses.c.html#LN1055"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="clauses.c.html#LN93"><span class='Ref_to_Member'>max_hazard</span></a> <span class='Operator'>= </span><a href="../../../include/catalog/pg_proc.h.html#LN5491"><span class='Ref_to_Const'>PROPARALLEL_SAFE</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN1055"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="clauses.c.html#LN94"><span class='Ref_to_Member'>max_interesting</span></a> <span class='Operator'>= </span><a href="../../../include/catalog/pg_proc.h.html#LN5493"><span class='Ref_to_Const'>PROPARALLEL_UNSAFE</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN1055"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="clauses.c.html#LN95"><span class='Ref_to_Member'>safe_param_ids</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN106"><span class='Ref_to_Proto'>max_parallel_hazard_walker</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1053"><span class='Ref_to_Parameter'>parse</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="clauses.c.html#LN1055"><span class='Ref_To_Local'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="clauses.c.html#LN1055"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="clauses.c.html#LN93"><span class='Ref_to_Member'>max_hazard</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * is_parallel_safe 
 *      Detect whether the given expr contains only parallel-safe functions 
 * 
 * root-&GT;glob-&GT;maxParallelHazard must previously have been set to the 
 * result of max_parallel_hazard() on the whole query. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN1072"></a><span class='Declare_Function'>is_parallel_safe</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1074"></a>    <a href="clauses.c.html#LN91"><span class='Ref_to_Typedef'>max_parallel_hazard_context</span></a> <span class='Declare_Local'>context</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Even if the original querytree contained nothing unsafe, we need to 
     * search the expression if we have generated any PARAM_EXEC Params while 
     * planning, because those are parallel-restricted and there might be one 
     * in this expression.  But otherwise we don't need to look. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN1072"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN156"><span class='Ref_to_Member'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN132"><span class='Ref_to_Member'>maxParallelHazard</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_proc.h.html#LN5491"><span class='Ref_to_Const'>PROPARALLEL_SAFE</span></a> <span class='Operator'>&& 
</span>        <a href="clauses.c.html#LN1072"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN156"><span class='Ref_to_Member'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN116"><span class='Ref_to_Member'>nParamExec</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* Else use max_parallel_hazard's search logic, but stop on RESTRICTED */ 
</span>    <a href="clauses.c.html#LN1074"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="clauses.c.html#LN93"><span class='Ref_to_Member'>max_hazard</span></a> <span class='Operator'>= </span><a href="../../../include/catalog/pg_proc.h.html#LN5491"><span class='Ref_to_Const'>PROPARALLEL_SAFE</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN1074"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="clauses.c.html#LN94"><span class='Ref_to_Member'>max_interesting</span></a> <span class='Operator'>= </span><a href="../../../include/catalog/pg_proc.h.html#LN5492"><span class='Ref_to_Const'>PROPARALLEL_RESTRICTED</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN1074"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="clauses.c.html#LN95"><span class='Ref_to_Member'>safe_param_ids</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Operator'>!</span><a href="clauses.c.html#LN106"><span class='Ref_to_Proto'>max_parallel_hazard_walker</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1072"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="clauses.c.html#LN1074"><span class='Ref_To_Local'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end is_parallel_safe &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* core logic for all parallel-hazard checks */ 
</span><span class='Keyword'>static bool 
</span><a name="LN1094"></a><span class='Declare_Function'>max_parallel_hazard_test</span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Declare_Parameter'>proparallel</span><span class='Delimiter'>, </span><a href="clauses.c.html#LN91"><span class='Ref_to_Typedef'>max_parallel_hazard_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN1094"><span class='Ref_to_Parameter'>proparallel</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../../include/catalog/pg_proc.h.html#LN5491"><span class='Ref_to_Const'>PROPARALLEL_SAFE</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* nothing to see here, move along */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/catalog/pg_proc.h.html#LN5492"><span class='Ref_to_Const'>PROPARALLEL_RESTRICTED</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* increase max_hazard to RESTRICTED */ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="clauses.c.html#LN1094"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN93"><span class='Ref_to_Member'>max_hazard</span></a> <span class='Operator'>!= </span><a href="../../../include/catalog/pg_proc.h.html#LN5493"><span class='Ref_to_Const'>PROPARALLEL_UNSAFE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="clauses.c.html#LN1094"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN93"><span class='Ref_to_Member'>max_hazard</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN1094"><span class='Ref_to_Parameter'>proparallel</span></a><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* done if we are not expecting any unsafe functions */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN1094"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN94"><span class='Ref_to_Member'>max_interesting</span></a> <span class='Operator'>== </span><a href="clauses.c.html#LN1094"><span class='Ref_to_Parameter'>proparallel</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/catalog/pg_proc.h.html#LN5493"><span class='Ref_to_Const'>PROPARALLEL_UNSAFE</span></a><span class='Operator'>: 
</span>            <a href="clauses.c.html#LN1094"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN93"><span class='Ref_to_Member'>max_hazard</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN1094"><span class='Ref_to_Parameter'>proparallel</span></a><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* we're always done at the first unsafe construct */ 
</span>            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Control'>default</span><span class='Operator'>: 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized proparallel value \"%c\""</span><span class='Delimiter'>, </span><a href="clauses.c.html#LN1094"><span class='Ref_to_Parameter'>proparallel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch proparallel &raquo; </span> 
    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end max_parallel_hazard_test &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* check_functions_in_node callback */ 
</span><span class='Keyword'>static bool 
</span><a name="LN1122"></a><span class='Declare_Function'>max_parallel_hazard_checker</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>func_id</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="clauses.c.html#LN1093"><span class='Ref_to_Func'>max_parallel_hazard_test</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/lsyscache.h.html#LN119"><span class='Ref_to_Proto'>func_parallel</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1122"><span class='Ref_to_Parameter'>func_id</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                    <span class='Parentheses'>(</span><a href="clauses.c.html#LN91"><span class='Ref_to_Typedef'>max_parallel_hazard_context</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1122"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static bool 
</span><a name="LN1129"></a><span class='Declare_Function'>max_parallel_hazard_walker</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><a href="clauses.c.html#LN91"><span class='Ref_to_Typedef'>max_parallel_hazard_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN1129"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Check for hazardous functions in node itself */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodeFuncs.h.html#LN49"><span class='Ref_to_Proto'>check_functions_in_node</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1129"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN1121"><span class='Ref_to_Func'>max_parallel_hazard_checker</span></a><span class='Delimiter'>, 
</span>                                <a href="clauses.c.html#LN1129"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * It should be OK to treat MinMaxExpr as parallel-safe, since btree 
     * opclass support functions are generally parallel-safe.  XmlExpr is a 
     * bit more dubious but we can probably get away with it.  We err on the 
     * side of caution by treating CoerceToDomain as parallel-restricted. 
     * (Note: in principle that's wrong because a domain constraint could 
     * contain a parallel-unsafe function; but useful constraints probably 
     * never would have such, and assuming they do would cripple use of 
     * parallel query in the presence of domain types.)  SQLValueFunction 
     * should be safe in all cases. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1129"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1215"><span class='Ref_to_Struct'>CoerceToDomain</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN1093"><span class='Ref_to_Func'>max_parallel_hazard_test</span></a><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_proc.h.html#LN5492"><span class='Ref_to_Const'>PROPARALLEL_RESTRICTED</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN1129"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * As a notational convenience for callers, look through RestrictInfo. 
     */ 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1129"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1161"></a>        <a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1129"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>return</span> <a href="clauses.c.html#LN106"><span class='Ref_to_Proto'>max_parallel_hazard_walker</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1161"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1746"><span class='Ref_to_Member'>clause</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN1129"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Really we should not see SubLink during a max_interesting == restricted 
     * scan, but if we do, return true. 
     */ 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1129"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN629"><span class='Ref_to_Struct'>SubLink</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN1093"><span class='Ref_to_Func'>max_parallel_hazard_test</span></a><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_proc.h.html#LN5492"><span class='Ref_to_Const'>PROPARALLEL_RESTRICTED</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN1129"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Only parallel-safe SubPlans can be sent to workers.  Within the 
     * testexpr of the SubPlan, Params representing the output columns of the 
     * subplan can be treated as parallel-safe, so temporarily add their IDs 
     * to the safe_param_ids list while examining the testexpr. 
     */ 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1129"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN678"><span class='Ref_to_Struct'>SubPlan</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1184"></a>        <a href="../../../include/nodes/primnodes.h.html#LN678"><span class='Ref_to_Struct'>SubPlan</span></a>    <span class='Operator'>*</span><span class='Declare_Local'>subplan</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN678"><span class='Ref_to_Struct'>SubPlan</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1129"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span><a name="LN1185"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>save_safe_param_ids</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="clauses.c.html#LN1184"><span class='Ref_To_Local'>subplan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN701"><span class='Ref_to_Member'>parallel_safe</span></a> <span class='Operator'>&& 
</span>            <a href="clauses.c.html#LN1093"><span class='Ref_to_Func'>max_parallel_hazard_test</span></a><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_proc.h.html#LN5492"><span class='Ref_to_Const'>PROPARALLEL_RESTRICTED</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN1129"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <a href="clauses.c.html#LN1185"><span class='Ref_To_Local'>save_safe_param_ids</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN1129"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN95"><span class='Ref_to_Member'>safe_param_ids</span></a><span class='Delimiter'>; 
</span>        <a href="clauses.c.html#LN1129"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN95"><span class='Ref_to_Member'>safe_param_ids</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN268"><span class='Ref_to_Proto'>list_copy</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1184"><span class='Ref_To_Local'>subplan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN685"><span class='Ref_to_Member'>paramIds</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                              <a href="clauses.c.html#LN1129"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN95"><span class='Ref_to_Member'>safe_param_ids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN106"><span class='Ref_to_Proto'>max_parallel_hazard_walker</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1184"><span class='Ref_To_Local'>subplan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN684"><span class='Ref_to_Member'>testexpr</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN1129"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* no need to restore safe_param_ids */ 
</span>        <a href="clauses.c.html#LN1129"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN95"><span class='Ref_to_Member'>safe_param_ids</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN1185"><span class='Ref_To_Local'>save_safe_param_ids</span></a><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* we must also check args, but no special Param treatment there */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN106"><span class='Ref_to_Proto'>max_parallel_hazard_walker</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1184"><span class='Ref_To_Local'>subplan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN708"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN1129"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* don't want to recurse normally, so we're done */ 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IsA(node,SubPlan) &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * We can't pass Params to workers at the moment either, so they are also 
     * parallel-restricted, unless they are PARAM_EXEC Params listed in 
     * safe_param_ids, meaning they could be generated within the worker. 
     */ 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1129"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN240"><span class='Ref_to_Struct'>Param</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1210"></a>        <a href="../../../include/nodes/primnodes.h.html#LN240"><span class='Ref_to_Struct'>Param</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>param</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN240"><span class='Ref_to_Struct'>Param</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1129"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN1210"><span class='Ref_To_Local'>param</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN243"><span class='Ref_to_Member'>paramkind</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/primnodes.h.html#LN235"><span class='Ref_to_EnumConst'>PARAM_EXEC</span></a> <span class='Operator'>|| 
</span>            <span class='Operator'>!</span><a href="../../../include/nodes/pg_list.h.html#LN230"><span class='Ref_to_Proto'>list_member_int</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1129"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN95"><span class='Ref_to_Member'>safe_param_ids</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN1210"><span class='Ref_To_Local'>param</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN244"><span class='Ref_to_Member'>paramid</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN1093"><span class='Ref_to_Func'>max_parallel_hazard_test</span></a><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_proc.h.html#LN5492"><span class='Ref_to_Const'>PROPARALLEL_RESTRICTED</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN1129"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* nothing to recurse to */ 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * When we're first invoked on a completely unplanned tree, we must 
     * recurse into subqueries so to as to locate parallel-unsafe constructs 
     * anywhere in the tree. 
     */ 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1129"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1228"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>query</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1129"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* SELECT FOR UPDATE/SHARE must be treated as unsafe */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN1228"><span class='Ref_To_Local'>query</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN160"><span class='Ref_to_Member'>rowMarks</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="clauses.c.html#LN1129"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN93"><span class='Ref_to_Member'>max_hazard</span></a> <span class='Operator'>= </span><a href="../../../include/catalog/pg_proc.h.html#LN5493"><span class='Ref_to_Const'>PROPARALLEL_UNSAFE</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Recurse into subselects */ 
</span>        <span class='Control'>return</span> <a href="../../../include/nodes/nodeFuncs.h.html#LN57"><span class='Ref_to_Proto'>query_tree_walker</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1228"><span class='Ref_To_Local'>query</span></a><span class='Delimiter'>, 
</span>                                 <a href="clauses.c.html#LN106"><span class='Ref_to_Proto'>max_parallel_hazard_walker</span></a><span class='Delimiter'>, 
</span>                                 <a href="clauses.c.html#LN1129"><span class='Ref_to_Parameter'>context</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Recurse to check arguments */ 
</span>    <span class='Control'>return</span> <a href="../../../include/nodes/nodeFuncs.h.html#LN52"><span class='Ref_to_Proto'>expression_tree_walker</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1129"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, 
</span>                                  <a href="clauses.c.html#LN106"><span class='Ref_to_Proto'>max_parallel_hazard_walker</span></a><span class='Delimiter'>, 
</span>                                  <a href="clauses.c.html#LN1129"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end max_parallel_hazard_walker &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/***************************************************************************** 
 *      Check clauses for nonstrict functions 
 *****************************************************************************/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * contain_nonstrict_functions 
 *    Recursively search for nonstrict functions within a clause. 
 * 
 * Returns true if any nonstrict construct is found --- ie, anything that 
 * could produce non-NULL output with a NULL input. 
 * 
 * The idea here is that the caller has verified that the expression contains 
 * one or more Var or Param nodes (as appropriate for the caller's need), and 
 * now wishes to prove that the expression result will be NULL if any of these 
 * inputs is NULL.  If we return false, then the proof succeeded. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN1267"></a><span class='Declare_Function'>contain_nonstrict_functions</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="clauses.c.html#LN108"><span class='Ref_to_Proto'>contain_nonstrict_functions_walker</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1267"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static bool 
</span><a name="LN1273"></a><span class='Declare_Function'>contain_nonstrict_functions_checker</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>func_id</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <span class='Operator'>!</span><a href="../../../include/utils/lsyscache.h.html#LN117"><span class='Ref_to_Proto'>func_strict</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1273"><span class='Ref_to_Parameter'>func_id</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static bool 
</span><a name="LN1279"></a><span class='Declare_Function'>contain_nonstrict_functions_walker</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN1279"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1279"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* an aggregate could return non-null with null input */ 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1279"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN337"><span class='Ref_to_Struct'>GroupingFunc</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * A GroupingFunc doesn't evaluate its arguments, and therefore must 
         * be treated as nonstrict. 
         */ 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1279"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN351"><span class='Ref_to_Struct'>WindowFunc</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* a window function could return non-null with null input */ 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1279"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN395"><span class='Ref_to_Struct'>ArrayRef</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* array assignment is nonstrict, but subscripting is strict */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN395"><span class='Ref_to_Struct'>ArrayRef</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1279"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>refassgnexpr <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* else fall through to check args */ 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1279"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN514"><span class='Ref_to_Typedef'>DistinctExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* IS DISTINCT FROM is inherently non-strict */ 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1279"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN522"><span class='Ref_to_Typedef'>NullIfExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* NULLIF is inherently non-strict */ 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1279"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1320"></a>        <a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1279"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN1320"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN560"><span class='Ref_to_Member'>boolop</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN554"><span class='Ref_to_EnumConst'>AND_EXPR</span></a><span class='Operator'>: 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN554"><span class='Ref_to_EnumConst'>OR_EXPR</span></a><span class='Operator'>: 
</span>                <span class='Comment_Multi_Line'>/* AND, OR are inherently non-strict */ 
</span>                <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>default</span><span class='Operator'>: 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1279"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN629"><span class='Ref_to_Struct'>SubLink</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* In some cases a sublink might be strict, but in general not */ 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1279"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN678"><span class='Ref_to_Struct'>SubPlan</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1279"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN722"><span class='Ref_to_Struct'>AlternativeSubPlan</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1279"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN763"><span class='Ref_to_Struct'>FieldStore</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1279"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN901"><span class='Ref_to_Struct'>CaseExpr</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1279"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN947"><span class='Ref_to_Struct'>ArrayExpr</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1279"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN981"><span class='Ref_to_Struct'>RowExpr</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1279"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1026"><span class='Ref_to_Struct'>RowCompareExpr</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1279"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1040"><span class='Ref_to_Struct'>CoalesceExpr</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1279"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1058"><span class='Ref_to_Struct'>MinMaxExpr</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1279"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1137"><span class='Ref_to_Struct'>XmlExpr</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1279"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1279"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1198"><span class='Ref_to_Struct'>BooleanTest</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Check other function-containing nodes; but ArrayCoerceExpr is strict at 
     * the array level, regardless of elemfunc. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1279"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN829"><span class='Ref_to_Struct'>ArrayCoerceExpr</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>        <a href="../../../include/nodes/nodeFuncs.h.html#LN49"><span class='Ref_to_Proto'>check_functions_in_node</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1279"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN1272"><span class='Ref_to_Func'>contain_nonstrict_functions_checker</span></a><span class='Delimiter'>, 
</span>                                <a href="clauses.c.html#LN1279"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="../../../include/nodes/nodeFuncs.h.html#LN52"><span class='Ref_to_Proto'>expression_tree_walker</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1279"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN108"><span class='Ref_to_Proto'>contain_nonstrict_functions_walker</span></a><span class='Delimiter'>, 
</span>                                  <a href="clauses.c.html#LN1279"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end contain_nonstrict_functions_walker &raquo; </span> 
 
<span class='Comment_Multi_Line'>/***************************************************************************** 
 *      Check clauses for context-dependent nodes 
 *****************************************************************************/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * contain_context_dependent_node 
 *    Recursively search for context-dependent nodes within a clause. 
 * 
 * CaseTestExpr nodes must appear directly within the corresponding CaseExpr, 
 * not nested within another one, or they'll see the wrong test value.  If one 
 * appears "bare" in the arguments of a SQL function, then we can't inline the 
 * SQL function for fear of creating such a situation. 
 * 
 * CoerceToDomainValue would have the same issue if domain CHECK expressions 
 * could get inlined into larger expressions, but presently that's impossible. 
 * Still, it might be allowed in future, or other node types with similar 
 * issues might get invented.  So give this function a generic name, and set 
 * up the recursion state to allow multiple flag bits. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN1394"></a><span class='Declare_Function'>contain_context_dependent_node</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1396"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>flags</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="clauses.c.html#LN110"><span class='Ref_to_Proto'>contain_context_dependent_node_walker</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1394"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="clauses.c.html#LN1396"><span class='Ref_To_Local'>flags</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<a name="LN1401"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>CCDN_IN_CASEEXPR</span>    <span class='Number'>0x0001</span>      <span class='Comment_Single_Line'>/* CaseTestExpr okay here? */ 
</span> 
<span class='Keyword'>static bool 
</span><a name="LN1404"></a><span class='Declare_Function'>contain_context_dependent_node_walker</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Operator'>*</span><span class='Declare_Parameter'>flags</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN1404"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1404"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN931"><span class='Ref_to_Struct'>CaseTestExpr</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Operator'>!</span><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="clauses.c.html#LN1404"><span class='Ref_to_Parameter'>flags</span></a> <span class='Operator'>& </span><a href="clauses.c.html#LN1401"><span class='Ref_to_Const'>CCDN_IN_CASEEXPR</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1404"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN901"><span class='Ref_to_Struct'>CaseExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1412"></a>        <a href="../../../include/nodes/primnodes.h.html#LN901"><span class='Ref_to_Struct'>CaseExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>caseexpr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN901"><span class='Ref_to_Struct'>CaseExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1404"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If this CASE doesn't have a test expression, then it doesn't create 
         * a context in which CaseTestExprs should appear, so just fall 
         * through and treat it as a generic expression node. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN1412"><span class='Ref_To_Local'>caseexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN906"><span class='Ref_to_Member'>arg</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1421"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>save_flags</span> <span class='Operator'>= *</span><a href="clauses.c.html#LN1404"><span class='Ref_to_Parameter'>flags</span></a><span class='Delimiter'>; 
</span><a name="LN1422"></a>            <span class='Keyword'>bool</span>        <span class='Declare_Local'>res</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Note: in principle, we could distinguish the various sub-parts 
             * of a CASE construct and set the flag bit only for some of them, 
             * since we are only expecting CaseTestExprs to appear in the 
             * "expr" subtree of the CaseWhen nodes.  But it doesn't really 
             * seem worth any extra code.  If there are any bare CaseTestExprs 
             * elsewhere in the CASE, something's wrong already. 
             */ 
</span>            <span class='Operator'>*</span><a href="clauses.c.html#LN1404"><span class='Ref_to_Parameter'>flags</span></a> <span class='Operator'>|= </span><a href="clauses.c.html#LN1401"><span class='Ref_to_Const'>CCDN_IN_CASEEXPR</span></a><span class='Delimiter'>; 
</span>            <a href="clauses.c.html#LN1422"><span class='Ref_To_Local'>res</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodeFuncs.h.html#LN52"><span class='Ref_to_Proto'>expression_tree_walker</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1404"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, 
</span>                                       <a href="clauses.c.html#LN110"><span class='Ref_to_Proto'>contain_context_dependent_node_walker</span></a><span class='Delimiter'>, 
</span>                                         <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1404"><span class='Ref_to_Parameter'>flags</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Operator'>*</span><a href="clauses.c.html#LN1404"><span class='Ref_to_Parameter'>flags</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN1421"><span class='Ref_To_Local'>save_flags</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <a href="clauses.c.html#LN1422"><span class='Ref_To_Local'>res</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if caseexpr-&GT;arg &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IsA(node,CaseExpr) &raquo; </span> 
    <span class='Control'>return</span> <a href="../../../include/nodes/nodeFuncs.h.html#LN52"><span class='Ref_to_Proto'>expression_tree_walker</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1404"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN110"><span class='Ref_to_Proto'>contain_context_dependent_node_walker</span></a><span class='Delimiter'>, 
</span>                                  <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1404"><span class='Ref_to_Parameter'>flags</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end contain_context_dependent_node_walker &raquo; </span> 
 
<span class='Comment_Multi_Line'>/***************************************************************************** 
 *        Check clauses for Vars passed to non-leakproof functions 
 *****************************************************************************/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * contain_leaked_vars 
 *      Recursively scan a clause to discover whether it contains any Var 
 *      nodes (of the current query level) that are passed as arguments to 
 *      leaky functions. 
 * 
 * Returns true if the clause contains any non-leakproof functions that are 
 * passed Var nodes of the current query level, and which might therefore leak 
 * data.  Such clauses must be applied after any lower-level security barrier 
 * clauses. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN1460"></a><span class='Declare_Function'>contain_leaked_vars</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="clauses.c.html#LN111"><span class='Ref_to_Proto'>contain_leaked_vars_walker</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1460"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static bool 
</span><a name="LN1466"></a><span class='Declare_Function'>contain_leaked_vars_checker</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>func_id</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <span class='Operator'>!</span><a href="../../../include/utils/lsyscache.h.html#LN120"><span class='Ref_to_Proto'>get_func_leakproof</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1466"><span class='Ref_to_Parameter'>func_id</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static bool 
</span><a name="LN1472"></a><span class='Declare_Function'>contain_leaked_vars_walker</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN1472"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN513"><span class='Ref_to_Macro'>nodeTag</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1472"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN145"><span class='Ref_to_EnumConst'>T_Var</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN146"><span class='Ref_to_EnumConst'>T_Const</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN147"><span class='Ref_to_EnumConst'>T_Param</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN151"><span class='Ref_to_EnumConst'>T_ArrayRef</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN172"><span class='Ref_to_EnumConst'>T_ArrayExpr</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN162"><span class='Ref_to_EnumConst'>T_FieldSelect</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN163"><span class='Ref_to_EnumConst'>T_FieldStore</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN153"><span class='Ref_to_EnumConst'>T_NamedArgExpr</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN158"><span class='Ref_to_EnumConst'>T_BoolExpr</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN164"><span class='Ref_to_EnumConst'>T_RelabelType</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN168"><span class='Ref_to_EnumConst'>T_CollateExpr</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN169"><span class='Ref_to_EnumConst'>T_CaseExpr</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN171"><span class='Ref_to_EnumConst'>T_CaseTestExpr</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN173"><span class='Ref_to_EnumConst'>T_RowExpr</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN176"><span class='Ref_to_EnumConst'>T_MinMaxExpr</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN177"><span class='Ref_to_EnumConst'>T_SQLValueFunction</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN179"><span class='Ref_to_EnumConst'>T_NullTest</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN180"><span class='Ref_to_EnumConst'>T_BooleanTest</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN290"><span class='Ref_to_EnumConst'>T_List</span></a><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * We know these node types don't contain function calls; but 
             * something further down in the node tree might. 
             */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN152"><span class='Ref_to_EnumConst'>T_FuncExpr</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN154"><span class='Ref_to_EnumConst'>T_OpExpr</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN155"><span class='Ref_to_EnumConst'>T_DistinctExpr</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN156"><span class='Ref_to_EnumConst'>T_NullIfExpr</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN157"><span class='Ref_to_EnumConst'>T_ScalarArrayOpExpr</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN165"><span class='Ref_to_EnumConst'>T_CoerceViaIO</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN166"><span class='Ref_to_EnumConst'>T_ArrayCoerceExpr</span></a><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * If node contains a leaky function call, and there's any Var 
             * underneath it, reject. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodeFuncs.h.html#LN49"><span class='Ref_to_Proto'>check_functions_in_node</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1472"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN1465"><span class='Ref_to_Func'>contain_leaked_vars_checker</span></a><span class='Delimiter'>, 
</span>                                        <a href="clauses.c.html#LN1472"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                <a href="../../../include/optimizer/var.h.html#LN33"><span class='Ref_to_Proto'>contain_var_clause</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1472"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN174"><span class='Ref_to_EnumConst'>T_RowCompareExpr</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * It's worth special-casing this because a leaky comparison 
                 * function only compromises one pair of row elements, which 
                 * might not contain Vars while others do. 
                 */ 
</span><a name="LN1530"></a>                <a href="../../../include/nodes/primnodes.h.html#LN1026"><span class='Ref_to_Struct'>RowCompareExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rcexpr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1026"><span class='Ref_to_Struct'>RowCompareExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1472"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span><a name="LN1531"></a>                <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>opid</span><span class='Delimiter'>; 
</span><a name="LN1532"></a>                <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>larg</span><span class='Delimiter'>; 
</span><a name="LN1533"></a>                <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>rarg</span><span class='Delimiter'>; 
</span> 
                <a href="../../../include/nodes/pg_list.h.html#LN202"><span class='Ref_to_Macro'>forthree</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1531"><span class='Ref_To_Local'>opid</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN1530"><span class='Ref_To_Local'>rcexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1030"><span class='Ref_to_Member'>opnos</span></a><span class='Delimiter'>, 
</span>                         <a href="clauses.c.html#LN1532"><span class='Ref_To_Local'>larg</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN1530"><span class='Ref_To_Local'>rcexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1033"><span class='Ref_to_Member'>largs</span></a><span class='Delimiter'>, 
</span>                         <a href="clauses.c.html#LN1533"><span class='Ref_To_Local'>rarg</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN1530"><span class='Ref_To_Local'>rcexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1034"><span class='Ref_to_Member'>rargs</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN1539"></a>                    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>funcid</span> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN98"><span class='Ref_to_Proto'>get_opcode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN107"><span class='Ref_to_Macro'>lfirst_oid</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1531"><span class='Ref_To_Local'>opid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
                    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/utils/lsyscache.h.html#LN120"><span class='Ref_to_Proto'>get_func_leakproof</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1539"><span class='Ref_To_Local'>funcid</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/optimizer/var.h.html#LN33"><span class='Ref_to_Proto'>contain_var_clause</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1532"><span class='Ref_To_Local'>larg</span></a><span class='Parentheses'>))</span> <span class='Operator'>|| 
</span>                         <a href="../../../include/optimizer/var.h.html#LN33"><span class='Ref_to_Proto'>contain_var_clause</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1533"><span class='Ref_To_Local'>rarg</span></a><span class='Parentheses'>))))</span> 
                        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN184"><span class='Ref_to_EnumConst'>T_CurrentOfExpr</span></a><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * WHERE CURRENT OF doesn't contain leaky function calls. 
             * Moreover, it is essential that this is considered non-leaky, 
             * since the planner must always generate a TID scan when CURRENT 
             * OF is present -- c.f. cost_tidscan. 
             */ 
</span>            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>default</span><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * If we don't recognize the node tag, assume it might be leaky. 
             * This prevents an unexpected security hole if someone adds a new 
             * node type that can call a function. 
             */ 
</span>            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch nodeTag(node) &raquo; </span> 
    <span class='Control'>return</span> <a href="../../../include/nodes/nodeFuncs.h.html#LN52"><span class='Ref_to_Proto'>expression_tree_walker</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1472"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN111"><span class='Ref_to_Proto'>contain_leaked_vars_walker</span></a><span class='Delimiter'>, 
</span>                                  <a href="clauses.c.html#LN1472"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end contain_leaked_vars_walker &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * find_nonnullable_rels 
 *      Determine which base rels are forced nonnullable by given clause. 
 * 
 * Returns the set of all Relids that are referenced in the clause in such 
 * a way that the clause cannot possibly return TRUE if any of these Relids 
 * is an all-NULL row.  (It is OK to err on the side of conservatism; hence 
 * the analysis here is simplistic.) 
 * 
 * The semantics here are subtly different from contain_nonstrict_functions: 
 * that function is concerned with NULL results from arbitrary expressions, 
 * but here we assume that the input is a Boolean expression, and wish to 
 * see if NULL inputs will provably cause a FALSE-or-NULL result.  We expect 
 * the expression to have been AND/OR flattened and converted to implicit-AND 
 * format. 
 * 
 * Note: this function is largely duplicative of find_nonnullable_vars(). 
 * The reason not to simplify this function into a thin wrapper around 
 * find_nonnullable_vars() is that the tested conditions really are different: 
 * a clause like "t1.v1 IS NOT NULL OR t1.v2 IS NOT NULL" does not prove 
 * that either v1 or v2 can't be NULL, but it does prove that the t1 row 
 * as a whole can't be all-NULL. 
 * 
 * top_level is TRUE while scanning top-level AND/OR structure; here, showing 
 * the result is either FALSE or NULL is good enough.  top_level is FALSE when 
 * we have descended below a NOT or a strict function: now we must be able to 
 * prove that the subexpression goes to NULL. 
 * 
 * We don't use expression_tree_walker here because we don't want to descend 
 * through very many kinds of nodes; only the ones we can be sure are strict. 
 */ 
</span><a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> 
<a name="LN1604"></a><span class='Declare_Function'>find_nonnullable_rels</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="clauses.c.html#LN112"><span class='Ref_to_Proto'>find_nonnullable_rels_walker</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1604"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static </span><a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> 
<a name="LN1610"></a><span class='Declare_Function'>find_nonnullable_rels_walker</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>top_level</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1612"></a>    <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>result</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN1613"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1619"></a>        <a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>var</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN1619"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN172"><span class='Ref_to_Member'>varlevelsup</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <a href="clauses.c.html#LN1612"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN67"><span class='Ref_to_Proto'>bms_make_singleton</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1619"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN165"><span class='Ref_to_Member'>varno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * At top level, we are examining an implicit-AND list: if any of the 
         * arms produces FALSE-or-NULL then the result is FALSE-or-NULL. If 
         * not at top level, we are examining the arguments of a strict 
         * function: if any of them produce NULL then the result of the 
         * function must be NULL.  So in both cases, the set of nonnullable 
         * rels is the union of those found in the arms, and we pass down the 
         * top_level flag unmodified. 
         */ 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1613"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <a href="clauses.c.html#LN1612"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN94"><span class='Ref_to_Proto'>bms_join</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1612"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, 
</span>                              <a href="clauses.c.html#LN112"><span class='Ref_to_Proto'>find_nonnullable_rels_walker</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1613"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                           <a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>top_level</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1644"></a>        <a href="../../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/lsyscache.h.html#LN117"><span class='Ref_to_Proto'>func_strict</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1644"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN447"><span class='Ref_to_Member'>funcid</span></a><span class='Parentheses'>))</span> 
            <a href="clauses.c.html#LN1612"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN112"><span class='Ref_to_Proto'>find_nonnullable_rels_walker</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1644"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN455"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1651"></a>        <a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <a href="../../../include/nodes/nodeFuncs.h.html#LN46"><span class='Ref_to_Proto'>set_opfuncid</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1651"><span class='Ref_To_Local'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/lsyscache.h.html#LN117"><span class='Ref_to_Proto'>func_strict</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1651"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN495"><span class='Ref_to_Member'>opfuncid</span></a><span class='Parentheses'>))</span> 
            <a href="clauses.c.html#LN1612"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN112"><span class='Ref_to_Proto'>find_nonnullable_rels_walker</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1651"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN500"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN534"><span class='Ref_to_Struct'>ScalarArrayOpExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1659"></a>        <a href="../../../include/nodes/primnodes.h.html#LN534"><span class='Ref_to_Struct'>ScalarArrayOpExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN534"><span class='Ref_to_Struct'>ScalarArrayOpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN114"><span class='Ref_to_Proto'>is_strict_saop</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1659"><span class='Ref_To_Local'>expr</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>))</span> 
            <a href="clauses.c.html#LN1612"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN112"><span class='Ref_to_Proto'>find_nonnullable_rels_walker</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1659"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN541"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1666"></a>        <a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN1666"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN560"><span class='Ref_to_Member'>boolop</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN554"><span class='Ref_to_EnumConst'>AND_EXPR</span></a><span class='Operator'>: 
</span>                <span class='Comment_Multi_Line'>/* At top level we can just recurse (to the List case) */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>top_level</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <a href="clauses.c.html#LN1612"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN112"><span class='Ref_to_Proto'>find_nonnullable_rels_walker</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1666"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN561"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>, 
</span>                                                          <a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>top_level</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Below top level, even if one arm produces NULL, the result 
                 * could be FALSE (hence not NULL).  However, if *all* the 
                 * arms produce NULL then the result is NULL, so we can take 
                 * the intersection of the sets of nonnullable rels, just as 
                 * for OR.  Fall through to share code. 
                 */ 
</span>                <span class='Comment_Multi_Line'>/* FALL THRU */ 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN554"><span class='Ref_to_EnumConst'>OR_EXPR</span></a><span class='Operator'>: 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * OR is strict if all of its arms are, so we can take the 
                 * intersection of the sets of nonnullable rels for each arm. 
                 * This works for both values of top_level. 
                 */ 
</span>                <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1613"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN1666"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN561"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN1696"></a>                    <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>subresult</span><span class='Delimiter'>; 
</span> 
                    <a href="clauses.c.html#LN1696"><span class='Ref_To_Local'>subresult</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN112"><span class='Ref_to_Proto'>find_nonnullable_rels_walker</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1613"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                             <a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>top_level</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN1612"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) </span><span class='Comment_Single_Line'>/* first subresult? */ 
</span>                        <a href="clauses.c.html#LN1612"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN1696"><span class='Ref_To_Local'>subresult</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>else</span> 
                        <a href="clauses.c.html#LN1612"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN92"><span class='Ref_to_Proto'>bms_int_members</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1612"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN1696"><span class='Ref_To_Local'>subresult</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * If the intersection is empty, we can stop looking. This 
                     * also justifies the test for first-subresult above. 
                     */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN85"><span class='Ref_to_Proto'>bms_is_empty</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1612"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>))</span> 
                        <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN554"><span class='Ref_to_EnumConst'>NOT_EXPR</span></a><span class='Operator'>: 
</span>                <span class='Comment_Multi_Line'>/* NOT will return null if its arg is null */ 
</span>                <a href="clauses.c.html#LN1612"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN112"><span class='Ref_to_Proto'>find_nonnullable_rels_walker</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1666"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN561"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>, 
</span>                                                      <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>default</span><span class='Operator'>: 
</span>                <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized boolop: %d"</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1666"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN560"><span class='Ref_to_Member'>boolop</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch expr-&GT;boolop &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IsA(node,BoolExpr) &raquo; </span> 
    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1725"></a>        <a href="../../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a> <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <a href="clauses.c.html#LN1612"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN112"><span class='Ref_to_Proto'>find_nonnullable_rels_walker</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1725"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN789"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>top_level</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN806"><span class='Ref_to_Struct'>CoerceViaIO</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* not clear this is useful, but it can't hurt */ 
</span><a name="LN1732"></a>        <a href="../../../include/nodes/primnodes.h.html#LN806"><span class='Ref_to_Struct'>CoerceViaIO</span></a> <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN806"><span class='Ref_to_Struct'>CoerceViaIO</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <a href="clauses.c.html#LN1612"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN112"><span class='Ref_to_Proto'>find_nonnullable_rels_walker</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1732"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN809"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>top_level</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN829"><span class='Ref_to_Struct'>ArrayCoerceExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* ArrayCoerceExpr is strict at the array level */ 
</span><a name="LN1739"></a>        <a href="../../../include/nodes/primnodes.h.html#LN829"><span class='Ref_to_Struct'>ArrayCoerceExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN829"><span class='Ref_to_Struct'>ArrayCoerceExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <a href="clauses.c.html#LN1612"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN112"><span class='Ref_to_Proto'>find_nonnullable_rels_walker</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1739"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN832"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>top_level</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN854"><span class='Ref_to_Struct'>ConvertRowtypeExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* not clear this is useful, but it can't hurt */ 
</span><a name="LN1746"></a>        <a href="../../../include/nodes/primnodes.h.html#LN854"><span class='Ref_to_Struct'>ConvertRowtypeExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN854"><span class='Ref_to_Struct'>ConvertRowtypeExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <a href="clauses.c.html#LN1612"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN112"><span class='Ref_to_Proto'>find_nonnullable_rels_walker</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1746"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN857"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>top_level</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN871"><span class='Ref_to_Struct'>CollateExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1752"></a>        <a href="../../../include/nodes/primnodes.h.html#LN871"><span class='Ref_to_Struct'>CollateExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN871"><span class='Ref_to_Struct'>CollateExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <a href="clauses.c.html#LN1612"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN112"><span class='Ref_to_Proto'>find_nonnullable_rels_walker</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1752"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN874"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>top_level</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* IS NOT NULL can be considered strict, but only at top level */ 
</span><a name="LN1759"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>top_level</span></a> <span class='Operator'>&& </span><a href="clauses.c.html#LN1759"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1179"><span class='Ref_to_Member'>nulltesttype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/primnodes.h.html#LN1172"><span class='Ref_to_EnumConst'>IS_NOT_NULL</span></a> <span class='Operator'>&& !</span><a href="clauses.c.html#LN1759"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1180"><span class='Ref_to_Member'>argisrow</span></a><span class='Parentheses'>) 
</span>            <a href="clauses.c.html#LN1612"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN112"><span class='Ref_to_Proto'>find_nonnullable_rels_walker</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1759"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1178"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1198"><span class='Ref_to_Struct'>BooleanTest</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Boolean tests that reject NULL are strict at top level */ 
</span><a name="LN1767"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1198"><span class='Ref_to_Struct'>BooleanTest</span></a> <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1198"><span class='Ref_to_Struct'>BooleanTest</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>top_level</span></a> <span class='Operator'>&& 
</span>            <span class='Parentheses'>(</span><a href="clauses.c.html#LN1767"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1202"><span class='Ref_to_Member'>booltesttype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/primnodes.h.html#LN1195"><span class='Ref_to_EnumConst'>IS_TRUE</span></a> <span class='Operator'>|| 
</span>             <a href="clauses.c.html#LN1767"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1202"><span class='Ref_to_Member'>booltesttype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/primnodes.h.html#LN1195"><span class='Ref_to_EnumConst'>IS_FALSE</span></a> <span class='Operator'>|| 
</span>             <a href="clauses.c.html#LN1767"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1202"><span class='Ref_to_Member'>booltesttype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/primnodes.h.html#LN1195"><span class='Ref_to_EnumConst'>IS_NOT_UNKNOWN</span></a><span class='Parentheses'>))</span> 
            <a href="clauses.c.html#LN1612"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN112"><span class='Ref_to_Proto'>find_nonnullable_rels_walker</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1767"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1201"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1846"><span class='Ref_to_Struct'>PlaceHolderVar</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1777"></a>        <a href="../../../include/nodes/relation.h.html#LN1846"><span class='Ref_to_Struct'>PlaceHolderVar</span></a> <span class='Operator'>*</span><span class='Declare_Local'>phv</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1846"><span class='Ref_to_Struct'>PlaceHolderVar</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <a href="clauses.c.html#LN1612"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN112"><span class='Ref_to_Proto'>find_nonnullable_rels_walker</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1777"><span class='Ref_To_Local'>phv</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1849"><span class='Ref_to_Member'>phexpr</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN1610"><span class='Ref_to_Parameter'>top_level</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <a href="clauses.c.html#LN1612"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end find_nonnullable_rels_walker &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * find_nonnullable_vars 
 *      Determine which Vars are forced nonnullable by given clause. 
 * 
 * Returns a list of all level-zero Vars that are referenced in the clause in 
 * such a way that the clause cannot possibly return TRUE if any of these Vars 
 * is NULL.  (It is OK to err on the side of conservatism; hence the analysis 
 * here is simplistic.) 
 * 
 * The semantics here are subtly different from contain_nonstrict_functions: 
 * that function is concerned with NULL results from arbitrary expressions, 
 * but here we assume that the input is a Boolean expression, and wish to 
 * see if NULL inputs will provably cause a FALSE-or-NULL result.  We expect 
 * the expression to have been AND/OR flattened and converted to implicit-AND 
 * format. 
 * 
 * The result is a palloc'd List, but we have not copied the member Var nodes. 
 * Also, we don't bother trying to eliminate duplicate entries. 
 * 
 * top_level is TRUE while scanning top-level AND/OR structure; here, showing 
 * the result is either FALSE or NULL is good enough.  top_level is FALSE when 
 * we have descended below a NOT or a strict function: now we must be able to 
 * prove that the subexpression goes to NULL. 
 * 
 * We don't use expression_tree_walker here because we don't want to descend 
 * through very many kinds of nodes; only the ones we can be sure are strict. 
 */ 
</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN1812"></a><span class='Declare_Function'>find_nonnullable_vars</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="clauses.c.html#LN113"><span class='Ref_to_Proto'>find_nonnullable_vars_walker</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1812"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN1818"></a><span class='Declare_Function'>find_nonnullable_vars_walker</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>top_level</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1820"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN1821"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1827"></a>        <a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>var</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN1827"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN172"><span class='Ref_to_Member'>varlevelsup</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <a href="clauses.c.html#LN1820"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1827"><span class='Ref_To_Local'>var</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * At top level, we are examining an implicit-AND list: if any of the 
         * arms produces FALSE-or-NULL then the result is FALSE-or-NULL. If 
         * not at top level, we are examining the arguments of a strict 
         * function: if any of them produce NULL then the result of the 
         * function must be NULL.  So in both cases, the set of nonnullable 
         * vars is the union of those found in the arms, and we pass down the 
         * top_level flag unmodified. 
         */ 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1821"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <a href="clauses.c.html#LN1820"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1820"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, 
</span>                                 <a href="clauses.c.html#LN113"><span class='Ref_to_Proto'>find_nonnullable_vars_walker</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1821"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                              <a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>top_level</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1852"></a>        <a href="../../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/lsyscache.h.html#LN117"><span class='Ref_to_Proto'>func_strict</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1852"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN447"><span class='Ref_to_Member'>funcid</span></a><span class='Parentheses'>))</span> 
            <a href="clauses.c.html#LN1820"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN113"><span class='Ref_to_Proto'>find_nonnullable_vars_walker</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1852"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN455"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1859"></a>        <a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <a href="../../../include/nodes/nodeFuncs.h.html#LN46"><span class='Ref_to_Proto'>set_opfuncid</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1859"><span class='Ref_To_Local'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/lsyscache.h.html#LN117"><span class='Ref_to_Proto'>func_strict</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1859"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN495"><span class='Ref_to_Member'>opfuncid</span></a><span class='Parentheses'>))</span> 
            <a href="clauses.c.html#LN1820"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN113"><span class='Ref_to_Proto'>find_nonnullable_vars_walker</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1859"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN500"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN534"><span class='Ref_to_Struct'>ScalarArrayOpExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1867"></a>        <a href="../../../include/nodes/primnodes.h.html#LN534"><span class='Ref_to_Struct'>ScalarArrayOpExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN534"><span class='Ref_to_Struct'>ScalarArrayOpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN114"><span class='Ref_to_Proto'>is_strict_saop</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1867"><span class='Ref_To_Local'>expr</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>))</span> 
            <a href="clauses.c.html#LN1820"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN113"><span class='Ref_to_Proto'>find_nonnullable_vars_walker</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1867"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN541"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1874"></a>        <a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN1874"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN560"><span class='Ref_to_Member'>boolop</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN554"><span class='Ref_to_EnumConst'>AND_EXPR</span></a><span class='Operator'>: 
</span>                <span class='Comment_Multi_Line'>/* At top level we can just recurse (to the List case) */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>top_level</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <a href="clauses.c.html#LN1820"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN113"><span class='Ref_to_Proto'>find_nonnullable_vars_walker</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1874"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN561"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>, 
</span>                                                          <a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>top_level</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Below top level, even if one arm produces NULL, the result 
                 * could be FALSE (hence not NULL).  However, if *all* the 
                 * arms produce NULL then the result is NULL, so we can take 
                 * the intersection of the sets of nonnullable vars, just as 
                 * for OR.  Fall through to share code. 
                 */ 
</span>                <span class='Comment_Multi_Line'>/* FALL THRU */ 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN554"><span class='Ref_to_EnumConst'>OR_EXPR</span></a><span class='Operator'>: 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * OR is strict if all of its arms are, so we can take the 
                 * intersection of the sets of nonnullable vars for each arm. 
                 * This works for both values of top_level. 
                 */ 
</span>                <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1821"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN1874"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN561"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN1904"></a>                    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>subresult</span><span class='Delimiter'>; 
</span> 
                    <a href="clauses.c.html#LN1904"><span class='Ref_To_Local'>subresult</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN113"><span class='Ref_to_Proto'>find_nonnullable_vars_walker</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1821"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                             <a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>top_level</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN1820"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span>  <span class='Comment_Single_Line'>/* first subresult? */ 
</span>                        <a href="clauses.c.html#LN1820"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN1904"><span class='Ref_To_Local'>subresult</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>else</span> 
                        <a href="clauses.c.html#LN1820"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN245"><span class='Ref_to_Proto'>list_intersection</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1820"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN1904"><span class='Ref_To_Local'>subresult</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * If the intersection is empty, we can stop looking. This 
                     * also justifies the test for first-subresult above. 
                     */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN1820"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>                        <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN554"><span class='Ref_to_EnumConst'>NOT_EXPR</span></a><span class='Operator'>: 
</span>                <span class='Comment_Multi_Line'>/* NOT will return null if its arg is null */ 
</span>                <a href="clauses.c.html#LN1820"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN113"><span class='Ref_to_Proto'>find_nonnullable_vars_walker</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1874"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN561"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>, 
</span>                                                      <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>default</span><span class='Operator'>: 
</span>                <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized boolop: %d"</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1874"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN560"><span class='Ref_to_Member'>boolop</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch expr-&GT;boolop &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IsA(node,BoolExpr) &raquo; </span> 
    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1933"></a>        <a href="../../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a> <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <a href="clauses.c.html#LN1820"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN113"><span class='Ref_to_Proto'>find_nonnullable_vars_walker</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1933"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN789"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>top_level</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN806"><span class='Ref_to_Struct'>CoerceViaIO</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* not clear this is useful, but it can't hurt */ 
</span><a name="LN1940"></a>        <a href="../../../include/nodes/primnodes.h.html#LN806"><span class='Ref_to_Struct'>CoerceViaIO</span></a> <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN806"><span class='Ref_to_Struct'>CoerceViaIO</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <a href="clauses.c.html#LN1820"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN113"><span class='Ref_to_Proto'>find_nonnullable_vars_walker</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1940"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN809"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN829"><span class='Ref_to_Struct'>ArrayCoerceExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* ArrayCoerceExpr is strict at the array level */ 
</span><a name="LN1947"></a>        <a href="../../../include/nodes/primnodes.h.html#LN829"><span class='Ref_to_Struct'>ArrayCoerceExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN829"><span class='Ref_to_Struct'>ArrayCoerceExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <a href="clauses.c.html#LN1820"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN113"><span class='Ref_to_Proto'>find_nonnullable_vars_walker</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1947"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN832"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>top_level</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN854"><span class='Ref_to_Struct'>ConvertRowtypeExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* not clear this is useful, but it can't hurt */ 
</span><a name="LN1954"></a>        <a href="../../../include/nodes/primnodes.h.html#LN854"><span class='Ref_to_Struct'>ConvertRowtypeExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN854"><span class='Ref_to_Struct'>ConvertRowtypeExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <a href="clauses.c.html#LN1820"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN113"><span class='Ref_to_Proto'>find_nonnullable_vars_walker</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1954"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN857"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>top_level</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN871"><span class='Ref_to_Struct'>CollateExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1960"></a>        <a href="../../../include/nodes/primnodes.h.html#LN871"><span class='Ref_to_Struct'>CollateExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN871"><span class='Ref_to_Struct'>CollateExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <a href="clauses.c.html#LN1820"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN113"><span class='Ref_to_Proto'>find_nonnullable_vars_walker</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1960"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN874"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>top_level</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* IS NOT NULL can be considered strict, but only at top level */ 
</span><a name="LN1967"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>top_level</span></a> <span class='Operator'>&& </span><a href="clauses.c.html#LN1967"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1179"><span class='Ref_to_Member'>nulltesttype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/primnodes.h.html#LN1172"><span class='Ref_to_EnumConst'>IS_NOT_NULL</span></a> <span class='Operator'>&& !</span><a href="clauses.c.html#LN1967"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1180"><span class='Ref_to_Member'>argisrow</span></a><span class='Parentheses'>) 
</span>            <a href="clauses.c.html#LN1820"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN113"><span class='Ref_to_Proto'>find_nonnullable_vars_walker</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1967"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1178"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1198"><span class='Ref_to_Struct'>BooleanTest</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Boolean tests that reject NULL are strict at top level */ 
</span><a name="LN1975"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1198"><span class='Ref_to_Struct'>BooleanTest</span></a> <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1198"><span class='Ref_to_Struct'>BooleanTest</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>top_level</span></a> <span class='Operator'>&& 
</span>            <span class='Parentheses'>(</span><a href="clauses.c.html#LN1975"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1202"><span class='Ref_to_Member'>booltesttype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/primnodes.h.html#LN1195"><span class='Ref_to_EnumConst'>IS_TRUE</span></a> <span class='Operator'>|| 
</span>             <a href="clauses.c.html#LN1975"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1202"><span class='Ref_to_Member'>booltesttype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/primnodes.h.html#LN1195"><span class='Ref_to_EnumConst'>IS_FALSE</span></a> <span class='Operator'>|| 
</span>             <a href="clauses.c.html#LN1975"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1202"><span class='Ref_to_Member'>booltesttype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/primnodes.h.html#LN1195"><span class='Ref_to_EnumConst'>IS_NOT_UNKNOWN</span></a><span class='Parentheses'>))</span> 
            <a href="clauses.c.html#LN1820"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN113"><span class='Ref_to_Proto'>find_nonnullable_vars_walker</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1975"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1201"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1846"><span class='Ref_to_Struct'>PlaceHolderVar</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1985"></a>        <a href="../../../include/nodes/relation.h.html#LN1846"><span class='Ref_to_Struct'>PlaceHolderVar</span></a> <span class='Operator'>*</span><span class='Declare_Local'>phv</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1846"><span class='Ref_to_Struct'>PlaceHolderVar</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <a href="clauses.c.html#LN1820"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN113"><span class='Ref_to_Proto'>find_nonnullable_vars_walker</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN1985"><span class='Ref_To_Local'>phv</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1849"><span class='Ref_to_Member'>phexpr</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN1818"><span class='Ref_to_Parameter'>top_level</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <a href="clauses.c.html#LN1820"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end find_nonnullable_vars_walker &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * find_forced_null_vars 
 *      Determine which Vars must be NULL for the given clause to return TRUE. 
 * 
 * This is the complement of find_nonnullable_vars: find the level-zero Vars 
 * that must be NULL for the clause to return TRUE.  (It is OK to err on the 
 * side of conservatism; hence the analysis here is simplistic.  In fact, 
 * we only detect simple "var IS NULL" tests at the top level.) 
 * 
 * The result is a palloc'd List, but we have not copied the member Var nodes. 
 * Also, we don't bother trying to eliminate duplicate entries. 
 */ 
</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN2005"></a><span class='Declare_Function'>find_forced_null_vars</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2007"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN2008"></a>    <a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>var</span><span class='Delimiter'>; 
</span><a name="LN2009"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2005"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* Check single-clause cases using subroutine */ 
</span>    <a href="clauses.c.html#LN2008"><span class='Ref_To_Local'>var</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/clauses.h.html#LN70"><span class='Ref_to_Proto'>find_forced_null_var</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2005"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2008"><span class='Ref_To_Local'>var</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="clauses.c.html#LN2007"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2008"><span class='Ref_To_Local'>var</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Comment_Multi_Line'>/* Otherwise, handle AND-conditions */ 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2005"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * At top level, we are examining an implicit-AND list: if any of the 
         * arms produces FALSE-or-NULL then the result is FALSE-or-NULL. 
         */ 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2009"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2005"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <a href="clauses.c.html#LN2007"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2007"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, 
</span>                                 <a href="../../../include/optimizer/clauses.h.html#LN69"><span class='Ref_to_Proto'>find_forced_null_vars</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2009"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2005"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN2034"></a>        <a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2005"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We don't bother considering the OR case, because it's fairly 
         * unlikely anyone would write "v1 IS NULL OR v1 IS NULL". Likewise, 
         * the NOT case isn't worth expending code on. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2034"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN560"><span class='Ref_to_Member'>boolop</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/primnodes.h.html#LN554"><span class='Ref_to_EnumConst'>AND_EXPR</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* At top level we can just recurse (to the List case) */ 
</span>            <a href="clauses.c.html#LN2007"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/clauses.h.html#LN69"><span class='Ref_to_Proto'>find_forced_null_vars</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2034"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN561"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <a href="clauses.c.html#LN2007"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end find_forced_null_vars &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * find_forced_null_var 
 *      Return the Var forced null by the given clause, or NULL if it's 
 *      not an IS NULL-type clause.  For success, the clause must enforce 
 *      *only* nullness of the particular Var, not any other conditions. 
 * 
 * This is just the single-clause case of find_forced_null_vars(), without 
 * any allowance for AND conditions.  It's used by initsplan.c on individual 
 * qual clauses.  The reason for not just applying find_forced_null_vars() 
 * is that if an AND of an IS NULL clause with something else were to somehow 
 * survive AND/OR flattening, initsplan.c might get fooled into discarding 
 * the whole clause when only the IS NULL part of it had been proved redundant. 
 */ 
</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>* 
</span><a name="LN2064"></a><span class='Declare_Function'>find_forced_null_var</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2064"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2064"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* check for var IS NULL */ 
</span><a name="LN2071"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2064"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2071"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1179"><span class='Ref_to_Member'>nulltesttype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/primnodes.h.html#LN1172"><span class='Ref_to_EnumConst'>IS_NULL</span></a> <span class='Operator'>&& !</span><a href="clauses.c.html#LN2071"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1180"><span class='Ref_to_Member'>argisrow</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN2075"></a>            <a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>var</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2071"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1178"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2075"><span class='Ref_To_Local'>var</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2075"><span class='Ref_To_Local'>var</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                <a href="clauses.c.html#LN2075"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN172"><span class='Ref_to_Member'>varlevelsup</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                <span class='Control'>return</span> <a href="clauses.c.html#LN2075"><span class='Ref_To_Local'>var</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2064"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1198"><span class='Ref_to_Struct'>BooleanTest</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* var IS UNKNOWN is equivalent to var IS NULL */ 
</span><a name="LN2085"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1198"><span class='Ref_to_Struct'>BooleanTest</span></a> <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1198"><span class='Ref_to_Struct'>BooleanTest</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2064"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2085"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1202"><span class='Ref_to_Member'>booltesttype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/primnodes.h.html#LN1195"><span class='Ref_to_EnumConst'>IS_UNKNOWN</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN2089"></a>            <a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>var</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2085"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1201"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2089"><span class='Ref_To_Local'>var</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2089"><span class='Ref_To_Local'>var</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                <a href="clauses.c.html#LN2089"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN172"><span class='Ref_to_Member'>varlevelsup</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                <span class='Control'>return</span> <a href="clauses.c.html#LN2089"><span class='Ref_To_Local'>var</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end find_forced_null_var &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Can we treat a ScalarArrayOpExpr as strict? 
 * 
 * If "falseOK" is true, then a "false" result can be considered strict, 
 * else we need to guarantee an actual NULL result for NULL input. 
 * 
 * "foo op ALL array" is strict if the op is strict *and* we can prove 
 * that the array input isn't an empty array.  We can check that 
 * for the cases of an array constant and an ARRAY[] construct. 
 * 
 * "foo op ANY array" is strict in the falseOK sense if the op is strict. 
 * If not falseOK, the test is the same as for "foo op ALL array". 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN2113"></a><span class='Declare_Function'>is_strict_saop</span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN534"><span class='Ref_to_Struct'>ScalarArrayOpExpr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>expr</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>falseOK</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2115"></a>    <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>rightop</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* The contained operator must be strict. */ 
</span>    <a href="../../../include/nodes/nodeFuncs.h.html#LN47"><span class='Ref_to_Proto'>set_sa_opfuncid</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2113"><span class='Ref_to_Parameter'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/utils/lsyscache.h.html#LN117"><span class='Ref_to_Proto'>func_strict</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2113"><span class='Ref_to_Parameter'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN538"><span class='Ref_to_Member'>opfuncid</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* If ANY and falseOK, that's all we need to check. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2113"><span class='Ref_to_Parameter'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN539"><span class='Ref_to_Member'>useOr</span></a> <span class='Operator'>&& </span><a href="clauses.c.html#LN2113"><span class='Ref_to_Parameter'>falseOK</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* Else, we have to see if the array is provably non-empty. */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2113"><span class='Ref_to_Parameter'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN541"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN2115"><span class='Ref_To_Local'>rightop</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN115"><span class='Ref_to_Macro'>lsecond</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2113"><span class='Ref_to_Parameter'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN541"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2115"><span class='Ref_To_Local'>rightop</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2115"><span class='Ref_To_Local'>rightop</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN2129"></a>        <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>arraydatum</span> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2115"><span class='Ref_To_Local'>rightop</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constvalue<span class='Delimiter'>; 
</span><a name="LN2130"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>arrayisnull</span> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2115"><span class='Ref_To_Local'>rightop</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constisnull<span class='Delimiter'>; 
</span><a name="LN2131"></a>        <a href="../../../include/utils/array.h.html#LN75"><span class='Ref_to_Typedef'>ArrayType</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>arrayval</span><span class='Delimiter'>; 
</span><a name="LN2132"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>nitems</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2130"><span class='Ref_To_Local'>arrayisnull</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="clauses.c.html#LN2131"><span class='Ref_To_Local'>arrayval</span></a> <span class='Operator'>= </span><a href="../../../include/utils/array.h.html#LN241"><span class='Ref_to_Macro'>DatumGetArrayTypeP</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2129"><span class='Ref_To_Local'>arraydatum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="clauses.c.html#LN2132"><span class='Ref_To_Local'>nitems</span></a> <span class='Operator'>= </span><a href="../../utils/adt/arrayutils.c.html#LN73"><span class='Ref_to_Func'>ArrayGetNItems</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/array.h.html#LN270"><span class='Ref_to_Macro'>ARR_NDIM</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2131"><span class='Ref_To_Local'>arrayval</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="../../../include/utils/array.h.html#LN274"><span class='Ref_to_Macro'>ARR_DIMS</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2131"><span class='Ref_To_Local'>arrayval</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2132"><span class='Ref_To_Local'>nitems</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2115"><span class='Ref_To_Local'>rightop</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2115"><span class='Ref_To_Local'>rightop</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN947"><span class='Ref_to_Struct'>ArrayExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN2143"></a>        <a href="../../../include/nodes/primnodes.h.html#LN947"><span class='Ref_to_Struct'>ArrayExpr</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>arrayexpr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN947"><span class='Ref_to_Struct'>ArrayExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2115"><span class='Ref_To_Local'>rightop</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2143"><span class='Ref_To_Local'>arrayexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN953"><span class='Ref_to_Member'>elements</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>&& !</span><a href="clauses.c.html#LN2143"><span class='Ref_To_Local'>arrayexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN954"><span class='Ref_to_Member'>multidims</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end is_strict_saop &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/***************************************************************************** 
 *      Check for "pseudo-constant" clauses 
 *****************************************************************************/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * is_pseudo_constant_clause 
 *    Detect whether an expression is "pseudo constant", ie, it contains no 
 *    variables of the current query level and no uses of volatile functions. 
 *    Such an expr is not necessarily a true constant: it can still contain 
 *    Params and outer-level Vars, not to mention functions whose results 
 *    may vary from one statement to the next.  However, the expr's value 
 *    will be constant over any one scan of the current query, so it can be 
 *    used as, eg, an indexscan key. 
 * 
 * CAUTION: this function omits to test for one very important class of 
 * not-constant expressions, namely aggregates (Aggrefs).  In current usage 
 * this is only applied to WHERE clauses and so a check for Aggrefs would be 
 * a waste of cycles; but be sure to also check contain_agg_clause() if you 
 * want to know about pseudo-constness in other contexts.  The same goes 
 * for window functions (WindowFuncs). 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN2174"></a><span class='Declare_Function'>is_pseudo_constant_clause</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * We could implement this check in one recursive scan.  But since the 
     * check for volatile functions is both moderately expensive and unlikely 
     * to fail, it seems better to look for Vars first and only check for 
     * volatile functions if we find no Vars. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/optimizer/var.h.html#LN33"><span class='Ref_to_Proto'>contain_var_clause</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2174"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>        <span class='Operator'>!</span><a href="../../../include/optimizer/clauses.h.html#LN60"><span class='Ref_to_Proto'>contain_volatile_functions</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2174"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * is_pseudo_constant_clause_relids 
 *    Same as above, except caller already has available the var membership 
 *    of the expression; this lets us avoid the contain_var_clause() scan. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN2194"></a><span class='Declare_Function'>is_pseudo_constant_clause_relids</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>relids</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN85"><span class='Ref_to_Proto'>bms_is_empty</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2194"><span class='Ref_to_Parameter'>relids</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>        <span class='Operator'>!</span><a href="../../../include/optimizer/clauses.h.html#LN60"><span class='Ref_to_Proto'>contain_volatile_functions</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2194"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/***************************************************************************** 
 *                                                                           * 
 *      General clause-manipulating routines                                 * 
 *                                                                           * 
 *****************************************************************************/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * NumRelids 
 *      (formerly clause_relids) 
 * 
 * Returns the number of different relations referenced in 'clause'. 
 */ 
</span><span class='Keyword'>int 
</span><a name="LN2216"></a><span class='Declare_Function'>NumRelids</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2218"></a>    <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>varnos</span> <span class='Operator'>= </span><a href="../../../include/optimizer/var.h.html#LN29"><span class='Ref_to_Proto'>pull_varnos</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2216"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2219"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>result</span> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN81"><span class='Ref_to_Proto'>bms_num_members</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2218"><span class='Ref_To_Local'>varnos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/bitmapset.h.html#LN68"><span class='Ref_to_Proto'>bms_free</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2218"><span class='Ref_To_Local'>varnos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="clauses.c.html#LN2219"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * CommuteOpExpr: commute a binary operator clause 
 * 
 * XXX the clause is destructively modified! 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2231"></a><span class='Declare_Function'>CommuteOpExpr</span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2233"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>opoid</span><span class='Delimiter'>; 
</span><a name="LN2234"></a>    <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>temp</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Sanity checks: caller is at fault if these fail */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/optimizer/clauses.h.html#LN19"><span class='Ref_to_Macro'>is_opclause</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2231"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2231"><span class='Ref_to_Parameter'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN500"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>2</span><span class='Parentheses'>)</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cannot commute non-binary-operator clause"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="clauses.c.html#LN2233"><span class='Ref_To_Local'>opoid</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN106"><span class='Ref_to_Proto'>get_commutator</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2231"><span class='Ref_to_Parameter'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN494"><span class='Ref_to_Member'>opno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2233"><span class='Ref_To_Local'>opoid</span></a><span class='Parentheses'>))</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"could not find commutator for operator %u"</span><span class='Delimiter'>, 
</span>             <a href="clauses.c.html#LN2231"><span class='Ref_to_Parameter'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN494"><span class='Ref_to_Member'>opno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * modify the clause in-place! 
     */ 
</span>    <a href="clauses.c.html#LN2231"><span class='Ref_to_Parameter'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN494"><span class='Ref_to_Member'>opno</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2233"><span class='Ref_To_Local'>opoid</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN2231"><span class='Ref_to_Parameter'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN495"><span class='Ref_to_Member'>opfuncid</span></a> <span class='Operator'>= </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* opresulttype, opretset, opcollid, inputcollid need not change */ 
</span> 
    <a href="clauses.c.html#LN2234"><span class='Ref_To_Local'>temp</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2231"><span class='Ref_to_Parameter'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN500"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2231"><span class='Ref_to_Parameter'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN500"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN115"><span class='Ref_to_Macro'>lsecond</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2231"><span class='Ref_to_Parameter'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN500"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN115"><span class='Ref_to_Macro'>lsecond</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2231"><span class='Ref_to_Parameter'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN500"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="clauses.c.html#LN2234"><span class='Ref_To_Local'>temp</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end CommuteOpExpr &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * CommuteRowCompareExpr: commute a RowCompareExpr clause 
 * 
 * XXX the clause is destructively modified! 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2265"></a><span class='Declare_Function'>CommuteRowCompareExpr</span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1026"><span class='Ref_to_Struct'>RowCompareExpr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2267"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>newops</span><span class='Delimiter'>; 
</span><a name="LN2268"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>temp</span><span class='Delimiter'>; 
</span><a name="LN2269"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Sanity checks: caller is at fault if these fail */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2265"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1026"><span class='Ref_to_Struct'>RowCompareExpr</span></a><span class='Parentheses'>))</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"expected a RowCompareExpr"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Build list of commuted operators */ 
</span>    <a href="clauses.c.html#LN2267"><span class='Ref_To_Local'>newops</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2269"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN2265"><span class='Ref_to_Parameter'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1030"><span class='Ref_to_Member'>opnos</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2279"></a>        <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>opoid</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN107"><span class='Ref_to_Macro'>lfirst_oid</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2269"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="clauses.c.html#LN2279"><span class='Ref_To_Local'>opoid</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN106"><span class='Ref_to_Proto'>get_commutator</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2279"><span class='Ref_To_Local'>opoid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2279"><span class='Ref_To_Local'>opoid</span></a><span class='Parentheses'>))</span> 
            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"could not find commutator for operator %u"</span><span class='Delimiter'>, 
</span>                 <a href="../../../include/nodes/pg_list.h.html#LN107"><span class='Ref_to_Macro'>lfirst_oid</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2269"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="clauses.c.html#LN2267"><span class='Ref_To_Local'>newops</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN162"><span class='Ref_to_Func'>lappend_oid</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2267"><span class='Ref_To_Local'>newops</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN2279"><span class='Ref_To_Local'>opoid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * modify the clause in-place! 
     */ 
</span>    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2265"><span class='Ref_to_Parameter'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1029"><span class='Ref_to_Member'>rctype</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN1018"><span class='Ref_to_EnumConst'>ROWCOMPARE_LT</span></a><span class='Operator'>: 
</span>            <a href="clauses.c.html#LN2265"><span class='Ref_to_Parameter'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1029"><span class='Ref_to_Member'>rctype</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/primnodes.h.html#LN1022"><span class='Ref_to_EnumConst'>ROWCOMPARE_GT</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN1019"><span class='Ref_to_EnumConst'>ROWCOMPARE_LE</span></a><span class='Operator'>: 
</span>            <a href="clauses.c.html#LN2265"><span class='Ref_to_Parameter'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1029"><span class='Ref_to_Member'>rctype</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/primnodes.h.html#LN1021"><span class='Ref_to_EnumConst'>ROWCOMPARE_GE</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN1021"><span class='Ref_to_EnumConst'>ROWCOMPARE_GE</span></a><span class='Operator'>: 
</span>            <a href="clauses.c.html#LN2265"><span class='Ref_to_Parameter'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1029"><span class='Ref_to_Member'>rctype</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/primnodes.h.html#LN1019"><span class='Ref_to_EnumConst'>ROWCOMPARE_LE</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN1022"><span class='Ref_to_EnumConst'>ROWCOMPARE_GT</span></a><span class='Operator'>: 
</span>            <a href="clauses.c.html#LN2265"><span class='Ref_to_Parameter'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1029"><span class='Ref_to_Member'>rctype</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/primnodes.h.html#LN1018"><span class='Ref_to_EnumConst'>ROWCOMPARE_LT</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>default</span><span class='Operator'>: 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unexpected RowCompare type: %d"</span><span class='Delimiter'>, 
</span>                 <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2265"><span class='Ref_to_Parameter'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1029"><span class='Ref_to_Member'>rctype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="clauses.c.html#LN2265"><span class='Ref_to_Parameter'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1030"><span class='Ref_to_Member'>opnos</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2267"><span class='Ref_To_Local'>newops</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Note: we need not change the opfamilies list; we assume any btree 
     * opfamily containing an operator will also contain its commutator. 
     * Collations don't change either. 
     */ 
</span> 
    <a href="clauses.c.html#LN2268"><span class='Ref_To_Local'>temp</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2265"><span class='Ref_to_Parameter'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1033"><span class='Ref_to_Member'>largs</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN2265"><span class='Ref_to_Parameter'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1033"><span class='Ref_to_Member'>largs</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2265"><span class='Ref_to_Parameter'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1034"><span class='Ref_to_Member'>rargs</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN2265"><span class='Ref_to_Parameter'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1034"><span class='Ref_to_Member'>rargs</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2268"><span class='Ref_To_Local'>temp</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end CommuteRowCompareExpr &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Helper for eval_const_expressions: check that datatype of an attribute 
 * is still what it was when the expression was parsed.  This is needed to 
 * guard against improper simplification after ALTER COLUMN TYPE.  (XXX we 
 * may well need to make similar checks elsewhere?) 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN2331"></a><span class='Declare_Function'>rowtype_field_matches</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>rowtypeid</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>fieldnum</span><span class='Delimiter'>, 
</span><a name="LN2332"></a>                      <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>expectedtype</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a> <span class='Declare_Parameter'>expectedtypmod</span><span class='Delimiter'>, 
</span><a name="LN2333"></a>                      <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>expectedcollation</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2335"></a>    <a href="../../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Local'>tupdesc</span><span class='Delimiter'>; 
</span><a name="LN2336"></a>    <a href="../../../include/catalog/pg_attribute.h.html#LN186"><span class='Ref_to_Typedef'>Form_pg_attribute</span></a> <span class='Declare_Local'>attr</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* No issue for RECORD, since there is no way to ALTER such a type */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2331"><span class='Ref_to_Parameter'>rowtypeid</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_type.h.html#LN679"><span class='Ref_to_Const'>RECORDOID</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN2335"><span class='Ref_To_Local'>tupdesc</span></a> <span class='Operator'>= </span><a href="../../../include/utils/typcache.h.html#LN151"><span class='Ref_to_Proto'>lookup_rowtype_tupdesc</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2331"><span class='Ref_to_Parameter'>rowtypeid</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2331"><span class='Ref_to_Parameter'>fieldnum</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span> <span class='Operator'>|| </span><a href="clauses.c.html#LN2331"><span class='Ref_to_Parameter'>fieldnum</span></a> <span class='Operator'>&GT; </span><a href="clauses.c.html#LN2335"><span class='Ref_To_Local'>tupdesc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/tupdesc.h.html#LN72"><span class='Ref_to_Member'>natts</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/access/tupdesc.h.html#LN106"><span class='Ref_to_Macro'>ReleaseTupleDesc</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2335"><span class='Ref_To_Local'>tupdesc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="clauses.c.html#LN2336"><span class='Ref_To_Local'>attr</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2335"><span class='Ref_To_Local'>tupdesc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/tupdesc.h.html#LN73"><span class='Ref_to_Member'>attrs</span></a><span class='Delimiter'>[</span><a href="clauses.c.html#LN2331"><span class='Ref_to_Parameter'>fieldnum</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2336"><span class='Ref_To_Local'>attr</span></a><span class='Operator'>-&GT;</span>attisdropped <span class='Operator'>|| 
</span>        <a href="clauses.c.html#LN2336"><span class='Ref_To_Local'>attr</span></a><span class='Operator'>-&GT;</span>atttypid <span class='Operator'>!= </span><a href="clauses.c.html#LN2332"><span class='Ref_to_Parameter'>expectedtype</span></a> <span class='Operator'>|| 
</span>        <a href="clauses.c.html#LN2336"><span class='Ref_To_Local'>attr</span></a><span class='Operator'>-&GT;</span>atttypmod <span class='Operator'>!= </span><a href="clauses.c.html#LN2332"><span class='Ref_to_Parameter'>expectedtypmod</span></a> <span class='Operator'>|| 
</span>        <a href="clauses.c.html#LN2336"><span class='Ref_To_Local'>attr</span></a><span class='Operator'>-&GT;</span>attcollation <span class='Operator'>!= </span><a href="clauses.c.html#LN2333"><span class='Ref_to_Parameter'>expectedcollation</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/access/tupdesc.h.html#LN106"><span class='Ref_to_Macro'>ReleaseTupleDesc</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2335"><span class='Ref_To_Local'>tupdesc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../../include/access/tupdesc.h.html#LN106"><span class='Ref_to_Macro'>ReleaseTupleDesc</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2335"><span class='Ref_To_Local'>tupdesc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end rowtype_field_matches &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/*-------------------- 
 * eval_const_expressions 
 * 
 * Reduce any recognizably constant subexpressions of the given 
 * expression tree, for example "2 + 2" =&GT; "4".  More interestingly, 
 * we can reduce certain boolean expressions even when they contain 
 * non-constant subexpressions: "x OR true" =&GT; "true" no matter what 
 * the subexpression x is.  (XXX We assume that no such subexpression 
 * will have important side-effects, which is not necessarily a good 
 * assumption in the presence of user-defined functions; do we need a 
 * pg_proc flag that prevents discarding the execution of a function?) 
 * 
 * We do understand that certain functions may deliver non-constant 
 * results even with constant inputs, "nextval()" being the classic 
 * example.  Functions that are not marked "immutable" in pg_proc 
 * will not be pre-evaluated here, although we will reduce their 
 * arguments as far as possible. 
 * 
 * Whenever a function is eliminated from the expression by means of 
 * constant-expression evaluation or inlining, we add the function to 
 * root-&GT;glob-&GT;invalItems.  This ensures the plan is known to depend on 
 * such functions, even though they aren't referenced anymore. 
 * 
 * We assume that the tree has already been type-checked and contains 
 * only operators and functions that are reasonable to try to execute. 
 * 
 * NOTE: "root" can be passed as NULL if the caller never wants to do any 
 * Param substitutions nor receive info about inlined functions. 
 * 
 * NOTE: the planner assumes that this will always flatten nested AND and 
 * OR clauses into N-argument form.  See comments in prepqual.c. 
 * 
 * NOTE: another critical effect is that any function calls that require 
 * default arguments will be expanded, and named-argument calls will be 
 * converted to positional notation.  The executor won't handle either. 
 *-------------------- 
 */ 
</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN2399"></a><span class='Declare_Function'>eval_const_expressions</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2401"></a>    <a href="clauses.c.html#LN62"><span class='Ref_to_Typedef'>eval_const_expressions_context</span></a> <span class='Declare_Local'>context</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2399"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>) 
</span>        <a href="clauses.c.html#LN2401"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="clauses.c.html#LN64"><span class='Ref_to_Member'>boundParams</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2399"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN156"><span class='Ref_to_Member'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN95"><span class='Ref_to_Member'>boundParams</span></a><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* bound Params */ 
</span>    <span class='Control'>else</span> 
        <a href="clauses.c.html#LN2401"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="clauses.c.html#LN64"><span class='Ref_to_Member'>boundParams</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN2401"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="clauses.c.html#LN65"><span class='Ref_to_Member'>root</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2399"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* for inlined-function dependencies */ 
</span>    <a href="clauses.c.html#LN2401"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="clauses.c.html#LN66"><span class='Ref_to_Member'>active_fns</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* nothing being recursively simplified */ 
</span>    <a href="clauses.c.html#LN2401"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="clauses.c.html#LN67"><span class='Ref_to_Member'>case_val</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* no CASE being examined */ 
</span>    <a href="clauses.c.html#LN2401"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="clauses.c.html#LN68"><span class='Ref_to_Member'>estimate</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* safe transformations only */ 
</span>    <span class='Control'>return</span> <a href="clauses.c.html#LN115"><span class='Ref_to_Proto'>eval_const_expressions_mutator</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2399"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="clauses.c.html#LN2401"><span class='Ref_To_Local'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/*-------------------- 
 * estimate_expression_value 
 * 
 * This function attempts to estimate the value of an expression for 
 * planning purposes.  It is in essence a more aggressive version of 
 * eval_const_expressions(): we will perform constant reductions that are 
 * not necessarily 100% safe, but are reasonable for estimation purposes. 
 * 
 * Currently the extra steps that are taken in this mode are: 
 * 1. Substitute values for Params, where a bound Param value has been made 
 *    available by the caller of planner(), even if the Param isn't marked 
 *    constant.  This effectively means that we plan using the first supplied 
 *    value of the Param. 
 * 2. Fold stable, as well as immutable, functions to constants. 
 * 3. Reduce PlaceHolderVar nodes to their contained expressions. 
 *-------------------- 
 */ 
</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN2432"></a><span class='Declare_Function'>estimate_expression_value</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2434"></a>    <a href="clauses.c.html#LN62"><span class='Ref_to_Typedef'>eval_const_expressions_context</span></a> <span class='Declare_Local'>context</span><span class='Delimiter'>; 
</span> 
    <a href="clauses.c.html#LN2434"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="clauses.c.html#LN64"><span class='Ref_to_Member'>boundParams</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2432"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN156"><span class='Ref_to_Member'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN95"><span class='Ref_to_Member'>boundParams</span></a><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* bound Params */ 
</span>    <span class='Comment_Multi_Line'>/* we do not need to mark the plan as depending on inlined functions */ 
</span>    <a href="clauses.c.html#LN2434"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="clauses.c.html#LN65"><span class='Ref_to_Member'>root</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN2434"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="clauses.c.html#LN66"><span class='Ref_to_Member'>active_fns</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* nothing being recursively simplified */ 
</span>    <a href="clauses.c.html#LN2434"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="clauses.c.html#LN67"><span class='Ref_to_Member'>case_val</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* no CASE being examined */ 
</span>    <a href="clauses.c.html#LN2434"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="clauses.c.html#LN68"><span class='Ref_to_Member'>estimate</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* unsafe transformations OK */ 
</span>    <span class='Control'>return</span> <a href="clauses.c.html#LN115"><span class='Ref_to_Proto'>eval_const_expressions_mutator</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2432"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="clauses.c.html#LN2434"><span class='Ref_To_Local'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN2446"></a><span class='Declare_Function'>eval_const_expressions_mutator</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, 
</span><a name="LN2447"></a>                               <a href="clauses.c.html#LN62"><span class='Ref_to_Typedef'>eval_const_expressions_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2446"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN513"><span class='Ref_to_Macro'>nodeTag</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2446"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN147"><span class='Ref_to_EnumConst'>T_Param</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span><a name="LN2455"></a>                <a href="../../../include/nodes/primnodes.h.html#LN240"><span class='Ref_to_Struct'>Param</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>param</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN240"><span class='Ref_to_Struct'>Param</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2446"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* Look to see if we've been given a value for this Param */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2455"><span class='Ref_To_Local'>param</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN243"><span class='Ref_to_Member'>paramkind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/primnodes.h.html#LN234"><span class='Ref_to_EnumConst'>PARAM_EXTERN</span></a> <span class='Operator'>&& 
</span>                    <a href="clauses.c.html#LN2447"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN64"><span class='Ref_to_Member'>boundParams</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL </span><span class='Operator'>&& 
</span>                    <a href="clauses.c.html#LN2455"><span class='Ref_To_Local'>param</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN244"><span class='Ref_to_Member'>paramid</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span> <span class='Operator'>&& 
</span>                    <a href="clauses.c.html#LN2455"><span class='Ref_To_Local'>param</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN244"><span class='Ref_to_Member'>paramid</span></a> <span class='Operator'>&LT;= </span><a href="clauses.c.html#LN2447"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN64"><span class='Ref_to_Member'>boundParams</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/params.h.html#LN73"><span class='Ref_to_Member'>numParams</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN2463"></a>                    <a href="../../../include/nodes/params.h.html#LN53"><span class='Ref_to_Struct'>ParamExternData</span></a> <span class='Operator'>*</span><span class='Declare_Local'>prm</span> <span class='Operator'>= &</span><a href="clauses.c.html#LN2447"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN64"><span class='Ref_to_Member'>boundParams</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/params.h.html#LN75"><span class='Ref_to_Member'>params</span></a><span class='Delimiter'>[</span><a href="clauses.c.html#LN2455"><span class='Ref_To_Local'>param</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN244"><span class='Ref_to_Member'>paramid</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span> 
                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2463"><span class='Ref_To_Local'>prm</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/params.h.html#LN58"><span class='Ref_to_Member'>ptype</span></a><span class='Parentheses'>))</span> 
                    <span class='Delimiter'>{ 
</span>                        <span class='Comment_Multi_Line'>/* OK to substitute parameter value? */ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2447"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN68"><span class='Ref_to_Member'>estimate</span></a> <span class='Operator'>|| 
</span>                            <span class='Parentheses'>(</span><a href="clauses.c.html#LN2463"><span class='Ref_To_Local'>prm</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/params.h.html#LN57"><span class='Ref_to_Member'>pflags</span></a> <span class='Operator'>& </span><a href="../../../include/nodes/params.h.html#LN51"><span class='Ref_to_Const'>PARAM_FLAG_CONST</span></a><span class='Parentheses'>))</span> 
                        <span class='Delimiter'>{ 
</span>                            <span class='Comment_Multi_Line'>/* 
                             * Return a Const representing the param value. 
                             * Must copy pass-by-ref datatypes, since the 
                             * Param might be in a memory context 
                             * shorter-lived than our output plan should be. 
                             */ 
</span><a name="LN2477"></a>                            <a href="../../../include/c.h.html#LN254"><span class='Ref_to_Typedef'>int16</span></a>       <span class='Declare_Local'>typLen</span><span class='Delimiter'>; 
</span><a name="LN2478"></a>                            <span class='Keyword'>bool</span>        <span class='Declare_Local'>typByVal</span><span class='Delimiter'>; 
</span><a name="LN2479"></a>                            <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>pval</span><span class='Delimiter'>; 
</span> 
                            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="clauses.c.html#LN2463"><span class='Ref_To_Local'>prm</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/params.h.html#LN58"><span class='Ref_to_Member'>ptype</span></a> <span class='Operator'>== </span><a href="clauses.c.html#LN2455"><span class='Ref_To_Local'>param</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN245"><span class='Ref_to_Member'>paramtype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                            <a href="../../../include/utils/lsyscache.h.html#LN135"><span class='Ref_to_Proto'>get_typlenbyval</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2455"><span class='Ref_To_Local'>param</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN245"><span class='Ref_to_Member'>paramtype</span></a><span class='Delimiter'>, 
</span>                                            <span class='Operator'>&</span><a href="clauses.c.html#LN2477"><span class='Ref_To_Local'>typLen</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="clauses.c.html#LN2478"><span class='Ref_To_Local'>typByVal</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2463"><span class='Ref_To_Local'>prm</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/params.h.html#LN56"><span class='Ref_to_Member'>isnull</span></a> <span class='Operator'>|| </span><a href="clauses.c.html#LN2478"><span class='Ref_To_Local'>typByVal</span></a><span class='Parentheses'>) 
</span>                                <a href="clauses.c.html#LN2479"><span class='Ref_To_Local'>pval</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2463"><span class='Ref_To_Local'>prm</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>value</span><span class='Delimiter'>; 
</span>                            <span class='Control'>else</span> 
                                <a href="clauses.c.html#LN2479"><span class='Ref_To_Local'>pval</span></a> <span class='Operator'>= </span><a href="../../../include/utils/datum.h.html#LN30"><span class='Ref_to_Proto'>datumCopy</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2463"><span class='Ref_To_Local'>prm</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>value</span><span class='Delimiter'>, </span><a href="clauses.c.html#LN2478"><span class='Ref_To_Local'>typByVal</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN2477"><span class='Ref_To_Local'>typLen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                            <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/makefuncs.h.html#LN49"><span class='Ref_to_Proto'>makeConst</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2455"><span class='Ref_To_Local'>param</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN245"><span class='Ref_to_Member'>paramtype</span></a><span class='Delimiter'>, 
</span>                                                      <a href="clauses.c.html#LN2455"><span class='Ref_To_Local'>param</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN246"><span class='Ref_to_Member'>paramtypmod</span></a><span class='Delimiter'>, 
</span>                                                      <a href="clauses.c.html#LN2455"><span class='Ref_To_Local'>param</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN247"><span class='Ref_to_Member'>paramcollid</span></a><span class='Delimiter'>, 
</span>                                                      <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2477"><span class='Ref_To_Local'>typLen</span></a><span class='Delimiter'>, 
</span>                                                      <a href="clauses.c.html#LN2479"><span class='Ref_To_Local'>pval</span></a><span class='Delimiter'>, 
</span>                                                      <a href="clauses.c.html#LN2463"><span class='Ref_To_Local'>prm</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/params.h.html#LN56"><span class='Ref_to_Member'>isnull</span></a><span class='Delimiter'>, 
</span>                                                      <a href="clauses.c.html#LN2478"><span class='Ref_To_Local'>typByVal</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if context-&GT;estimate||(p... &raquo; </span> 
                    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if OidIsValid(prm-&GT;ptype... &raquo; </span> 
                <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if param-&GT;paramkind==PAR... &raquo; </span> 
 
                <span class='Comment_Multi_Line'>/* 
                 * Not replaceable, so just copy the Param (no need to 
                 * recurse) 
                 */ 
</span>                <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2455"><span class='Ref_To_Local'>param</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN150"><span class='Ref_to_EnumConst'>T_WindowFunc</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span><a name="LN2507"></a>                <a href="../../../include/nodes/primnodes.h.html#LN351"><span class='Ref_to_Struct'>WindowFunc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN351"><span class='Ref_to_Struct'>WindowFunc</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2446"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span><a name="LN2508"></a>                <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>funcid</span> <span class='Operator'>= </span><a href="clauses.c.html#LN2507"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN354"><span class='Ref_to_Member'>winfnoid</span></a><span class='Delimiter'>; 
</span><a name="LN2509"></a>                <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>args</span><span class='Delimiter'>; 
</span><a name="LN2510"></a>                <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>aggfilter</span><span class='Delimiter'>; 
</span><a name="LN2511"></a>                <a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>func_tuple</span><span class='Delimiter'>; 
</span><a name="LN2512"></a>                <a href="../../../include/nodes/primnodes.h.html#LN351"><span class='Ref_to_Struct'>WindowFunc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>newexpr</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * We can't really simplify a WindowFunc node, but we mustn't 
                 * just fall through to the default processing, because we 
                 * have to apply expand_function_arguments to its argument 
                 * list.  That takes care of inserting default arguments and 
                 * expanding named-argument notation. 
                 */ 
</span>                <a href="clauses.c.html#LN2511"><span class='Ref_To_Local'>func_tuple</span></a> <span class='Operator'>= </span><a href="../../../include/utils/syscache.h.html#LN155"><span class='Ref_to_Macro'>SearchSysCache1</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/syscache.h.html#LN76"><span class='Ref_to_EnumConst'>PROCOID</span></a><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2508"><span class='Ref_To_Local'>funcid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2511"><span class='Ref_To_Local'>func_tuple</span></a><span class='Parentheses'>))</span> 
                    <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for function %u"</span><span class='Delimiter'>, </span><a href="clauses.c.html#LN2508"><span class='Ref_To_Local'>funcid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="clauses.c.html#LN2509"><span class='Ref_To_Local'>args</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN129"><span class='Ref_to_Proto'>expand_function_arguments</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2507"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN358"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN2507"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN355"><span class='Ref_to_Member'>wintype</span></a><span class='Delimiter'>, 
</span>                                                 <a href="clauses.c.html#LN2511"><span class='Ref_To_Local'>func_tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="../../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2511"><span class='Ref_To_Local'>func_tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* Now, recursively simplify the args (which are a List) */ 
</span>                <a href="clauses.c.html#LN2509"><span class='Ref_To_Local'>args</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                    <a href="../../../include/nodes/nodeFuncs.h.html#LN54"><span class='Ref_to_Proto'>expression_tree_mutator</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2509"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>, 
</span>                                            <a href="clauses.c.html#LN115"><span class='Ref_to_Proto'>eval_const_expressions_mutator</span></a><span class='Delimiter'>, 
</span>                                            <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2447"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Comment_Multi_Line'>/* ... and the filter expression, which isn't */ 
</span>                <a href="clauses.c.html#LN2510"><span class='Ref_To_Local'>aggfilter</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                    <a href="clauses.c.html#LN115"><span class='Ref_to_Proto'>eval_const_expressions_mutator</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2507"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN359"><span class='Ref_to_Member'>aggfilter</span></a><span class='Delimiter'>, 
</span>                                                   <a href="clauses.c.html#LN2447"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* And build the replacement WindowFunc node */ 
</span>                <a href="clauses.c.html#LN2512"><span class='Ref_To_Local'>newexpr</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN351"><span class='Ref_to_Struct'>WindowFunc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2512"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN354"><span class='Ref_to_Member'>winfnoid</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2507"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN354"><span class='Ref_to_Member'>winfnoid</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2512"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN355"><span class='Ref_to_Member'>wintype</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2507"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN355"><span class='Ref_to_Member'>wintype</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2512"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN356"><span class='Ref_to_Member'>wincollid</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2507"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN356"><span class='Ref_to_Member'>wincollid</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2512"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN357"><span class='Ref_to_Member'>inputcollid</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2507"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN357"><span class='Ref_to_Member'>inputcollid</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2512"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN358"><span class='Ref_to_Member'>args</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2509"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2512"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN359"><span class='Ref_to_Member'>aggfilter</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2510"><span class='Ref_To_Local'>aggfilter</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2512"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN360"><span class='Ref_to_Member'>winref</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2507"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN360"><span class='Ref_to_Member'>winref</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2512"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN361"><span class='Ref_to_Member'>winstar</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2507"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN361"><span class='Ref_to_Member'>winstar</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2512"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN362"><span class='Ref_to_Member'>winagg</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2507"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN362"><span class='Ref_to_Member'>winagg</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2512"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN363"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2507"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN363"><span class='Ref_to_Member'>location</span></a><span class='Delimiter'>; 
</span> 
                <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2512"><span class='Ref_To_Local'>newexpr</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN152"><span class='Ref_to_EnumConst'>T_FuncExpr</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span><a name="LN2557"></a>                <a href="../../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2446"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span><a name="LN2558"></a>                <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>args</span> <span class='Operator'>= </span><a href="clauses.c.html#LN2557"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN455"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>; 
</span><a name="LN2559"></a>                <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>simple</span><span class='Delimiter'>; 
</span><a name="LN2560"></a>                <a href="../../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>newexpr</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Code for op/func reduction is pretty bulky, so split it out 
                 * as a separate function.  Note: exprTypmod normally returns 
                 * -1 for a FuncExpr, but not when the node is recognizably a 
                 * length coercion; we want to preserve the typmod in the 
                 * eventual Const if so. 
                 */ 
</span>                <a href="clauses.c.html#LN2559"><span class='Ref_To_Local'>simple</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN124"><span class='Ref_to_Proto'>simplify_function</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2557"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN447"><span class='Ref_to_Member'>funcid</span></a><span class='Delimiter'>, 
</span>                                           <a href="clauses.c.html#LN2557"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN448"><span class='Ref_to_Member'>funcresulttype</span></a><span class='Delimiter'>, 
</span>                                           <a href="../../../include/nodes/nodeFuncs.h.html#LN32"><span class='Ref_to_Proto'>exprTypmod</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2446"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                           <a href="clauses.c.html#LN2557"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN453"><span class='Ref_to_Member'>funccollid</span></a><span class='Delimiter'>, 
</span>                                           <a href="clauses.c.html#LN2557"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN454"><span class='Ref_to_Member'>inputcollid</span></a><span class='Delimiter'>, 
</span>                                           <span class='Operator'>&</span><a href="clauses.c.html#LN2558"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>, 
</span>                                           <a href="clauses.c.html#LN2557"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN450"><span class='Ref_to_Member'>funcvariadic</span></a><span class='Delimiter'>, 
</span>                                           <span class='Boolean'>true</span><span class='Delimiter'>, 
</span>                                           <span class='Boolean'>true</span><span class='Delimiter'>, 
</span>                                           <a href="clauses.c.html#LN2447"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2559"><span class='Ref_To_Local'>simple</span></a><span class='Parentheses'>)</span>     <span class='Comment_Single_Line'>/* successfully simplified it */ 
</span>                    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2559"><span class='Ref_To_Local'>simple</span></a><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * The expression cannot be simplified any further, so build 
                 * and return a replacement FuncExpr node using the 
                 * possibly-simplified arguments.  Note that we have also 
                 * converted the argument list to positional notation. 
                 */ 
</span>                <a href="clauses.c.html#LN2560"><span class='Ref_To_Local'>newexpr</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2560"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN447"><span class='Ref_to_Member'>funcid</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2557"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN447"><span class='Ref_to_Member'>funcid</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2560"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN448"><span class='Ref_to_Member'>funcresulttype</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2557"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN448"><span class='Ref_to_Member'>funcresulttype</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2560"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN449"><span class='Ref_to_Member'>funcretset</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2557"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN449"><span class='Ref_to_Member'>funcretset</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2560"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN450"><span class='Ref_to_Member'>funcvariadic</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2557"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN450"><span class='Ref_to_Member'>funcvariadic</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2560"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN452"><span class='Ref_to_Member'>funcformat</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2557"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN452"><span class='Ref_to_Member'>funcformat</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2560"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN453"><span class='Ref_to_Member'>funccollid</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2557"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN453"><span class='Ref_to_Member'>funccollid</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2560"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN454"><span class='Ref_to_Member'>inputcollid</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2557"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN454"><span class='Ref_to_Member'>inputcollid</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2560"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN455"><span class='Ref_to_Member'>args</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2558"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2560"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN456"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2557"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN456"><span class='Ref_to_Member'>location</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2560"><span class='Ref_To_Local'>newexpr</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN154"><span class='Ref_to_EnumConst'>T_OpExpr</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span><a name="LN2602"></a>                <a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2446"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span><a name="LN2603"></a>                <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>args</span> <span class='Operator'>= </span><a href="clauses.c.html#LN2602"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN500"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>; 
</span><a name="LN2604"></a>                <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>simple</span><span class='Delimiter'>; 
</span><a name="LN2605"></a>                <a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>newexpr</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Need to get OID of underlying function.  Okay to scribble 
                 * on input to this extent. 
                 */ 
</span>                <a href="../../../include/nodes/nodeFuncs.h.html#LN46"><span class='Ref_to_Proto'>set_opfuncid</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2602"><span class='Ref_To_Local'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Code for op/func reduction is pretty bulky, so split it out 
                 * as a separate function. 
                 */ 
</span>                <a href="clauses.c.html#LN2604"><span class='Ref_To_Local'>simple</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN124"><span class='Ref_to_Proto'>simplify_function</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2602"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN495"><span class='Ref_to_Member'>opfuncid</span></a><span class='Delimiter'>, 
</span>                                           <a href="clauses.c.html#LN2602"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN496"><span class='Ref_to_Member'>opresulttype</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                                           <a href="clauses.c.html#LN2602"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN498"><span class='Ref_to_Member'>opcollid</span></a><span class='Delimiter'>, 
</span>                                           <a href="clauses.c.html#LN2602"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN499"><span class='Ref_to_Member'>inputcollid</span></a><span class='Delimiter'>, 
</span>                                           <span class='Operator'>&</span><a href="clauses.c.html#LN2603"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>, 
</span>                                           <span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                                           <span class='Boolean'>true</span><span class='Delimiter'>, 
</span>                                           <span class='Boolean'>true</span><span class='Delimiter'>, 
</span>                                           <a href="clauses.c.html#LN2447"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2604"><span class='Ref_To_Local'>simple</span></a><span class='Parentheses'>)</span>     <span class='Comment_Single_Line'>/* successfully simplified it */ 
</span>                    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2604"><span class='Ref_To_Local'>simple</span></a><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * If the operator is boolean equality or inequality, we know 
                 * how to simplify cases involving one constant and one 
                 * non-constant argument. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2602"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN494"><span class='Ref_to_Member'>opno</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_operator.h.html#LN113"><span class='Ref_to_Const'>BooleanEqualOperator</span></a> <span class='Operator'>|| 
</span>                    <a href="clauses.c.html#LN2602"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN494"><span class='Ref_to_Member'>opno</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_operator.h.html#LN110"><span class='Ref_to_Const'>BooleanNotEqualOperator</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <a href="clauses.c.html#LN2604"><span class='Ref_To_Local'>simple</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN123"><span class='Ref_to_Proto'>simplify_boolean_equality</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2602"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN494"><span class='Ref_to_Member'>opno</span></a><span class='Delimiter'>, 
</span>                                                                <a href="clauses.c.html#LN2603"><span class='Ref_To_Local'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2604"><span class='Ref_To_Local'>simple</span></a><span class='Parentheses'>) </span><span class='Comment_Single_Line'>/* successfully simplified it */ 
</span>                        <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2604"><span class='Ref_To_Local'>simple</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * The expression cannot be simplified any further, so build 
                 * and return a replacement OpExpr node using the 
                 * possibly-simplified arguments. 
                 */ 
</span>                <a href="clauses.c.html#LN2605"><span class='Ref_To_Local'>newexpr</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2605"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN494"><span class='Ref_to_Member'>opno</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2602"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN494"><span class='Ref_to_Member'>opno</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2605"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN495"><span class='Ref_to_Member'>opfuncid</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2602"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN495"><span class='Ref_to_Member'>opfuncid</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2605"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN496"><span class='Ref_to_Member'>opresulttype</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2602"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN496"><span class='Ref_to_Member'>opresulttype</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2605"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN497"><span class='Ref_to_Member'>opretset</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2602"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN497"><span class='Ref_to_Member'>opretset</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2605"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN498"><span class='Ref_to_Member'>opcollid</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2602"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN498"><span class='Ref_to_Member'>opcollid</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2605"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN499"><span class='Ref_to_Member'>inputcollid</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2602"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN499"><span class='Ref_to_Member'>inputcollid</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2605"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN500"><span class='Ref_to_Member'>args</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2603"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2605"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN501"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2602"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN501"><span class='Ref_to_Member'>location</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2605"><span class='Ref_To_Local'>newexpr</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN155"><span class='Ref_to_EnumConst'>T_DistinctExpr</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span><a name="LN2661"></a>                <a href="../../../include/nodes/primnodes.h.html#LN514"><span class='Ref_to_Typedef'>DistinctExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN514"><span class='Ref_to_Typedef'>DistinctExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2446"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span><a name="LN2662"></a>                <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>args</span><span class='Delimiter'>; 
</span><a name="LN2663"></a>                <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>arg</span><span class='Delimiter'>; 
</span><a name="LN2664"></a>                <span class='Keyword'>bool</span>        <span class='Declare_Local'>has_null_input</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN2665"></a>                <span class='Keyword'>bool</span>        <span class='Declare_Local'>all_null_input</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span><a name="LN2666"></a>                <span class='Keyword'>bool</span>        <span class='Declare_Local'>has_nonconst_input</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN2667"></a>                <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>simple</span><span class='Delimiter'>; 
</span><a name="LN2668"></a>                <a href="../../../include/nodes/primnodes.h.html#LN514"><span class='Ref_to_Typedef'>DistinctExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>newexpr</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Reduce constants in the DistinctExpr's arguments.  We know 
                 * args is either NIL or a List node, so we can call 
                 * expression_tree_mutator directly rather than recursing to 
                 * self. 
                 */ 
</span>                <a href="clauses.c.html#LN2662"><span class='Ref_To_Local'>args</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/nodeFuncs.h.html#LN54"><span class='Ref_to_Proto'>expression_tree_mutator</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2661"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN500"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>, 
</span>                                              <a href="clauses.c.html#LN115"><span class='Ref_to_Proto'>eval_const_expressions_mutator</span></a><span class='Delimiter'>, 
</span>                                                        <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2447"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * We must do our own check for NULLs because DistinctExpr has 
                 * different results for NULL input than the underlying 
                 * operator does. 
                 */ 
</span>                <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2663"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN2662"><span class='Ref_To_Local'>args</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2663"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
                    <span class='Delimiter'>{ 
</span>                        <a href="clauses.c.html#LN2664"><span class='Ref_To_Local'>has_null_input</span></a> <span class='Operator'>|= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2663"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>constisnull<span class='Delimiter'>; 
</span>                        <a href="clauses.c.html#LN2665"><span class='Ref_To_Local'>all_null_input</span></a> <span class='Operator'>&= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2663"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>constisnull<span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <span class='Control'>else</span> 
                        <a href="clauses.c.html#LN2666"><span class='Ref_To_Local'>has_nonconst_input</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
                <span class='Comment_Multi_Line'>/* all constants? then can optimize this out */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="clauses.c.html#LN2666"><span class='Ref_To_Local'>has_nonconst_input</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* all nulls? then not distinct */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2665"><span class='Ref_To_Local'>all_null_input</span></a><span class='Parentheses'>) 
</span>                        <span class='Control'>return</span> <a href="../../../include/nodes/makefuncs.h.html#LN59"><span class='Ref_to_Proto'>makeBoolConst</span></a><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <span class='Comment_Multi_Line'>/* one null? then distinct */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2664"><span class='Ref_To_Local'>has_null_input</span></a><span class='Parentheses'>) 
</span>                        <span class='Control'>return</span> <a href="../../../include/nodes/makefuncs.h.html#LN59"><span class='Ref_to_Proto'>makeBoolConst</span></a><span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <span class='Comment_Multi_Line'>/* otherwise try to evaluate the '=' operator */ 
</span>                    <span class='Comment_Multi_Line'>/* (NOT okay to try to inline it, though!) */ 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * Need to get OID of underlying function.  Okay to 
                     * scribble on input to this extent. 
                     */ 
</span>                    <a href="../../../include/nodes/nodeFuncs.h.html#LN46"><span class='Ref_to_Proto'>set_opfuncid</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2661"><span class='Ref_To_Local'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>      <span class='Comment_Multi_Line'>/* rely on struct 
                                                         * equivalence */ 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * Code for op/func reduction is pretty bulky, so split it 
                     * out as a separate function. 
                     */ 
</span>                    <a href="clauses.c.html#LN2667"><span class='Ref_To_Local'>simple</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN124"><span class='Ref_to_Proto'>simplify_function</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2661"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN495"><span class='Ref_to_Member'>opfuncid</span></a><span class='Delimiter'>, 
</span>                                               <a href="clauses.c.html#LN2661"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN496"><span class='Ref_to_Member'>opresulttype</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                                               <a href="clauses.c.html#LN2661"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN498"><span class='Ref_to_Member'>opcollid</span></a><span class='Delimiter'>, 
</span>                                               <a href="clauses.c.html#LN2661"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN499"><span class='Ref_to_Member'>inputcollid</span></a><span class='Delimiter'>, 
</span>                                               <span class='Operator'>&</span><a href="clauses.c.html#LN2662"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>, 
</span>                                               <span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                                               <span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                                               <span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                                               <a href="clauses.c.html#LN2447"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2667"><span class='Ref_To_Local'>simple</span></a><span class='Parentheses'>) </span><span class='Comment_Single_Line'>/* successfully simplified it */ 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Comment_Multi_Line'>/* 
                         * Since the underlying operator is "=", must negate 
                         * its result 
                         */ 
</span><a name="LN2736"></a>                        <a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>csimple</span> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN575"><span class='Ref_to_Macro'>castNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN2667"><span class='Ref_To_Local'>simple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                        <a href="clauses.c.html#LN2736"><span class='Ref_To_Local'>csimple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a> <span class='Operator'>= 
</span>                            <a href="../../../include/postgres.h.html#LN407"><span class='Ref_to_Macro'>BoolGetDatum</span></a><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2736"><span class='Ref_To_Local'>csimple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                        <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2736"><span class='Ref_To_Local'>csimple</span></a><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !has_nonconst_input &raquo; </span> 
 
                <span class='Comment_Multi_Line'>/* 
                 * The expression cannot be simplified any further, so build 
                 * and return a replacement DistinctExpr node using the 
                 * possibly-simplified arguments. 
                 */ 
</span>                <a href="clauses.c.html#LN2668"><span class='Ref_To_Local'>newexpr</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN514"><span class='Ref_to_Typedef'>DistinctExpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2668"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN494"><span class='Ref_to_Member'>opno</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2661"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN494"><span class='Ref_to_Member'>opno</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2668"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN495"><span class='Ref_to_Member'>opfuncid</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2661"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN495"><span class='Ref_to_Member'>opfuncid</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2668"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN496"><span class='Ref_to_Member'>opresulttype</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2661"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN496"><span class='Ref_to_Member'>opresulttype</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2668"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN497"><span class='Ref_to_Member'>opretset</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2661"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN497"><span class='Ref_to_Member'>opretset</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2668"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN498"><span class='Ref_to_Member'>opcollid</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2661"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN498"><span class='Ref_to_Member'>opcollid</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2668"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN499"><span class='Ref_to_Member'>inputcollid</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2661"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN499"><span class='Ref_to_Member'>inputcollid</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2668"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN500"><span class='Ref_to_Member'>args</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2662"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2668"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN501"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2661"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN501"><span class='Ref_to_Member'>location</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2668"><span class='Ref_To_Local'>newexpr</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN158"><span class='Ref_to_EnumConst'>T_BoolExpr</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span><a name="LN2762"></a>                <a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2446"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
                <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2762"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN560"><span class='Ref_to_Member'>boolop</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN554"><span class='Ref_to_EnumConst'>OR_EXPR</span></a><span class='Operator'>: 
</span>                        <span class='Delimiter'>{ 
</span><a name="LN2768"></a>                            <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>newargs</span><span class='Delimiter'>; 
</span><a name="LN2769"></a>                            <span class='Keyword'>bool</span>        <span class='Declare_Local'>haveNull</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN2770"></a>                            <span class='Keyword'>bool</span>        <span class='Declare_Local'>forceTrue</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
                            <a href="clauses.c.html#LN2768"><span class='Ref_To_Local'>newargs</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN117"><span class='Ref_to_Proto'>simplify_or_arguments</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2762"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN561"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>, 
</span>                                                            <a href="clauses.c.html#LN2447"><span class='Ref_to_Parameter'>context</span></a><span class='Delimiter'>, 
</span>                                                            <span class='Operator'>&</span><a href="clauses.c.html#LN2769"><span class='Ref_To_Local'>haveNull</span></a><span class='Delimiter'>, 
</span>                                                            <span class='Operator'>&</span><a href="clauses.c.html#LN2770"><span class='Ref_To_Local'>forceTrue</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2770"><span class='Ref_To_Local'>forceTrue</span></a><span class='Parentheses'>) 
</span>                                <span class='Control'>return</span> <a href="../../../include/nodes/makefuncs.h.html#LN59"><span class='Ref_to_Proto'>makeBoolConst</span></a><span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2769"><span class='Ref_To_Local'>haveNull</span></a><span class='Parentheses'>) 
</span>                                <a href="clauses.c.html#LN2768"><span class='Ref_To_Local'>newargs</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2768"><span class='Ref_To_Local'>newargs</span></a><span class='Delimiter'>, 
</span>                                                  <a href="../../../include/nodes/makefuncs.h.html#LN59"><span class='Ref_to_Proto'>makeBoolConst</span></a><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                            <span class='Comment_Multi_Line'>/* If all the inputs are FALSE, result is FALSE */ 
</span>                            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2768"><span class='Ref_To_Local'>newargs</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>                                <span class='Control'>return</span> <a href="../../../include/nodes/makefuncs.h.html#LN59"><span class='Ref_to_Proto'>makeBoolConst</span></a><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                            <span class='Comment_Multi_Line'>/* 
                             * If only one nonconst-or-NULL input, it's the 
                             * result 
                             */ 
</span>                            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2768"><span class='Ref_To_Local'>newargs</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
                                <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2768"><span class='Ref_To_Local'>newargs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                            <span class='Comment_Multi_Line'>/* Else we still need an OR node */ 
</span>                            <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/clauses.h.html#LN40"><span class='Ref_to_Proto'>make_orclause</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2768"><span class='Ref_To_Local'>newargs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                    <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN554"><span class='Ref_to_EnumConst'>AND_EXPR</span></a><span class='Operator'>: 
</span>                        <span class='Delimiter'>{ 
</span><a name="LN2796"></a>                            <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>newargs</span><span class='Delimiter'>; 
</span><a name="LN2797"></a>                            <span class='Keyword'>bool</span>        <span class='Declare_Local'>haveNull</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN2798"></a>                            <span class='Keyword'>bool</span>        <span class='Declare_Local'>forceFalse</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
                            <a href="clauses.c.html#LN2796"><span class='Ref_To_Local'>newargs</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN120"><span class='Ref_to_Proto'>simplify_and_arguments</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2762"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN561"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>, 
</span>                                                             <a href="clauses.c.html#LN2447"><span class='Ref_to_Parameter'>context</span></a><span class='Delimiter'>, 
</span>                                                             <span class='Operator'>&</span><a href="clauses.c.html#LN2797"><span class='Ref_To_Local'>haveNull</span></a><span class='Delimiter'>, 
</span>                                                             <span class='Operator'>&</span><a href="clauses.c.html#LN2798"><span class='Ref_To_Local'>forceFalse</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2798"><span class='Ref_To_Local'>forceFalse</span></a><span class='Parentheses'>) 
</span>                                <span class='Control'>return</span> <a href="../../../include/nodes/makefuncs.h.html#LN59"><span class='Ref_to_Proto'>makeBoolConst</span></a><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2797"><span class='Ref_To_Local'>haveNull</span></a><span class='Parentheses'>) 
</span>                                <a href="clauses.c.html#LN2796"><span class='Ref_To_Local'>newargs</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2796"><span class='Ref_To_Local'>newargs</span></a><span class='Delimiter'>, 
</span>                                                  <a href="../../../include/nodes/makefuncs.h.html#LN59"><span class='Ref_to_Proto'>makeBoolConst</span></a><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                            <span class='Comment_Multi_Line'>/* If all the inputs are TRUE, result is TRUE */ 
</span>                            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2796"><span class='Ref_To_Local'>newargs</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>                                <span class='Control'>return</span> <a href="../../../include/nodes/makefuncs.h.html#LN59"><span class='Ref_to_Proto'>makeBoolConst</span></a><span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                            <span class='Comment_Multi_Line'>/* 
                             * If only one nonconst-or-NULL input, it's the 
                             * result 
                             */ 
</span>                            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2796"><span class='Ref_To_Local'>newargs</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
                                <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2796"><span class='Ref_To_Local'>newargs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                            <span class='Comment_Multi_Line'>/* Else we still need an AND node */ 
</span>                            <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/clauses.h.html#LN43"><span class='Ref_to_Proto'>make_andclause</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2796"><span class='Ref_To_Local'>newargs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                    <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN554"><span class='Ref_to_EnumConst'>NOT_EXPR</span></a><span class='Operator'>: 
</span>                        <span class='Delimiter'>{ 
</span><a name="LN2824"></a>                            <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>arg</span><span class='Delimiter'>; 
</span> 
                            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2762"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN561"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                            <a href="clauses.c.html#LN2824"><span class='Ref_To_Local'>arg</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN115"><span class='Ref_to_Proto'>eval_const_expressions_mutator</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2762"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN561"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                                 <a href="clauses.c.html#LN2447"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                            <span class='Comment_Multi_Line'>/* 
                             * Use negate_clause() to see if we can simplify 
                             * away the NOT. 
                             */ 
</span>                            <span class='Control'>return</span> <a href="../../../include/optimizer/prep.h.html#LN34"><span class='Ref_to_Proto'>negate_clause</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2824"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                    <span class='Control'>default</span><span class='Operator'>: 
</span>                        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized boolop: %d"</span><span class='Delimiter'>, 
</span>                             <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2762"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN560"><span class='Ref_to_Member'>boolop</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch expr-&GT;boolop &raquo; </span> 
                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN160"><span class='Ref_to_EnumConst'>T_SubPlan</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN161"><span class='Ref_to_EnumConst'>T_AlternativeSubPlan</span></a><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Return a SubPlan unchanged --- too late to do anything with it. 
             * 
             * XXX should we ereport() here instead?  Probably this routine 
             * should never be invoked after SubPlan creation. 
             */ 
</span>            <span class='Control'>return</span> <a href="clauses.c.html#LN2446"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN164"><span class='Ref_to_EnumConst'>T_RelabelType</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * If we can simplify the input to a constant, then we don't 
                 * need the RelabelType node anymore: just change the type 
                 * field of the Const node.  Otherwise, must copy the 
                 * RelabelType node. 
                 */ 
</span><a name="LN2861"></a>                <a href="../../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a> <span class='Operator'>*</span><span class='Declare_Local'>relabel</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2446"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span><a name="LN2862"></a>                <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>arg</span><span class='Delimiter'>; 
</span> 
                <a href="clauses.c.html#LN2862"><span class='Ref_To_Local'>arg</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN115"><span class='Ref_to_Proto'>eval_const_expressions_mutator</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2861"><span class='Ref_To_Local'>relabel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN789"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>, 
</span>                                                     <a href="clauses.c.html#LN2447"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * If we find stacked RelabelTypes (eg, from foo :: int :: 
                 * oid) we can discard all but the top one. 
                 */ 
</span>                <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2862"><span class='Ref_To_Local'>arg</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2862"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a><span class='Parentheses'>))</span> 
                    <a href="clauses.c.html#LN2862"><span class='Ref_To_Local'>arg</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) ((</span><a href="../../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2862"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>arg<span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2862"><span class='Ref_To_Local'>arg</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2862"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span><a name="LN2876"></a>                    <a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>con</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2862"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>; 
</span> 
                    <a href="clauses.c.html#LN2876"><span class='Ref_To_Local'>con</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN191"><span class='Ref_to_Member'>consttype</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2861"><span class='Ref_To_Local'>relabel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN790"><span class='Ref_to_Member'>resulttype</span></a><span class='Delimiter'>; 
</span>                    <a href="clauses.c.html#LN2876"><span class='Ref_To_Local'>con</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN192"><span class='Ref_to_Member'>consttypmod</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2861"><span class='Ref_To_Local'>relabel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN791"><span class='Ref_to_Member'>resulttypmod</span></a><span class='Delimiter'>; 
</span>                    <a href="clauses.c.html#LN2876"><span class='Ref_To_Local'>con</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN193"><span class='Ref_to_Member'>constcollid</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2861"><span class='Ref_To_Local'>relabel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN792"><span class='Ref_to_Member'>resultcollid</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2876"><span class='Ref_To_Local'>con</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>else</span> 
                <span class='Delimiter'>{ 
</span><a name="LN2885"></a>                    <a href="../../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a> <span class='Operator'>*</span><span class='Declare_Local'>newrelabel</span> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <a href="clauses.c.html#LN2885"><span class='Ref_To_Local'>newrelabel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN789"><span class='Ref_to_Member'>arg</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2862"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>; 
</span>                    <a href="clauses.c.html#LN2885"><span class='Ref_To_Local'>newrelabel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN790"><span class='Ref_to_Member'>resulttype</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2861"><span class='Ref_To_Local'>relabel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN790"><span class='Ref_to_Member'>resulttype</span></a><span class='Delimiter'>; 
</span>                    <a href="clauses.c.html#LN2885"><span class='Ref_To_Local'>newrelabel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN791"><span class='Ref_to_Member'>resulttypmod</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2861"><span class='Ref_To_Local'>relabel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN791"><span class='Ref_to_Member'>resulttypmod</span></a><span class='Delimiter'>; 
</span>                    <a href="clauses.c.html#LN2885"><span class='Ref_To_Local'>newrelabel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN792"><span class='Ref_to_Member'>resultcollid</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2861"><span class='Ref_To_Local'>relabel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN792"><span class='Ref_to_Member'>resultcollid</span></a><span class='Delimiter'>; 
</span>                    <a href="clauses.c.html#LN2885"><span class='Ref_To_Local'>newrelabel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN793"><span class='Ref_to_Member'>relabelformat</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2861"><span class='Ref_To_Local'>relabel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN793"><span class='Ref_to_Member'>relabelformat</span></a><span class='Delimiter'>; 
</span>                    <a href="clauses.c.html#LN2885"><span class='Ref_To_Local'>newrelabel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN794"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2861"><span class='Ref_To_Local'>relabel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN794"><span class='Ref_to_Member'>location</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2885"><span class='Ref_To_Local'>newrelabel</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN165"><span class='Ref_to_EnumConst'>T_CoerceViaIO</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span><a name="LN2898"></a>                <a href="../../../include/nodes/primnodes.h.html#LN806"><span class='Ref_to_Struct'>CoerceViaIO</span></a> <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN806"><span class='Ref_to_Struct'>CoerceViaIO</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2446"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span><a name="LN2899"></a>                <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>args</span><span class='Delimiter'>; 
</span><a name="LN2900"></a>                <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>outfunc</span><span class='Delimiter'>; 
</span><a name="LN2901"></a>                <span class='Keyword'>bool</span>        <span class='Declare_Local'>outtypisvarlena</span><span class='Delimiter'>; 
</span><a name="LN2902"></a>                <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>infunc</span><span class='Delimiter'>; 
</span><a name="LN2903"></a>                <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>intypioparam</span><span class='Delimiter'>; 
</span><a name="LN2904"></a>                <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>simple</span><span class='Delimiter'>; 
</span><a name="LN2905"></a>                <a href="../../../include/nodes/primnodes.h.html#LN806"><span class='Ref_to_Struct'>CoerceViaIO</span></a> <span class='Operator'>*</span><span class='Declare_Local'>newexpr</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* Make a List so we can use simplify_function */ 
</span>                <a href="clauses.c.html#LN2899"><span class='Ref_To_Local'>args</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2898"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN809"><span class='Ref_to_Member'>arg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * CoerceViaIO represents calling the source type's output 
                 * function then the result type's input function.  So, try to 
                 * simplify it as though it were a stack of two such function 
                 * calls.  First we need to know what the functions are. 
                 * 
                 * Note that the coercion functions are assumed not to care 
                 * about input collation, so we just pass InvalidOid for that. 
                 */ 
</span>                <a href="../../../include/utils/lsyscache.h.html#LN162"><span class='Ref_to_Proto'>getTypeOutputInfo</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2898"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN809"><span class='Ref_to_Member'>arg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                  <span class='Operator'>&</span><a href="clauses.c.html#LN2900"><span class='Ref_To_Local'>outfunc</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="clauses.c.html#LN2901"><span class='Ref_To_Local'>outtypisvarlena</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../include/utils/lsyscache.h.html#LN161"><span class='Ref_to_Proto'>getTypeInputInfo</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2898"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN810"><span class='Ref_to_Member'>resulttype</span></a><span class='Delimiter'>, 
</span>                                 <span class='Operator'>&</span><a href="clauses.c.html#LN2902"><span class='Ref_To_Local'>infunc</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="clauses.c.html#LN2903"><span class='Ref_To_Local'>intypioparam</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="clauses.c.html#LN2904"><span class='Ref_To_Local'>simple</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN124"><span class='Ref_to_Proto'>simplify_function</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2900"><span class='Ref_To_Local'>outfunc</span></a><span class='Delimiter'>, 
</span>                                           <a href="../../../include/catalog/pg_type.h.html#LN683"><span class='Ref_to_Const'>CSTRINGOID</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                                           <a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                                           <a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                                           <span class='Operator'>&</span><a href="clauses.c.html#LN2899"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>, 
</span>                                           <span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                                           <span class='Boolean'>true</span><span class='Delimiter'>, 
</span>                                           <span class='Boolean'>true</span><span class='Delimiter'>, 
</span>                                           <a href="clauses.c.html#LN2447"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2904"><span class='Ref_To_Local'>simple</span></a><span class='Parentheses'>)</span>     <span class='Comment_Single_Line'>/* successfully simplified output fn */ 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* 
                     * Input functions may want 1 to 3 arguments.  We always 
                     * supply all three, trusting that nothing downstream will 
                     * complain. 
                     */ 
</span>                    <a href="clauses.c.html#LN2899"><span class='Ref_To_Local'>args</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN140"><span class='Ref_to_Macro'>list_make3</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2904"><span class='Ref_To_Local'>simple</span></a><span class='Delimiter'>, 
</span>                                      <a href="../../../include/nodes/makefuncs.h.html#LN49"><span class='Ref_to_Proto'>makeConst</span></a><span class='Parentheses'>(</span><a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN27"><span class='Ref_to_Const'>OIDOID</span></a><span class='Delimiter'>, 
</span>                                                <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                                                <a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                                                <span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                              <a href="../../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2903"><span class='Ref_To_Local'>intypioparam</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                <span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                                                <span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                      <a href="../../../include/nodes/makefuncs.h.html#LN49"><span class='Ref_to_Proto'>makeConst</span></a><span class='Parentheses'>(</span><a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN24"><span class='Ref_to_Const'>INT4OID</span></a><span class='Delimiter'>, 
</span>                                                <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                                                <a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                                                <span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                <a href="../../../include/postgres.h.html#LN484"><span class='Ref_to_Macro'>Int32GetDatum</span></a><span class='Parentheses'>(</span><span class='Operator'>-</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                <span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                                                <span class='Boolean'>true</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
                    <a href="clauses.c.html#LN2904"><span class='Ref_To_Local'>simple</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN124"><span class='Ref_to_Proto'>simplify_function</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2902"><span class='Ref_To_Local'>infunc</span></a><span class='Delimiter'>, 
</span>                                               <a href="clauses.c.html#LN2898"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN810"><span class='Ref_to_Member'>resulttype</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                                               <a href="clauses.c.html#LN2898"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN812"><span class='Ref_to_Member'>resultcollid</span></a><span class='Delimiter'>, 
</span>                                               <a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                                               <span class='Operator'>&</span><a href="clauses.c.html#LN2899"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>, 
</span>                                               <span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                                               <span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                                               <span class='Boolean'>true</span><span class='Delimiter'>, 
</span>                                               <a href="clauses.c.html#LN2447"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2904"><span class='Ref_To_Local'>simple</span></a><span class='Parentheses'>) </span><span class='Comment_Single_Line'>/* successfully simplified input fn */ 
</span>                        <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2904"><span class='Ref_To_Local'>simple</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if simple &raquo; </span> 
 
                <span class='Comment_Multi_Line'>/* 
                 * The expression cannot be simplified any further, so build 
                 * and return a replacement CoerceViaIO node using the 
                 * possibly-simplified argument. 
                 */ 
</span>                <a href="clauses.c.html#LN2905"><span class='Ref_To_Local'>newexpr</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN806"><span class='Ref_to_Struct'>CoerceViaIO</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2905"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN809"><span class='Ref_to_Member'>arg</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2899"><span class='Ref_To_Local'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2905"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN810"><span class='Ref_to_Member'>resulttype</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2898"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN810"><span class='Ref_to_Member'>resulttype</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2905"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN812"><span class='Ref_to_Member'>resultcollid</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2898"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN812"><span class='Ref_to_Member'>resultcollid</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2905"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN813"><span class='Ref_to_Member'>coerceformat</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2898"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN813"><span class='Ref_to_Member'>coerceformat</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2905"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN814"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2898"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN814"><span class='Ref_to_Member'>location</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2905"><span class='Ref_To_Local'>newexpr</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN166"><span class='Ref_to_EnumConst'>T_ArrayCoerceExpr</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span><a name="LN2984"></a>                <a href="../../../include/nodes/primnodes.h.html#LN829"><span class='Ref_to_Struct'>ArrayCoerceExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN829"><span class='Ref_to_Struct'>ArrayCoerceExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2446"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span><a name="LN2985"></a>                <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>arg</span><span class='Delimiter'>; 
</span><a name="LN2986"></a>                <a href="../../../include/nodes/primnodes.h.html#LN829"><span class='Ref_to_Struct'>ArrayCoerceExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>newexpr</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Reduce constants in the ArrayCoerceExpr's argument, then 
                 * build a new ArrayCoerceExpr. 
                 */ 
</span>                <a href="clauses.c.html#LN2985"><span class='Ref_To_Local'>arg</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN115"><span class='Ref_to_Proto'>eval_const_expressions_mutator</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2984"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN832"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>, 
</span>                                                              <a href="clauses.c.html#LN2447"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="clauses.c.html#LN2986"><span class='Ref_To_Local'>newexpr</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN829"><span class='Ref_to_Struct'>ArrayCoerceExpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2986"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN832"><span class='Ref_to_Member'>arg</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2985"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2986"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN833"><span class='Ref_to_Member'>elemfuncid</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2984"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN833"><span class='Ref_to_Member'>elemfuncid</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2986"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN834"><span class='Ref_to_Member'>resulttype</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2984"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN834"><span class='Ref_to_Member'>resulttype</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2986"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN835"><span class='Ref_to_Member'>resulttypmod</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2984"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN835"><span class='Ref_to_Member'>resulttypmod</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2986"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN836"><span class='Ref_to_Member'>resultcollid</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2984"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN836"><span class='Ref_to_Member'>resultcollid</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2986"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN837"><span class='Ref_to_Member'>isExplicit</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2984"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN837"><span class='Ref_to_Member'>isExplicit</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2986"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN838"><span class='Ref_to_Member'>coerceformat</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2984"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN838"><span class='Ref_to_Member'>coerceformat</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN2986"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN839"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2984"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN839"><span class='Ref_to_Member'>location</span></a><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * If constant argument and it's a binary-coercible or 
                 * immutable conversion, we can simplify it to a constant. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2985"><span class='Ref_To_Local'>arg</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2985"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>                    <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2986"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN833"><span class='Ref_to_Member'>elemfuncid</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>                <a href="../../../include/utils/lsyscache.h.html#LN118"><span class='Ref_to_Proto'>func_volatile</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2986"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN833"><span class='Ref_to_Member'>elemfuncid</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="../../../include/catalog/pg_proc.h.html#LN5482"><span class='Ref_to_Const'>PROVOLATILE_IMMUTABLE</span></a><span class='Parentheses'>))</span> 
                    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN151"><span class='Ref_to_Proto'>evaluate_expr</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2986"><span class='Ref_To_Local'>newexpr</span></a><span class='Delimiter'>, 
</span>                                                  <a href="clauses.c.html#LN2986"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN834"><span class='Ref_to_Member'>resulttype</span></a><span class='Delimiter'>, 
</span>                                                  <a href="clauses.c.html#LN2986"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN835"><span class='Ref_to_Member'>resulttypmod</span></a><span class='Delimiter'>, 
</span>                                                  <a href="clauses.c.html#LN2986"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN836"><span class='Ref_to_Member'>resultcollid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* Else we must return the partially-simplified node */ 
</span>                <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2986"><span class='Ref_To_Local'>newexpr</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN168"><span class='Ref_to_EnumConst'>T_CollateExpr</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * If we can simplify the input to a constant, then we don't 
                 * need the CollateExpr node at all: just change the 
                 * constcollid field of the Const node.  Otherwise, replace 
                 * the CollateExpr with a RelabelType. (We do that so as to 
                 * improve uniformity of expression representation and thus 
                 * simplify comparison of expressions.) 
                 */ 
</span><a name="LN3030"></a>                <a href="../../../include/nodes/primnodes.h.html#LN871"><span class='Ref_to_Struct'>CollateExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>collate</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN871"><span class='Ref_to_Struct'>CollateExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2446"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span><a name="LN3031"></a>                <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>arg</span><span class='Delimiter'>; 
</span> 
                <a href="clauses.c.html#LN3031"><span class='Ref_To_Local'>arg</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN115"><span class='Ref_to_Proto'>eval_const_expressions_mutator</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3030"><span class='Ref_To_Local'>collate</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN874"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>, 
</span>                                                     <a href="clauses.c.html#LN2447"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN3031"><span class='Ref_To_Local'>arg</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3031"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span><a name="LN3038"></a>                    <a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>con</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3031"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>; 
</span> 
                    <a href="clauses.c.html#LN3038"><span class='Ref_To_Local'>con</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN193"><span class='Ref_to_Member'>constcollid</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3030"><span class='Ref_To_Local'>collate</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN875"><span class='Ref_to_Member'>collOid</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3038"><span class='Ref_To_Local'>con</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN3030"><span class='Ref_To_Local'>collate</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN875"><span class='Ref_to_Member'>collOid</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodeFuncs.h.html#LN38"><span class='Ref_to_Proto'>exprCollation</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3031"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* Don't need a RelabelType either... */ 
</span>                    <span class='Control'>return</span> <a href="clauses.c.html#LN3031"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>else</span> 
                <span class='Delimiter'>{ 
</span><a name="LN3050"></a>                    <a href="../../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a> <span class='Operator'>*</span><span class='Declare_Local'>relabel</span> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <a href="clauses.c.html#LN3050"><span class='Ref_To_Local'>relabel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN790"><span class='Ref_to_Member'>resulttype</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3031"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="clauses.c.html#LN3050"><span class='Ref_To_Local'>relabel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN791"><span class='Ref_to_Member'>resulttypmod</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodeFuncs.h.html#LN32"><span class='Ref_to_Proto'>exprTypmod</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3031"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="clauses.c.html#LN3050"><span class='Ref_To_Local'>relabel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN792"><span class='Ref_to_Member'>resultcollid</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3030"><span class='Ref_To_Local'>collate</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN875"><span class='Ref_to_Member'>collOid</span></a><span class='Delimiter'>; 
</span>                    <a href="clauses.c.html#LN3050"><span class='Ref_To_Local'>relabel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN793"><span class='Ref_to_Member'>relabelformat</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/primnodes.h.html#LN438"><span class='Ref_to_EnumConst'>COERCE_IMPLICIT_CAST</span></a><span class='Delimiter'>; 
</span>                    <a href="clauses.c.html#LN3050"><span class='Ref_To_Local'>relabel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN794"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3030"><span class='Ref_To_Local'>collate</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN876"><span class='Ref_to_Member'>location</span></a><span class='Delimiter'>; 
</span> 
                    <span class='Comment_Multi_Line'>/* Don't create stacked RelabelTypes */ 
</span>                    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN3031"><span class='Ref_To_Local'>arg</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3031"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a><span class='Parentheses'>))</span> 
                        <a href="clauses.c.html#LN3031"><span class='Ref_To_Local'>arg</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) ((</span><a href="../../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3031"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>arg<span class='Delimiter'>; 
</span>                    <a href="clauses.c.html#LN3050"><span class='Ref_To_Local'>relabel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN789"><span class='Ref_to_Member'>arg</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3031"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>; 
</span> 
                    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3050"><span class='Ref_To_Local'>relabel</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN169"><span class='Ref_to_EnumConst'>T_CaseExpr</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/*---------- 
                 * CASE expressions can be simplified if there are constant 
                 * condition clauses: 
                 *      FALSE (or NULL): drop the alternative 
                 *      TRUE: drop all remaining alternatives 
                 * If the first non-FALSE alternative is a constant TRUE, 
                 * we can simplify the entire CASE to that alternative's 
                 * expression.  If there are no non-FALSE alternatives, 
                 * we simplify the entire CASE to the default result (ELSE). 
                 * 
                 * If we have a simple-form CASE with constant test 
                 * expression, we substitute the constant value for contained 
                 * CaseTestExpr placeholder nodes, so that we have the 
                 * opportunity to reduce constant test conditions.  For 
                 * example this allows 
                 *      CASE 0 WHEN 0 THEN 1 ELSE 1/0 END 
                 * to reduce to 1 rather than drawing a divide-by-0 error. 
                 * Note that when the test expression is constant, we don't 
                 * have to include it in the resulting CASE; for example 
                 *      CASE 0 WHEN x THEN y ELSE z END 
                 * is transformed by the parser to 
                 *      CASE 0 WHEN CaseTestExpr = x THEN y ELSE z END 
                 * which we can simplify to 
                 *      CASE WHEN 0 = x THEN y ELSE z END 
                 * It is not necessary for the executor to evaluate the "arg" 
                 * expression when executing the CASE, since any contained 
                 * CaseTestExprs that might have referred to it will have been 
                 * replaced by the constant. 
                 *---------- 
                 */ 
</span><a name="LN3098"></a>                <a href="../../../include/nodes/primnodes.h.html#LN901"><span class='Ref_to_Struct'>CaseExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>caseexpr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN901"><span class='Ref_to_Struct'>CaseExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2446"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span><a name="LN3099"></a>                <a href="../../../include/nodes/primnodes.h.html#LN901"><span class='Ref_to_Struct'>CaseExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>newcase</span><span class='Delimiter'>; 
</span><a name="LN3100"></a>                <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>save_case_val</span><span class='Delimiter'>; 
</span><a name="LN3101"></a>                <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>newarg</span><span class='Delimiter'>; 
</span><a name="LN3102"></a>                <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>newargs</span><span class='Delimiter'>; 
</span><a name="LN3103"></a>                <span class='Keyword'>bool</span>        <span class='Declare_Local'>const_true_cond</span><span class='Delimiter'>; 
</span><a name="LN3104"></a>                <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>defresult</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN3105"></a>                <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>arg</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* Simplify the test expression, if any */ 
</span>                <a href="clauses.c.html#LN3101"><span class='Ref_To_Local'>newarg</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN115"><span class='Ref_to_Proto'>eval_const_expressions_mutator</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3098"><span class='Ref_To_Local'>caseexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN906"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>, 
</span>                                                        <a href="clauses.c.html#LN2447"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* Set up for contained CaseTestExpr nodes */ 
</span>                <a href="clauses.c.html#LN3100"><span class='Ref_To_Local'>save_case_val</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN2447"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN67"><span class='Ref_to_Member'>case_val</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN3101"><span class='Ref_To_Local'>newarg</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3101"><span class='Ref_To_Local'>newarg</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <a href="clauses.c.html#LN2447"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN67"><span class='Ref_to_Member'>case_val</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3101"><span class='Ref_To_Local'>newarg</span></a><span class='Delimiter'>; 
</span>                    <a href="clauses.c.html#LN3101"><span class='Ref_To_Local'>newarg</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* not needed anymore, see above */ 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>else</span> 
                    <a href="clauses.c.html#LN2447"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN67"><span class='Ref_to_Member'>case_val</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* Simplify the WHEN clauses */ 
</span>                <a href="clauses.c.html#LN3102"><span class='Ref_To_Local'>newargs</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN3103"><span class='Ref_To_Local'>const_true_cond</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3105"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN3098"><span class='Ref_To_Local'>caseexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN907"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN3126"></a>                    <a href="../../../include/nodes/primnodes.h.html#LN915"><span class='Ref_to_Struct'>CaseWhen</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>oldcasewhen</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN108"><span class='Ref_to_Macro'>lfirst_node</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN915"><span class='Ref_to_Struct'>CaseWhen</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN3105"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3127"></a>                    <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>casecond</span><span class='Delimiter'>; 
</span><a name="LN3128"></a>                    <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>caseresult</span><span class='Delimiter'>; 
</span> 
                    <span class='Comment_Multi_Line'>/* Simplify this alternative's test condition */ 
</span>                    <a href="clauses.c.html#LN3127"><span class='Ref_To_Local'>casecond</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN115"><span class='Ref_to_Proto'>eval_const_expressions_mutator</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3126"><span class='Ref_To_Local'>oldcasewhen</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN918"><span class='Ref_to_Member'>expr</span></a><span class='Delimiter'>, 
</span>                                                              <a href="clauses.c.html#LN2447"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * If the test condition is constant FALSE (or NULL), then 
                     * drop this WHEN clause completely, without processing 
                     * the result. 
                     */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN3127"><span class='Ref_To_Local'>casecond</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3127"><span class='Ref_To_Local'>casecond</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
                    <span class='Delimiter'>{ 
</span><a name="LN3141"></a>                        <a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>const_input</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3127"><span class='Ref_To_Local'>casecond</span></a><span class='Delimiter'>; 
</span> 
                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN3141"><span class='Ref_To_Local'>const_input</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN196"><span class='Ref_to_Member'>constisnull</span></a> <span class='Operator'>|| 
</span>                            <span class='Operator'>!</span><a href="../../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3141"><span class='Ref_To_Local'>const_input</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Parentheses'>))</span> 
                            <span class='Control'>continue</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* drop alternative with FALSE cond */ 
</span>                        <span class='Comment_Multi_Line'>/* Else it's constant TRUE */ 
</span>                        <a href="clauses.c.html#LN3103"><span class='Ref_To_Local'>const_true_cond</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span> 
                    <span class='Comment_Multi_Line'>/* Simplify this alternative's result value */ 
</span>                    <a href="clauses.c.html#LN3128"><span class='Ref_To_Local'>caseresult</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN115"><span class='Ref_to_Proto'>eval_const_expressions_mutator</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3126"><span class='Ref_To_Local'>oldcasewhen</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN919"><span class='Ref_to_Member'>result</span></a><span class='Delimiter'>, 
</span>                                                                <a href="clauses.c.html#LN2447"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <span class='Comment_Multi_Line'>/* If non-constant test condition, emit a new WHEN node */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="clauses.c.html#LN3103"><span class='Ref_To_Local'>const_true_cond</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span><a name="LN3157"></a>                        <a href="../../../include/nodes/primnodes.h.html#LN915"><span class='Ref_to_Struct'>CaseWhen</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>newcasewhen</span> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN915"><span class='Ref_to_Struct'>CaseWhen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                        <a href="clauses.c.html#LN3157"><span class='Ref_To_Local'>newcasewhen</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN918"><span class='Ref_to_Member'>expr</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3127"><span class='Ref_To_Local'>casecond</span></a><span class='Delimiter'>; 
</span>                        <a href="clauses.c.html#LN3157"><span class='Ref_To_Local'>newcasewhen</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN919"><span class='Ref_to_Member'>result</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3128"><span class='Ref_To_Local'>caseresult</span></a><span class='Delimiter'>; 
</span>                        <a href="clauses.c.html#LN3157"><span class='Ref_To_Local'>newcasewhen</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN920"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3126"><span class='Ref_To_Local'>oldcasewhen</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN920"><span class='Ref_to_Member'>location</span></a><span class='Delimiter'>; 
</span>                        <a href="clauses.c.html#LN3102"><span class='Ref_To_Local'>newargs</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3102"><span class='Ref_To_Local'>newargs</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN3157"><span class='Ref_To_Local'>newcasewhen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <span class='Control'>continue</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * Found a TRUE condition, so none of the remaining 
                     * alternatives can be reached.  We treat the result as 
                     * the default result. 
                     */ 
</span>                    <a href="clauses.c.html#LN3104"><span class='Ref_To_Local'>defresult</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3128"><span class='Ref_To_Local'>caseresult</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
                <span class='Comment_Multi_Line'>/* Simplify the default result, unless we replaced it above */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="clauses.c.html#LN3103"><span class='Ref_To_Local'>const_true_cond</span></a><span class='Parentheses'>) 
</span>                    <a href="clauses.c.html#LN3104"><span class='Ref_To_Local'>defresult</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN115"><span class='Ref_to_Proto'>eval_const_expressions_mutator</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3098"><span class='Ref_To_Local'>caseexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN908"><span class='Ref_to_Member'>defresult</span></a><span class='Delimiter'>, 
</span>                                                               <a href="clauses.c.html#LN2447"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="clauses.c.html#LN2447"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN67"><span class='Ref_to_Member'>case_val</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3100"><span class='Ref_To_Local'>save_case_val</span></a><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * If no non-FALSE alternatives, CASE reduces to the default 
                 * result 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN3102"><span class='Ref_To_Local'>newargs</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>                    <span class='Control'>return</span> <a href="clauses.c.html#LN3104"><span class='Ref_To_Local'>defresult</span></a><span class='Delimiter'>; 
</span>                <span class='Comment_Multi_Line'>/* Otherwise we need a new CASE node */ 
</span>                <a href="clauses.c.html#LN3099"><span class='Ref_To_Local'>newcase</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN901"><span class='Ref_to_Struct'>CaseExpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN3099"><span class='Ref_To_Local'>newcase</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN904"><span class='Ref_to_Member'>casetype</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3098"><span class='Ref_To_Local'>caseexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN904"><span class='Ref_to_Member'>casetype</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN3099"><span class='Ref_To_Local'>newcase</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN905"><span class='Ref_to_Member'>casecollid</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3098"><span class='Ref_To_Local'>caseexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN905"><span class='Ref_to_Member'>casecollid</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN3099"><span class='Ref_To_Local'>newcase</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN906"><span class='Ref_to_Member'>arg</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3101"><span class='Ref_To_Local'>newarg</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN3099"><span class='Ref_To_Local'>newcase</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN907"><span class='Ref_to_Member'>args</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3102"><span class='Ref_To_Local'>newargs</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN3099"><span class='Ref_To_Local'>newcase</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN908"><span class='Ref_to_Member'>defresult</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3104"><span class='Ref_To_Local'>defresult</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN3099"><span class='Ref_To_Local'>newcase</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN909"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3098"><span class='Ref_To_Local'>caseexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN909"><span class='Ref_to_Member'>location</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3099"><span class='Ref_To_Local'>newcase</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN171"><span class='Ref_to_EnumConst'>T_CaseTestExpr</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * If we know a constant test value for the current CASE 
                 * construct, substitute it for the placeholder.  Else just 
                 * return the placeholder as-is. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2447"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN67"><span class='Ref_to_Member'>case_val</span></a><span class='Parentheses'>) 
</span>                    <span class='Control'>return</span> <a href="../../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2447"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN67"><span class='Ref_to_Member'>case_val</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>else</span> 
                    <span class='Control'>return</span> <a href="../../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2446"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN172"><span class='Ref_to_EnumConst'>T_ArrayExpr</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span><a name="LN3212"></a>                <a href="../../../include/nodes/primnodes.h.html#LN947"><span class='Ref_to_Struct'>ArrayExpr</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>arrayexpr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN947"><span class='Ref_to_Struct'>ArrayExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2446"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span><a name="LN3213"></a>                <a href="../../../include/nodes/primnodes.h.html#LN947"><span class='Ref_to_Struct'>ArrayExpr</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>newarray</span><span class='Delimiter'>; 
</span><a name="LN3214"></a>                <span class='Keyword'>bool</span>        <span class='Declare_Local'>all_const</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span><a name="LN3215"></a>                <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>newelems</span><span class='Delimiter'>; 
</span><a name="LN3216"></a>                <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>element</span><span class='Delimiter'>; 
</span> 
                <a href="clauses.c.html#LN3215"><span class='Ref_To_Local'>newelems</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>                <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3216"><span class='Ref_To_Local'>element</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN3212"><span class='Ref_To_Local'>arrayexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN953"><span class='Ref_to_Member'>elements</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN3221"></a>                    <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>e</span><span class='Delimiter'>; 
</span> 
                    <a href="clauses.c.html#LN3221"><span class='Ref_To_Local'>e</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN115"><span class='Ref_to_Proto'>eval_const_expressions_mutator</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3216"><span class='Ref_To_Local'>element</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                       <a href="clauses.c.html#LN2447"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3221"><span class='Ref_To_Local'>e</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
                        <a href="clauses.c.html#LN3214"><span class='Ref_To_Local'>all_const</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                    <a href="clauses.c.html#LN3215"><span class='Ref_To_Local'>newelems</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3215"><span class='Ref_To_Local'>newelems</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN3221"><span class='Ref_To_Local'>e</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
                <a href="clauses.c.html#LN3213"><span class='Ref_To_Local'>newarray</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN947"><span class='Ref_to_Struct'>ArrayExpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN3213"><span class='Ref_To_Local'>newarray</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN950"><span class='Ref_to_Member'>array_typeid</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3212"><span class='Ref_To_Local'>arrayexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN950"><span class='Ref_to_Member'>array_typeid</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN3213"><span class='Ref_To_Local'>newarray</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN951"><span class='Ref_to_Member'>array_collid</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3212"><span class='Ref_To_Local'>arrayexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN951"><span class='Ref_to_Member'>array_collid</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN3213"><span class='Ref_To_Local'>newarray</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN952"><span class='Ref_to_Member'>element_typeid</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3212"><span class='Ref_To_Local'>arrayexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN952"><span class='Ref_to_Member'>element_typeid</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN3213"><span class='Ref_To_Local'>newarray</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN953"><span class='Ref_to_Member'>elements</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3215"><span class='Ref_To_Local'>newelems</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN3213"><span class='Ref_To_Local'>newarray</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN954"><span class='Ref_to_Member'>multidims</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3212"><span class='Ref_To_Local'>arrayexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN954"><span class='Ref_to_Member'>multidims</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN3213"><span class='Ref_To_Local'>newarray</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN955"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3212"><span class='Ref_To_Local'>arrayexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN955"><span class='Ref_to_Member'>location</span></a><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN3214"><span class='Ref_To_Local'>all_const</span></a><span class='Parentheses'>) 
</span>                    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN151"><span class='Ref_to_Proto'>evaluate_expr</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3213"><span class='Ref_To_Local'>newarray</span></a><span class='Delimiter'>, 
</span>                                                  <a href="clauses.c.html#LN3213"><span class='Ref_To_Local'>newarray</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN950"><span class='Ref_to_Member'>array_typeid</span></a><span class='Delimiter'>, 
</span>                                                  <a href="../../../include/nodes/nodeFuncs.h.html#LN32"><span class='Ref_to_Proto'>exprTypmod</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2446"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                  <a href="clauses.c.html#LN3213"><span class='Ref_To_Local'>newarray</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN951"><span class='Ref_to_Member'>array_collid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3213"><span class='Ref_To_Local'>newarray</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN175"><span class='Ref_to_EnumConst'>T_CoalesceExpr</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span><a name="LN3248"></a>                <a href="../../../include/nodes/primnodes.h.html#LN1040"><span class='Ref_to_Struct'>CoalesceExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>coalesceexpr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1040"><span class='Ref_to_Struct'>CoalesceExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2446"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span><a name="LN3249"></a>                <a href="../../../include/nodes/primnodes.h.html#LN1040"><span class='Ref_to_Struct'>CoalesceExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>newcoalesce</span><span class='Delimiter'>; 
</span><a name="LN3250"></a>                <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>newargs</span><span class='Delimiter'>; 
</span><a name="LN3251"></a>                <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>arg</span><span class='Delimiter'>; 
</span> 
                <a href="clauses.c.html#LN3250"><span class='Ref_To_Local'>newargs</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>                <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3251"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN3248"><span class='Ref_To_Local'>coalesceexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1045"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN3256"></a>                    <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>e</span><span class='Delimiter'>; 
</span> 
                    <a href="clauses.c.html#LN3256"><span class='Ref_To_Local'>e</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN115"><span class='Ref_to_Proto'>eval_const_expressions_mutator</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3251"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                       <a href="clauses.c.html#LN2447"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * We can remove null constants from the list. For a 
                     * non-null constant, if it has not been preceded by any 
                     * other non-null-constant expressions then it is the 
                     * result. Otherwise, it's the next argument, but we can 
                     * drop following arguments since they will never be 
                     * reached. 
                     */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3256"><span class='Ref_To_Local'>e</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
                    <span class='Delimiter'>{ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3256"><span class='Ref_To_Local'>e</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constisnull<span class='Parentheses'>)</span> 
                            <span class='Control'>continue</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* drop null constant */ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN3250"><span class='Ref_To_Local'>newargs</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>                            <span class='Control'>return</span> <a href="clauses.c.html#LN3256"><span class='Ref_To_Local'>e</span></a><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* first expr */ 
</span>                        <a href="clauses.c.html#LN3250"><span class='Ref_To_Local'>newargs</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3250"><span class='Ref_To_Local'>newargs</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN3256"><span class='Ref_To_Local'>e</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <span class='Control'>break</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <a href="clauses.c.html#LN3250"><span class='Ref_To_Local'>newargs</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3250"><span class='Ref_To_Local'>newargs</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN3256"><span class='Ref_To_Local'>e</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * If all the arguments were constant null, the result is just 
                 * null 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN3250"><span class='Ref_To_Local'>newargs</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>                    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/makefuncs.h.html#LN57"><span class='Ref_to_Proto'>makeNullConst</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3248"><span class='Ref_To_Local'>coalesceexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1043"><span class='Ref_to_Member'>coalescetype</span></a><span class='Delimiter'>, 
</span>                                                  <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                                               <a href="clauses.c.html#LN3248"><span class='Ref_To_Local'>coalesceexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1044"><span class='Ref_to_Member'>coalescecollid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="clauses.c.html#LN3249"><span class='Ref_To_Local'>newcoalesce</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1040"><span class='Ref_to_Struct'>CoalesceExpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN3249"><span class='Ref_To_Local'>newcoalesce</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1043"><span class='Ref_to_Member'>coalescetype</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3248"><span class='Ref_To_Local'>coalesceexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1043"><span class='Ref_to_Member'>coalescetype</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN3249"><span class='Ref_To_Local'>newcoalesce</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1044"><span class='Ref_to_Member'>coalescecollid</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3248"><span class='Ref_To_Local'>coalesceexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1044"><span class='Ref_to_Member'>coalescecollid</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN3249"><span class='Ref_To_Local'>newcoalesce</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1045"><span class='Ref_to_Member'>args</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3250"><span class='Ref_To_Local'>newargs</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN3249"><span class='Ref_To_Local'>newcoalesce</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1046"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3248"><span class='Ref_To_Local'>coalesceexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1046"><span class='Ref_to_Member'>location</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3249"><span class='Ref_To_Local'>newcoalesce</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN177"><span class='Ref_to_EnumConst'>T_SQLValueFunction</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * All variants of SQLValueFunction are stable, so if we are 
                 * estimating the expression's value, we should evaluate the 
                 * current function value.  Otherwise just copy. 
                 */ 
</span><a name="LN3304"></a>                <a href="../../../include/nodes/primnodes.h.html#LN1099"><span class='Ref_to_Struct'>SQLValueFunction</span></a> <span class='Operator'>*</span><span class='Declare_Local'>svf</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1099"><span class='Ref_to_Struct'>SQLValueFunction</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2446"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2447"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN68"><span class='Ref_to_Member'>estimate</span></a><span class='Parentheses'>) 
</span>                    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN151"><span class='Ref_to_Proto'>evaluate_expr</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3304"><span class='Ref_To_Local'>svf</span></a><span class='Delimiter'>, 
</span>                                                  <a href="clauses.c.html#LN3304"><span class='Ref_To_Local'>svf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1103"><span class='Ref_to_Member'>type</span></a><span class='Delimiter'>, 
</span>                                                  <a href="clauses.c.html#LN3304"><span class='Ref_To_Local'>svf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1104"><span class='Ref_to_Member'>typmod</span></a><span class='Delimiter'>, 
</span>                                                  <a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>else</span> 
                    <span class='Control'>return</span> <a href="../../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3304"><span class='Ref_To_Local'>svf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN162"><span class='Ref_to_EnumConst'>T_FieldSelect</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * We can optimize field selection from a whole-row Var into a 
                 * simple Var.  (This case won't be generated directly by the 
                 * parser, because ParseComplexProjection short-circuits it. 
                 * But it can arise while simplifying functions.)  Also, we 
                 * can optimize field selection from a RowExpr construct. 
                 * 
                 * However, replacing a whole-row Var in this way has a 
                 * pitfall: if we've already built the rel targetlist for the 
                 * source relation, then the whole-row Var is scheduled to be 
                 * produced by the relation scan, but the simple Var probably 
                 * isn't, which will lead to a failure in setrefs.c.  This is 
                 * not a problem when handling simple single-level queries, in 
                 * which expression simplification always happens first.  It 
                 * is a risk for lateral references from subqueries, though. 
                 * To avoid such failures, don't optimize uplevel references. 
                 * 
                 * We must also check that the declared type of the field is 
                 * still the same as when the FieldSelect was created --- this 
                 * can change if someone did ALTER COLUMN TYPE on the rowtype. 
                 */ 
</span><a name="LN3337"></a>                <a href="../../../include/nodes/primnodes.h.html#LN737"><span class='Ref_to_Struct'>FieldSelect</span></a> <span class='Operator'>*</span><span class='Declare_Local'>fselect</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN737"><span class='Ref_to_Struct'>FieldSelect</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2446"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span><a name="LN3338"></a>                <a href="../../../include/nodes/primnodes.h.html#LN737"><span class='Ref_to_Struct'>FieldSelect</span></a> <span class='Operator'>*</span><span class='Declare_Local'>newfselect</span><span class='Delimiter'>; 
</span><a name="LN3339"></a>                <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>arg</span><span class='Delimiter'>; 
</span> 
                <a href="clauses.c.html#LN3339"><span class='Ref_To_Local'>arg</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN115"><span class='Ref_to_Proto'>eval_const_expressions_mutator</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3337"><span class='Ref_To_Local'>fselect</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN740"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>, 
</span>                                                     <a href="clauses.c.html#LN2447"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN3339"><span class='Ref_To_Local'>arg</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3339"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>                    <span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3339"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>varattno <span class='Operator'>== </span><a href="../../../include/access/attnum.h.html#LN22"><span class='Ref_to_Const'>InvalidAttrNumber</span></a> <span class='Operator'>&& 
</span>                    <span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3339"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>varlevelsup <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2330"><span class='Ref_to_Func'>rowtype_field_matches</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3339"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>vartype<span class='Delimiter'>, 
</span>                                              <a href="clauses.c.html#LN3337"><span class='Ref_To_Local'>fselect</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN741"><span class='Ref_to_Member'>fieldnum</span></a><span class='Delimiter'>, 
</span>                                              <a href="clauses.c.html#LN3337"><span class='Ref_To_Local'>fselect</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN742"><span class='Ref_to_Member'>resulttype</span></a><span class='Delimiter'>, 
</span>                                              <a href="clauses.c.html#LN3337"><span class='Ref_To_Local'>fselect</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN744"><span class='Ref_to_Member'>resulttypmod</span></a><span class='Delimiter'>, 
</span>                                              <a href="clauses.c.html#LN3337"><span class='Ref_To_Local'>fselect</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN745"><span class='Ref_to_Member'>resultcollid</span></a><span class='Parentheses'>))</span> 
                        <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/makefuncs.h.html#LN25"><span class='Ref_to_Proto'>makeVar</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3339"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>varno<span class='Delimiter'>, 
</span>                                                <a href="clauses.c.html#LN3337"><span class='Ref_To_Local'>fselect</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN741"><span class='Ref_to_Member'>fieldnum</span></a><span class='Delimiter'>, 
</span>                                                <a href="clauses.c.html#LN3337"><span class='Ref_To_Local'>fselect</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN742"><span class='Ref_to_Member'>resulttype</span></a><span class='Delimiter'>, 
</span>                                                <a href="clauses.c.html#LN3337"><span class='Ref_To_Local'>fselect</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN744"><span class='Ref_to_Member'>resulttypmod</span></a><span class='Delimiter'>, 
</span>                                                <a href="clauses.c.html#LN3337"><span class='Ref_To_Local'>fselect</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN745"><span class='Ref_to_Member'>resultcollid</span></a><span class='Delimiter'>, 
</span>                                                <span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3339"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>varlevelsup<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN3339"><span class='Ref_To_Local'>arg</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3339"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN981"><span class='Ref_to_Struct'>RowExpr</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span><a name="LN3361"></a>                    <a href="../../../include/nodes/primnodes.h.html#LN981"><span class='Ref_to_Struct'>RowExpr</span></a>    <span class='Operator'>*</span><span class='Declare_Local'>rowexpr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN981"><span class='Ref_to_Struct'>RowExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3339"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>; 
</span> 
                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN3337"><span class='Ref_To_Local'>fselect</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN741"><span class='Ref_to_Member'>fieldnum</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span> <span class='Operator'>&& 
</span>                        <a href="clauses.c.html#LN3337"><span class='Ref_To_Local'>fselect</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN741"><span class='Ref_to_Member'>fieldnum</span></a> <span class='Operator'>&LT;= </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3361"><span class='Ref_To_Local'>rowexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN984"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>))</span> 
                    <span class='Delimiter'>{ 
</span><a name="LN3366"></a>                        <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>fld</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN223"><span class='Ref_to_Proto'>list_nth</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3361"><span class='Ref_To_Local'>rowexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN984"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>, 
</span>                                                      <a href="clauses.c.html#LN3337"><span class='Ref_To_Local'>fselect</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN741"><span class='Ref_to_Member'>fieldnum</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2330"><span class='Ref_to_Func'>rowtype_field_matches</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3361"><span class='Ref_To_Local'>rowexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN985"><span class='Ref_to_Member'>row_typeid</span></a><span class='Delimiter'>, 
</span>                                                  <a href="clauses.c.html#LN3337"><span class='Ref_To_Local'>fselect</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN741"><span class='Ref_to_Member'>fieldnum</span></a><span class='Delimiter'>, 
</span>                                                  <a href="clauses.c.html#LN3337"><span class='Ref_To_Local'>fselect</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN742"><span class='Ref_to_Member'>resulttype</span></a><span class='Delimiter'>, 
</span>                                                  <a href="clauses.c.html#LN3337"><span class='Ref_To_Local'>fselect</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN744"><span class='Ref_to_Member'>resulttypmod</span></a><span class='Delimiter'>, 
</span>                                                  <a href="clauses.c.html#LN3337"><span class='Ref_To_Local'>fselect</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN745"><span class='Ref_to_Member'>resultcollid</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                            <a href="clauses.c.html#LN3337"><span class='Ref_To_Local'>fselect</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN742"><span class='Ref_to_Member'>resulttype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3366"><span class='Ref_To_Local'>fld</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                            <a href="clauses.c.html#LN3337"><span class='Ref_To_Local'>fselect</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN744"><span class='Ref_to_Member'>resulttypmod</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodeFuncs.h.html#LN32"><span class='Ref_to_Proto'>exprTypmod</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3366"><span class='Ref_To_Local'>fld</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                            <a href="clauses.c.html#LN3337"><span class='Ref_To_Local'>fselect</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN745"><span class='Ref_to_Member'>resultcollid</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodeFuncs.h.html#LN38"><span class='Ref_to_Proto'>exprCollation</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3366"><span class='Ref_To_Local'>fld</span></a><span class='Parentheses'>))</span> 
                            <span class='Control'>return</span> <a href="clauses.c.html#LN3366"><span class='Ref_To_Local'>fld</span></a><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if arg&&IsA(arg,RowExpr) &raquo; </span> 
                <a href="clauses.c.html#LN3338"><span class='Ref_To_Local'>newfselect</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN737"><span class='Ref_to_Struct'>FieldSelect</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN3338"><span class='Ref_To_Local'>newfselect</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN740"><span class='Ref_to_Member'>arg</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3339"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN3338"><span class='Ref_To_Local'>newfselect</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN741"><span class='Ref_to_Member'>fieldnum</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3337"><span class='Ref_To_Local'>fselect</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN741"><span class='Ref_to_Member'>fieldnum</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN3338"><span class='Ref_To_Local'>newfselect</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN742"><span class='Ref_to_Member'>resulttype</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3337"><span class='Ref_To_Local'>fselect</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN742"><span class='Ref_to_Member'>resulttype</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN3338"><span class='Ref_To_Local'>newfselect</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN744"><span class='Ref_to_Member'>resulttypmod</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3337"><span class='Ref_To_Local'>fselect</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN744"><span class='Ref_to_Member'>resulttypmod</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN3338"><span class='Ref_To_Local'>newfselect</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN745"><span class='Ref_to_Member'>resultcollid</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3337"><span class='Ref_To_Local'>fselect</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN745"><span class='Ref_to_Member'>resultcollid</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3338"><span class='Ref_To_Local'>newfselect</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN179"><span class='Ref_to_EnumConst'>T_NullTest</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span><a name="LN3390"></a>                <a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>ntest</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2446"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span><a name="LN3391"></a>                <a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>newntest</span><span class='Delimiter'>; 
</span><a name="LN3392"></a>                <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>arg</span><span class='Delimiter'>; 
</span> 
                <a href="clauses.c.html#LN3392"><span class='Ref_To_Local'>arg</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN115"><span class='Ref_to_Proto'>eval_const_expressions_mutator</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3390"><span class='Ref_To_Local'>ntest</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1178"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>, 
</span>                                                     <a href="clauses.c.html#LN2447"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN3390"><span class='Ref_To_Local'>ntest</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1180"><span class='Ref_to_Member'>argisrow</span></a> <span class='Operator'>&& </span><a href="clauses.c.html#LN3392"><span class='Ref_To_Local'>arg</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3392"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN981"><span class='Ref_to_Struct'>RowExpr</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* 
                     * We break ROW(...) IS [NOT] NULL into separate tests on 
                     * its component fields.  This form is usually more 
                     * efficient to evaluate, as well as being more amenable 
                     * to optimization. 
                     */ 
</span><a name="LN3404"></a>                    <a href="../../../include/nodes/primnodes.h.html#LN981"><span class='Ref_to_Struct'>RowExpr</span></a>    <span class='Operator'>*</span><span class='Declare_Local'>rarg</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN981"><span class='Ref_to_Struct'>RowExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3392"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>; 
</span><a name="LN3405"></a>                    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>newargs</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN3406"></a>                    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
                    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3406"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN3404"><span class='Ref_To_Local'>rarg</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN984"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span><a name="LN3410"></a>                        <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>relem</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3406"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                        <span class='Comment_Multi_Line'>/* 
                         * A constant field refutes the whole NullTest if it's 
                         * of the wrong nullness; else we can discard it. 
                         */ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN3410"><span class='Ref_To_Local'>relem</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3410"><span class='Ref_To_Local'>relem</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
                        <span class='Delimiter'>{ 
</span><a name="LN3418"></a>                            <a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>carg</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3410"><span class='Ref_To_Local'>relem</span></a><span class='Delimiter'>; 
</span> 
                            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN3418"><span class='Ref_To_Local'>carg</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN196"><span class='Ref_to_Member'>constisnull</span></a> <span class='Operator'>? 
</span>                                <span class='Parentheses'>(</span><a href="clauses.c.html#LN3390"><span class='Ref_To_Local'>ntest</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1179"><span class='Ref_to_Member'>nulltesttype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/primnodes.h.html#LN1172"><span class='Ref_to_EnumConst'>IS_NOT_NULL</span></a><span class='Parentheses'>) </span><span class='Operator'>: 
</span>                                <span class='Parentheses'>(</span><a href="clauses.c.html#LN3390"><span class='Ref_To_Local'>ntest</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1179"><span class='Ref_to_Member'>nulltesttype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/primnodes.h.html#LN1172"><span class='Ref_to_EnumConst'>IS_NULL</span></a><span class='Parentheses'>))</span> 
                                <span class='Control'>return</span> <a href="../../../include/nodes/makefuncs.h.html#LN59"><span class='Ref_to_Proto'>makeBoolConst</span></a><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span> 
                        <span class='Comment_Multi_Line'>/* 
                         * Else, make a scalar (argisrow == false) NullTest 
                         * for this field.  Scalar semantics are required 
                         * because IS [NOT] NULL doesn't recurse; see comments 
                         * in ExecEvalRowNullInt(). 
                         */ 
</span>                        <a href="clauses.c.html#LN3391"><span class='Ref_To_Local'>newntest</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <a href="clauses.c.html#LN3391"><span class='Ref_To_Local'>newntest</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1178"><span class='Ref_to_Member'>arg</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3410"><span class='Ref_To_Local'>relem</span></a><span class='Delimiter'>; 
</span>                        <a href="clauses.c.html#LN3391"><span class='Ref_To_Local'>newntest</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1179"><span class='Ref_to_Member'>nulltesttype</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3390"><span class='Ref_To_Local'>ntest</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1179"><span class='Ref_to_Member'>nulltesttype</span></a><span class='Delimiter'>; 
</span>                        <a href="clauses.c.html#LN3391"><span class='Ref_To_Local'>newntest</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1180"><span class='Ref_to_Member'>argisrow</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                        <a href="clauses.c.html#LN3391"><span class='Ref_To_Local'>newntest</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1181"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3390"><span class='Ref_To_Local'>ntest</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1181"><span class='Ref_to_Member'>location</span></a><span class='Delimiter'>; 
</span>                        <a href="clauses.c.html#LN3405"><span class='Ref_To_Local'>newargs</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3405"><span class='Ref_To_Local'>newargs</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN3391"><span class='Ref_To_Local'>newntest</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <span class='Comment_Multi_Line'>/* If all the inputs were constants, result is TRUE */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN3405"><span class='Ref_To_Local'>newargs</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>                        <span class='Control'>return</span> <a href="../../../include/nodes/makefuncs.h.html#LN59"><span class='Ref_to_Proto'>makeBoolConst</span></a><span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Comment_Multi_Line'>/* If only one nonconst input, it's the result */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3405"><span class='Ref_To_Local'>newargs</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
                        <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3405"><span class='Ref_To_Local'>newargs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Comment_Multi_Line'>/* Else we need an AND node */ 
</span>                    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/clauses.h.html#LN43"><span class='Ref_to_Proto'>make_andclause</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3405"><span class='Ref_To_Local'>newargs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if ntest-&GT;argisrow&&arg&... &raquo; </span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="clauses.c.html#LN3390"><span class='Ref_To_Local'>ntest</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1180"><span class='Ref_to_Member'>argisrow</span></a> <span class='Operator'>&& </span><a href="clauses.c.html#LN3392"><span class='Ref_To_Local'>arg</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3392"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span><a name="LN3451"></a>                    <a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>carg</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3392"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>; 
</span><a name="LN3452"></a>                    <span class='Keyword'>bool</span>        <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span> 
                    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN3390"><span class='Ref_To_Local'>ntest</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1179"><span class='Ref_to_Member'>nulltesttype</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN1172"><span class='Ref_to_EnumConst'>IS_NULL</span></a><span class='Operator'>: 
</span>                            <a href="clauses.c.html#LN3452"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3451"><span class='Ref_To_Local'>carg</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN196"><span class='Ref_to_Member'>constisnull</span></a><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN1172"><span class='Ref_to_EnumConst'>IS_NOT_NULL</span></a><span class='Operator'>: 
</span>                            <a href="clauses.c.html#LN3452"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= !</span><a href="clauses.c.html#LN3451"><span class='Ref_To_Local'>carg</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN196"><span class='Ref_to_Member'>constisnull</span></a><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Control'>default</span><span class='Operator'>: 
</span>                            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized nulltesttype: %d"</span><span class='Delimiter'>, 
</span>                                 <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3390"><span class='Ref_To_Local'>ntest</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1179"><span class='Ref_to_Member'>nulltesttype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                            <a href="clauses.c.html#LN3452"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span> 
                    <span class='Control'>return</span> <a href="../../../include/nodes/makefuncs.h.html#LN59"><span class='Ref_to_Proto'>makeBoolConst</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3452"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !ntest-&GT;argisrow&&arg... &raquo; </span> 
 
                <a href="clauses.c.html#LN3391"><span class='Ref_To_Local'>newntest</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN3391"><span class='Ref_To_Local'>newntest</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1178"><span class='Ref_to_Member'>arg</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3392"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN3391"><span class='Ref_To_Local'>newntest</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1179"><span class='Ref_to_Member'>nulltesttype</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3390"><span class='Ref_To_Local'>ntest</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1179"><span class='Ref_to_Member'>nulltesttype</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN3391"><span class='Ref_To_Local'>newntest</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1180"><span class='Ref_to_Member'>argisrow</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3390"><span class='Ref_To_Local'>ntest</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1180"><span class='Ref_to_Member'>argisrow</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN3391"><span class='Ref_To_Local'>newntest</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1181"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3390"><span class='Ref_To_Local'>ntest</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1181"><span class='Ref_to_Member'>location</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3391"><span class='Ref_To_Local'>newntest</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN180"><span class='Ref_to_EnumConst'>T_BooleanTest</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span><a name="LN3481"></a>                <a href="../../../include/nodes/primnodes.h.html#LN1198"><span class='Ref_to_Struct'>BooleanTest</span></a> <span class='Operator'>*</span><span class='Declare_Local'>btest</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1198"><span class='Ref_to_Struct'>BooleanTest</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2446"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span><a name="LN3482"></a>                <a href="../../../include/nodes/primnodes.h.html#LN1198"><span class='Ref_to_Struct'>BooleanTest</span></a> <span class='Operator'>*</span><span class='Declare_Local'>newbtest</span><span class='Delimiter'>; 
</span><a name="LN3483"></a>                <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>arg</span><span class='Delimiter'>; 
</span> 
                <a href="clauses.c.html#LN3483"><span class='Ref_To_Local'>arg</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN115"><span class='Ref_to_Proto'>eval_const_expressions_mutator</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3481"><span class='Ref_To_Local'>btest</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1201"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>, 
</span>                                                     <a href="clauses.c.html#LN2447"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN3483"><span class='Ref_To_Local'>arg</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3483"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span><a name="LN3489"></a>                    <a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>carg</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3483"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>; 
</span><a name="LN3490"></a>                    <span class='Keyword'>bool</span>        <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span> 
                    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN3481"><span class='Ref_To_Local'>btest</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1202"><span class='Ref_to_Member'>booltesttype</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN1195"><span class='Ref_to_EnumConst'>IS_TRUE</span></a><span class='Operator'>: 
</span>                            <a href="clauses.c.html#LN3490"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="clauses.c.html#LN3489"><span class='Ref_To_Local'>carg</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN196"><span class='Ref_to_Member'>constisnull</span></a> <span class='Operator'>&& 
</span>                                      <a href="../../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3489"><span class='Ref_To_Local'>carg</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN1195"><span class='Ref_to_EnumConst'>IS_NOT_TRUE</span></a><span class='Operator'>: 
</span>                            <a href="clauses.c.html#LN3490"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="clauses.c.html#LN3489"><span class='Ref_To_Local'>carg</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN196"><span class='Ref_to_Member'>constisnull</span></a> <span class='Operator'>|| 
</span>                                      <span class='Operator'>!</span><a href="../../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3489"><span class='Ref_To_Local'>carg</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN1195"><span class='Ref_to_EnumConst'>IS_FALSE</span></a><span class='Operator'>: 
</span>                            <a href="clauses.c.html#LN3490"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="clauses.c.html#LN3489"><span class='Ref_To_Local'>carg</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN196"><span class='Ref_to_Member'>constisnull</span></a> <span class='Operator'>&& 
</span>                                      <span class='Operator'>!</span><a href="../../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3489"><span class='Ref_To_Local'>carg</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN1195"><span class='Ref_to_EnumConst'>IS_NOT_FALSE</span></a><span class='Operator'>: 
</span>                            <a href="clauses.c.html#LN3490"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="clauses.c.html#LN3489"><span class='Ref_To_Local'>carg</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN196"><span class='Ref_to_Member'>constisnull</span></a> <span class='Operator'>|| 
</span>                                      <a href="../../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3489"><span class='Ref_To_Local'>carg</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN1195"><span class='Ref_to_EnumConst'>IS_UNKNOWN</span></a><span class='Operator'>: 
</span>                            <a href="clauses.c.html#LN3490"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3489"><span class='Ref_To_Local'>carg</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN196"><span class='Ref_to_Member'>constisnull</span></a><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN1195"><span class='Ref_to_EnumConst'>IS_NOT_UNKNOWN</span></a><span class='Operator'>: 
</span>                            <a href="clauses.c.html#LN3490"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= !</span><a href="clauses.c.html#LN3489"><span class='Ref_To_Local'>carg</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN196"><span class='Ref_to_Member'>constisnull</span></a><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Control'>default</span><span class='Operator'>: 
</span>                            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized booltesttype: %d"</span><span class='Delimiter'>, 
</span>                                 <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3481"><span class='Ref_To_Local'>btest</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1202"><span class='Ref_to_Member'>booltesttype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                            <a href="clauses.c.html#LN3490"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch btest-&GT;booltesttype &raquo; </span> 
 
                    <span class='Control'>return</span> <a href="../../../include/nodes/makefuncs.h.html#LN59"><span class='Ref_to_Proto'>makeBoolConst</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3490"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if arg&&IsA(arg,Const) &raquo; </span> 
 
                <a href="clauses.c.html#LN3482"><span class='Ref_To_Local'>newbtest</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1198"><span class='Ref_to_Struct'>BooleanTest</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN3482"><span class='Ref_To_Local'>newbtest</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1201"><span class='Ref_to_Member'>arg</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3483"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN3482"><span class='Ref_To_Local'>newbtest</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1202"><span class='Ref_to_Member'>booltesttype</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3481"><span class='Ref_To_Local'>btest</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1202"><span class='Ref_to_Member'>booltesttype</span></a><span class='Delimiter'>; 
</span>                <a href="clauses.c.html#LN3482"><span class='Ref_To_Local'>newbtest</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1203"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3481"><span class='Ref_To_Local'>btest</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1203"><span class='Ref_to_Member'>location</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3482"><span class='Ref_To_Local'>newbtest</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN259"><span class='Ref_to_EnumConst'>T_PlaceHolderVar</span></a><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * In estimation mode, just strip the PlaceHolderVar node 
             * altogether; this amounts to estimating that the contained value 
             * won't be forced to null by an outer join.  In regular mode we 
             * just use the default behavior (ie, simplify the expression but 
             * leave the PlaceHolderVar node intact). 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN2447"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN68"><span class='Ref_to_Member'>estimate</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN3543"></a>                <a href="../../../include/nodes/relation.h.html#LN1846"><span class='Ref_to_Struct'>PlaceHolderVar</span></a> <span class='Operator'>*</span><span class='Declare_Local'>phv</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1846"><span class='Ref_to_Struct'>PlaceHolderVar</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2446"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
                <span class='Control'>return</span> <a href="clauses.c.html#LN115"><span class='Ref_to_Proto'>eval_const_expressions_mutator</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3543"><span class='Ref_To_Local'>phv</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1849"><span class='Ref_to_Member'>phexpr</span></a><span class='Delimiter'>, 
</span>                                                      <a href="clauses.c.html#LN2447"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>default</span><span class='Operator'>: 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch nodeTag(node) &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * For any node type not handled above, we recurse using 
     * expression_tree_mutator, which will copy the node unchanged but try to 
     * simplify its arguments (if any) using this routine. For example: we 
     * cannot eliminate an ArrayRef node, but we might be able to simplify 
     * constant expressions in its subscripts. 
     */ 
</span>    <span class='Control'>return</span> <a href="../../../include/nodes/nodeFuncs.h.html#LN54"><span class='Ref_to_Proto'>expression_tree_mutator</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN2446"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN115"><span class='Ref_to_Proto'>eval_const_expressions_mutator</span></a><span class='Delimiter'>, 
</span>                                   <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN2447"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end eval_const_expressions_mutator &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Subroutine for eval_const_expressions: process arguments of an OR clause 
 * 
 * This includes flattening of nested ORs as well as recursion to 
 * eval_const_expressions to simplify the OR arguments. 
 * 
 * After simplification, OR arguments are handled as follows: 
 *      non constant: keep 
 *      FALSE: drop (does not affect result) 
 *      TRUE: force result to TRUE 
 *      NULL: keep only one 
 * We must keep one NULL input because OR expressions evaluate to NULL when no 
 * input is TRUE and at least one is NULL.  We don't actually include the NULL 
 * here, that's supposed to be done by the caller. 
 * 
 * The output arguments *haveNull and *forceTrue must be initialized FALSE 
 * by the caller.  They will be set TRUE if a null constant or true constant, 
 * respectively, is detected anywhere in the argument list. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN3584"></a><span class='Declare_Function'>simplify_or_arguments</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>args</span><span class='Delimiter'>, 
</span><a name="LN3585"></a>                      <a href="clauses.c.html#LN62"><span class='Ref_to_Typedef'>eval_const_expressions_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Delimiter'>, 
</span><a name="LN3586"></a>                      <span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>haveNull</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>forceTrue</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3588"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>newargs</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN3589"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>unprocessed_args</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We want to ensure that any OR immediately beneath another OR gets 
     * flattened into a single OR-list, so as to simplify later reasoning. 
     * 
     * To avoid stack overflow from recursion of eval_const_expressions, we 
     * resort to some tenseness here: we keep a list of not-yet-processed 
     * inputs, and handle flattening of nested ORs by prepending to the to-do 
     * list instead of recursing.  Now that the parser generates N-argument 
     * ORs from simple lists, this complexity is probably less necessary than 
     * it once was, but we might as well keep the logic. 
     */ 
</span>    <a href="clauses.c.html#LN3589"><span class='Ref_To_Local'>unprocessed_args</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN268"><span class='Ref_to_Proto'>list_copy</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3584"><span class='Ref_to_Parameter'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN3589"><span class='Ref_To_Local'>unprocessed_args</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3605"></a>        <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>arg</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3589"><span class='Ref_To_Local'>unprocessed_args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="clauses.c.html#LN3589"><span class='Ref_To_Local'>unprocessed_args</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN237"><span class='Ref_to_Proto'>list_delete_first</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3589"><span class='Ref_To_Local'>unprocessed_args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* flatten nested ORs as per above comment */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/clauses.h.html#LN39"><span class='Ref_to_Proto'>or_clause</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3605"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN3612"></a>            <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>subargs</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN268"><span class='Ref_to_Proto'>list_copy</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3605"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>args<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* overly tense code to avoid leaking unused list header */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="clauses.c.html#LN3589"><span class='Ref_To_Local'>unprocessed_args</span></a><span class='Parentheses'>) 
</span>                <a href="clauses.c.html#LN3589"><span class='Ref_To_Local'>unprocessed_args</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3612"><span class='Ref_To_Local'>subargs</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span><a name="LN3619"></a>                <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>oldhdr</span> <span class='Operator'>= </span><a href="clauses.c.html#LN3589"><span class='Ref_To_Local'>unprocessed_args</span></a><span class='Delimiter'>; 
</span> 
                <a href="clauses.c.html#LN3589"><span class='Ref_To_Local'>unprocessed_args</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3612"><span class='Ref_To_Local'>subargs</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN3589"><span class='Ref_To_Local'>unprocessed_args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3619"><span class='Ref_To_Local'>oldhdr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* If it's not an OR, simplify it */ 
</span>        <a href="clauses.c.html#LN3605"><span class='Ref_To_Local'>arg</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN115"><span class='Ref_to_Proto'>eval_const_expressions_mutator</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3605"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN3585"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * It is unlikely but not impossible for simplification of a non-OR 
         * clause to produce an OR.  Recheck, but don't be too tense about it 
         * since it's not a mainstream case. In particular we don't worry 
         * about const-simplifying the input twice. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/clauses.h.html#LN39"><span class='Ref_to_Proto'>or_clause</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3605"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN3638"></a>            <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>subargs</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN268"><span class='Ref_to_Proto'>list_copy</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3605"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>args<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="clauses.c.html#LN3589"><span class='Ref_To_Local'>unprocessed_args</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3638"><span class='Ref_To_Local'>subargs</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN3589"><span class='Ref_To_Local'>unprocessed_args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * OK, we have a const-simplified non-OR argument.  Process it per 
         * comments above. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3605"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN3650"></a>            <a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>const_input</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3605"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN3650"><span class='Ref_To_Local'>const_input</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN196"><span class='Ref_to_Member'>constisnull</span></a><span class='Parentheses'>) 
</span>                <span class='Operator'>*</span><a href="clauses.c.html#LN3586"><span class='Ref_to_Parameter'>haveNull</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3650"><span class='Ref_To_Local'>const_input</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Operator'>*</span><a href="clauses.c.html#LN3586"><span class='Ref_to_Parameter'>forceTrue</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Once we detect a TRUE result we can just exit the loop 
                 * immediately.  However, if we ever add a notion of 
                 * non-removable functions, we'd need to keep scanning. 
                 */ 
</span>                <span class='Control'>return</span> <a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Comment_Multi_Line'>/* otherwise, we can drop the constant-false input */ 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IsA(arg,Const) &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* else emit the simplified arg into the result list */ 
</span>        <a href="clauses.c.html#LN3588"><span class='Ref_To_Local'>newargs</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3588"><span class='Ref_To_Local'>newargs</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN3605"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while unprocessed_args &raquo; </span> 
 
    <span class='Control'>return</span> <a href="clauses.c.html#LN3588"><span class='Ref_To_Local'>newargs</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end simplify_or_arguments &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Subroutine for eval_const_expressions: process arguments of an AND clause 
 * 
 * This includes flattening of nested ANDs as well as recursion to 
 * eval_const_expressions to simplify the AND arguments. 
 * 
 * After simplification, AND arguments are handled as follows: 
 *      non constant: keep 
 *      TRUE: drop (does not affect result) 
 *      FALSE: force result to FALSE 
 *      NULL: keep only one 
 * We must keep one NULL input because AND expressions evaluate to NULL when 
 * no input is FALSE and at least one is NULL.  We don't actually include the 
 * NULL here, that's supposed to be done by the caller. 
 * 
 * The output arguments *haveNull and *forceFalse must be initialized FALSE 
 * by the caller.  They will be set TRUE if a null constant or false constant, 
 * respectively, is detected anywhere in the argument list. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN3696"></a><span class='Declare_Function'>simplify_and_arguments</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>args</span><span class='Delimiter'>, 
</span><a name="LN3697"></a>                       <a href="clauses.c.html#LN62"><span class='Ref_to_Typedef'>eval_const_expressions_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Delimiter'>, 
</span><a name="LN3698"></a>                       <span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>haveNull</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>forceFalse</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3700"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>newargs</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN3701"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>unprocessed_args</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* See comments in simplify_or_arguments */ 
</span>    <a href="clauses.c.html#LN3701"><span class='Ref_To_Local'>unprocessed_args</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN268"><span class='Ref_to_Proto'>list_copy</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3696"><span class='Ref_to_Parameter'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN3701"><span class='Ref_To_Local'>unprocessed_args</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3707"></a>        <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>arg</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3701"><span class='Ref_To_Local'>unprocessed_args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="clauses.c.html#LN3701"><span class='Ref_To_Local'>unprocessed_args</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN237"><span class='Ref_to_Proto'>list_delete_first</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3701"><span class='Ref_To_Local'>unprocessed_args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* flatten nested ANDs as per above comment */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/clauses.h.html#LN42"><span class='Ref_to_Proto'>and_clause</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3707"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN3714"></a>            <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>subargs</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN268"><span class='Ref_to_Proto'>list_copy</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3707"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>args<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* overly tense code to avoid leaking unused list header */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="clauses.c.html#LN3701"><span class='Ref_To_Local'>unprocessed_args</span></a><span class='Parentheses'>) 
</span>                <a href="clauses.c.html#LN3701"><span class='Ref_To_Local'>unprocessed_args</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3714"><span class='Ref_To_Local'>subargs</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span><a name="LN3721"></a>                <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>oldhdr</span> <span class='Operator'>= </span><a href="clauses.c.html#LN3701"><span class='Ref_To_Local'>unprocessed_args</span></a><span class='Delimiter'>; 
</span> 
                <a href="clauses.c.html#LN3701"><span class='Ref_To_Local'>unprocessed_args</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3714"><span class='Ref_To_Local'>subargs</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN3701"><span class='Ref_To_Local'>unprocessed_args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3721"><span class='Ref_To_Local'>oldhdr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* If it's not an AND, simplify it */ 
</span>        <a href="clauses.c.html#LN3707"><span class='Ref_To_Local'>arg</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN115"><span class='Ref_to_Proto'>eval_const_expressions_mutator</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3707"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN3697"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * It is unlikely but not impossible for simplification of a non-AND 
         * clause to produce an AND.  Recheck, but don't be too tense about it 
         * since it's not a mainstream case. In particular we don't worry 
         * about const-simplifying the input twice. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/clauses.h.html#LN42"><span class='Ref_to_Proto'>and_clause</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3707"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN3740"></a>            <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>subargs</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN268"><span class='Ref_to_Proto'>list_copy</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3707"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>args<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="clauses.c.html#LN3701"><span class='Ref_To_Local'>unprocessed_args</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3740"><span class='Ref_To_Local'>subargs</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN3701"><span class='Ref_To_Local'>unprocessed_args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * OK, we have a const-simplified non-AND argument.  Process it per 
         * comments above. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3707"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN3752"></a>            <a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>const_input</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3707"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN3752"><span class='Ref_To_Local'>const_input</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN196"><span class='Ref_to_Member'>constisnull</span></a><span class='Parentheses'>) 
</span>                <span class='Operator'>*</span><a href="clauses.c.html#LN3698"><span class='Ref_to_Parameter'>haveNull</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3752"><span class='Ref_To_Local'>const_input</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Operator'>*</span><a href="clauses.c.html#LN3698"><span class='Ref_to_Parameter'>forceFalse</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Once we detect a FALSE result we can just exit the loop 
                 * immediately.  However, if we ever add a notion of 
                 * non-removable functions, we'd need to keep scanning. 
                 */ 
</span>                <span class='Control'>return</span> <a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Comment_Multi_Line'>/* otherwise, we can drop the constant-true input */ 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IsA(arg,Const) &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* else emit the simplified arg into the result list */ 
</span>        <a href="clauses.c.html#LN3700"><span class='Ref_To_Local'>newargs</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3700"><span class='Ref_To_Local'>newargs</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN3707"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while unprocessed_args &raquo; </span> 
 
    <span class='Control'>return</span> <a href="clauses.c.html#LN3700"><span class='Ref_To_Local'>newargs</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end simplify_and_arguments &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Subroutine for eval_const_expressions: try to simplify boolean equality 
 * or inequality condition 
 * 
 * Inputs are the operator OID and the simplified arguments to the operator. 
 * Returns a simplified expression if successful, or NULL if cannot 
 * simplify the expression. 
 * 
 * The idea here is to reduce "x = true" to "x" and "x = false" to "NOT x", 
 * or similarly "x &LT;&GT; true" to "NOT x" and "x &LT;&GT; false" to "x". 
 * This is only marginally useful in itself, but doing it in constant folding 
 * ensures that we will recognize these forms as being equivalent in, for 
 * example, partial index matching. 
 * 
 * We come here only if simplify_function has failed; therefore we cannot 
 * see two constant inputs, nor a constant-NULL input. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN3796"></a><span class='Declare_Function'>simplify_boolean_equality</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>opno</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>args</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3798"></a>    <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>leftop</span><span class='Delimiter'>; 
</span><a name="LN3799"></a>    <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>rightop</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3796"><span class='Ref_to_Parameter'>args</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN3798"><span class='Ref_To_Local'>leftop</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3796"><span class='Ref_to_Parameter'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN3799"><span class='Ref_To_Local'>rightop</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN115"><span class='Ref_to_Macro'>lsecond</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3796"><span class='Ref_to_Parameter'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN3798"><span class='Ref_To_Local'>leftop</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3798"><span class='Ref_To_Local'>leftop</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3798"><span class='Ref_To_Local'>leftop</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constisnull<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN3796"><span class='Ref_to_Parameter'>opno</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_operator.h.html#LN113"><span class='Ref_to_Const'>BooleanEqualOperator</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3798"><span class='Ref_To_Local'>leftop</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constvalue<span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <a href="clauses.c.html#LN3799"><span class='Ref_To_Local'>rightop</span></a><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* true = foo */ 
</span>            <span class='Control'>else</span> 
                <span class='Control'>return</span> <a href="../../../include/optimizer/prep.h.html#LN34"><span class='Ref_to_Proto'>negate_clause</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3799"><span class='Ref_To_Local'>rightop</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* false = foo */ 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3798"><span class='Ref_To_Local'>leftop</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constvalue<span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <a href="../../../include/optimizer/prep.h.html#LN34"><span class='Ref_to_Proto'>negate_clause</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3799"><span class='Ref_To_Local'>rightop</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* true &LT;&GT; foo */ 
</span>            <span class='Control'>else</span> 
                <span class='Control'>return</span> <a href="clauses.c.html#LN3799"><span class='Ref_To_Local'>rightop</span></a><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* false &LT;&GT; foo */ 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN3799"><span class='Ref_To_Local'>rightop</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3799"><span class='Ref_To_Local'>rightop</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3799"><span class='Ref_To_Local'>rightop</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constisnull<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN3796"><span class='Ref_to_Parameter'>opno</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_operator.h.html#LN113"><span class='Ref_to_Const'>BooleanEqualOperator</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3799"><span class='Ref_To_Local'>rightop</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constvalue<span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <a href="clauses.c.html#LN3798"><span class='Ref_To_Local'>leftop</span></a><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* foo = true */ 
</span>            <span class='Control'>else</span> 
                <span class='Control'>return</span> <a href="../../../include/optimizer/prep.h.html#LN34"><span class='Ref_to_Proto'>negate_clause</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3798"><span class='Ref_To_Local'>leftop</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* foo = false */ 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3799"><span class='Ref_To_Local'>rightop</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constvalue<span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <a href="../../../include/optimizer/prep.h.html#LN34"><span class='Ref_to_Proto'>negate_clause</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3798"><span class='Ref_To_Local'>leftop</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* foo &LT;&GT; true */ 
</span>            <span class='Control'>else</span> 
                <span class='Control'>return</span> <a href="clauses.c.html#LN3798"><span class='Ref_To_Local'>leftop</span></a><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* foo &LT;&GT; false */ 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end simplify_boolean_equality &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Subroutine for eval_const_expressions: try to simplify a function call 
 * (which might originally have been an operator; we don't care) 
 * 
 * Inputs are the function OID, actual result type OID (which is needed for 
 * polymorphic functions), result typmod, result collation, the input 
 * collation to use for the function, the original argument list (not 
 * const-simplified yet, unless process_args is false), and some flags; 
 * also the context data for eval_const_expressions. 
 * 
 * Returns a simplified expression if successful, or NULL if cannot 
 * simplify the function call. 
 * 
 * This function is also responsible for converting named-notation argument 
 * lists into positional notation and/or adding any needed default argument 
 * expressions; which is a bit grotty, but it avoids extra fetches of the 
 * function's pg_proc tuple.  For this reason, the args list is 
 * pass-by-reference.  Conversion and const-simplification of the args list 
 * will be done even if simplification of the function call itself is not 
 * possible. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>* 
</span><a name="LN3865"></a><span class='Declare_Function'>simplify_function</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>funcid</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>result_type</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a> <span class='Declare_Parameter'>result_typmod</span><span class='Delimiter'>, 
</span><a name="LN3866"></a>                  <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>result_collid</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>input_collid</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>args_p</span><span class='Delimiter'>, 
</span><a name="LN3867"></a>                  <span class='Keyword'>bool </span><span class='Declare_Parameter'>funcvariadic</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>process_args</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>allow_non_const</span><span class='Delimiter'>, 
</span><a name="LN3868"></a>                  <a href="clauses.c.html#LN62"><span class='Ref_to_Typedef'>eval_const_expressions_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3870"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>args</span> <span class='Operator'>= *</span><a href="clauses.c.html#LN3866"><span class='Ref_to_Parameter'>args_p</span></a><span class='Delimiter'>; 
</span><a name="LN3871"></a>    <a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>func_tuple</span><span class='Delimiter'>; 
</span><a name="LN3872"></a>    <a href="../../../include/catalog/pg_proc.h.html#LN82"><span class='Ref_to_Typedef'>Form_pg_proc</span></a> <span class='Declare_Local'>func_form</span><span class='Delimiter'>; 
</span><a name="LN3873"></a>    <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>newexpr</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We have three strategies for simplification: execute the function to 
     * deliver a constant result, use a transform function to generate a 
     * substitute node tree, or expand in-line the body of the function 
     * definition (which only works for simple SQL-language functions, but 
     * that is a common case).  Each case needs access to the function's 
     * pg_proc tuple, so fetch it just once. 
     * 
     * Note: the allow_non_const flag suppresses both the second and third 
     * strategies; so if !allow_non_const, simplify_function can only return a 
     * Const or NULL.  Argument-list rewriting happens anyway, though. 
     */ 
</span>    <a href="clauses.c.html#LN3871"><span class='Ref_To_Local'>func_tuple</span></a> <span class='Operator'>= </span><a href="../../../include/utils/syscache.h.html#LN155"><span class='Ref_to_Macro'>SearchSysCache1</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/syscache.h.html#LN76"><span class='Ref_to_EnumConst'>PROCOID</span></a><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3865"><span class='Ref_to_Parameter'>funcid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3871"><span class='Ref_To_Local'>func_tuple</span></a><span class='Parentheses'>))</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for function %u"</span><span class='Delimiter'>, </span><a href="clauses.c.html#LN3865"><span class='Ref_to_Parameter'>funcid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN3872"><span class='Ref_To_Local'>func_form</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_proc.h.html#LN82"><span class='Ref_to_Typedef'>Form_pg_proc</span></a><span class='Parentheses'>) </span><a href="../../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3871"><span class='Ref_To_Local'>func_tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Process the function arguments, unless the caller did it already. 
     * 
     * Here we must deal with named or defaulted arguments, and then 
     * recursively apply eval_const_expressions to the whole argument list. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN3867"><span class='Ref_to_Parameter'>process_args</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="clauses.c.html#LN3870"><span class='Ref_To_Local'>args</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN129"><span class='Ref_to_Proto'>expand_function_arguments</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3870"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN3865"><span class='Ref_to_Parameter'>result_type</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN3871"><span class='Ref_To_Local'>func_tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="clauses.c.html#LN3870"><span class='Ref_To_Local'>args</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/nodeFuncs.h.html#LN54"><span class='Ref_to_Proto'>expression_tree_mutator</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3870"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>, 
</span>                                              <a href="clauses.c.html#LN115"><span class='Ref_to_Proto'>eval_const_expressions_mutator</span></a><span class='Delimiter'>, 
</span>                                                <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN3868"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Argument processing done, give it back to the caller */ 
</span>        <span class='Operator'>*</span><a href="clauses.c.html#LN3866"><span class='Ref_to_Parameter'>args_p</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3870"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Now attempt simplification of the function call proper. */ 
</span> 
    <a href="clauses.c.html#LN3873"><span class='Ref_To_Local'>newexpr</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN136"><span class='Ref_to_Proto'>evaluate_function</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3865"><span class='Ref_to_Parameter'>funcid</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN3865"><span class='Ref_to_Parameter'>result_type</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN3865"><span class='Ref_to_Parameter'>result_typmod</span></a><span class='Delimiter'>, 
</span>                                <a href="clauses.c.html#LN3866"><span class='Ref_to_Parameter'>result_collid</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN3866"><span class='Ref_to_Parameter'>input_collid</span></a><span class='Delimiter'>, 
</span>                                <a href="clauses.c.html#LN3870"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN3867"><span class='Ref_to_Parameter'>funcvariadic</span></a><span class='Delimiter'>, 
</span>                                <a href="clauses.c.html#LN3871"><span class='Ref_To_Local'>func_tuple</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN3868"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="clauses.c.html#LN3873"><span class='Ref_To_Local'>newexpr</span></a> <span class='Operator'>&& </span><a href="clauses.c.html#LN3867"><span class='Ref_to_Parameter'>allow_non_const</span></a> <span class='Operator'>&& </span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3872"><span class='Ref_To_Local'>func_form</span></a><span class='Operator'>-&GT;</span>protransform<span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Build a dummy FuncExpr node containing the simplified arg list.  We 
         * use this approach to present a uniform interface to the transform 
         * function regardless of how the function is actually being invoked. 
         */ 
</span><a name="LN3922"></a>        <a href="../../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a>    <span class='Declare_Local'>fexpr</span><span class='Delimiter'>; 
</span> 
        <a href="clauses.c.html#LN3922"><span class='Ref_To_Local'>fexpr</span></a><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN446"><span class='Ref_to_Member'>xpr</span></a><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN133"><span class='Ref_to_Member'>type</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN152"><span class='Ref_to_EnumConst'>T_FuncExpr</span></a><span class='Delimiter'>; 
</span>        <a href="clauses.c.html#LN3922"><span class='Ref_To_Local'>fexpr</span></a><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN447"><span class='Ref_to_Member'>funcid</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3865"><span class='Ref_to_Parameter'>funcid</span></a><span class='Delimiter'>; 
</span>        <a href="clauses.c.html#LN3922"><span class='Ref_To_Local'>fexpr</span></a><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN448"><span class='Ref_to_Member'>funcresulttype</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3865"><span class='Ref_to_Parameter'>result_type</span></a><span class='Delimiter'>; 
</span>        <a href="clauses.c.html#LN3922"><span class='Ref_To_Local'>fexpr</span></a><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN449"><span class='Ref_to_Member'>funcretset</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3872"><span class='Ref_To_Local'>func_form</span></a><span class='Operator'>-&GT;</span>proretset<span class='Delimiter'>; 
</span>        <a href="clauses.c.html#LN3922"><span class='Ref_To_Local'>fexpr</span></a><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN450"><span class='Ref_to_Member'>funcvariadic</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3867"><span class='Ref_to_Parameter'>funcvariadic</span></a><span class='Delimiter'>; 
</span>        <a href="clauses.c.html#LN3922"><span class='Ref_To_Local'>fexpr</span></a><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN452"><span class='Ref_to_Member'>funcformat</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/primnodes.h.html#LN436"><span class='Ref_to_EnumConst'>COERCE_EXPLICIT_CALL</span></a><span class='Delimiter'>; 
</span>        <a href="clauses.c.html#LN3922"><span class='Ref_To_Local'>fexpr</span></a><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN453"><span class='Ref_to_Member'>funccollid</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3866"><span class='Ref_to_Parameter'>result_collid</span></a><span class='Delimiter'>; 
</span>        <a href="clauses.c.html#LN3922"><span class='Ref_To_Local'>fexpr</span></a><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN454"><span class='Ref_to_Member'>inputcollid</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3866"><span class='Ref_to_Parameter'>input_collid</span></a><span class='Delimiter'>; 
</span>        <a href="clauses.c.html#LN3922"><span class='Ref_To_Local'>fexpr</span></a><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN455"><span class='Ref_to_Member'>args</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN3870"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>; 
</span>        <a href="clauses.c.html#LN3922"><span class='Ref_To_Local'>fexpr</span></a><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN456"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
        <a href="clauses.c.html#LN3873"><span class='Ref_To_Local'>newexpr</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN621"><span class='Ref_to_Macro'>OidFunctionCall1</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3872"><span class='Ref_To_Local'>func_form</span></a><span class='Operator'>-&GT;</span>protransform<span class='Delimiter'>, 
</span>                                             <a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="clauses.c.html#LN3922"><span class='Ref_To_Local'>fexpr</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !newexpr&&allow_non_c... &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="clauses.c.html#LN3873"><span class='Ref_To_Local'>newexpr</span></a> <span class='Operator'>&& </span><a href="clauses.c.html#LN3867"><span class='Ref_to_Parameter'>allow_non_const</span></a><span class='Parentheses'>) 
</span>        <a href="clauses.c.html#LN3873"><span class='Ref_To_Local'>newexpr</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN141"><span class='Ref_to_Proto'>inline_function</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3865"><span class='Ref_to_Parameter'>funcid</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN3865"><span class='Ref_to_Parameter'>result_type</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN3866"><span class='Ref_to_Parameter'>result_collid</span></a><span class='Delimiter'>, 
</span>                                  <a href="clauses.c.html#LN3866"><span class='Ref_to_Parameter'>input_collid</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN3870"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN3867"><span class='Ref_to_Parameter'>funcvariadic</span></a><span class='Delimiter'>, 
</span>                                  <a href="clauses.c.html#LN3871"><span class='Ref_To_Local'>func_tuple</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN3868"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3871"><span class='Ref_To_Local'>func_tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="clauses.c.html#LN3873"><span class='Ref_To_Local'>newexpr</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end simplify_function &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * expand_function_arguments: convert named-notation args to positional args 
 * and/or insert default args, as needed 
 * 
 * If we need to change anything, the input argument list is copied, not 
 * modified. 
 * 
 * Note: this gets applied to operator argument lists too, even though the 
 * cases it handles should never occur there.  This should be OK since it 
 * will fall through very quickly if there's nothing to do. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN3962"></a><span class='Declare_Function'>expand_function_arguments</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>args</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>result_type</span><span class='Delimiter'>, </span><a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> <span class='Declare_Parameter'>func_tuple</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3964"></a>    <a href="../../../include/catalog/pg_proc.h.html#LN82"><span class='Ref_to_Typedef'>Form_pg_proc</span></a> <span class='Declare_Local'>funcform</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_proc.h.html#LN82"><span class='Ref_to_Typedef'>Form_pg_proc</span></a><span class='Parentheses'>) </span><a href="../../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3962"><span class='Ref_to_Parameter'>func_tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3965"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>has_named_args</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN3966"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Do we have any named arguments? */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3966"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN3962"><span class='Ref_to_Parameter'>args</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3971"></a>        <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>arg</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3966"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3971"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN473"><span class='Ref_to_Struct'>NamedArgExpr</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="clauses.c.html#LN3965"><span class='Ref_To_Local'>has_named_args</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* If so, we must apply reorder_function_arguments */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN3965"><span class='Ref_To_Local'>has_named_args</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="clauses.c.html#LN3962"><span class='Ref_to_Parameter'>args</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN131"><span class='Ref_to_Proto'>reorder_function_arguments</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3962"><span class='Ref_to_Parameter'>args</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN3962"><span class='Ref_to_Parameter'>func_tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Recheck argument types and add casts if needed */ 
</span>        <a href="clauses.c.html#LN134"><span class='Ref_to_Proto'>recheck_cast_function_args</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3962"><span class='Ref_to_Parameter'>args</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN3962"><span class='Ref_to_Parameter'>result_type</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN3962"><span class='Ref_to_Parameter'>func_tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3962"><span class='Ref_to_Parameter'>args</span></a><span class='Parentheses'>) </span><span class='Operator'>&LT; </span><a href="clauses.c.html#LN3964"><span class='Ref_To_Local'>funcform</span></a><span class='Operator'>-&GT;</span>pronargs<span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* No named args, but we seem to be short some defaults */ 
</span>        <a href="clauses.c.html#LN3962"><span class='Ref_to_Parameter'>args</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN132"><span class='Ref_to_Proto'>add_function_defaults</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3962"><span class='Ref_to_Parameter'>args</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN3962"><span class='Ref_to_Parameter'>func_tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Recheck argument types and add casts if needed */ 
</span>        <a href="clauses.c.html#LN134"><span class='Ref_to_Proto'>recheck_cast_function_args</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN3962"><span class='Ref_to_Parameter'>args</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN3962"><span class='Ref_to_Parameter'>result_type</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN3962"><span class='Ref_to_Parameter'>func_tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="clauses.c.html#LN3962"><span class='Ref_to_Parameter'>args</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end expand_function_arguments &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * reorder_function_arguments: convert named-notation args to positional args 
 * 
 * This function also inserts default argument values as needed, since it's 
 * impossible to form a truly valid positional call without that. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN4005"></a><span class='Declare_Function'>reorder_function_arguments</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>args</span><span class='Delimiter'>, </span><a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> <span class='Declare_Parameter'>func_tuple</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4007"></a>    <a href="../../../include/catalog/pg_proc.h.html#LN82"><span class='Ref_to_Typedef'>Form_pg_proc</span></a> <span class='Declare_Local'>funcform</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_proc.h.html#LN82"><span class='Ref_to_Typedef'>Form_pg_proc</span></a><span class='Parentheses'>) </span><a href="../../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4005"><span class='Ref_to_Parameter'>func_tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN4008"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>pronargs</span> <span class='Operator'>= </span><a href="clauses.c.html#LN4007"><span class='Ref_To_Local'>funcform</span></a><span class='Operator'>-&GT;</span>pronargs<span class='Delimiter'>; 
</span><a name="LN4009"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>nargsprovided</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4005"><span class='Ref_to_Parameter'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN4010"></a>    <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>argarray</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN36"><span class='Ref_to_Const'>FUNC_MAX_ARGS</span></a><span class='Delimiter'>]; 
</span><a name="LN4011"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span><a name="LN4012"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="clauses.c.html#LN4009"><span class='Ref_To_Local'>nargsprovided</span></a> <span class='Operator'>&LT;= </span><a href="clauses.c.html#LN4008"><span class='Ref_To_Local'>pronargs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN4008"><span class='Ref_To_Local'>pronargs</span></a> <span class='Operator'>&GT; </span><a href="../../../include/pg_config_manual.h.html#LN36"><span class='Ref_to_Const'>FUNC_MAX_ARGS</span></a><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"too many function arguments"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4010"><span class='Ref_To_Local'>argarray</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><a href="clauses.c.html#LN4008"><span class='Ref_To_Local'>pronargs</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Deconstruct the argument list into an array indexed by argnumber */ 
</span>    <a href="clauses.c.html#LN4012"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4011"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN4005"><span class='Ref_to_Parameter'>args</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN4023"></a>        <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>arg</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4011"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4023"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN473"><span class='Ref_to_Struct'>NamedArgExpr</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* positional argument, assumed to precede all named args */ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="clauses.c.html#LN4010"><span class='Ref_To_Local'>argarray</span></a><span class='Delimiter'>[</span><a href="clauses.c.html#LN4012"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="clauses.c.html#LN4010"><span class='Ref_To_Local'>argarray</span></a><span class='Delimiter'>[</span><a href="clauses.c.html#LN4012"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="clauses.c.html#LN4023"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span><a name="LN4033"></a>            <a href="../../../include/nodes/primnodes.h.html#LN473"><span class='Ref_to_Struct'>NamedArgExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>na</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN473"><span class='Ref_to_Struct'>NamedArgExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN4023"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>; 
</span> 
            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="clauses.c.html#LN4010"><span class='Ref_To_Local'>argarray</span></a><span class='Delimiter'>[</span><a href="clauses.c.html#LN4033"><span class='Ref_To_Local'>na</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN478"><span class='Ref_to_Member'>argnumber</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="clauses.c.html#LN4010"><span class='Ref_To_Local'>argarray</span></a><span class='Delimiter'>[</span><a href="clauses.c.html#LN4033"><span class='Ref_To_Local'>na</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN478"><span class='Ref_to_Member'>argnumber</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN4033"><span class='Ref_To_Local'>na</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN476"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Fetch default expressions, if needed, and insert into array at proper 
     * locations (they aren't necessarily consecutive or all used) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN4009"><span class='Ref_To_Local'>nargsprovided</span></a> <span class='Operator'>&LT; </span><a href="clauses.c.html#LN4008"><span class='Ref_To_Local'>pronargs</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN4046"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>defaults</span> <span class='Operator'>= </span><a href="clauses.c.html#LN133"><span class='Ref_to_Proto'>fetch_function_defaults</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4005"><span class='Ref_to_Parameter'>func_tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="clauses.c.html#LN4012"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN4008"><span class='Ref_To_Local'>pronargs</span></a> <span class='Operator'>- </span><a href="clauses.c.html#LN4007"><span class='Ref_To_Local'>funcform</span></a><span class='Operator'>-&GT;</span>pronargdefaults<span class='Delimiter'>; 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4011"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN4046"><span class='Ref_To_Local'>defaults</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN4010"><span class='Ref_To_Local'>argarray</span></a><span class='Delimiter'>[</span><a href="clauses.c.html#LN4012"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>                <a href="clauses.c.html#LN4010"><span class='Ref_To_Local'>argarray</span></a><span class='Delimiter'>[</span><a href="clauses.c.html#LN4012"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4011"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="clauses.c.html#LN4012"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Now reconstruct the args list in proper order */ 
</span>    <a href="clauses.c.html#LN4005"><span class='Ref_to_Parameter'>args</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN4012"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="clauses.c.html#LN4012"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="clauses.c.html#LN4008"><span class='Ref_To_Local'>pronargs</span></a><span class='Delimiter'>; </span><a href="clauses.c.html#LN4012"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="clauses.c.html#LN4010"><span class='Ref_To_Local'>argarray</span></a><span class='Delimiter'>[</span><a href="clauses.c.html#LN4012"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="clauses.c.html#LN4005"><span class='Ref_to_Parameter'>args</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4005"><span class='Ref_to_Parameter'>args</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN4010"><span class='Ref_To_Local'>argarray</span></a><span class='Delimiter'>[</span><a href="clauses.c.html#LN4012"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="clauses.c.html#LN4005"><span class='Ref_to_Parameter'>args</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end reorder_function_arguments &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * add_function_defaults: add missing function arguments from its defaults 
 * 
 * This is used only when the argument list was positional to begin with, 
 * and so we know we just need to add defaults at the end. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN4075"></a><span class='Declare_Function'>add_function_defaults</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>args</span><span class='Delimiter'>, </span><a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> <span class='Declare_Parameter'>func_tuple</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4077"></a>    <a href="../../../include/catalog/pg_proc.h.html#LN82"><span class='Ref_to_Typedef'>Form_pg_proc</span></a> <span class='Declare_Local'>funcform</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_proc.h.html#LN82"><span class='Ref_to_Typedef'>Form_pg_proc</span></a><span class='Parentheses'>) </span><a href="../../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4075"><span class='Ref_to_Parameter'>func_tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN4078"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>nargsprovided</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4075"><span class='Ref_to_Parameter'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN4079"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>defaults</span><span class='Delimiter'>; 
</span><a name="LN4080"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>ndelete</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Get all the default expressions from the pg_proc tuple */ 
</span>    <a href="clauses.c.html#LN4079"><span class='Ref_To_Local'>defaults</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN133"><span class='Ref_to_Proto'>fetch_function_defaults</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4075"><span class='Ref_to_Parameter'>func_tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Delete any unused defaults from the list */ 
</span>    <a href="clauses.c.html#LN4080"><span class='Ref_To_Local'>ndelete</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN4078"><span class='Ref_To_Local'>nargsprovided</span></a> <span class='Operator'>+ </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4079"><span class='Ref_To_Local'>defaults</span></a><span class='Parentheses'>) </span><span class='Operator'>- </span><a href="clauses.c.html#LN4077"><span class='Ref_To_Local'>funcform</span></a><span class='Operator'>-&GT;</span>pronargs<span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN4080"><span class='Ref_To_Local'>ndelete</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"not enough default arguments"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN4080"><span class='Ref_To_Local'>ndelete</span></a><span class='Operator'>-- &GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="clauses.c.html#LN4079"><span class='Ref_To_Local'>defaults</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN237"><span class='Ref_to_Proto'>list_delete_first</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4079"><span class='Ref_To_Local'>defaults</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* And form the combined argument list, not modifying the input list */ 
</span>    <span class='Control'>return</span> <a href="../../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN268"><span class='Ref_to_Proto'>list_copy</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4075"><span class='Ref_to_Parameter'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="clauses.c.html#LN4079"><span class='Ref_To_Local'>defaults</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end add_function_defaults &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * fetch_function_defaults: get function's default arguments as expression list 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN4100"></a><span class='Declare_Function'>fetch_function_defaults</span><span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> <span class='Declare_Parameter'>func_tuple</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4102"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>defaults</span><span class='Delimiter'>; 
</span><a name="LN4103"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>proargdefaults</span><span class='Delimiter'>; 
</span><a name="LN4104"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isnull</span><span class='Delimiter'>; 
</span><a name="LN4105"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>str</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* The error cases here shouldn't happen, but check anyway */ 
</span>    <a href="clauses.c.html#LN4103"><span class='Ref_To_Local'>proargdefaults</span></a> <span class='Operator'>= </span><a href="../../../include/utils/syscache.h.html#LN133"><span class='Ref_to_Proto'>SysCacheGetAttr</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/syscache.h.html#LN76"><span class='Ref_to_EnumConst'>PROCOID</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN4100"><span class='Ref_to_Parameter'>func_tuple</span></a><span class='Delimiter'>, 
</span>                                     <a href="../../../include/catalog/pg_proc.h.html#LN112"><span class='Ref_to_Const'>Anum_pg_proc_proargdefaults</span></a><span class='Delimiter'>, 
</span>                                     <span class='Operator'>&</span><a href="clauses.c.html#LN4104"><span class='Ref_To_Local'>isnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN4104"><span class='Ref_To_Local'>isnull</span></a><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"not enough default arguments"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4105"><span class='Ref_To_Local'>str</span></a> <span class='Operator'>= </span><a href="../../../include/utils/builtins.h.html#LN91"><span class='Ref_to_Macro'>TextDatumGetCString</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4103"><span class='Ref_To_Local'>proargdefaults</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4102"><span class='Ref_To_Local'>defaults</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN575"><span class='Ref_to_Macro'>castNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a><span class='Delimiter'>, </span><a href="../../nodes/read.c.html#LN36"><span class='Ref_to_Func'>stringToNode</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4105"><span class='Ref_To_Local'>str</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4105"><span class='Ref_To_Local'>str</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="clauses.c.html#LN4102"><span class='Ref_To_Local'>defaults</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * recheck_cast_function_args: recheck function args and typecast as needed 
 * after adding defaults. 
 * 
 * It is possible for some of the defaulted arguments to be polymorphic; 
 * therefore we can't assume that the default expressions have the correct 
 * data types already.  We have to re-resolve polymorphics and do coercion 
 * just like the parser did. 
 * 
 * This should be a no-op if there are no polymorphic arguments, 
 * but we do it anyway to be sure. 
 * 
 * Note: if any casts are needed, the args list is modified in-place; 
 * caller should have already copied the list structure. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN4135"></a><span class='Declare_Function'>recheck_cast_function_args</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>args</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>result_type</span><span class='Delimiter'>, </span><a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> <span class='Declare_Parameter'>func_tuple</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4137"></a>    <a href="../../../include/catalog/pg_proc.h.html#LN82"><span class='Ref_to_Typedef'>Form_pg_proc</span></a> <span class='Declare_Local'>funcform</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_proc.h.html#LN82"><span class='Ref_to_Typedef'>Form_pg_proc</span></a><span class='Parentheses'>) </span><a href="../../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4135"><span class='Ref_to_Parameter'>func_tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN4138"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>nargs</span><span class='Delimiter'>; 
</span><a name="LN4139"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>actual_arg_types</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN36"><span class='Ref_to_Const'>FUNC_MAX_ARGS</span></a><span class='Delimiter'>]; 
</span><a name="LN4140"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>declared_arg_types</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN36"><span class='Ref_to_Const'>FUNC_MAX_ARGS</span></a><span class='Delimiter'>]; 
</span><a name="LN4141"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>rettype</span><span class='Delimiter'>; 
</span><a name="LN4142"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4135"><span class='Ref_to_Parameter'>args</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT; </span><a href="../../../include/pg_config_manual.h.html#LN36"><span class='Ref_to_Const'>FUNC_MAX_ARGS</span></a><span class='Parentheses'>)</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"too many function arguments"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4138"><span class='Ref_To_Local'>nargs</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4142"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN4135"><span class='Ref_to_Parameter'>args</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="clauses.c.html#LN4139"><span class='Ref_To_Local'>actual_arg_types</span></a><span class='Delimiter'>[</span><a href="clauses.c.html#LN4138"><span class='Ref_To_Local'>nargs</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4142"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="clauses.c.html#LN4138"><span class='Ref_To_Local'>nargs</span></a> <span class='Operator'>== </span><a href="clauses.c.html#LN4137"><span class='Ref_To_Local'>funcform</span></a><span class='Operator'>-&GT;</span>pronargs<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    memcpy<span class='Parentheses'>(</span><a href="clauses.c.html#LN4140"><span class='Ref_To_Local'>declared_arg_types</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN4137"><span class='Ref_To_Local'>funcform</span></a><span class='Operator'>-&GT;</span>proargtypes<span class='Operator'>.</span>values<span class='Delimiter'>, 
</span>           <a href="clauses.c.html#LN4137"><span class='Ref_To_Local'>funcform</span></a><span class='Operator'>-&GT;</span>pronargs <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4141"><span class='Ref_To_Local'>rettype</span></a> <span class='Operator'>= </span><a href="../../../include/parser/parse_coerce.h.html#LN77"><span class='Ref_to_Proto'>enforce_generic_type_consistency</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4139"><span class='Ref_To_Local'>actual_arg_types</span></a><span class='Delimiter'>, 
</span>                                               <a href="clauses.c.html#LN4140"><span class='Ref_To_Local'>declared_arg_types</span></a><span class='Delimiter'>, 
</span>                                               <a href="clauses.c.html#LN4138"><span class='Ref_To_Local'>nargs</span></a><span class='Delimiter'>, 
</span>                                               <a href="clauses.c.html#LN4137"><span class='Ref_To_Local'>funcform</span></a><span class='Operator'>-&GT;</span>prorettype<span class='Delimiter'>, 
</span>                                               <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* let's just check we got the same answer as the parser did ... */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN4141"><span class='Ref_To_Local'>rettype</span></a> <span class='Operator'>!= </span><a href="clauses.c.html#LN4135"><span class='Ref_to_Parameter'>result_type</span></a><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"function's resolved result type changed during planning"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* perform any necessary typecasting of arguments */ 
</span>    <a href="../../../include/parser/parse_func.h.html#LN52"><span class='Ref_to_Proto'>make_fn_arguments</span></a><span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><a href="clauses.c.html#LN4135"><span class='Ref_to_Parameter'>args</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN4139"><span class='Ref_To_Local'>actual_arg_types</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN4140"><span class='Ref_To_Local'>declared_arg_types</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end recheck_cast_function_args &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * evaluate_function: try to pre-evaluate a function call 
 * 
 * We can do this if the function is strict and has any constant-null inputs 
 * (just return a null constant), or if the function is immutable and has all 
 * constant inputs (call it and return the result as a Const node).  In 
 * estimation mode we are willing to pre-evaluate stable functions too. 
 * 
 * Returns a simplified expression if successful, or NULL if cannot 
 * simplify the function. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>* 
</span><a name="LN4179"></a><span class='Declare_Function'>evaluate_function</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>funcid</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>result_type</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a> <span class='Declare_Parameter'>result_typmod</span><span class='Delimiter'>, 
</span><a name="LN4180"></a>                  <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>result_collid</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>input_collid</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>args</span><span class='Delimiter'>, 
</span><a name="LN4181"></a>                  <span class='Keyword'>bool </span><span class='Declare_Parameter'>funcvariadic</span><span class='Delimiter'>, 
</span><a name="LN4182"></a>                  <a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> <span class='Declare_Parameter'>func_tuple</span><span class='Delimiter'>, 
</span><a name="LN4183"></a>                  <a href="clauses.c.html#LN62"><span class='Ref_to_Typedef'>eval_const_expressions_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4185"></a>    <a href="../../../include/catalog/pg_proc.h.html#LN82"><span class='Ref_to_Typedef'>Form_pg_proc</span></a> <span class='Declare_Local'>funcform</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_proc.h.html#LN82"><span class='Ref_to_Typedef'>Form_pg_proc</span></a><span class='Parentheses'>) </span><a href="../../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4182"><span class='Ref_to_Parameter'>func_tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN4186"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>has_nonconst_input</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN4187"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>has_null_input</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN4188"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>arg</span><span class='Delimiter'>; 
</span><a name="LN4189"></a>    <a href="../../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>newexpr</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Can't simplify if it returns a set. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN4185"><span class='Ref_To_Local'>funcform</span></a><span class='Operator'>-&GT;</span>proretset<span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Can't simplify if it returns RECORD.  The immediate problem is that it 
     * will be needing an expected tupdesc which we can't supply here. 
     * 
     * In the case where it has OUT parameters, it could get by without an 
     * expected tupdesc, but we still have issues: get_expr_result_type() 
     * doesn't know how to extract type info from a RECORD constant, and in 
     * the case of a NULL function result there doesn't seem to be any clean 
     * way to fix that.  In view of the likelihood of there being still other 
     * gotchas, seems best to leave the function call unreduced. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN4185"><span class='Ref_To_Local'>funcform</span></a><span class='Operator'>-&GT;</span>prorettype <span class='Operator'>== </span><a href="../../../include/catalog/pg_type.h.html#LN679"><span class='Ref_to_Const'>RECORDOID</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Check for constant inputs and especially constant-NULL inputs. 
     */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4188"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN4180"><span class='Ref_to_Parameter'>args</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4188"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
            <a href="clauses.c.html#LN4187"><span class='Ref_To_Local'>has_null_input</span></a> <span class='Operator'>|= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4188"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>constisnull<span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="clauses.c.html#LN4186"><span class='Ref_To_Local'>has_nonconst_input</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the function is strict and has a constant-NULL input, it will never 
     * be called at all, so we can replace the call by a NULL constant, even 
     * if there are other inputs that aren't constant, and even if the 
     * function is not otherwise immutable. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN4185"><span class='Ref_To_Local'>funcform</span></a><span class='Operator'>-&GT;</span>proisstrict <span class='Operator'>&& </span><a href="clauses.c.html#LN4187"><span class='Ref_To_Local'>has_null_input</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/makefuncs.h.html#LN57"><span class='Ref_to_Proto'>makeNullConst</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4179"><span class='Ref_to_Parameter'>result_type</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN4179"><span class='Ref_to_Parameter'>result_typmod</span></a><span class='Delimiter'>, 
</span>                                      <a href="clauses.c.html#LN4180"><span class='Ref_to_Parameter'>result_collid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Otherwise, can simplify only if all inputs are constants. (For a 
     * non-strict function, constant NULL inputs are treated the same as 
     * constant non-NULL inputs.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN4186"><span class='Ref_To_Local'>has_nonconst_input</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Ordinarily we are only allowed to simplify immutable functions. But for 
     * purposes of estimation, we consider it okay to simplify functions that 
     * are merely stable; the risk that the result might change from planning 
     * time to execution time is worth taking in preference to not being able 
     * to estimate the value at all. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN4185"><span class='Ref_To_Local'>funcform</span></a><span class='Operator'>-&GT;</span>provolatile <span class='Operator'>== </span><a href="../../../include/catalog/pg_proc.h.html#LN5482"><span class='Ref_to_Const'>PROVOLATILE_IMMUTABLE</span></a><span class='Parentheses'>) 
</span>         <span class='Comment_Multi_Line'>/* okay */ </span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN4183"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN68"><span class='Ref_to_Member'>estimate</span></a> <span class='Operator'>&& </span><a href="clauses.c.html#LN4185"><span class='Ref_To_Local'>funcform</span></a><span class='Operator'>-&GT;</span>provolatile <span class='Operator'>== </span><a href="../../../include/catalog/pg_proc.h.html#LN5483"><span class='Ref_to_Const'>PROVOLATILE_STABLE</span></a><span class='Parentheses'>) 
</span>         <span class='Comment_Multi_Line'>/* okay */ </span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * OK, looks like we can simplify this operator/function. 
     * 
     * Build a new FuncExpr node containing the already-simplified arguments. 
     */ 
</span>    <a href="clauses.c.html#LN4189"><span class='Ref_To_Local'>newexpr</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4189"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN447"><span class='Ref_to_Member'>funcid</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN4179"><span class='Ref_to_Parameter'>funcid</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4189"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN448"><span class='Ref_to_Member'>funcresulttype</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN4179"><span class='Ref_to_Parameter'>result_type</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4189"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN449"><span class='Ref_to_Member'>funcretset</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4189"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN450"><span class='Ref_to_Member'>funcvariadic</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN4181"><span class='Ref_to_Parameter'>funcvariadic</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4189"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN452"><span class='Ref_to_Member'>funcformat</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/primnodes.h.html#LN436"><span class='Ref_to_EnumConst'>COERCE_EXPLICIT_CALL</span></a><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* doesn't matter */ 
</span>    <a href="clauses.c.html#LN4189"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN453"><span class='Ref_to_Member'>funccollid</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN4180"><span class='Ref_to_Parameter'>result_collid</span></a><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* doesn't matter */ 
</span>    <a href="clauses.c.html#LN4189"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN454"><span class='Ref_to_Member'>inputcollid</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN4180"><span class='Ref_to_Parameter'>input_collid</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4189"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN455"><span class='Ref_to_Member'>args</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN4180"><span class='Ref_to_Parameter'>args</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4189"><span class='Ref_To_Local'>newexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN456"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="clauses.c.html#LN151"><span class='Ref_to_Proto'>evaluate_expr</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN4189"><span class='Ref_To_Local'>newexpr</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN4179"><span class='Ref_to_Parameter'>result_type</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN4179"><span class='Ref_to_Parameter'>result_typmod</span></a><span class='Delimiter'>, 
</span>                         <a href="clauses.c.html#LN4180"><span class='Ref_to_Parameter'>result_collid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end evaluate_function &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * inline_function: try to expand a function call inline 
 * 
 * If the function is a sufficiently simple SQL-language function 
 * (just "SELECT expression"), then we can inline it and avoid the rather 
 * high per-call overhead of SQL functions.  Furthermore, this can expose 
 * opportunities for constant-folding within the function expression. 
 * 
 * We have to beware of some special cases however.  A directly or 
 * indirectly recursive function would cause us to recurse forever, 
 * so we keep track of which functions we are already expanding and 
 * do not re-expand them.  Also, if a parameter is used more than once 
 * in the SQL-function body, we require it not to contain any volatile 
 * functions (volatiles might deliver inconsistent answers) nor to be 
 * unreasonably expensive to evaluate.  The expensiveness check not only 
 * prevents us from doing multiple evaluations of an expensive parameter 
 * at runtime, but is a safety value to limit growth of an expression due 
 * to repeated inlining. 
 * 
 * We must also beware of changing the volatility or strictness status of 
 * functions by inlining them. 
 * 
 * Also, at the moment we can't inline functions returning RECORD.  This 
 * doesn't work in the general case because it discards information such 
 * as OUT-parameter declarations. 
 * 
 * Also, context-dependent expression nodes in the argument list are trouble. 
 * 
 * Returns a simplified expression if successful, or NULL if cannot 
 * simplify the function. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>* 
</span><a name="LN4306"></a><span class='Declare_Function'>inline_function</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>funcid</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>result_type</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>result_collid</span><span class='Delimiter'>, 
</span><a name="LN4307"></a>                <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>input_collid</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>args</span><span class='Delimiter'>, 
</span><a name="LN4308"></a>                <span class='Keyword'>bool </span><span class='Declare_Parameter'>funcvariadic</span><span class='Delimiter'>, 
</span><a name="LN4309"></a>                <a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> <span class='Declare_Parameter'>func_tuple</span><span class='Delimiter'>, 
</span><a name="LN4310"></a>                <a href="clauses.c.html#LN62"><span class='Ref_to_Typedef'>eval_const_expressions_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4312"></a>    <a href="../../../include/catalog/pg_proc.h.html#LN82"><span class='Ref_to_Typedef'>Form_pg_proc</span></a> <span class='Declare_Local'>funcform</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_proc.h.html#LN82"><span class='Ref_to_Typedef'>Form_pg_proc</span></a><span class='Parentheses'>) </span><a href="../../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4309"><span class='Ref_to_Parameter'>func_tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN4313"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>src</span><span class='Delimiter'>; 
</span><a name="LN4314"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>tmp</span><span class='Delimiter'>; 
</span><a name="LN4315"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isNull</span><span class='Delimiter'>; 
</span><a name="LN4316"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>modifyTargetList</span><span class='Delimiter'>; 
</span><a name="LN4317"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcxt</span><span class='Delimiter'>; 
</span><a name="LN4318"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>mycxt</span><span class='Delimiter'>; 
</span><a name="LN4319"></a>    <a href="clauses.c.html#LN85"><span class='Ref_to_Typedef'>inline_error_callback_arg</span></a> <span class='Declare_Local'>callback_arg</span><span class='Delimiter'>; 
</span><a name="LN4320"></a>    ErrorContextCallback <span class='Declare_Local'>sqlerrcontext</span><span class='Delimiter'>; 
</span><a name="LN4321"></a>    <a href="../../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>fexpr</span><span class='Delimiter'>; 
</span><a name="LN4322"></a>    <a href="../../../include/executor/functions.h.html#LN20"><span class='Ref_to_Typedef'>SQLFunctionParseInfoPtr</span></a> <span class='Declare_Local'>pinfo</span><span class='Delimiter'>; 
</span><a name="LN4323"></a>    <a href="../../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pstate</span><span class='Delimiter'>; 
</span><a name="LN4324"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>raw_parsetree_list</span><span class='Delimiter'>; 
</span><a name="LN4325"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>querytree</span><span class='Delimiter'>; 
</span><a name="LN4326"></a>    <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>newexpr</span><span class='Delimiter'>; 
</span><a name="LN4327"></a>    <span class='Keyword'>int</span>        <span class='Operator'>*</span><span class='Declare_Local'>usecounts</span><span class='Delimiter'>; 
</span><a name="LN4328"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>arg</span><span class='Delimiter'>; 
</span><a name="LN4329"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Forget it if the function is not SQL-language or has other showstopper 
     * properties.  (The nargs check is just paranoia.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN4312"><span class='Ref_To_Local'>funcform</span></a><span class='Operator'>-&GT;</span>prolang <span class='Operator'>!= </span><a href="../../../include/catalog/pg_language.h.html#LN79"><span class='Ref_to_Const'>SQLlanguageId</span></a> <span class='Operator'>|| 
</span>        <a href="clauses.c.html#LN4312"><span class='Ref_To_Local'>funcform</span></a><span class='Operator'>-&GT;</span>prosecdef <span class='Operator'>|| 
</span>        <a href="clauses.c.html#LN4312"><span class='Ref_To_Local'>funcform</span></a><span class='Operator'>-&GT;</span>proretset <span class='Operator'>|| 
</span>        <a href="clauses.c.html#LN4312"><span class='Ref_To_Local'>funcform</span></a><span class='Operator'>-&GT;</span>prorettype <span class='Operator'>== </span><a href="../../../include/catalog/pg_type.h.html#LN679"><span class='Ref_to_Const'>RECORDOID</span></a> <span class='Operator'>|| 
</span>        <span class='Operator'>!</span><a href="../../access/common/heaptuple.c.html#LN295"><span class='Ref_to_Func'>heap_attisnull</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4309"><span class='Ref_to_Parameter'>func_tuple</span></a><span class='Delimiter'>, </span><a href="../../../include/catalog/pg_proc.h.html#LN116"><span class='Ref_to_Const'>Anum_pg_proc_proconfig</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <a href="clauses.c.html#LN4312"><span class='Ref_To_Local'>funcform</span></a><span class='Operator'>-&GT;</span>pronargs <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4307"><span class='Ref_to_Parameter'>args</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Check for recursive function, and give up trying to expand if so */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN231"><span class='Ref_to_Proto'>list_member_oid</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4310"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN66"><span class='Ref_to_Member'>active_fns</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN4306"><span class='Ref_to_Parameter'>funcid</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Check permission to call function (fail later, if not) */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/acl.h.html#LN285"><span class='Ref_to_Proto'>pg_proc_aclcheck</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4306"><span class='Ref_to_Parameter'>funcid</span></a><span class='Delimiter'>, </span><a href="../../utils/init/miscinit.c.html#LN281"><span class='Ref_to_Func'>GetUserId</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN78"><span class='Ref_to_Const'>ACL_EXECUTE</span></a><span class='Parentheses'>)</span> <span class='Operator'>!= </span><a href="../../../include/utils/acl.h.html#LN171"><span class='Ref_to_EnumConst'>ACLCHECK_OK</span></a><span class='Parentheses'>)</span> 
        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Check whether a plugin wants to hook function entry/exit */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN727"><span class='Ref_to_Macro'>FmgrHookIsNeeded</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4306"><span class='Ref_to_Parameter'>funcid</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Make a temporary memory context, so that we don't leak all the stuff 
     * that parsing might create. 
     */ 
</span>    <a href="clauses.c.html#LN4318"><span class='Ref_To_Local'>mycxt</span></a> <span class='Operator'>= </span><a href="../../../include/utils/memutils.h.html#LN145"><span class='Ref_to_Proto'>AllocSetContextCreate</span></a><span class='Parentheses'>(</span><a href="../../utils/mmgr/mcxt.c.html#LN36"><span class='Ref_to_Global_Var'>CurrentMemoryContext</span></a><span class='Delimiter'>, 
</span>                                  <span class='String'>"inline_function"</span><span class='Delimiter'>, 
</span>                                  <a href="../../../include/utils/memutils.h.html#LN164"><span class='Ref_to_Const'>ALLOCSET_DEFAULT_SIZES</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4317"><span class='Ref_To_Local'>oldcxt</span></a> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4318"><span class='Ref_To_Local'>mycxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Fetch the function body */ 
</span>    <a href="clauses.c.html#LN4314"><span class='Ref_To_Local'>tmp</span></a> <span class='Operator'>= </span><a href="../../../include/utils/syscache.h.html#LN133"><span class='Ref_to_Proto'>SysCacheGetAttr</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/syscache.h.html#LN76"><span class='Ref_to_EnumConst'>PROCOID</span></a><span class='Delimiter'>, 
</span>                          <a href="clauses.c.html#LN4309"><span class='Ref_to_Parameter'>func_tuple</span></a><span class='Delimiter'>, 
</span>                          <a href="../../../include/catalog/pg_proc.h.html#LN114"><span class='Ref_to_Const'>Anum_pg_proc_prosrc</span></a><span class='Delimiter'>, 
</span>                          <span class='Operator'>&</span><a href="clauses.c.html#LN4315"><span class='Ref_To_Local'>isNull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN4315"><span class='Ref_To_Local'>isNull</span></a><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"null prosrc for function %u"</span><span class='Delimiter'>, </span><a href="clauses.c.html#LN4306"><span class='Ref_to_Parameter'>funcid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4313"><span class='Ref_To_Local'>src</span></a> <span class='Operator'>= </span><a href="../../../include/utils/builtins.h.html#LN91"><span class='Ref_to_Macro'>TextDatumGetCString</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4314"><span class='Ref_To_Local'>tmp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Setup error traceback support for ereport().  This is so that we can 
     * finger the function that bad information came from. 
     */ 
</span>    <a href="clauses.c.html#LN4319"><span class='Ref_To_Local'>callback_arg</span></a><span class='Operator'>.</span><a href="clauses.c.html#LN87"><span class='Ref_to_Member'>proname</span></a> <span class='Operator'>= </span><a href="../../../include/c.h.html#LN498"><span class='Ref_to_Macro'>NameStr</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4312"><span class='Ref_To_Local'>funcform</span></a><span class='Operator'>-&GT;</span>proname<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4319"><span class='Ref_To_Local'>callback_arg</span></a><span class='Operator'>.</span><a href="clauses.c.html#LN88"><span class='Ref_to_Member'>prosrc</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN4313"><span class='Ref_To_Local'>src</span></a><span class='Delimiter'>; 
</span> 
    <a href="clauses.c.html#LN4320"><span class='Ref_To_Local'>sqlerrcontext</span></a><span class='Operator'>.</span>callback <span class='Operator'>= </span><a href="clauses.c.html#LN150"><span class='Ref_to_Proto'>sql_inline_error_callback</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4320"><span class='Ref_To_Local'>sqlerrcontext</span></a><span class='Operator'>.</span>arg <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="clauses.c.html#LN4319"><span class='Ref_To_Local'>callback_arg</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4320"><span class='Ref_To_Local'>sqlerrcontext</span></a><span class='Operator'>.</span>previous <span class='Operator'>= </span><a href="../../utils/error/elog.c.html#LN87"><span class='Ref_to_Global_Var'>error_context_stack</span></a><span class='Delimiter'>; 
</span>    <a href="../../utils/error/elog.c.html#LN87"><span class='Ref_to_Global_Var'>error_context_stack</span></a> <span class='Operator'>= &</span><a href="clauses.c.html#LN4320"><span class='Ref_To_Local'>sqlerrcontext</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Set up to handle parameters while parsing the function body.  We need a 
     * dummy FuncExpr node containing the already-simplified arguments to pass 
     * to prepare_sql_fn_parse_info.  (It is really only needed if there are 
     * some polymorphic arguments, but for simplicity we always build it.) 
     */ 
</span>    <a href="clauses.c.html#LN4321"><span class='Ref_To_Local'>fexpr</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4321"><span class='Ref_To_Local'>fexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN447"><span class='Ref_to_Member'>funcid</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN4306"><span class='Ref_to_Parameter'>funcid</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4321"><span class='Ref_To_Local'>fexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN448"><span class='Ref_to_Member'>funcresulttype</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN4306"><span class='Ref_to_Parameter'>result_type</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4321"><span class='Ref_To_Local'>fexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN449"><span class='Ref_to_Member'>funcretset</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4321"><span class='Ref_To_Local'>fexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN450"><span class='Ref_to_Member'>funcvariadic</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN4308"><span class='Ref_to_Parameter'>funcvariadic</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4321"><span class='Ref_To_Local'>fexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN452"><span class='Ref_to_Member'>funcformat</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/primnodes.h.html#LN436"><span class='Ref_to_EnumConst'>COERCE_EXPLICIT_CALL</span></a><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* doesn't matter */ 
</span>    <a href="clauses.c.html#LN4321"><span class='Ref_To_Local'>fexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN453"><span class='Ref_to_Member'>funccollid</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN4306"><span class='Ref_to_Parameter'>result_collid</span></a><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* doesn't matter */ 
</span>    <a href="clauses.c.html#LN4321"><span class='Ref_To_Local'>fexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN454"><span class='Ref_to_Member'>inputcollid</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN4307"><span class='Ref_to_Parameter'>input_collid</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4321"><span class='Ref_To_Local'>fexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN455"><span class='Ref_to_Member'>args</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN4307"><span class='Ref_to_Parameter'>args</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4321"><span class='Ref_To_Local'>fexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN456"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <a href="clauses.c.html#LN4322"><span class='Ref_To_Local'>pinfo</span></a> <span class='Operator'>= </span><a href="../../../include/executor/functions.h.html#LN24"><span class='Ref_to_Proto'>prepare_sql_fn_parse_info</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4309"><span class='Ref_to_Parameter'>func_tuple</span></a><span class='Delimiter'>, 
</span>                                      <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN4321"><span class='Ref_To_Local'>fexpr</span></a><span class='Delimiter'>, 
</span>                                      <a href="clauses.c.html#LN4307"><span class='Ref_to_Parameter'>input_collid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We just do parsing and parse analysis, not rewriting, because rewriting 
     * will not affect table-free-SELECT-only queries, which is all that we 
     * care about.  Also, we can punt as soon as we detect more than one 
     * command in the function body. 
     */ 
</span>    <a href="clauses.c.html#LN4324"><span class='Ref_To_Local'>raw_parsetree_list</span></a> <span class='Operator'>= </span><a href="../../../include/tcop/tcopprot.h.html#LN49"><span class='Ref_to_Proto'>pg_parse_query</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4313"><span class='Ref_To_Local'>src</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4324"><span class='Ref_To_Local'>raw_parsetree_list</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
        <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="clauses.c.html#LN4599"><span class='Ref_to_Label'>fail</span></a><span class='Delimiter'>; 
</span> 
    <a href="clauses.c.html#LN4323"><span class='Ref_To_Local'>pstate</span></a> <span class='Operator'>= </span><a href="../../parser/parse_node.c.html#LN42"><span class='Ref_to_Func'>make_parsestate</span></a><span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4323"><span class='Ref_To_Local'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../../include/parser/parse_node.h.html#LN167"><span class='Ref_to_Member'>p_sourcetext</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN4313"><span class='Ref_To_Local'>src</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/executor/functions.h.html#LN28"><span class='Ref_to_Proto'>sql_fn_parser_setup</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4323"><span class='Ref_To_Local'>pstate</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN4322"><span class='Ref_To_Local'>pinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="clauses.c.html#LN4325"><span class='Ref_To_Local'>querytree</span></a> <span class='Operator'>= </span><a href="../../../include/parser/analyze.h.html#LN34"><span class='Ref_to_Proto'>transformTopLevelStmt</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4323"><span class='Ref_To_Local'>pstate</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4324"><span class='Ref_To_Local'>raw_parsetree_list</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="../../parser/parse_node.c.html#LN75"><span class='Ref_to_Func'>free_parsestate</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4323"><span class='Ref_To_Local'>pstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The single command must be a simple "SELECT expression". 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4325"><span class='Ref_To_Local'>querytree</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <a href="clauses.c.html#LN4325"><span class='Ref_To_Local'>querytree</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN109"><span class='Ref_to_Member'>commandType</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/nodes.h.html#LN650"><span class='Ref_to_EnumConst'>CMD_SELECT</span></a> <span class='Operator'>|| 
</span>        <a href="clauses.c.html#LN4325"><span class='Ref_To_Local'>querytree</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN122"><span class='Ref_to_Member'>hasAggs</span></a> <span class='Operator'>|| 
</span>        <a href="clauses.c.html#LN4325"><span class='Ref_To_Local'>querytree</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN123"><span class='Ref_to_Member'>hasWindowFuncs</span></a> <span class='Operator'>|| 
</span>        <a href="clauses.c.html#LN4325"><span class='Ref_To_Local'>querytree</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN124"><span class='Ref_to_Member'>hasTargetSRFs</span></a> <span class='Operator'>|| 
</span>        <a href="clauses.c.html#LN4325"><span class='Ref_To_Local'>querytree</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN125"><span class='Ref_to_Member'>hasSubLinks</span></a> <span class='Operator'>|| 
</span>        <a href="clauses.c.html#LN4325"><span class='Ref_To_Local'>querytree</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN132"><span class='Ref_to_Member'>cteList</span></a> <span class='Operator'>|| 
</span>        <a href="clauses.c.html#LN4325"><span class='Ref_To_Local'>querytree</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN134"><span class='Ref_to_Member'>rtable</span></a> <span class='Operator'>|| 
</span>        <a href="clauses.c.html#LN4325"><span class='Ref_To_Local'>querytree</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN135"><span class='Ref_to_Member'>jointree</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1469"><span class='Ref_to_Member'>fromlist</span></a> <span class='Operator'>|| 
</span>        <a href="clauses.c.html#LN4325"><span class='Ref_To_Local'>querytree</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN135"><span class='Ref_to_Member'>jointree</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1470"><span class='Ref_to_Member'>quals</span></a> <span class='Operator'>|| 
</span>        <a href="clauses.c.html#LN4325"><span class='Ref_To_Local'>querytree</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a> <span class='Operator'>|| 
</span>        <a href="clauses.c.html#LN4325"><span class='Ref_To_Local'>querytree</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN147"><span class='Ref_to_Member'>groupingSets</span></a> <span class='Operator'>|| 
</span>        <a href="clauses.c.html#LN4325"><span class='Ref_To_Local'>querytree</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a> <span class='Operator'>|| 
</span>        <a href="clauses.c.html#LN4325"><span class='Ref_To_Local'>querytree</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN151"><span class='Ref_to_Member'>windowClause</span></a> <span class='Operator'>|| 
</span>        <a href="clauses.c.html#LN4325"><span class='Ref_To_Local'>querytree</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN153"><span class='Ref_to_Member'>distinctClause</span></a> <span class='Operator'>|| 
</span>        <a href="clauses.c.html#LN4325"><span class='Ref_To_Local'>querytree</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN155"><span class='Ref_to_Member'>sortClause</span></a> <span class='Operator'>|| 
</span>        <a href="clauses.c.html#LN4325"><span class='Ref_To_Local'>querytree</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN157"><span class='Ref_to_Member'>limitOffset</span></a> <span class='Operator'>|| 
</span>        <a href="clauses.c.html#LN4325"><span class='Ref_To_Local'>querytree</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN158"><span class='Ref_to_Member'>limitCount</span></a> <span class='Operator'>|| 
</span>        <a href="clauses.c.html#LN4325"><span class='Ref_To_Local'>querytree</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN162"><span class='Ref_to_Member'>setOperations</span></a> <span class='Operator'>|| 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4325"><span class='Ref_To_Local'>querytree</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
        <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="clauses.c.html#LN4599"><span class='Ref_to_Label'>fail</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Make sure the function (still) returns what it's declared to.  This 
     * will raise an error if wrong, but that's okay since the function would 
     * fail at runtime anyway.  Note that check_sql_fn_retval will also insert 
     * a RelabelType if needed to make the tlist expression match the declared 
     * type of the function. 
     * 
     * Note: we do not try this until we have verified that no rewriting was 
     * needed; that's probably not important, but let's be careful. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/executor/functions.h.html#LN31"><span class='Ref_to_Proto'>check_sql_fn_retval</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4306"><span class='Ref_to_Parameter'>funcid</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN4306"><span class='Ref_to_Parameter'>result_type</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4325"><span class='Ref_To_Local'>querytree</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                            <span class='Operator'>&</span><a href="clauses.c.html#LN4316"><span class='Ref_To_Local'>modifyTargetList</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>))</span> 
        <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="clauses.c.html#LN4599"><span class='Ref_to_Label'>fail</span></a><span class='Delimiter'>;</span>              <span class='Comment_Single_Line'>/* reject whole-tuple-result cases */ 
</span> 
    <span class='Comment_Multi_Line'>/* Now we can grab the tlist expression */ 
</span>    <a href="clauses.c.html#LN4326"><span class='Ref_To_Local'>newexpr</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) ((</span><a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4325"><span class='Ref_To_Local'>querytree</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>expr<span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Assert that check_sql_fn_retval did the right thing */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4326"><span class='Ref_To_Local'>newexpr</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="clauses.c.html#LN4306"><span class='Ref_to_Parameter'>result_type</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* It couldn't have made any dangerous tlist changes, either */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="clauses.c.html#LN4316"><span class='Ref_To_Local'>modifyTargetList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Additional validity checks on the expression.  It mustn't be more 
     * volatile than the surrounding function (this is to avoid breaking hacks 
     * that involve pretending a function is immutable when it really ain't). 
     * If the surrounding function is declared strict, then the expression 
     * must contain only strict constructs and must use all of the function 
     * parameters (this is overkill, but an exact analysis is hard). 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN4312"><span class='Ref_To_Local'>funcform</span></a><span class='Operator'>-&GT;</span>provolatile <span class='Operator'>== </span><a href="../../../include/catalog/pg_proc.h.html#LN5482"><span class='Ref_to_Const'>PROVOLATILE_IMMUTABLE</span></a> <span class='Operator'>&& 
</span>        <a href="../../../include/optimizer/clauses.h.html#LN59"><span class='Ref_to_Proto'>contain_mutable_functions</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4326"><span class='Ref_To_Local'>newexpr</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="clauses.c.html#LN4599"><span class='Ref_to_Label'>fail</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN4312"><span class='Ref_To_Local'>funcform</span></a><span class='Operator'>-&GT;</span>provolatile <span class='Operator'>== </span><a href="../../../include/catalog/pg_proc.h.html#LN5483"><span class='Ref_to_Const'>PROVOLATILE_STABLE</span></a> <span class='Operator'>&& 
</span>             <a href="../../../include/optimizer/clauses.h.html#LN60"><span class='Ref_to_Proto'>contain_volatile_functions</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4326"><span class='Ref_To_Local'>newexpr</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="clauses.c.html#LN4599"><span class='Ref_to_Label'>fail</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN4312"><span class='Ref_To_Local'>funcform</span></a><span class='Operator'>-&GT;</span>proisstrict <span class='Operator'>&& 
</span>        <a href="../../../include/optimizer/clauses.h.html#LN64"><span class='Ref_to_Proto'>contain_nonstrict_functions</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4326"><span class='Ref_To_Local'>newexpr</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="clauses.c.html#LN4599"><span class='Ref_to_Label'>fail</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If any parameter expression contains a context-dependent node, we can't 
     * inline, for fear of putting such a node into the wrong context. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN109"><span class='Ref_to_Proto'>contain_context_dependent_node</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN4307"><span class='Ref_to_Parameter'>args</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="clauses.c.html#LN4599"><span class='Ref_to_Label'>fail</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We may be able to do it; there are still checks on parameter usage to 
     * make, but those are most easily done in combination with the actual 
     * substitution of the inputs.  So start building expression with inputs 
     * substituted. 
     */ 
</span>    <a href="clauses.c.html#LN4327"><span class='Ref_To_Local'>usecounts</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4312"><span class='Ref_To_Local'>funcform</span></a><span class='Operator'>-&GT;</span>pronargs <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4326"><span class='Ref_To_Local'>newexpr</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN146"><span class='Ref_to_Proto'>substitute_actual_parameters</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4326"><span class='Ref_To_Local'>newexpr</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN4312"><span class='Ref_To_Local'>funcform</span></a><span class='Operator'>-&GT;</span>pronargs<span class='Delimiter'>, 
</span>                                           <a href="clauses.c.html#LN4307"><span class='Ref_to_Parameter'>args</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN4327"><span class='Ref_To_Local'>usecounts</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Now check for parameter usage */ 
</span>    <a href="clauses.c.html#LN4329"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4328"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN4307"><span class='Ref_to_Parameter'>args</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN4511"></a>        <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>param</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4328"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN4327"><span class='Ref_To_Local'>usecounts</span></a><span class='Delimiter'>[</span><a href="clauses.c.html#LN4329"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Param not used at all: uncool if func is strict */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN4312"><span class='Ref_To_Local'>funcform</span></a><span class='Operator'>-&GT;</span>proisstrict<span class='Parentheses'>) 
</span>                <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="clauses.c.html#LN4599"><span class='Ref_to_Label'>fail</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN4327"><span class='Ref_To_Local'>usecounts</span></a><span class='Delimiter'>[</span><a href="clauses.c.html#LN4329"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>!= </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Param used multiple times: uncool if expensive or volatile */ 
</span><a name="LN4522"></a>            <a href="../../../include/nodes/relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a>    <span class='Declare_Local'>eval_cost</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * We define "expensive" as "contains any subplan or more than 10 
             * operators".  Note that the subplan search has to be done 
             * explicitly, since cost_qual_eval() will barf on unplanned 
             * subselects. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/clauses.h.html#LN57"><span class='Ref_to_Proto'>contain_subplans</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4511"><span class='Ref_To_Local'>param</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="clauses.c.html#LN4599"><span class='Ref_to_Label'>fail</span></a><span class='Delimiter'>; 
</span>            <a href="../../../include/optimizer/cost.h.html#LN157"><span class='Ref_to_Proto'>cost_qual_eval</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="clauses.c.html#LN4522"><span class='Ref_To_Local'>eval_cost</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4511"><span class='Ref_To_Local'>param</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN4522"><span class='Ref_To_Local'>eval_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a> <span class='Operator'>+ </span><a href="clauses.c.html#LN4522"><span class='Ref_To_Local'>eval_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>&GT; 
</span>                <span class='Number'>10</span> <span class='Operator'>* </span><a href="../path/costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="clauses.c.html#LN4599"><span class='Ref_to_Label'>fail</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Check volatility last since this is more expensive than the 
             * above tests 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/clauses.h.html#LN60"><span class='Ref_to_Proto'>contain_volatile_functions</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4511"><span class='Ref_To_Local'>param</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="clauses.c.html#LN4599"><span class='Ref_to_Label'>fail</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if usecounts[i]!=1 &raquo; </span> 
        <a href="clauses.c.html#LN4329"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Whew --- we can make the substitution.  Copy the modified expression 
     * out of the temporary memory context, and clean up. 
     */ 
</span>    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4317"><span class='Ref_To_Local'>oldcxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="clauses.c.html#LN4326"><span class='Ref_To_Local'>newexpr</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4326"><span class='Ref_To_Local'>newexpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/memutils.h.html#LN74"><span class='Ref_to_Proto'>MemoryContextDelete</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4318"><span class='Ref_To_Local'>mycxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the result is of a collatable type, force the result to expose the 
     * correct collation.  In most cases this does not matter, but it's 
     * possible that the function result is used directly as a sort key or in 
     * other places where we expect exprCollation() to tell the truth. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4306"><span class='Ref_to_Parameter'>result_collid</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN4565"></a>        <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>exprcoll</span> <span class='Operator'>= </span><a href="../../../include/nodes/nodeFuncs.h.html#LN38"><span class='Ref_to_Proto'>exprCollation</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4326"><span class='Ref_To_Local'>newexpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4565"><span class='Ref_To_Local'>exprcoll</span></a><span class='Parentheses'>) </span><span class='Operator'>&& </span><a href="clauses.c.html#LN4565"><span class='Ref_To_Local'>exprcoll</span></a> <span class='Operator'>!= </span><a href="clauses.c.html#LN4306"><span class='Ref_to_Parameter'>result_collid</span></a><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span><a name="LN4569"></a>            <a href="../../../include/nodes/primnodes.h.html#LN871"><span class='Ref_to_Struct'>CollateExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>newnode</span> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN871"><span class='Ref_to_Struct'>CollateExpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="clauses.c.html#LN4569"><span class='Ref_To_Local'>newnode</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN874"><span class='Ref_to_Member'>arg</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN4326"><span class='Ref_To_Local'>newexpr</span></a><span class='Delimiter'>; 
</span>            <a href="clauses.c.html#LN4569"><span class='Ref_To_Local'>newnode</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN875"><span class='Ref_to_Member'>collOid</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN4306"><span class='Ref_to_Parameter'>result_collid</span></a><span class='Delimiter'>; 
</span>            <a href="clauses.c.html#LN4569"><span class='Ref_To_Local'>newnode</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN876"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
            <a href="clauses.c.html#LN4326"><span class='Ref_To_Local'>newexpr</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN4569"><span class='Ref_To_Local'>newnode</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Since there is now no trace of the function in the plan tree, we must 
     * explicitly record the plan's dependency on the function. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN4310"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN65"><span class='Ref_to_Member'>root</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/optimizer/planmain.h.html#LN116"><span class='Ref_to_Proto'>record_plan_function_dependency</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4310"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN65"><span class='Ref_to_Member'>root</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN4306"><span class='Ref_to_Parameter'>funcid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Recursively try to simplify the modified expression.  Here we must add 
     * the current function to the context list of active functions. 
     */ 
</span>    <a href="clauses.c.html#LN4310"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN66"><span class='Ref_to_Member'>active_fns</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN217"><span class='Ref_to_Proto'>lcons_oid</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4306"><span class='Ref_to_Parameter'>funcid</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN4310"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN66"><span class='Ref_to_Member'>active_fns</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4326"><span class='Ref_To_Local'>newexpr</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN115"><span class='Ref_to_Proto'>eval_const_expressions_mutator</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4326"><span class='Ref_To_Local'>newexpr</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN4310"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4310"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN66"><span class='Ref_to_Member'>active_fns</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN237"><span class='Ref_to_Proto'>list_delete_first</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4310"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN66"><span class='Ref_to_Member'>active_fns</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../utils/error/elog.c.html#LN87"><span class='Ref_to_Global_Var'>error_context_stack</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN4320"><span class='Ref_To_Local'>sqlerrcontext</span></a><span class='Operator'>.</span>previous<span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN4326"><span class='Ref_To_Local'>newexpr</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Here if func is not inlinable: release temp memory and return NULL */ 
</span><a name="LN4599"></a><span class='Label'>fail</span><span class='Operator'>: 
</span>    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4317"><span class='Ref_To_Local'>oldcxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/utils/memutils.h.html#LN74"><span class='Ref_to_Proto'>MemoryContextDelete</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4318"><span class='Ref_To_Local'>mycxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../utils/error/elog.c.html#LN87"><span class='Ref_to_Global_Var'>error_context_stack</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN4320"><span class='Ref_To_Local'>sqlerrcontext</span></a><span class='Operator'>.</span>previous<span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end inline_function &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Replace Param nodes by appropriate actual parameters 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN4611"></a><span class='Declare_Function'>substitute_actual_parameters</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>expr</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>nargs</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>args</span><span class='Delimiter'>, 
</span><a name="LN4612"></a>                             <span class='Keyword'>int </span><span class='Operator'>*</span><span class='Declare_Parameter'>usecounts</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4614"></a>    <a href="clauses.c.html#LN71"><span class='Ref_to_Typedef'>substitute_actual_parameters_context</span></a> <span class='Declare_Local'>context</span><span class='Delimiter'>; 
</span> 
    <a href="clauses.c.html#LN4614"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="clauses.c.html#LN73"><span class='Ref_to_Member'>nargs</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN4611"><span class='Ref_to_Parameter'>nargs</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4614"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="clauses.c.html#LN74"><span class='Ref_to_Member'>args</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN4611"><span class='Ref_to_Parameter'>args</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4614"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="clauses.c.html#LN75"><span class='Ref_to_Member'>usecounts</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN4612"><span class='Ref_to_Parameter'>usecounts</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="clauses.c.html#LN148"><span class='Ref_to_Proto'>substitute_actual_parameters_mutator</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4611"><span class='Ref_to_Parameter'>expr</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="clauses.c.html#LN4614"><span class='Ref_To_Local'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN4624"></a><span class='Declare_Function'>substitute_actual_parameters_mutator</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, 
</span><a name="LN4625"></a>                               <a href="clauses.c.html#LN71"><span class='Ref_to_Typedef'>substitute_actual_parameters_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN4624"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4624"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN240"><span class='Ref_to_Struct'>Param</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN4631"></a>        <a href="../../../include/nodes/primnodes.h.html#LN240"><span class='Ref_to_Struct'>Param</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>param</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN240"><span class='Ref_to_Struct'>Param</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN4624"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN4631"><span class='Ref_To_Local'>param</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN243"><span class='Ref_to_Member'>paramkind</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/primnodes.h.html#LN234"><span class='Ref_to_EnumConst'>PARAM_EXTERN</span></a><span class='Parentheses'>) 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unexpected paramkind: %d"</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN4631"><span class='Ref_To_Local'>param</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN243"><span class='Ref_to_Member'>paramkind</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN4631"><span class='Ref_To_Local'>param</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN244"><span class='Ref_to_Member'>paramid</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span> <span class='Operator'>|| </span><a href="clauses.c.html#LN4631"><span class='Ref_To_Local'>param</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN244"><span class='Ref_to_Member'>paramid</span></a> <span class='Operator'>&GT; </span><a href="clauses.c.html#LN4625"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN73"><span class='Ref_to_Member'>nargs</span></a><span class='Parentheses'>) 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"invalid paramid: %d"</span><span class='Delimiter'>, </span><a href="clauses.c.html#LN4631"><span class='Ref_To_Local'>param</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN244"><span class='Ref_to_Member'>paramid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Count usage of parameter */ 
</span>        <a href="clauses.c.html#LN4625"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN75"><span class='Ref_to_Member'>usecounts</span></a><span class='Delimiter'>[</span><a href="clauses.c.html#LN4631"><span class='Ref_To_Local'>param</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN244"><span class='Ref_to_Member'>paramid</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Operator'>++</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Select the appropriate actual arg and replace the Param with it */ 
</span>        <span class='Comment_Multi_Line'>/* We don't need to copy at this time (it'll get done later) */ 
</span>        <span class='Control'>return</span> <a href="../../../include/nodes/pg_list.h.html#LN223"><span class='Ref_to_Proto'>list_nth</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4625"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN74"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN4631"><span class='Ref_To_Local'>param</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN244"><span class='Ref_to_Member'>paramid</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <a href="../../../include/nodes/nodeFuncs.h.html#LN54"><span class='Ref_to_Proto'>expression_tree_mutator</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4624"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN148"><span class='Ref_to_Proto'>substitute_actual_parameters_mutator</span></a><span class='Delimiter'>, 
</span>                                   <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN4625"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end substitute_actual_parameters_mutator &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * error context callback to let us supply a call-stack traceback 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN4653"></a><span class='Declare_Function'>sql_inline_error_callback</span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>arg</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4655"></a>    <a href="clauses.c.html#LN85"><span class='Ref_to_Typedef'>inline_error_callback_arg</span></a> <span class='Operator'>*</span><span class='Declare_Local'>callback_arg</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="clauses.c.html#LN85"><span class='Ref_to_Typedef'>inline_error_callback_arg</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN4653"><span class='Ref_to_Parameter'>arg</span></a><span class='Delimiter'>; 
</span><a name="LN4656"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>syntaxerrposition</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If it's a syntax error, convert to internal syntax error report */ 
</span>    <a href="clauses.c.html#LN4656"><span class='Ref_To_Local'>syntaxerrposition</span></a> <span class='Operator'>= </span><a href="../../utils/error/elog.c.html#LN1255"><span class='Ref_to_Func'>geterrposition</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN4656"><span class='Ref_To_Local'>syntaxerrposition</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../utils/error/elog.c.html#LN1123"><span class='Ref_to_Func'>errposition</span></a><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../utils/error/elog.c.html#LN1139"><span class='Ref_to_Func'>internalerrposition</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4656"><span class='Ref_To_Local'>syntaxerrposition</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../utils/error/elog.c.html#LN1159"><span class='Ref_to_Func'>internalerrquery</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4655"><span class='Ref_To_Local'>callback_arg</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN88"><span class='Ref_to_Member'>prosrc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    errcontext<span class='Parentheses'>(</span><span class='String'>"SQL function \"%s\" during inlining"</span><span class='Delimiter'>, </span><a href="clauses.c.html#LN4655"><span class='Ref_To_Local'>callback_arg</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN87"><span class='Ref_to_Member'>proname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * evaluate_expr: pre-evaluate a constant expression 
 * 
 * We use the executor's routine ExecEvalExpr() to avoid duplication of 
 * code and ensure we get the same result as the executor would get. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>* 
</span><a name="LN4677"></a><span class='Declare_Function'>evaluate_expr</span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>expr</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>result_type</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a> <span class='Declare_Parameter'>result_typmod</span><span class='Delimiter'>, 
</span><a name="LN4678"></a>              <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>result_collation</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4680"></a>    <a href="../../../include/nodes/execnodes.h.html#LN402"><span class='Ref_to_Struct'>EState</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>estate</span><span class='Delimiter'>; 
</span><a name="LN4681"></a>    <a href="../../../include/nodes/execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>exprstate</span><span class='Delimiter'>; 
</span><a name="LN4682"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span><span class='Delimiter'>; 
</span><a name="LN4683"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>const_val</span><span class='Delimiter'>; 
</span><a name="LN4684"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>const_is_null</span><span class='Delimiter'>; 
</span><a name="LN4685"></a>    <a href="../../../include/c.h.html#LN254"><span class='Ref_to_Typedef'>int16</span></a>       <span class='Declare_Local'>resultTypLen</span><span class='Delimiter'>; 
</span><a name="LN4686"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>resultTypByVal</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * To use the executor, we need an EState. 
     */ 
</span>    <a href="clauses.c.html#LN4680"><span class='Ref_To_Local'>estate</span></a> <span class='Operator'>= </span><a href="../../executor/execUtils.c.html#LN78"><span class='Ref_to_Func'>CreateExecutorState</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* We can use the estate's working context to avoid memory leaks. */ 
</span>    <a href="clauses.c.html#LN4682"><span class='Ref_To_Local'>oldcontext</span></a> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4680"><span class='Ref_To_Local'>estate</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/execnodes.h.html#LN447"><span class='Ref_to_Member'>es_query_cxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Make sure any opfuncids are filled in. */ 
</span>    <a href="../../../include/nodes/nodeFuncs.h.html#LN45"><span class='Ref_to_Proto'>fix_opfuncids</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN4677"><span class='Ref_to_Parameter'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Prepare expr for execution.  (Note: we can't use ExecPrepareExpr 
     * because it'd result in recursively invoking eval_const_expressions.) 
     */ 
</span>    <a href="clauses.c.html#LN4681"><span class='Ref_To_Local'>exprstate</span></a> <span class='Operator'>= </span><a href="../../executor/execExpr.c.html#LN111"><span class='Ref_to_Func'>ExecInitExpr</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4677"><span class='Ref_to_Parameter'>expr</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * And evaluate it. 
     * 
     * It is OK to use a default econtext because none of the ExecEvalExpr() 
     * code used in this situation will use econtext.  That might seem 
     * fortuitous, but it's not so unreasonable --- a constant expression does 
     * not depend on context, by definition, n'est ce pas? 
     */ 
</span>    <a href="clauses.c.html#LN4683"><span class='Ref_To_Local'>const_val</span></a> <span class='Operator'>= </span><a href="../../../include/executor/executor.h.html#LN279"><span class='Ref_to_Func'>ExecEvalExprSwitchContext</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4681"><span class='Ref_To_Local'>exprstate</span></a><span class='Delimiter'>, 
</span>                                          <a href="../../../include/executor/executor.h.html#LN455"><span class='Ref_to_Macro'>GetPerTupleExprContext</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4680"><span class='Ref_To_Local'>estate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                          <span class='Operator'>&</span><a href="clauses.c.html#LN4684"><span class='Ref_To_Local'>const_is_null</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Get info needed about result datatype */ 
</span>    <a href="../../../include/utils/lsyscache.h.html#LN135"><span class='Ref_to_Proto'>get_typlenbyval</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4677"><span class='Ref_to_Parameter'>result_type</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="clauses.c.html#LN4685"><span class='Ref_To_Local'>resultTypLen</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="clauses.c.html#LN4686"><span class='Ref_To_Local'>resultTypByVal</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Get back to outer memory context */ 
</span>    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4682"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Must copy result out of sub-context used by expression eval. 
     * 
     * Also, if it's varlena, forcibly detoast it.  This protects us against 
     * storing TOAST pointers into plans that might outlive the referenced 
     * data.  (makeConst would handle detoasting anyway, but it's worth a few 
     * extra lines here so that we can do the copy and detoast in one step.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="clauses.c.html#LN4684"><span class='Ref_To_Local'>const_is_null</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN4685"><span class='Ref_To_Local'>resultTypLen</span></a> <span class='Operator'>== -</span><span class='Number'>1</span><span class='Parentheses'>) 
</span>            <a href="clauses.c.html#LN4683"><span class='Ref_To_Local'>const_val</span></a> <span class='Operator'>= </span><a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN206"><span class='Ref_to_Macro'>PG_DETOAST_DATUM_COPY</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4683"><span class='Ref_To_Local'>const_val</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="clauses.c.html#LN4683"><span class='Ref_To_Local'>const_val</span></a> <span class='Operator'>= </span><a href="../../../include/utils/datum.h.html#LN30"><span class='Ref_to_Proto'>datumCopy</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4683"><span class='Ref_To_Local'>const_val</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN4686"><span class='Ref_To_Local'>resultTypByVal</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN4685"><span class='Ref_To_Local'>resultTypLen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Release all the junk we just created */ 
</span>    <a href="../../executor/execUtils.c.html#LN176"><span class='Ref_to_Func'>FreeExecutorState</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4680"><span class='Ref_To_Local'>estate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Make the constant result node. 
     */ 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/makefuncs.h.html#LN49"><span class='Ref_to_Proto'>makeConst</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4677"><span class='Ref_to_Parameter'>result_type</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN4677"><span class='Ref_to_Parameter'>result_typmod</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN4678"><span class='Ref_to_Parameter'>result_collation</span></a><span class='Delimiter'>, 
</span>                              <a href="clauses.c.html#LN4685"><span class='Ref_To_Local'>resultTypLen</span></a><span class='Delimiter'>, 
</span>                              <a href="clauses.c.html#LN4683"><span class='Ref_To_Local'>const_val</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN4684"><span class='Ref_To_Local'>const_is_null</span></a><span class='Delimiter'>, 
</span>                              <a href="clauses.c.html#LN4686"><span class='Ref_To_Local'>resultTypByVal</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end evaluate_expr &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * inline_set_returning_function 
 *      Attempt to "inline" a set-returning function in the FROM clause. 
 * 
 * "rte" is an RTE_FUNCTION rangetable entry.  If it represents a call of a 
 * set-returning SQL function that can safely be inlined, expand the function 
 * and return the substitute Query structure.  Otherwise, return NULL. 
 * 
 * This has a good deal of similarity to inline_function(), but that's 
 * for the non-set-returning case, and there are enough differences to 
 * justify separate functions. 
 */ 
</span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>* 
</span><a name="LN4765"></a><span class='Declare_Function'>inline_set_returning_function</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4767"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN1051"><span class='Ref_to_Struct'>RangeTblFunction</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rtfunc</span><span class='Delimiter'>; 
</span><a name="LN4768"></a>    <a href="../../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>fexpr</span><span class='Delimiter'>; 
</span><a name="LN4769"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>func_oid</span><span class='Delimiter'>; 
</span><a name="LN4770"></a>    <a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>func_tuple</span><span class='Delimiter'>; 
</span><a name="LN4771"></a>    <a href="../../../include/catalog/pg_proc.h.html#LN82"><span class='Ref_to_Typedef'>Form_pg_proc</span></a> <span class='Declare_Local'>funcform</span><span class='Delimiter'>; 
</span><a name="LN4772"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>src</span><span class='Delimiter'>; 
</span><a name="LN4773"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>tmp</span><span class='Delimiter'>; 
</span><a name="LN4774"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isNull</span><span class='Delimiter'>; 
</span><a name="LN4775"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>modifyTargetList</span><span class='Delimiter'>; 
</span><a name="LN4776"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcxt</span><span class='Delimiter'>; 
</span><a name="LN4777"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>mycxt</span><span class='Delimiter'>; 
</span><a name="LN4778"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>saveInvalItems</span><span class='Delimiter'>; 
</span><a name="LN4779"></a>    <a href="clauses.c.html#LN85"><span class='Ref_to_Typedef'>inline_error_callback_arg</span></a> <span class='Declare_Local'>callback_arg</span><span class='Delimiter'>; 
</span><a name="LN4780"></a>    ErrorContextCallback <span class='Declare_Local'>sqlerrcontext</span><span class='Delimiter'>; 
</span><a name="LN4781"></a>    <a href="../../../include/executor/functions.h.html#LN20"><span class='Ref_to_Typedef'>SQLFunctionParseInfoPtr</span></a> <span class='Declare_Local'>pinfo</span><span class='Delimiter'>; 
</span><a name="LN4782"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>raw_parsetree_list</span><span class='Delimiter'>; 
</span><a name="LN4783"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>querytree_list</span><span class='Delimiter'>; 
</span><a name="LN4784"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>querytree</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="clauses.c.html#LN4765"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN925"><span class='Ref_to_EnumConst'>RTE_FUNCTION</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * It doesn't make a lot of sense for a SQL SRF to refer to itself in its 
     * own FROM clause, since that must cause infinite recursion at runtime. 
     * It will cause this code to recurse too, so check for stack overflow. 
     * (There's no need to do more.) 
     */ 
</span>    <a href="../../../include/miscadmin.h.html#LN275"><span class='Ref_to_Proto'>check_stack_depth</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Fail if the RTE has ORDINALITY - we don't implement that here. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN4765"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN986"><span class='Ref_to_Member'>funcordinality</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Fail if RTE isn't a single, simple FuncExpr */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4765"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN985"><span class='Ref_to_Member'>functions</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4767"><span class='Ref_To_Local'>rtfunc</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1051"><span class='Ref_to_Struct'>RangeTblFunction</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4765"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN985"><span class='Ref_to_Member'>functions</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4767"><span class='Ref_To_Local'>rtfunc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1055"><span class='Ref_to_Member'>funcexpr</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4768"><span class='Ref_To_Local'>fexpr</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN4767"><span class='Ref_To_Local'>rtfunc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1055"><span class='Ref_to_Member'>funcexpr</span></a><span class='Delimiter'>; 
</span> 
    <a href="clauses.c.html#LN4769"><span class='Ref_To_Local'>func_oid</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN4768"><span class='Ref_To_Local'>fexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN447"><span class='Ref_to_Member'>funcid</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The function must be declared to return a set, else inlining would 
     * change the results if the contained SELECT didn't return exactly one 
     * row. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="clauses.c.html#LN4768"><span class='Ref_To_Local'>fexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN449"><span class='Ref_to_Member'>funcretset</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Refuse to inline if the arguments contain any volatile functions or 
     * sub-selects.  Volatile functions are rejected because inlining may 
     * result in the arguments being evaluated multiple times, risking a 
     * change in behavior.  Sub-selects are rejected partly for implementation 
     * reasons (pushing them down another level might change their behavior) 
     * and partly because they're likely to be expensive and so multiple 
     * evaluation would be bad. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/clauses.h.html#LN60"><span class='Ref_to_Proto'>contain_volatile_functions</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN4768"><span class='Ref_To_Local'>fexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN455"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span> <span class='Operator'>|| 
</span>        <a href="../../../include/optimizer/clauses.h.html#LN57"><span class='Ref_to_Proto'>contain_subplans</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN4768"><span class='Ref_To_Local'>fexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN455"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Check permission to call function (fail later, if not) */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/acl.h.html#LN285"><span class='Ref_to_Proto'>pg_proc_aclcheck</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4769"><span class='Ref_To_Local'>func_oid</span></a><span class='Delimiter'>, </span><a href="../../utils/init/miscinit.c.html#LN281"><span class='Ref_to_Func'>GetUserId</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN78"><span class='Ref_to_Const'>ACL_EXECUTE</span></a><span class='Parentheses'>)</span> <span class='Operator'>!= </span><a href="../../../include/utils/acl.h.html#LN171"><span class='Ref_to_EnumConst'>ACLCHECK_OK</span></a><span class='Parentheses'>)</span> 
        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Check whether a plugin wants to hook function entry/exit */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN727"><span class='Ref_to_Macro'>FmgrHookIsNeeded</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4769"><span class='Ref_To_Local'>func_oid</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * OK, let's take a look at the function's pg_proc entry. 
     */ 
</span>    <a href="clauses.c.html#LN4770"><span class='Ref_To_Local'>func_tuple</span></a> <span class='Operator'>= </span><a href="../../../include/utils/syscache.h.html#LN155"><span class='Ref_to_Macro'>SearchSysCache1</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/syscache.h.html#LN76"><span class='Ref_to_EnumConst'>PROCOID</span></a><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4769"><span class='Ref_To_Local'>func_oid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4770"><span class='Ref_To_Local'>func_tuple</span></a><span class='Parentheses'>))</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for function %u"</span><span class='Delimiter'>, </span><a href="clauses.c.html#LN4769"><span class='Ref_To_Local'>func_oid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4771"><span class='Ref_To_Local'>funcform</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_proc.h.html#LN82"><span class='Ref_to_Typedef'>Form_pg_proc</span></a><span class='Parentheses'>) </span><a href="../../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4770"><span class='Ref_To_Local'>func_tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Forget it if the function is not SQL-language or has other showstopper 
     * properties.  In particular it mustn't be declared STRICT, since we 
     * couldn't enforce that.  It also mustn't be VOLATILE, because that is 
     * supposed to cause it to be executed with its own snapshot, rather than 
     * sharing the snapshot of the calling query.  (Rechecking proretset is 
     * just paranoia.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN4771"><span class='Ref_To_Local'>funcform</span></a><span class='Operator'>-&GT;</span>prolang <span class='Operator'>!= </span><a href="../../../include/catalog/pg_language.h.html#LN79"><span class='Ref_to_Const'>SQLlanguageId</span></a> <span class='Operator'>|| 
</span>        <a href="clauses.c.html#LN4771"><span class='Ref_To_Local'>funcform</span></a><span class='Operator'>-&GT;</span>proisstrict <span class='Operator'>|| 
</span>        <a href="clauses.c.html#LN4771"><span class='Ref_To_Local'>funcform</span></a><span class='Operator'>-&GT;</span>provolatile <span class='Operator'>== </span><a href="../../../include/catalog/pg_proc.h.html#LN5484"><span class='Ref_to_Const'>PROVOLATILE_VOLATILE</span></a> <span class='Operator'>|| 
</span>        <a href="clauses.c.html#LN4771"><span class='Ref_To_Local'>funcform</span></a><span class='Operator'>-&GT;</span>prosecdef <span class='Operator'>|| 
</span>        <span class='Operator'>!</span><a href="clauses.c.html#LN4771"><span class='Ref_To_Local'>funcform</span></a><span class='Operator'>-&GT;</span>proretset <span class='Operator'>|| 
</span>        <span class='Operator'>!</span><a href="../../access/common/heaptuple.c.html#LN295"><span class='Ref_to_Func'>heap_attisnull</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4770"><span class='Ref_To_Local'>func_tuple</span></a><span class='Delimiter'>, </span><a href="../../../include/catalog/pg_proc.h.html#LN116"><span class='Ref_to_Const'>Anum_pg_proc_proconfig</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4770"><span class='Ref_To_Local'>func_tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Make a temporary memory context, so that we don't leak all the stuff 
     * that parsing might create. 
     */ 
</span>    <a href="clauses.c.html#LN4777"><span class='Ref_To_Local'>mycxt</span></a> <span class='Operator'>= </span><a href="../../../include/utils/memutils.h.html#LN145"><span class='Ref_to_Proto'>AllocSetContextCreate</span></a><span class='Parentheses'>(</span><a href="../../utils/mmgr/mcxt.c.html#LN36"><span class='Ref_to_Global_Var'>CurrentMemoryContext</span></a><span class='Delimiter'>, 
</span>                                  <span class='String'>"inline_set_returning_function"</span><span class='Delimiter'>, 
</span>                                  <a href="../../../include/utils/memutils.h.html#LN164"><span class='Ref_to_Const'>ALLOCSET_DEFAULT_SIZES</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4776"><span class='Ref_To_Local'>oldcxt</span></a> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4777"><span class='Ref_To_Local'>mycxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * When we call eval_const_expressions below, it might try to add items to 
     * root-&GT;glob-&GT;invalItems.  Since it is running in the temp context, those 
     * items will be in that context, and will need to be copied out if we're 
     * successful.  Temporarily reset the list so that we can keep those items 
     * separate from the pre-existing list contents. 
     */ 
</span>    <a href="clauses.c.html#LN4778"><span class='Ref_To_Local'>saveInvalItems</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN4765"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN156"><span class='Ref_to_Member'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN114"><span class='Ref_to_Member'>invalItems</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4765"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN156"><span class='Ref_to_Member'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN114"><span class='Ref_to_Member'>invalItems</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Fetch the function body */ 
</span>    <a href="clauses.c.html#LN4773"><span class='Ref_To_Local'>tmp</span></a> <span class='Operator'>= </span><a href="../../../include/utils/syscache.h.html#LN133"><span class='Ref_to_Proto'>SysCacheGetAttr</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/syscache.h.html#LN76"><span class='Ref_to_EnumConst'>PROCOID</span></a><span class='Delimiter'>, 
</span>                          <a href="clauses.c.html#LN4770"><span class='Ref_To_Local'>func_tuple</span></a><span class='Delimiter'>, 
</span>                          <a href="../../../include/catalog/pg_proc.h.html#LN114"><span class='Ref_to_Const'>Anum_pg_proc_prosrc</span></a><span class='Delimiter'>, 
</span>                          <span class='Operator'>&</span><a href="clauses.c.html#LN4774"><span class='Ref_To_Local'>isNull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN4774"><span class='Ref_To_Local'>isNull</span></a><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"null prosrc for function %u"</span><span class='Delimiter'>, </span><a href="clauses.c.html#LN4769"><span class='Ref_To_Local'>func_oid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4772"><span class='Ref_To_Local'>src</span></a> <span class='Operator'>= </span><a href="../../../include/utils/builtins.h.html#LN91"><span class='Ref_to_Macro'>TextDatumGetCString</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4773"><span class='Ref_To_Local'>tmp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Setup error traceback support for ereport().  This is so that we can 
     * finger the function that bad information came from. 
     */ 
</span>    <a href="clauses.c.html#LN4779"><span class='Ref_To_Local'>callback_arg</span></a><span class='Operator'>.</span><a href="clauses.c.html#LN87"><span class='Ref_to_Member'>proname</span></a> <span class='Operator'>= </span><a href="../../../include/c.h.html#LN498"><span class='Ref_to_Macro'>NameStr</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4771"><span class='Ref_To_Local'>funcform</span></a><span class='Operator'>-&GT;</span>proname<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4779"><span class='Ref_To_Local'>callback_arg</span></a><span class='Operator'>.</span><a href="clauses.c.html#LN88"><span class='Ref_to_Member'>prosrc</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN4772"><span class='Ref_To_Local'>src</span></a><span class='Delimiter'>; 
</span> 
    <a href="clauses.c.html#LN4780"><span class='Ref_To_Local'>sqlerrcontext</span></a><span class='Operator'>.</span>callback <span class='Operator'>= </span><a href="clauses.c.html#LN150"><span class='Ref_to_Proto'>sql_inline_error_callback</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4780"><span class='Ref_To_Local'>sqlerrcontext</span></a><span class='Operator'>.</span>arg <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="clauses.c.html#LN4779"><span class='Ref_To_Local'>callback_arg</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4780"><span class='Ref_To_Local'>sqlerrcontext</span></a><span class='Operator'>.</span>previous <span class='Operator'>= </span><a href="../../utils/error/elog.c.html#LN87"><span class='Ref_to_Global_Var'>error_context_stack</span></a><span class='Delimiter'>; 
</span>    <a href="../../utils/error/elog.c.html#LN87"><span class='Ref_to_Global_Var'>error_context_stack</span></a> <span class='Operator'>= &</span><a href="clauses.c.html#LN4780"><span class='Ref_To_Local'>sqlerrcontext</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Run eval_const_expressions on the function call.  This is necessary to 
     * ensure that named-argument notation is converted to positional notation 
     * and any default arguments are inserted.  It's a bit of overkill for the 
     * arguments, since they'll get processed again later, but no harm will be 
     * done. 
     */ 
</span>    <a href="clauses.c.html#LN4768"><span class='Ref_To_Local'>fexpr</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/clauses.h.html#LN80"><span class='Ref_to_Proto'>eval_const_expressions</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4765"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN4768"><span class='Ref_To_Local'>fexpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* It should still be a call of the same function, but let's check */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4768"><span class='Ref_To_Local'>fexpr</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <a href="clauses.c.html#LN4768"><span class='Ref_To_Local'>fexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN447"><span class='Ref_to_Member'>funcid</span></a> <span class='Operator'>!= </span><a href="clauses.c.html#LN4769"><span class='Ref_To_Local'>func_oid</span></a><span class='Parentheses'>)</span> 
        <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="clauses.c.html#LN5035"><span class='Ref_to_Label'>fail</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Arg list length should now match the function */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4768"><span class='Ref_To_Local'>fexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN455"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="clauses.c.html#LN4771"><span class='Ref_To_Local'>funcform</span></a><span class='Operator'>-&GT;</span>pronargs<span class='Parentheses'>)</span> 
        <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="clauses.c.html#LN5035"><span class='Ref_to_Label'>fail</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Set up to handle parameters while parsing the function body.  We can 
     * use the FuncExpr just created as the input for 
     * prepare_sql_fn_parse_info. 
     */ 
</span>    <a href="clauses.c.html#LN4781"><span class='Ref_To_Local'>pinfo</span></a> <span class='Operator'>= </span><a href="../../../include/executor/functions.h.html#LN24"><span class='Ref_to_Proto'>prepare_sql_fn_parse_info</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4770"><span class='Ref_To_Local'>func_tuple</span></a><span class='Delimiter'>, 
</span>                                      <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN4768"><span class='Ref_To_Local'>fexpr</span></a><span class='Delimiter'>, 
</span>                                      <a href="clauses.c.html#LN4768"><span class='Ref_To_Local'>fexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN454"><span class='Ref_to_Member'>inputcollid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Parse, analyze, and rewrite (unlike inline_function(), we can't skip 
     * rewriting here).  We can fail as soon as we find more than one query, 
     * though. 
     */ 
</span>    <a href="clauses.c.html#LN4782"><span class='Ref_To_Local'>raw_parsetree_list</span></a> <span class='Operator'>= </span><a href="../../../include/tcop/tcopprot.h.html#LN49"><span class='Ref_to_Proto'>pg_parse_query</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4772"><span class='Ref_To_Local'>src</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4782"><span class='Ref_To_Local'>raw_parsetree_list</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
        <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="clauses.c.html#LN5035"><span class='Ref_to_Label'>fail</span></a><span class='Delimiter'>; 
</span> 
    <a href="clauses.c.html#LN4783"><span class='Ref_To_Local'>querytree_list</span></a> <span class='Operator'>= </span><a href="../../../include/tcop/tcopprot.h.html#LN54"><span class='Ref_to_Proto'>pg_analyze_and_rewrite_params</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4782"><span class='Ref_To_Local'>raw_parsetree_list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                   <a href="clauses.c.html#LN4772"><span class='Ref_To_Local'>src</span></a><span class='Delimiter'>, 
</span>                                       <span class='Parentheses'>(</span><a href="../../../include/nodes/params.h.html#LN65"><span class='Ref_to_Typedef'>ParserSetupHook</span></a><span class='Parentheses'>) </span><a href="../../../include/executor/functions.h.html#LN28"><span class='Ref_to_Proto'>sql_fn_parser_setup</span></a><span class='Delimiter'>, 
</span>                                                   <a href="clauses.c.html#LN4781"><span class='Ref_To_Local'>pinfo</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4783"><span class='Ref_To_Local'>querytree_list</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
        <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="clauses.c.html#LN5035"><span class='Ref_to_Label'>fail</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4784"><span class='Ref_To_Local'>querytree</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4783"><span class='Ref_To_Local'>querytree_list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The single command must be a plain SELECT. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4784"><span class='Ref_To_Local'>querytree</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <a href="clauses.c.html#LN4784"><span class='Ref_To_Local'>querytree</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN109"><span class='Ref_to_Member'>commandType</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/nodes.h.html#LN650"><span class='Ref_to_EnumConst'>CMD_SELECT</span></a><span class='Parentheses'>)</span> 
        <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="clauses.c.html#LN5035"><span class='Ref_to_Label'>fail</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Make sure the function (still) returns what it's declared to.  This 
     * will raise an error if wrong, but that's okay since the function would 
     * fail at runtime anyway.  Note that check_sql_fn_retval will also insert 
     * RelabelType(s) and/or NULL columns if needed to make the tlist 
     * expression(s) match the declared type of the function. 
     * 
     * If the function returns a composite type, don't inline unless the check 
     * shows it's returning a whole tuple result; otherwise what it's 
     * returning is a single composite column which is not what we need. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/executor/functions.h.html#LN31"><span class='Ref_to_Proto'>check_sql_fn_retval</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4769"><span class='Ref_To_Local'>func_oid</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN4768"><span class='Ref_To_Local'>fexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN448"><span class='Ref_to_Member'>funcresulttype</span></a><span class='Delimiter'>, 
</span>                             <a href="clauses.c.html#LN4783"><span class='Ref_To_Local'>querytree_list</span></a><span class='Delimiter'>, 
</span>                             <span class='Operator'>&</span><a href="clauses.c.html#LN4775"><span class='Ref_To_Local'>modifyTargetList</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>        <span class='Parentheses'>(</span><a href="../../../include/utils/lsyscache.h.html#LN149"><span class='Ref_to_Proto'>get_typtype</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4768"><span class='Ref_To_Local'>fexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN448"><span class='Ref_to_Member'>funcresulttype</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="../../../include/catalog/pg_type.h.html#LN720"><span class='Ref_to_Const'>TYPTYPE_COMPOSITE</span></a> <span class='Operator'>|| 
</span>         <a href="clauses.c.html#LN4768"><span class='Ref_To_Local'>fexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN448"><span class='Ref_to_Member'>funcresulttype</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_type.h.html#LN679"><span class='Ref_to_Const'>RECORDOID</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="clauses.c.html#LN5035"><span class='Ref_to_Label'>fail</span></a><span class='Delimiter'>;</span>              <span class='Comment_Single_Line'>/* reject not-whole-tuple-result cases */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we had to modify the tlist to make it match, and the statement is 
     * one in which changing the tlist contents could change semantics, we 
     * have to punt and not inline. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN4775"><span class='Ref_To_Local'>modifyTargetList</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="clauses.c.html#LN5035"><span class='Ref_to_Label'>fail</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If it returns RECORD, we have to check against the column type list 
     * provided in the RTE; check_sql_fn_retval can't do that.  (If no match, 
     * we just fail to inline, rather than complaining; see notes for 
     * tlist_matches_coltypelist.)  We don't have to do this for functions 
     * with declared OUT parameters, even though their funcresulttype is 
     * RECORDOID, so check get_func_result_type too. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN4768"><span class='Ref_To_Local'>fexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN448"><span class='Ref_to_Member'>funcresulttype</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_type.h.html#LN679"><span class='Ref_to_Const'>RECORDOID</span></a> <span class='Operator'>&& 
</span>        <a href="../../../include/funcapi.h.html#LN163"><span class='Ref_to_Proto'>get_func_result_type</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4769"><span class='Ref_To_Local'>func_oid</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="../../../include/funcapi.h.html#LN153"><span class='Ref_to_EnumConst'>TYPEFUNC_RECORD</span></a> <span class='Operator'>&& 
</span>        <span class='Operator'>!</span><a href="clauses.c.html#LN157"><span class='Ref_to_Proto'>tlist_matches_coltypelist</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4784"><span class='Ref_To_Local'>querytree</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Delimiter'>, 
</span>                                   <a href="clauses.c.html#LN4767"><span class='Ref_To_Local'>rtfunc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1059"><span class='Ref_to_Member'>funccoltypes</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="clauses.c.html#LN5035"><span class='Ref_to_Label'>fail</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Looks good --- substitute parameters into the query. 
     */ 
</span>    <a href="clauses.c.html#LN4784"><span class='Ref_To_Local'>querytree</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN153"><span class='Ref_to_Proto'>substitute_actual_srf_parameters</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4784"><span class='Ref_To_Local'>querytree</span></a><span class='Delimiter'>, 
</span>                                                 <a href="clauses.c.html#LN4771"><span class='Ref_To_Local'>funcform</span></a><span class='Operator'>-&GT;</span>pronargs<span class='Delimiter'>, 
</span>                                                 <a href="clauses.c.html#LN4768"><span class='Ref_To_Local'>fexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN455"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Copy the modified query out of the temporary memory context, and clean 
     * up. 
     */ 
</span>    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4776"><span class='Ref_To_Local'>oldcxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="clauses.c.html#LN4784"><span class='Ref_To_Local'>querytree</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4784"><span class='Ref_To_Local'>querytree</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* copy up any new invalItems, too */ 
</span>    <a href="clauses.c.html#LN4765"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN156"><span class='Ref_to_Member'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN114"><span class='Ref_to_Member'>invalItems</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4778"><span class='Ref_To_Local'>saveInvalItems</span></a><span class='Delimiter'>, 
</span>                                         <a href="../../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4765"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN156"><span class='Ref_to_Member'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN114"><span class='Ref_to_Member'>invalItems</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/memutils.h.html#LN74"><span class='Ref_to_Proto'>MemoryContextDelete</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4777"><span class='Ref_To_Local'>mycxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../utils/error/elog.c.html#LN87"><span class='Ref_to_Global_Var'>error_context_stack</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN4780"><span class='Ref_To_Local'>sqlerrcontext</span></a><span class='Operator'>.</span>previous<span class='Delimiter'>; 
</span>    <a href="../../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4770"><span class='Ref_To_Local'>func_tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We don't have to fix collations here because the upper query is already 
     * parsed, ie, the collations in the RTE are what count. 
     */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Since there is now no trace of the function in the plan tree, we must 
     * explicitly record the plan's dependency on the function. 
     */ 
</span>    <a href="../../../include/optimizer/planmain.h.html#LN116"><span class='Ref_to_Proto'>record_plan_function_dependency</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4765"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN4769"><span class='Ref_To_Local'>func_oid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="clauses.c.html#LN4784"><span class='Ref_To_Local'>querytree</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Here if func is not inlinable: release temp memory and return NULL */ 
</span><a name="LN5035"></a><span class='Label'>fail</span><span class='Operator'>: 
</span>    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4776"><span class='Ref_To_Local'>oldcxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN4765"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN156"><span class='Ref_to_Member'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN114"><span class='Ref_to_Member'>invalItems</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN4778"><span class='Ref_To_Local'>saveInvalItems</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/utils/memutils.h.html#LN74"><span class='Ref_to_Proto'>MemoryContextDelete</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4777"><span class='Ref_To_Local'>mycxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../utils/error/elog.c.html#LN87"><span class='Ref_to_Global_Var'>error_context_stack</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN4780"><span class='Ref_To_Local'>sqlerrcontext</span></a><span class='Operator'>.</span>previous<span class='Delimiter'>; 
</span>    <a href="../../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN4770"><span class='Ref_To_Local'>func_tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end inline_set_returning_function &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Replace Param nodes by appropriate actual parameters 
 * 
 * This is just enough different from substitute_actual_parameters() 
 * that it needs its own code. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>* 
</span><a name="LN5052"></a><span class='Declare_Function'>substitute_actual_srf_parameters</span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>expr</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>nargs</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>args</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN5054"></a>    <a href="clauses.c.html#LN78"><span class='Ref_to_Typedef'>substitute_actual_srf_parameters_context</span></a> <span class='Declare_Local'>context</span><span class='Delimiter'>; 
</span> 
    <a href="clauses.c.html#LN5054"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="clauses.c.html#LN80"><span class='Ref_to_Member'>nargs</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN5052"><span class='Ref_to_Parameter'>nargs</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN5054"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="clauses.c.html#LN81"><span class='Ref_to_Member'>args</span></a> <span class='Operator'>= </span><a href="clauses.c.html#LN5052"><span class='Ref_to_Parameter'>args</span></a><span class='Delimiter'>; 
</span>    <a href="clauses.c.html#LN5054"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="clauses.c.html#LN82"><span class='Ref_to_Member'>sublevels_up</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="../../../include/nodes/nodeFuncs.h.html#LN59"><span class='Ref_to_Proto'>query_tree_mutator</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN5052"><span class='Ref_to_Parameter'>expr</span></a><span class='Delimiter'>, 
</span>                              <a href="clauses.c.html#LN155"><span class='Ref_to_Proto'>substitute_actual_srf_parameters_mutator</span></a><span class='Delimiter'>, 
</span>                              <span class='Operator'>&</span><a href="clauses.c.html#LN5054"><span class='Ref_To_Local'>context</span></a><span class='Delimiter'>, 
</span>                              <span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN5067"></a><span class='Declare_Function'>substitute_actual_srf_parameters_mutator</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, 
</span><a name="LN5068"></a>                           <a href="clauses.c.html#LN78"><span class='Ref_to_Typedef'>substitute_actual_srf_parameters_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN5070"></a>    <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN5067"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN5067"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="clauses.c.html#LN5068"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN82"><span class='Ref_to_Member'>sublevels_up</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <a href="clauses.c.html#LN5070"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/nodeFuncs.h.html#LN59"><span class='Ref_to_Proto'>query_tree_mutator</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN5067"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, 
</span>                                    <a href="clauses.c.html#LN155"><span class='Ref_to_Proto'>substitute_actual_srf_parameters_mutator</span></a><span class='Delimiter'>, 
</span>                                             <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN5068"><span class='Ref_to_Parameter'>context</span></a><span class='Delimiter'>, 
</span>                                             <span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="clauses.c.html#LN5068"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN82"><span class='Ref_to_Member'>sublevels_up</span></a><span class='Operator'>--</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <a href="clauses.c.html#LN5070"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN5067"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN240"><span class='Ref_to_Struct'>Param</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN5086"></a>        <a href="../../../include/nodes/primnodes.h.html#LN240"><span class='Ref_to_Struct'>Param</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>param</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN240"><span class='Ref_to_Struct'>Param</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN5067"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN5086"><span class='Ref_To_Local'>param</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN243"><span class='Ref_to_Member'>paramkind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/primnodes.h.html#LN234"><span class='Ref_to_EnumConst'>PARAM_EXTERN</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN5086"><span class='Ref_To_Local'>param</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN244"><span class='Ref_to_Member'>paramid</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span> <span class='Operator'>|| </span><a href="clauses.c.html#LN5086"><span class='Ref_To_Local'>param</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN244"><span class='Ref_to_Member'>paramid</span></a> <span class='Operator'>&GT; </span><a href="clauses.c.html#LN5068"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN80"><span class='Ref_to_Member'>nargs</span></a><span class='Parentheses'>) 
</span>                <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"invalid paramid: %d"</span><span class='Delimiter'>, </span><a href="clauses.c.html#LN5086"><span class='Ref_To_Local'>param</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN244"><span class='Ref_to_Member'>paramid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Since the parameter is being inserted into a subquery, we must 
             * adjust levels. 
             */ 
</span>            <a href="clauses.c.html#LN5070"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN223"><span class='Ref_to_Proto'>list_nth</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN5068"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN81"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN5086"><span class='Ref_To_Local'>param</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN244"><span class='Ref_to_Member'>paramid</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="../../../include/rewrite/rewriteManip.h.html#LN44"><span class='Ref_to_Proto'>IncrementVarSublevelsUp</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN5070"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN5068"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="clauses.c.html#LN82"><span class='Ref_to_Member'>sublevels_up</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <a href="clauses.c.html#LN5070"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <a href="../../../include/nodes/nodeFuncs.h.html#LN54"><span class='Ref_to_Proto'>expression_tree_mutator</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN5067"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, 
</span>                                   <a href="clauses.c.html#LN155"><span class='Ref_to_Proto'>substitute_actual_srf_parameters_mutator</span></a><span class='Delimiter'>, 
</span>                                   <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN5068"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end substitute_actual_srf_parameters_mutator &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Check whether a SELECT targetlist emits the specified column types, 
 * to see if it's safe to inline a function returning record. 
 * 
 * We insist on exact match here.  The executor allows binary-coercible 
 * cases too, but we don't have a way to preserve the correct column types 
 * in the correct places if we inline the function in such a case. 
 * 
 * Note that we only check type OIDs not typmods; this agrees with what the 
 * executor would do at runtime, and attributing a specific typmod to a 
 * function result is largely wishful thinking anyway. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN5120"></a><span class='Declare_Function'>tlist_matches_coltypelist</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tlist</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>coltypelist</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN5122"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>tlistitem</span><span class='Delimiter'>; 
</span><a name="LN5123"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>clistitem</span><span class='Delimiter'>; 
</span> 
    <a href="clauses.c.html#LN5123"><span class='Ref_To_Local'>clistitem</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN5120"><span class='Ref_to_Parameter'>coltypelist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN5122"><span class='Ref_To_Local'>tlistitem</span></a><span class='Delimiter'>, </span><a href="clauses.c.html#LN5120"><span class='Ref_to_Parameter'>tlist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN5128"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN5122"><span class='Ref_To_Local'>tlistitem</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN5129"></a>        <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>coltype</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN5128"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1373"><span class='Ref_to_Member'>resjunk</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* ignore junk columns */ 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN5123"><span class='Ref_To_Local'>clistitem</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* too many tlist items */ 
</span> 
        <a href="clauses.c.html#LN5129"><span class='Ref_To_Local'>coltype</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN107"><span class='Ref_to_Macro'>lfirst_oid</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN5123"><span class='Ref_To_Local'>clistitem</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="clauses.c.html#LN5123"><span class='Ref_To_Local'>clistitem</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="clauses.c.html#LN5123"><span class='Ref_To_Local'>clistitem</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="clauses.c.html#LN5128"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Parentheses'>)</span> <span class='Operator'>!= </span><a href="clauses.c.html#LN5129"><span class='Ref_To_Local'>coltype</span></a><span class='Parentheses'>)</span> 
            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* column type mismatch */ 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="clauses.c.html#LN5123"><span class='Ref_To_Local'>clistitem</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* too few tlist items */ 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end tlist_matches_coltypelist &raquo; </span> 
</pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>