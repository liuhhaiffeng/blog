<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\optimizer\util\orclauses.c</title>
<LINK REL=StyleSheet HREF="../../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\optimizer\util\orclauses.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:43 2017
</td></tr>
<tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * orclauses.c 
 *    Routines to extract restriction OR clauses from join OR clauses 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * 
 * IDENTIFICATION 
 *    src/backend/optimizer/util/orclauses.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span> 
<span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"optimizer/clauses.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/cost.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/orclauses.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/restrictinfo.h"</span> 
 
 
<a name="LN23"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>is_safe_restriction_clause_for</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rinfo</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN24"></a><span class='Keyword'>static </span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>extract_or_clause</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>or_rinfo</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN25"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>consider_new_or_clause</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN26"></a>                       <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>orclause</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>join_or_rinfo</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * extract_restriction_or_clauses 
 *    Examine join OR-of-AND clauses to see if any useful restriction OR 
 *    clauses can be extracted.  If so, add them to the query. 
 * 
 * Although a join clause must reference multiple relations overall, 
 * an OR of ANDs clause might contain sub-clauses that reference just one 
 * relation and can be used to build a restriction clause for that rel. 
 * For example consider 
 *      WHERE ((a.x = 42 AND b.y = 43) OR (a.x = 44 AND b.z = 45)); 
 * We can transform this into 
 *      WHERE ((a.x = 42 AND b.y = 43) OR (a.x = 44 AND b.z = 45)) 
 *          AND (a.x = 42 OR a.x = 44) 
 *          AND (b.y = 43 OR b.z = 45); 
 * which allows the latter clauses to be applied during the scans of a and b, 
 * perhaps as index qualifications, and in any case reducing the number of 
 * rows arriving at the join.  In essence this is a partial transformation to 
 * CNF (AND of ORs format).  It is not complete, however, because we do not 
 * unravel the original OR --- doing so would usually bloat the qualification 
 * expression to little gain. 
 * 
 * The added quals are partially redundant with the original OR, and therefore 
 * would cause the size of the joinrel to be underestimated when it is finally 
 * formed.  (This would be true of a full transformation to CNF as well; the 
 * fault is not really in the transformation, but in clauselist_selectivity's 
 * inability to recognize redundant conditions.)  We can compensate for this 
 * redundancy by changing the cached selectivity of the original OR clause, 
 * canceling out the (valid) reduction in the estimated sizes of the base 
 * relations so that the estimated joinrel size remains the same.  This is 
 * a MAJOR HACK: it depends on the fact that clause selectivities are cached 
 * and on the fact that the same RestrictInfo node will appear in every 
 * joininfo list that might be used when the joinrel is formed. 
 * And it doesn't work in cases where the size estimation is nonlinear 
 * (i.e., outer and IN joins).  But it beats not doing anything. 
 * 
 * We examine each base relation to see if join clauses associated with it 
 * contain extractable restriction conditions.  If so, add those conditions 
 * to the rel's baserestrictinfo and update the cached selectivities of the 
 * join clauses.  Note that the same join clause will be examined afresh 
 * from the point of view of each baserel that participates in it, so its 
 * cached selectivity may get updated multiple times. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN72"></a><span class='Declare_Function'>extract_restriction_or_clauses</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN74"></a>    <a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Local'>rti</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Examine each baserel for potential join OR clauses */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="orclauses.c.html#LN74"><span class='Ref_To_Local'>rti</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="orclauses.c.html#LN74"><span class='Ref_To_Local'>rti</span></a> <span class='Operator'>&LT; </span><a href="orclauses.c.html#LN72"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN179"><span class='Ref_to_Member'>simple_rel_array_size</span></a><span class='Delimiter'>; </span><a href="orclauses.c.html#LN74"><span class='Ref_To_Local'>rti</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN79"></a>        <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rel</span> <span class='Operator'>= </span><a href="orclauses.c.html#LN72"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN178"><span class='Ref_to_Member'>simple_rel_array</span></a><span class='Delimiter'>[</span><a href="orclauses.c.html#LN74"><span class='Ref_To_Local'>rti</span></a><span class='Delimiter'>]; 
</span><a name="LN80"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* there may be empty slots corresponding to non-baserel RTEs */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="orclauses.c.html#LN79"><span class='Ref_To_Local'>rel</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="orclauses.c.html#LN79"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a> <span class='Operator'>== </span><a href="orclauses.c.html#LN74"><span class='Ref_To_Local'>rti</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* sanity check on array */ 
</span> 
        <span class='Comment_Multi_Line'>/* ignore RTEs that are "other rels" */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="orclauses.c.html#LN79"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN521"><span class='Ref_to_Member'>reloptkind</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/relation.h.html#LN493"><span class='Ref_to_EnumConst'>RELOPT_BASEREL</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Find potentially interesting OR joinclauses.  We can use any 
         * joinclause that is considered safe to move to this rel by the 
         * parameterized-path machinery, even though what we are going to do 
         * with it is not exactly a parameterized path. 
         * 
         * However, it seems best to ignore clauses that have been marked 
         * redundant (by setting norm_selec &GT; 1).  That likely can't happen 
         * for OR clauses, but let's be safe. 
         */ 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="orclauses.c.html#LN80"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="orclauses.c.html#LN79"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN588"><span class='Ref_to_Member'>joininfo</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN104"></a>            <a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="orclauses.c.html#LN80"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/restrictinfo.h.html#LN31"><span class='Ref_to_Proto'>restriction_is_or_clause</span></a><span class='Parentheses'>(</span><a href="orclauses.c.html#LN104"><span class='Ref_To_Local'>rinfo</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                <a href="../../../include/optimizer/restrictinfo.h.html#LN40"><span class='Ref_to_Proto'>join_clause_is_movable_to</span></a><span class='Parentheses'>(</span><a href="orclauses.c.html#LN104"><span class='Ref_To_Local'>rinfo</span></a><span class='Delimiter'>, </span><a href="orclauses.c.html#LN79"><span class='Ref_To_Local'>rel</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                <a href="orclauses.c.html#LN104"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1784"><span class='Ref_to_Member'>norm_selec</span></a> <span class='Operator'>&LT;= </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Try to extract a qual for this rel only */ 
</span><a name="LN111"></a>                <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>orclause</span> <span class='Operator'>= </span><a href="orclauses.c.html#LN24"><span class='Ref_to_Proto'>extract_or_clause</span></a><span class='Parentheses'>(</span><a href="orclauses.c.html#LN104"><span class='Ref_To_Local'>rinfo</span></a><span class='Delimiter'>, </span><a href="orclauses.c.html#LN79"><span class='Ref_To_Local'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * If successful, decide whether we want to use the clause, 
                 * and insert it into the rel's restrictinfo list if so. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="orclauses.c.html#LN111"><span class='Ref_To_Local'>orclause</span></a><span class='Parentheses'>) 
</span>                    <a href="orclauses.c.html#LN25"><span class='Ref_to_Proto'>consider_new_or_clause</span></a><span class='Parentheses'>(</span><a href="orclauses.c.html#LN72"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="orclauses.c.html#LN79"><span class='Ref_To_Local'>rel</span></a><span class='Delimiter'>, </span><a href="orclauses.c.html#LN111"><span class='Ref_To_Local'>orclause</span></a><span class='Delimiter'>, </span><a href="orclauses.c.html#LN104"><span class='Ref_To_Local'>rinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for rti=1;rti&LT;root-&GT;simpl... &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end extract_restriction_or_clauses &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Is the given primitive (non-OR) RestrictInfo safe to move to the rel? 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN128"></a><span class='Declare_Function'>is_safe_restriction_clause_for</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rinfo</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * We want clauses that mention the rel, and only the rel.  So in 
     * particular pseudoconstant clauses can be rejected quickly.  Then check 
     * the clause's Var membership. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="orclauses.c.html#LN128"><span class='Ref_to_Parameter'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1754"><span class='Ref_to_Member'>pseudoconstant</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN66"><span class='Ref_to_Proto'>bms_equal</span></a><span class='Parentheses'>(</span><a href="orclauses.c.html#LN128"><span class='Ref_to_Parameter'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1761"><span class='Ref_to_Member'>clause_relids</span></a><span class='Delimiter'>, </span><a href="orclauses.c.html#LN128"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* We don't want extra evaluations of any volatile functions */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/clauses.h.html#LN60"><span class='Ref_to_Proto'>contain_volatile_functions</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="orclauses.c.html#LN128"><span class='Ref_to_Parameter'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1746"><span class='Ref_to_Member'>clause</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Try to extract a restriction clause mentioning only "rel" from the given 
 * join OR-clause. 
 * 
 * We must be able to extract at least one qual for this rel from each of 
 * the arms of the OR, else we can't use it. 
 * 
 * Returns an OR clause (not a RestrictInfo!) pertaining to rel, or NULL 
 * if no OR clause could be extracted. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>* 
</span><a name="LN158"></a><span class='Declare_Function'>extract_or_clause</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>or_rinfo</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN160"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>clauselist</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN161"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Scan each arm of the input OR clause.  Notice we descend into 
     * or_rinfo-&GT;orclause, which has RestrictInfo nodes embedded below the 
     * toplevel OR/AND structure.  This is useful because we can use the info 
     * in those nodes to make is_safe_restriction_clause_for()'s checks 
     * cheaper.  We'll strip those nodes from the returned tree, though, 
     * meaning that fresh ones will be built if the clause is accepted as a 
     * restriction clause.  This might seem wasteful --- couldn't we re-use 
     * the existing RestrictInfos?  But that'd require assuming that 
     * selectivity and other cached data is computed exactly the same way for 
     * a restriction clause as for a join clause, which seems undesirable. 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/optimizer/clauses.h.html#LN39"><span class='Ref_to_Proto'>or_clause</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="orclauses.c.html#LN158"><span class='Ref_to_Parameter'>or_rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1777"><span class='Ref_to_Member'>orclause</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="orclauses.c.html#LN161"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="orclauses.c.html#LN158"><span class='Ref_to_Parameter'>or_rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1777"><span class='Ref_to_Member'>orclause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>args<span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span><a name="LN178"></a>        <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>orarg</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="orclauses.c.html#LN161"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN179"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>subclauses</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN180"></a>        <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>subclause</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* OR arguments should be ANDs or sub-RestrictInfos */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/clauses.h.html#LN42"><span class='Ref_to_Proto'>and_clause</span></a><span class='Parentheses'>(</span><a href="orclauses.c.html#LN178"><span class='Ref_To_Local'>orarg</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN185"></a>            <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>andargs</span> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="orclauses.c.html#LN178"><span class='Ref_To_Local'>orarg</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>args<span class='Delimiter'>; 
</span><a name="LN186"></a>            <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc2</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="orclauses.c.html#LN186"><span class='Ref_To_Local'>lc2</span></a><span class='Delimiter'>, </span><a href="orclauses.c.html#LN185"><span class='Ref_To_Local'>andargs</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN190"></a>                <a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rinfo</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN108"><span class='Ref_to_Macro'>lfirst_node</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a><span class='Delimiter'>, </span><a href="orclauses.c.html#LN186"><span class='Ref_To_Local'>lc2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/restrictinfo.h.html#LN31"><span class='Ref_to_Proto'>restriction_is_or_clause</span></a><span class='Parentheses'>(</span><a href="orclauses.c.html#LN190"><span class='Ref_To_Local'>rinfo</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* 
                     * Recurse to deal with nested OR.  Note we *must* recurse 
                     * here, this isn't just overly-tense optimization: we 
                     * have to descend far enough to find and strip all 
                     * RestrictInfos in the expression. 
                     */ 
</span><a name="LN200"></a>                    <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>suborclause</span><span class='Delimiter'>; 
</span> 
                    <a href="orclauses.c.html#LN200"><span class='Ref_To_Local'>suborclause</span></a> <span class='Operator'>= </span><a href="orclauses.c.html#LN24"><span class='Ref_to_Proto'>extract_or_clause</span></a><span class='Parentheses'>(</span><a href="orclauses.c.html#LN190"><span class='Ref_To_Local'>rinfo</span></a><span class='Delimiter'>, </span><a href="orclauses.c.html#LN158"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="orclauses.c.html#LN200"><span class='Ref_To_Local'>suborclause</span></a><span class='Parentheses'>) 
</span>                        <a href="orclauses.c.html#LN179"><span class='Ref_To_Local'>subclauses</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="orclauses.c.html#LN179"><span class='Ref_To_Local'>subclauses</span></a><span class='Delimiter'>, </span><a href="orclauses.c.html#LN200"><span class='Ref_To_Local'>suborclause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="orclauses.c.html#LN23"><span class='Ref_to_Proto'>is_safe_restriction_clause_for</span></a><span class='Parentheses'>(</span><a href="orclauses.c.html#LN190"><span class='Ref_To_Local'>rinfo</span></a><span class='Delimiter'>, </span><a href="orclauses.c.html#LN158"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>))</span> 
                    <a href="orclauses.c.html#LN179"><span class='Ref_To_Local'>subclauses</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="orclauses.c.html#LN179"><span class='Ref_To_Local'>subclauses</span></a><span class='Delimiter'>, </span><a href="orclauses.c.html#LN190"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1746"><span class='Ref_to_Member'>clause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if and_clause(orarg) &raquo; </span> 
        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span><a name="LN212"></a>            <a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rinfo</span> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN575"><span class='Ref_to_Macro'>castNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a><span class='Delimiter'>, </span><a href="orclauses.c.html#LN178"><span class='Ref_To_Local'>orarg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/optimizer/restrictinfo.h.html#LN31"><span class='Ref_to_Proto'>restriction_is_or_clause</span></a><span class='Parentheses'>(</span><a href="orclauses.c.html#LN212"><span class='Ref_To_Local'>rinfo</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="orclauses.c.html#LN23"><span class='Ref_to_Proto'>is_safe_restriction_clause_for</span></a><span class='Parentheses'>(</span><a href="orclauses.c.html#LN212"><span class='Ref_To_Local'>rinfo</span></a><span class='Delimiter'>, </span><a href="orclauses.c.html#LN158"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>))</span> 
                <a href="orclauses.c.html#LN179"><span class='Ref_To_Local'>subclauses</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="orclauses.c.html#LN179"><span class='Ref_To_Local'>subclauses</span></a><span class='Delimiter'>, </span><a href="orclauses.c.html#LN212"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1746"><span class='Ref_to_Member'>clause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If nothing could be extracted from this arm, we can't do anything 
         * with this OR clause. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="orclauses.c.html#LN179"><span class='Ref_To_Local'>subclauses</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * OK, add subclause(s) to the result OR.  If we found more than one, 
         * we need an AND node.  But if we found only one, and it is itself an 
         * OR node, add its subclauses to the result instead; this is needed 
         * to preserve AND/OR flatness (ie, no OR directly underneath OR). 
         */ 
</span>        <a href="orclauses.c.html#LN180"><span class='Ref_To_Local'>subclause</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/clauses.h.html#LN45"><span class='Ref_to_Proto'>make_ands_explicit</span></a><span class='Parentheses'>(</span><a href="orclauses.c.html#LN179"><span class='Ref_To_Local'>subclauses</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/clauses.h.html#LN39"><span class='Ref_to_Proto'>or_clause</span></a><span class='Parentheses'>(</span><a href="orclauses.c.html#LN180"><span class='Ref_To_Local'>subclause</span></a><span class='Parentheses'>))</span> 
            <a href="orclauses.c.html#LN160"><span class='Ref_To_Local'>clauselist</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="orclauses.c.html#LN160"><span class='Ref_To_Local'>clauselist</span></a><span class='Delimiter'>, 
</span>                                  <a href="../../../include/nodes/pg_list.h.html#LN268"><span class='Ref_to_Proto'>list_copy</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="orclauses.c.html#LN180"><span class='Ref_To_Local'>subclause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>args<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="orclauses.c.html#LN160"><span class='Ref_To_Local'>clauselist</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="orclauses.c.html#LN160"><span class='Ref_To_Local'>clauselist</span></a><span class='Delimiter'>, </span><a href="orclauses.c.html#LN180"><span class='Ref_To_Local'>subclause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we got a restriction clause from every arm, wrap them up in an OR 
     * node.  (In theory the OR node might be unnecessary, if there was only 
     * one arm --- but then the input OR node was also redundant.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="orclauses.c.html#LN160"><span class='Ref_To_Local'>clauselist</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="../../../include/optimizer/clauses.h.html#LN40"><span class='Ref_to_Proto'>make_orclause</span></a><span class='Parentheses'>(</span><a href="orclauses.c.html#LN160"><span class='Ref_To_Local'>clauselist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end extract_or_clause &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Consider whether a successfully-extracted restriction OR clause is 
 * actually worth using.  If so, add it to the planner's data structures, 
 * and adjust the original join clause (join_or_rinfo) to compensate. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN256"></a><span class='Declare_Function'>consider_new_or_clause</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN257"></a>                       <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>orclause</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>join_or_rinfo</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN259"></a>    <a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>or_rinfo</span><span class='Delimiter'>; 
</span><a name="LN260"></a>    <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>or_selec</span><span class='Delimiter'>, 
</span><a name="LN261"></a>                <span class='Declare_Local'>orig_selec</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Build a RestrictInfo from the new OR clause.  We can assume it's valid 
     * as a base restriction clause. 
     */ 
</span>    <a href="orclauses.c.html#LN259"><span class='Ref_To_Local'>or_rinfo</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/restrictinfo.h.html#LN23"><span class='Ref_to_Proto'>make_restrictinfo</span></a><span class='Parentheses'>(</span><a href="orclauses.c.html#LN257"><span class='Ref_to_Parameter'>orclause</span></a><span class='Delimiter'>, 
</span>                                 <span class='Boolean'>true</span><span class='Delimiter'>, 
</span>                                 <span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                                 <span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                                 <a href="orclauses.c.html#LN257"><span class='Ref_to_Parameter'>join_or_rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1758"><span class='Ref_to_Member'>security_level</span></a><span class='Delimiter'>, 
</span>                                 <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                 <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                 <span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Estimate its selectivity.  (We could have done this earlier, but doing 
     * it on the RestrictInfo representation allows the result to get cached, 
     * saving work later.) 
     */ 
</span>    <a href="orclauses.c.html#LN260"><span class='Ref_To_Local'>or_selec</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/cost.h.html#LN202"><span class='Ref_to_Proto'>clause_selectivity</span></a><span class='Parentheses'>(</span><a href="orclauses.c.html#LN256"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="orclauses.c.html#LN259"><span class='Ref_To_Local'>or_rinfo</span></a><span class='Delimiter'>, 
</span>                                  <span class='Number'>0</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN677"><span class='Ref_to_EnumConst'>JOIN_INNER</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The clause is only worth adding to the query if it rejects a useful 
     * fraction of the base relation's rows; otherwise, it's just going to 
     * cause duplicate computation (since we will still have to check the 
     * original OR clause when the join is formed).  Somewhat arbitrarily, we 
     * set the selectivity threshold at 0.9. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="orclauses.c.html#LN260"><span class='Ref_To_Local'>or_selec</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>9</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>;</span>                 <span class='Comment_Single_Line'>/* forget it */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * OK, add it to the rel's restriction-clause list. 
     */ 
</span>    <a href="orclauses.c.html#LN256"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN583"><span class='Ref_to_Member'>baserestrictinfo</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="orclauses.c.html#LN256"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN583"><span class='Ref_to_Member'>baserestrictinfo</span></a><span class='Delimiter'>, </span><a href="orclauses.c.html#LN259"><span class='Ref_To_Local'>or_rinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="orclauses.c.html#LN256"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN586"><span class='Ref_to_Member'>baserestrict_min_security</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN11"><span class='Ref_to_Macro'>Min</span></a><span class='Parentheses'>(</span><a href="orclauses.c.html#LN256"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN586"><span class='Ref_to_Member'>baserestrict_min_security</span></a><span class='Delimiter'>, 
</span>                                         <a href="orclauses.c.html#LN259"><span class='Ref_To_Local'>or_rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1758"><span class='Ref_to_Member'>security_level</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Adjust the original join OR clause's cached selectivity to compensate 
     * for the selectivity of the added (but redundant) lower-level qual. This 
     * should result in the join rel getting approximately the same rows 
     * estimate as it would have gotten without all these shenanigans. 
     * 
     * XXX major hack alert: this depends on the assumption that the 
     * selectivity will stay cached. 
     * 
     * XXX another major hack: we adjust only norm_selec, the cached 
     * selectivity for JOIN_INNER semantics, even though the join clause 
     * might've been an outer-join clause.  This is partly because we can't 
     * easily identify the relevant SpecialJoinInfo here, and partly because 
     * the linearity assumption we're making would fail anyway.  (If it is an 
     * outer-join clause, "rel" must be on the nullable side, else we'd not 
     * have gotten here.  So the computation of the join size is going to be 
     * quite nonlinear with respect to the size of "rel", so it's not clear 
     * how we ought to adjust outer_selec even if we could compute its 
     * original value correctly.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="orclauses.c.html#LN260"><span class='Ref_To_Local'>or_selec</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN323"></a>        <a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Declare_Local'>sjinfo</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Make up a SpecialJoinInfo for JOIN_INNER semantics.  (Compare 
         * approx_tuple_count() in costsize.c.) 
         */ 
</span>        <a href="orclauses.c.html#LN323"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1915"><span class='Ref_to_Member'>type</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN260"><span class='Ref_to_EnumConst'>T_SpecialJoinInfo</span></a><span class='Delimiter'>; 
</span>        <a href="orclauses.c.html#LN323"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1916"><span class='Ref_to_Member'>min_lefthand</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN72"><span class='Ref_to_Proto'>bms_difference</span></a><span class='Parentheses'>(</span><a href="orclauses.c.html#LN257"><span class='Ref_to_Parameter'>join_or_rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1761"><span class='Ref_to_Member'>clause_relids</span></a><span class='Delimiter'>, 
</span>                                             <a href="orclauses.c.html#LN256"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="orclauses.c.html#LN323"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a> <span class='Operator'>= </span><a href="orclauses.c.html#LN256"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>; 
</span>        <a href="orclauses.c.html#LN323"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1918"><span class='Ref_to_Member'>syn_lefthand</span></a> <span class='Operator'>= </span><a href="orclauses.c.html#LN323"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1916"><span class='Ref_to_Member'>min_lefthand</span></a><span class='Delimiter'>; 
</span>        <a href="orclauses.c.html#LN323"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1919"><span class='Ref_to_Member'>syn_righthand</span></a> <span class='Operator'>= </span><a href="orclauses.c.html#LN323"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a><span class='Delimiter'>; 
</span>        <a href="orclauses.c.html#LN323"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1920"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN677"><span class='Ref_to_EnumConst'>JOIN_INNER</span></a><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* we don't bother trying to make the remaining fields valid */ 
</span>        <a href="orclauses.c.html#LN323"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1921"><span class='Ref_to_Member'>lhs_strict</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="orclauses.c.html#LN323"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1922"><span class='Ref_to_Member'>delay_upper_joins</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="orclauses.c.html#LN323"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1924"><span class='Ref_to_Member'>semi_can_btree</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="orclauses.c.html#LN323"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1925"><span class='Ref_to_Member'>semi_can_hash</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="orclauses.c.html#LN323"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1926"><span class='Ref_to_Member'>semi_operators</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>        <a href="orclauses.c.html#LN323"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1927"><span class='Ref_to_Member'>semi_rhs_exprs</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Compute inner-join size */ 
</span>        <a href="orclauses.c.html#LN261"><span class='Ref_To_Local'>orig_selec</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/cost.h.html#LN202"><span class='Ref_to_Proto'>clause_selectivity</span></a><span class='Parentheses'>(</span><a href="orclauses.c.html#LN256"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="orclauses.c.html#LN257"><span class='Ref_to_Parameter'>join_or_rinfo</span></a><span class='Delimiter'>, 
</span>                                        <span class='Number'>0</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN677"><span class='Ref_to_EnumConst'>JOIN_INNER</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="orclauses.c.html#LN323"><span class='Ref_To_Local'>sjinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* And hack cached selectivity so join size remains the same */ 
</span>        <a href="orclauses.c.html#LN257"><span class='Ref_to_Parameter'>join_or_rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1784"><span class='Ref_to_Member'>norm_selec</span></a> <span class='Operator'>= </span><a href="orclauses.c.html#LN261"><span class='Ref_To_Local'>orig_selec</span></a> <span class='Operator'>/ </span><a href="orclauses.c.html#LN260"><span class='Ref_To_Local'>or_selec</span></a><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* ensure result stays in sane range, in particular not "redundant" */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="orclauses.c.html#LN257"><span class='Ref_to_Parameter'>join_or_rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1784"><span class='Ref_to_Member'>norm_selec</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>            <a href="orclauses.c.html#LN257"><span class='Ref_to_Parameter'>join_or_rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1784"><span class='Ref_to_Member'>norm_selec</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* as explained above, we don't touch outer_selec */ 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if or_selec&GT;0 &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end consider_new_or_clause &raquo; </span> 
</pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>