<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\optimizer\util\predtest.c</title>
<LINK REL=StyleSheet HREF="../../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\optimizer\util\predtest.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:43 2017
</td></tr>
<tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * predtest.c 
 *    Routines to attempt to prove logical implications between predicate 
 *    expressions. 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * 
 * IDENTIFICATION 
 *    src/backend/optimizer/util/predtest.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_proc.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_type.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"executor/executor.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"miscadmin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/nodeFuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/clauses.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/predtest.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/array.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/inval.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/lsyscache.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/syscache.h"</span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Proof attempts involving large arrays in ScalarArrayOpExpr nodes are 
 * likely to require O(N^2) time, and more often than not fail anyway. 
 * So we set an arbitrary limit on the number of array elements that 
 * we will allow to be treated as an AND or OR clause. 
 * XXX is it worth exposing this as a GUC knob? 
 */ 
</span><a name="LN37"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>MAX_SAOP_ARRAY_SIZE</span>     <span class='Number'>100</span> 
 
<span class='Comment_Multi_Line'>/* 
 * To avoid redundant coding in predicate_implied_by_recurse and 
 * predicate_refuted_by_recurse, we need to abstract out the notion of 
 * iterating over the components of an expression that is logically an AND 
 * or OR structure.  There are multiple sorts of expression nodes that can 
 * be treated as ANDs or ORs, and we don't want to code each one separately. 
 * Hence, these types and support routines. 
 */ 
</span><span class='Control'>typedef</span> <span class='Control'>enum</span> 
<span class='Delimiter'>{ 
</span><a name="LN49"></a>    <span class='Declare_Enum_Const'>CLASS_ATOM</span><span class='Delimiter'>,</span>                 <span class='Comment_Single_Line'>/* expression that's not AND or OR */ 
</span><a name="LN50"></a>    <span class='Declare_Enum_Const'>CLASS_AND</span><span class='Delimiter'>,</span>                  <span class='Comment_Single_Line'>/* expression with AND semantics */ 
</span><a name="LN51"></a>    <span class='Declare_Enum_Const'>CLASS_OR</span>                    <span class='Comment_Single_Line'>/* expression with OR semantics */ 
</span><a name="LN52"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>PredClass</span><span class='Delimiter'>; 
</span> 
<a name="LN54"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <a href="predtest.c.html#LN56"><span class='Ref_to_Struct'>PredIterInfoData</span></a> <span class='Operator'>*</span><span class='Declare_Typedef'>PredIterInfo</span><span class='Delimiter'>; 
</span> 
<a name="LN56"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>PredIterInfoData</span> 
<span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* node-type-specific iteration state */ 
</span><a name="LN59"></a>    <span class='Keyword'>void</span>       <span class='Operator'>*</span><span class='Declare_Member'>state</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* initialize to do the iteration */ 
</span><a name="LN61"></a>    <span class='Keyword'>void</span>        <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Declare_Member'>startup_fn</span><span class='Parentheses'>) (</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span>clause<span class='Delimiter'>, </span><a href="predtest.c.html#LN54"><span class='Ref_to_Typedef'>PredIterInfo</span></a> info<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* next-component iteration function */ 
</span>    <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Parentheses'>(</span><span class='Operator'>*</span>next_fn<span class='Parentheses'>) (</span><a href="predtest.c.html#LN54"><span class='Ref_to_Typedef'>PredIterInfo</span></a> info<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* release resources when done with iteration */ 
</span><a name="LN65"></a>    <span class='Keyword'>void</span>        <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Declare_Member'>cleanup_fn</span><span class='Parentheses'>) (</span><a href="predtest.c.html#LN54"><span class='Ref_to_Typedef'>PredIterInfo</span></a> info<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN66"></a>} <span class='Declare_Typedef'>PredIterInfoData</span><span class='Delimiter'>; 
</span> 
<a name="LN68"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>iterate_begin</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>item</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>clause</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>info</span><span class='Parentheses'>)</span>   <span class='Operator'>\ 
</span>    <span class='Control'>do</span> <span class='Delimiter'>{ </span><span class='Operator'>\ 
</span>        <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>   <span class='Operator'>*</span><a href="predtest.c.html#LN68"><span class='Ref_to_Parameter'>item</span></a><span class='Delimiter'>; </span><span class='Operator'>\ 
</span>        <span class='Parentheses'>(</span><a href="predtest.c.html#LN68"><span class='Ref_to_Parameter'>info</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>startup_fn<span class='Parentheses'>((</span><a href="predtest.c.html#LN68"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predtest.c.html#LN68"><span class='Ref_to_Parameter'>info</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; </span><span class='Operator'>\ 
</span>        <span class='Control'>while</span> <span class='Parentheses'>((</span><a href="predtest.c.html#LN68"><span class='Ref_to_Parameter'>item</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="predtest.c.html#LN68"><span class='Ref_to_Parameter'>info</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>next_fn<span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predtest.c.html#LN68"><span class='Ref_to_Parameter'>info</span></a><span class='Parentheses'>)))</span> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
 
<a name="LN74"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>iterate_end</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>info</span><span class='Parentheses'>)</span>   <span class='Operator'>\ 
</span>        <span class='Parentheses'>(</span><a href="predtest.c.html#LN74"><span class='Ref_to_Parameter'>info</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>cleanup_fn<span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predtest.c.html#LN74"><span class='Ref_to_Parameter'>info</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; </span><span class='Operator'>\ 
</span>    <span class='Delimiter'>} </span><span class='Control'>while</span> <span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>) 
</span> 
 
<a name="LN79"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>predicate_implied_by_recurse</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>predicate</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN80"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>predicate_refuted_by_recurse</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>predicate</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN81"></a><span class='Keyword'>static </span><a href="predtest.c.html#LN47"><span class='Ref_to_Typedef'>PredClass</span></a> <span class='Declare_Prototype'>predicate_classify</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Delimiter'>, </span><a href="predtest.c.html#LN54"><span class='Ref_to_Typedef'>PredIterInfo</span></a> <span class='Declare_Parameter'>info</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN82"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>list_startup_fn</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Delimiter'>, </span><a href="predtest.c.html#LN54"><span class='Ref_to_Typedef'>PredIterInfo</span></a> <span class='Declare_Parameter'>info</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN83"></a><span class='Keyword'>static </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>list_next_fn</span><span class='Parentheses'>(</span><a href="predtest.c.html#LN54"><span class='Ref_to_Typedef'>PredIterInfo</span></a> <span class='Declare_Parameter'>info</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN84"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>list_cleanup_fn</span><span class='Parentheses'>(</span><a href="predtest.c.html#LN54"><span class='Ref_to_Typedef'>PredIterInfo</span></a> <span class='Declare_Parameter'>info</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN85"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>boolexpr_startup_fn</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Delimiter'>, </span><a href="predtest.c.html#LN54"><span class='Ref_to_Typedef'>PredIterInfo</span></a> <span class='Declare_Parameter'>info</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN86"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>arrayconst_startup_fn</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Delimiter'>, </span><a href="predtest.c.html#LN54"><span class='Ref_to_Typedef'>PredIterInfo</span></a> <span class='Declare_Parameter'>info</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN87"></a><span class='Keyword'>static </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>arrayconst_next_fn</span><span class='Parentheses'>(</span><a href="predtest.c.html#LN54"><span class='Ref_to_Typedef'>PredIterInfo</span></a> <span class='Declare_Parameter'>info</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN88"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>arrayconst_cleanup_fn</span><span class='Parentheses'>(</span><a href="predtest.c.html#LN54"><span class='Ref_to_Typedef'>PredIterInfo</span></a> <span class='Declare_Parameter'>info</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN89"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>arrayexpr_startup_fn</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Delimiter'>, </span><a href="predtest.c.html#LN54"><span class='Ref_to_Typedef'>PredIterInfo</span></a> <span class='Declare_Parameter'>info</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN90"></a><span class='Keyword'>static </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>arrayexpr_next_fn</span><span class='Parentheses'>(</span><a href="predtest.c.html#LN54"><span class='Ref_to_Typedef'>PredIterInfo</span></a> <span class='Declare_Parameter'>info</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN91"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>arrayexpr_cleanup_fn</span><span class='Parentheses'>(</span><a href="predtest.c.html#LN54"><span class='Ref_to_Typedef'>PredIterInfo</span></a> <span class='Declare_Parameter'>info</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN92"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>predicate_implied_by_simple_clause</span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>predicate</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN93"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>predicate_refuted_by_simple_clause</span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>predicate</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN94"></a><span class='Keyword'>static </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>extract_not_arg</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN95"></a><span class='Keyword'>static </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>extract_strong_not_arg</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN96"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>list_member_strip</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>datum</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN97"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>operator_predicate_proof</span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>predicate</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Delimiter'>, 
</span><a name="LN98"></a>                         <span class='Keyword'>bool </span><span class='Declare_Parameter'>refute_it</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN99"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>operator_same_subexprs_proof</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>pred_op</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>clause_op</span><span class='Delimiter'>, 
</span><a name="LN100"></a>                             <span class='Keyword'>bool </span><span class='Declare_Parameter'>refute_it</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN101"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>operator_same_subexprs_lookup</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>pred_op</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>clause_op</span><span class='Delimiter'>, 
</span><a name="LN102"></a>                              <span class='Keyword'>bool </span><span class='Declare_Parameter'>refute_it</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN103"></a><span class='Keyword'>static </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>  <span class='Declare_Prototype'>get_btree_test_op</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>pred_op</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>clause_op</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>refute_it</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN104"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>InvalidateOprProofCacheCallBack</span><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>arg</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>cacheid</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Parameter'>hashvalue</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * predicate_implied_by 
 *    Recursively checks whether the clauses in restrictinfo_list imply 
 *    that the given predicate is true. 
 * 
 * The top-level List structure of each list corresponds to an AND list. 
 * We assume that eval_const_expressions() has been applied and so there 
 * are no un-flattened ANDs or ORs (e.g., no AND immediately within an AND, 
 * including AND just below the top-level List structure). 
 * If this is not true we might fail to prove an implication that is 
 * valid, but no worse consequences will ensue. 
 * 
 * We assume the predicate has already been checked to contain only 
 * immutable functions and operators.  (In most current uses this is true 
 * because the predicate is part of an index predicate that has passed 
 * CheckPredicate().)  We dare not make deductions based on non-immutable 
 * functions, because they might change answers between the time we make 
 * the plan and the time we execute the plan. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN127"></a><span class='Declare_Function'>predicate_implied_by</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>predicate_list</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>restrictinfo_list</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN129"></a>    <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>p</span><span class='Delimiter'>, 
</span><a name="LN130"></a>               <span class='Operator'>*</span><span class='Declare_Local'>r</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN127"><span class='Ref_to_Parameter'>predicate_list</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* no predicate: implication is vacuous */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN127"><span class='Ref_to_Parameter'>restrictinfo_list</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* no restriction: implication must fail */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If either input is a single-element list, replace it with its lone 
     * member; this avoids one useless level of AND-recursion.  We only need 
     * to worry about this at top level, since eval_const_expressions should 
     * have gotten rid of any trivial ANDs or ORs below that. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN127"><span class='Ref_to_Parameter'>predicate_list</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
        <a href="predtest.c.html#LN129"><span class='Ref_To_Local'>p</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN127"><span class='Ref_to_Parameter'>predicate_list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="predtest.c.html#LN129"><span class='Ref_To_Local'>p</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN127"><span class='Ref_to_Parameter'>predicate_list</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN127"><span class='Ref_to_Parameter'>restrictinfo_list</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
        <a href="predtest.c.html#LN130"><span class='Ref_To_Local'>r</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN127"><span class='Ref_to_Parameter'>restrictinfo_list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="predtest.c.html#LN130"><span class='Ref_To_Local'>r</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN127"><span class='Ref_to_Parameter'>restrictinfo_list</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* And away we go ... */ 
</span>    <span class='Control'>return</span> <a href="predtest.c.html#LN79"><span class='Ref_to_Proto'>predicate_implied_by_recurse</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN130"><span class='Ref_To_Local'>r</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN129"><span class='Ref_To_Local'>p</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end predicate_implied_by &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * predicate_refuted_by 
 *    Recursively checks whether the clauses in restrictinfo_list refute 
 *    the given predicate (that is, prove it false). 
 * 
 * This is NOT the same as !(predicate_implied_by), though it is similar 
 * in the technique and structure of the code. 
 * 
 * An important fine point is that truth of the clauses must imply that 
 * the predicate returns FALSE, not that it does not return TRUE.  This 
 * is normally used to try to refute CHECK constraints, and the only 
 * thing we can assume about a CHECK constraint is that it didn't return 
 * FALSE --- a NULL result isn't a violation per the SQL spec.  (Someday 
 * perhaps this code should be extended to support both "strong" and 
 * "weak" refutation, but for now we only need "strong".) 
 * 
 * The top-level List structure of each list corresponds to an AND list. 
 * We assume that eval_const_expressions() has been applied and so there 
 * are no un-flattened ANDs or ORs (e.g., no AND immediately within an AND, 
 * including AND just below the top-level List structure). 
 * If this is not true we might fail to prove an implication that is 
 * valid, but no worse consequences will ensue. 
 * 
 * We assume the predicate has already been checked to contain only 
 * immutable functions and operators.  We dare not make deductions based on 
 * non-immutable functions, because they might change answers between the 
 * time we make the plan and the time we execute the plan. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN185"></a><span class='Declare_Function'>predicate_refuted_by</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>predicate_list</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>restrictinfo_list</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN187"></a>    <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>p</span><span class='Delimiter'>, 
</span><a name="LN188"></a>               <span class='Operator'>*</span><span class='Declare_Local'>r</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN185"><span class='Ref_to_Parameter'>predicate_list</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* no predicate: no refutation is possible */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN185"><span class='Ref_to_Parameter'>restrictinfo_list</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* no restriction: refutation must fail */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If either input is a single-element list, replace it with its lone 
     * member; this avoids one useless level of AND-recursion.  We only need 
     * to worry about this at top level, since eval_const_expressions should 
     * have gotten rid of any trivial ANDs or ORs below that. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN185"><span class='Ref_to_Parameter'>predicate_list</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
        <a href="predtest.c.html#LN187"><span class='Ref_To_Local'>p</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN185"><span class='Ref_to_Parameter'>predicate_list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="predtest.c.html#LN187"><span class='Ref_To_Local'>p</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN185"><span class='Ref_to_Parameter'>predicate_list</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN185"><span class='Ref_to_Parameter'>restrictinfo_list</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
        <a href="predtest.c.html#LN188"><span class='Ref_To_Local'>r</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN185"><span class='Ref_to_Parameter'>restrictinfo_list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="predtest.c.html#LN188"><span class='Ref_To_Local'>r</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN185"><span class='Ref_to_Parameter'>restrictinfo_list</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* And away we go ... */ 
</span>    <span class='Control'>return</span> <a href="predtest.c.html#LN80"><span class='Ref_to_Proto'>predicate_refuted_by_recurse</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN188"><span class='Ref_To_Local'>r</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN187"><span class='Ref_To_Local'>p</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end predicate_refuted_by &raquo; </span> 
 
<span class='Comment_Multi_Line'>/*---------- 
 * predicate_implied_by_recurse 
 *    Does the predicate implication test for non-NULL restriction and 
 *    predicate clauses. 
 * 
 * The logic followed here is ("=&GT;" means "implies"): 
 *  atom A =&GT; atom B iff:           predicate_implied_by_simple_clause says so 
 *  atom A =&GT; AND-expr B iff:       A =&GT; each of B's components 
 *  atom A =&GT; OR-expr B iff:        A =&GT; any of B's components 
 *  AND-expr A =&GT; atom B iff:       any of A's components =&GT; B 
 *  AND-expr A =&GT; AND-expr B iff:   A =&GT; each of B's components 
 *  AND-expr A =&GT; OR-expr B iff:    A =&GT; any of B's components, 
 *                                  *or* any of A's components =&GT; B 
 *  OR-expr A =&GT; atom B iff:        each of A's components =&GT; B 
 *  OR-expr A =&GT; AND-expr B iff:    A =&GT; each of B's components 
 *  OR-expr A =&GT; OR-expr B iff:     each of A's components =&GT; any of B's 
 * 
 * An "atom" is anything other than an AND or OR node.  Notice that we don't 
 * have any special logic to handle NOT nodes; these should have been pushed 
 * down or eliminated where feasible by prepqual.c. 
 * 
 * We can't recursively expand either side first, but have to interleave 
 * the expansions per the above rules, to be sure we handle all of these 
 * examples: 
 *      (x OR y) =&GT; (x OR y OR z) 
 *      (x AND y AND z) =&GT; (x AND y) 
 *      (x AND y) =&GT; ((x AND y) OR z) 
 *      ((x OR y) AND z) =&GT; (x OR y) 
 * This is still not an exhaustive test, but it handles most normal cases 
 * under the assumption that both inputs have been AND/OR flattened. 
 * 
 * We have to be prepared to handle RestrictInfo nodes in the restrictinfo 
 * tree, though not in the predicate tree. 
 *---------- 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN250"></a><span class='Declare_Function'>predicate_implied_by_recurse</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>predicate</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN252"></a>    <a href="predtest.c.html#LN56"><span class='Ref_to_Struct'>PredIterInfoData</span></a> <span class='Declare_Local'>clause_info</span><span class='Delimiter'>; 
</span><a name="LN253"></a>    <a href="predtest.c.html#LN56"><span class='Ref_to_Struct'>PredIterInfoData</span></a> <span class='Declare_Local'>pred_info</span><span class='Delimiter'>; 
</span><a name="LN254"></a>    <a href="predtest.c.html#LN47"><span class='Ref_to_Typedef'>PredClass</span></a>   <span class='Declare_Local'>pclass</span><span class='Delimiter'>; 
</span><a name="LN255"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* skip through RestrictInfo */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predtest.c.html#LN250"><span class='Ref_to_Parameter'>clause</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN250"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a><span class='Parentheses'>))</span> 
        <a href="predtest.c.html#LN250"><span class='Ref_to_Parameter'>clause</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) ((</span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN250"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>clause<span class='Delimiter'>; 
</span> 
    <a href="predtest.c.html#LN254"><span class='Ref_To_Local'>pclass</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN81"><span class='Ref_to_Proto'>predicate_classify</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN250"><span class='Ref_to_Parameter'>predicate</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predtest.c.html#LN253"><span class='Ref_To_Local'>pred_info</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN81"><span class='Ref_to_Proto'>predicate_classify</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN250"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predtest.c.html#LN252"><span class='Ref_To_Local'>clause_info</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="predtest.c.html#LN50"><span class='Ref_to_EnumConst'>CLASS_AND</span></a><span class='Operator'>: 
</span>            <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN254"><span class='Ref_To_Local'>pclass</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>case</span> <a href="predtest.c.html#LN50"><span class='Ref_to_EnumConst'>CLASS_AND</span></a><span class='Operator'>: 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * AND-clause =&GT; AND-clause if A implies each of B's items 
                     */ 
</span>                    <a href="predtest.c.html#LN255"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                    <a href="predtest.c.html#LN68"><span class='Ref_to_Macro'>iterate_begin</span></a><span class='Parentheses'>(</span>pitem<span class='Delimiter'>, </span><a href="predtest.c.html#LN250"><span class='Ref_to_Parameter'>predicate</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN253"><span class='Ref_To_Local'>pred_info</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predtest.c.html#LN79"><span class='Ref_to_Proto'>predicate_implied_by_recurse</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN250"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span>pitem<span class='Parentheses'>))</span> 
                        <span class='Delimiter'>{ 
</span>                            <a href="predtest.c.html#LN255"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                    <span class='Delimiter'>} 
</span>                    <a href="predtest.c.html#LN74"><span class='Ref_to_Macro'>iterate_end</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN253"><span class='Ref_To_Local'>pred_info</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>return</span> <a href="predtest.c.html#LN255"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span> 
                <span class='Control'>case</span> <a href="predtest.c.html#LN51"><span class='Ref_to_EnumConst'>CLASS_OR</span></a><span class='Operator'>: 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * AND-clause =&GT; OR-clause if A implies any of B's items 
                     * 
                     * Needed to handle (x AND y) =&GT; ((x AND y) OR z) 
                     */ 
</span>                    <a href="predtest.c.html#LN255"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                    <a href="predtest.c.html#LN68"><span class='Ref_to_Macro'>iterate_begin</span></a><span class='Parentheses'>(</span>pitem<span class='Delimiter'>, </span><a href="predtest.c.html#LN250"><span class='Ref_to_Parameter'>predicate</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN253"><span class='Ref_To_Local'>pred_info</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN79"><span class='Ref_to_Proto'>predicate_implied_by_recurse</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN250"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span>pitem<span class='Parentheses'>))</span> 
                        <span class='Delimiter'>{ 
</span>                            <a href="predtest.c.html#LN255"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                    <span class='Delimiter'>} 
</span>                    <a href="predtest.c.html#LN74"><span class='Ref_to_Macro'>iterate_end</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN253"><span class='Ref_To_Local'>pred_info</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN255"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>) 
</span>                        <span class='Control'>return</span> <a href="predtest.c.html#LN255"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * Also check if any of A's items implies B 
                     * 
                     * Needed to handle ((x OR y) AND z) =&GT; (x OR y) 
                     */ 
</span>                    <a href="predtest.c.html#LN68"><span class='Ref_to_Macro'>iterate_begin</span></a><span class='Parentheses'>(</span>citem<span class='Delimiter'>, </span><a href="predtest.c.html#LN250"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN252"><span class='Ref_To_Local'>clause_info</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN79"><span class='Ref_to_Proto'>predicate_implied_by_recurse</span></a><span class='Parentheses'>(</span>citem<span class='Delimiter'>, </span><a href="predtest.c.html#LN250"><span class='Ref_to_Parameter'>predicate</span></a><span class='Parentheses'>))</span> 
                        <span class='Delimiter'>{ 
</span>                            <a href="predtest.c.html#LN255"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                    <span class='Delimiter'>} 
</span>                    <a href="predtest.c.html#LN74"><span class='Ref_to_Macro'>iterate_end</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN252"><span class='Ref_To_Local'>clause_info</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>return</span> <a href="predtest.c.html#LN255"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span> 
                <span class='Control'>case</span> <a href="predtest.c.html#LN49"><span class='Ref_to_EnumConst'>CLASS_ATOM</span></a><span class='Operator'>: 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * AND-clause =&GT; atom if any of A's items implies B 
                     */ 
</span>                    <a href="predtest.c.html#LN255"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                    <a href="predtest.c.html#LN68"><span class='Ref_to_Macro'>iterate_begin</span></a><span class='Parentheses'>(</span>citem<span class='Delimiter'>, </span><a href="predtest.c.html#LN250"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN252"><span class='Ref_To_Local'>clause_info</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN79"><span class='Ref_to_Proto'>predicate_implied_by_recurse</span></a><span class='Parentheses'>(</span>citem<span class='Delimiter'>, </span><a href="predtest.c.html#LN250"><span class='Ref_to_Parameter'>predicate</span></a><span class='Parentheses'>))</span> 
                        <span class='Delimiter'>{ 
</span>                            <a href="predtest.c.html#LN255"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                    <span class='Delimiter'>} 
</span>                    <a href="predtest.c.html#LN74"><span class='Ref_to_Macro'>iterate_end</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN252"><span class='Ref_To_Local'>clause_info</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>return</span> <a href="predtest.c.html#LN255"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch pclass &raquo; </span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="predtest.c.html#LN51"><span class='Ref_to_EnumConst'>CLASS_OR</span></a><span class='Operator'>: 
</span>            <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN254"><span class='Ref_To_Local'>pclass</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>case</span> <a href="predtest.c.html#LN51"><span class='Ref_to_EnumConst'>CLASS_OR</span></a><span class='Operator'>: 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * OR-clause =&GT; OR-clause if each of A's items implies any 
                     * of B's items.  Messy but can't do it any more simply. 
                     */ 
</span>                    <a href="predtest.c.html#LN255"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                    <a href="predtest.c.html#LN68"><span class='Ref_to_Macro'>iterate_begin</span></a><span class='Parentheses'>(</span>citem<span class='Delimiter'>, </span><a href="predtest.c.html#LN250"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN252"><span class='Ref_To_Local'>clause_info</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span><a name="LN353"></a>                        <span class='Keyword'>bool</span>        <span class='Declare_Local'>presult</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
                        <a href="predtest.c.html#LN68"><span class='Ref_to_Macro'>iterate_begin</span></a><span class='Parentheses'>(</span>pitem<span class='Delimiter'>, </span><a href="predtest.c.html#LN250"><span class='Ref_to_Parameter'>predicate</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN253"><span class='Ref_To_Local'>pred_info</span></a><span class='Parentheses'>) 
</span>                        <span class='Delimiter'>{ 
</span>                            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN79"><span class='Ref_to_Proto'>predicate_implied_by_recurse</span></a><span class='Parentheses'>(</span>citem<span class='Delimiter'>, </span>pitem<span class='Parentheses'>))</span> 
                            <span class='Delimiter'>{ 
</span>                                <a href="predtest.c.html#LN353"><span class='Ref_To_Local'>presult</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                                <span class='Control'>break</span><span class='Delimiter'>; 
</span>                            <span class='Delimiter'>} 
</span>                        <span class='Delimiter'>} 
</span>                        <a href="predtest.c.html#LN74"><span class='Ref_to_Macro'>iterate_end</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN253"><span class='Ref_To_Local'>pred_info</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predtest.c.html#LN353"><span class='Ref_To_Local'>presult</span></a><span class='Parentheses'>) 
</span>                        <span class='Delimiter'>{ 
</span>                            <a href="predtest.c.html#LN255"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* doesn't imply any of B's */ 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                    <span class='Delimiter'>} 
</span>                    <a href="predtest.c.html#LN74"><span class='Ref_to_Macro'>iterate_end</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN252"><span class='Ref_To_Local'>clause_info</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>return</span> <a href="predtest.c.html#LN255"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span> 
                <span class='Control'>case</span> <a href="predtest.c.html#LN50"><span class='Ref_to_EnumConst'>CLASS_AND</span></a><span class='Operator'>: 
</span>                <span class='Control'>case</span> <a href="predtest.c.html#LN49"><span class='Ref_to_EnumConst'>CLASS_ATOM</span></a><span class='Operator'>: 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * OR-clause =&GT; AND-clause if each of A's items implies B 
                     * 
                     * OR-clause =&GT; atom if each of A's items implies B 
                     */ 
</span>                    <a href="predtest.c.html#LN255"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                    <a href="predtest.c.html#LN68"><span class='Ref_to_Macro'>iterate_begin</span></a><span class='Parentheses'>(</span>citem<span class='Delimiter'>, </span><a href="predtest.c.html#LN250"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN252"><span class='Ref_To_Local'>clause_info</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predtest.c.html#LN79"><span class='Ref_to_Proto'>predicate_implied_by_recurse</span></a><span class='Parentheses'>(</span>citem<span class='Delimiter'>, </span><a href="predtest.c.html#LN250"><span class='Ref_to_Parameter'>predicate</span></a><span class='Parentheses'>))</span> 
                        <span class='Delimiter'>{ 
</span>                            <a href="predtest.c.html#LN255"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                    <span class='Delimiter'>} 
</span>                    <a href="predtest.c.html#LN74"><span class='Ref_to_Macro'>iterate_end</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN252"><span class='Ref_To_Local'>clause_info</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>return</span> <a href="predtest.c.html#LN255"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch pclass &raquo; </span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="predtest.c.html#LN49"><span class='Ref_to_EnumConst'>CLASS_ATOM</span></a><span class='Operator'>: 
</span>            <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN254"><span class='Ref_To_Local'>pclass</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>case</span> <a href="predtest.c.html#LN50"><span class='Ref_to_EnumConst'>CLASS_AND</span></a><span class='Operator'>: 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * atom =&GT; AND-clause if A implies each of B's items 
                     */ 
</span>                    <a href="predtest.c.html#LN255"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                    <a href="predtest.c.html#LN68"><span class='Ref_to_Macro'>iterate_begin</span></a><span class='Parentheses'>(</span>pitem<span class='Delimiter'>, </span><a href="predtest.c.html#LN250"><span class='Ref_to_Parameter'>predicate</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN253"><span class='Ref_To_Local'>pred_info</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predtest.c.html#LN79"><span class='Ref_to_Proto'>predicate_implied_by_recurse</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN250"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span>pitem<span class='Parentheses'>))</span> 
                        <span class='Delimiter'>{ 
</span>                            <a href="predtest.c.html#LN255"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                    <span class='Delimiter'>} 
</span>                    <a href="predtest.c.html#LN74"><span class='Ref_to_Macro'>iterate_end</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN253"><span class='Ref_To_Local'>pred_info</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>return</span> <a href="predtest.c.html#LN255"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span> 
                <span class='Control'>case</span> <a href="predtest.c.html#LN51"><span class='Ref_to_EnumConst'>CLASS_OR</span></a><span class='Operator'>: 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * atom =&GT; OR-clause if A implies any of B's items 
                     */ 
</span>                    <a href="predtest.c.html#LN255"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                    <a href="predtest.c.html#LN68"><span class='Ref_to_Macro'>iterate_begin</span></a><span class='Parentheses'>(</span>pitem<span class='Delimiter'>, </span><a href="predtest.c.html#LN250"><span class='Ref_to_Parameter'>predicate</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN253"><span class='Ref_To_Local'>pred_info</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN79"><span class='Ref_to_Proto'>predicate_implied_by_recurse</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN250"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span>pitem<span class='Parentheses'>))</span> 
                        <span class='Delimiter'>{ 
</span>                            <a href="predtest.c.html#LN255"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                    <span class='Delimiter'>} 
</span>                    <a href="predtest.c.html#LN74"><span class='Ref_to_Macro'>iterate_end</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN253"><span class='Ref_To_Local'>pred_info</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>return</span> <a href="predtest.c.html#LN255"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span> 
                <span class='Control'>case</span> <a href="predtest.c.html#LN49"><span class='Ref_to_EnumConst'>CLASS_ATOM</span></a><span class='Operator'>: 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * atom =&GT; atom is the base case 
                     */ 
</span>                    <span class='Control'>return</span> 
                        <a href="predtest.c.html#LN92"><span class='Ref_to_Proto'>predicate_implied_by_simple_clause</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN250"><span class='Ref_to_Parameter'>predicate</span></a><span class='Delimiter'>, 
</span>                                                           <a href="predtest.c.html#LN250"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch pclass &raquo; </span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch predicate_classify(cl... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* can't get here */ 
</span>    <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"predicate_classify returned a bogus value"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end predicate_implied_by_recurse &raquo; </span> 
 
<span class='Comment_Multi_Line'>/*---------- 
 * predicate_refuted_by_recurse 
 *    Does the predicate refutation test for non-NULL restriction and 
 *    predicate clauses. 
 * 
 * The logic followed here is ("R=&GT;" means "refutes"): 
 *  atom A R=&GT; atom B iff:          predicate_refuted_by_simple_clause says so 
 *  atom A R=&GT; AND-expr B iff:      A R=&GT; any of B's components 
 *  atom A R=&GT; OR-expr B iff:       A R=&GT; each of B's components 
 *  AND-expr A R=&GT; atom B iff:      any of A's components R=&GT; B 
 *  AND-expr A R=&GT; AND-expr B iff:  A R=&GT; any of B's components, 
 *                                  *or* any of A's components R=&GT; B 
 *  AND-expr A R=&GT; OR-expr B iff:   A R=&GT; each of B's components 
 *  OR-expr A R=&GT; atom B iff:       each of A's components R=&GT; B 
 *  OR-expr A R=&GT; AND-expr B iff:   each of A's components R=&GT; any of B's 
 *  OR-expr A R=&GT; OR-expr B iff:    A R=&GT; each of B's components 
 * 
 * In addition, if the predicate is a NOT-clause then we can use 
 *  A R=&GT; NOT B if:                 A =&GT; B 
 * This works for several different SQL constructs that assert the non-truth 
 * of their argument, ie NOT, IS FALSE, IS NOT TRUE, IS UNKNOWN. 
 * Unfortunately we *cannot* use 
 *  NOT A R=&GT; B if:                 B =&GT; A 
 * because this type of reasoning fails to prove that B doesn't yield NULL. 
 * We can however make the more limited deduction that 
 *  NOT A R=&GT; A 
 * 
 * Other comments are as for predicate_implied_by_recurse(). 
 *---------- 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN480"></a><span class='Declare_Function'>predicate_refuted_by_recurse</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>predicate</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN482"></a>    <a href="predtest.c.html#LN56"><span class='Ref_to_Struct'>PredIterInfoData</span></a> <span class='Declare_Local'>clause_info</span><span class='Delimiter'>; 
</span><a name="LN483"></a>    <a href="predtest.c.html#LN56"><span class='Ref_to_Struct'>PredIterInfoData</span></a> <span class='Declare_Local'>pred_info</span><span class='Delimiter'>; 
</span><a name="LN484"></a>    <a href="predtest.c.html#LN47"><span class='Ref_to_Typedef'>PredClass</span></a>   <span class='Declare_Local'>pclass</span><span class='Delimiter'>; 
</span><a name="LN485"></a>    <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>not_arg</span><span class='Delimiter'>; 
</span><a name="LN486"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* skip through RestrictInfo */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predtest.c.html#LN480"><span class='Ref_to_Parameter'>clause</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN480"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a><span class='Parentheses'>))</span> 
        <a href="predtest.c.html#LN480"><span class='Ref_to_Parameter'>clause</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) ((</span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN480"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>clause<span class='Delimiter'>; 
</span> 
    <a href="predtest.c.html#LN484"><span class='Ref_To_Local'>pclass</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN81"><span class='Ref_to_Proto'>predicate_classify</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN480"><span class='Ref_to_Parameter'>predicate</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predtest.c.html#LN483"><span class='Ref_To_Local'>pred_info</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN81"><span class='Ref_to_Proto'>predicate_classify</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN480"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predtest.c.html#LN482"><span class='Ref_To_Local'>clause_info</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="predtest.c.html#LN50"><span class='Ref_to_EnumConst'>CLASS_AND</span></a><span class='Operator'>: 
</span>            <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN484"><span class='Ref_To_Local'>pclass</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>case</span> <a href="predtest.c.html#LN50"><span class='Ref_to_EnumConst'>CLASS_AND</span></a><span class='Operator'>: 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * AND-clause R=&GT; AND-clause if A refutes any of B's items 
                     * 
                     * Needed to handle (x AND y) R=&GT; ((!x OR !y) AND z) 
                     */ 
</span>                    <a href="predtest.c.html#LN486"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                    <a href="predtest.c.html#LN68"><span class='Ref_to_Macro'>iterate_begin</span></a><span class='Parentheses'>(</span>pitem<span class='Delimiter'>, </span><a href="predtest.c.html#LN480"><span class='Ref_to_Parameter'>predicate</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN483"><span class='Ref_To_Local'>pred_info</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN80"><span class='Ref_to_Proto'>predicate_refuted_by_recurse</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN480"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span>pitem<span class='Parentheses'>))</span> 
                        <span class='Delimiter'>{ 
</span>                            <a href="predtest.c.html#LN486"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                    <span class='Delimiter'>} 
</span>                    <a href="predtest.c.html#LN74"><span class='Ref_to_Macro'>iterate_end</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN483"><span class='Ref_To_Local'>pred_info</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN486"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>) 
</span>                        <span class='Control'>return</span> <a href="predtest.c.html#LN486"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * Also check if any of A's items refutes B 
                     * 
                     * Needed to handle ((x OR y) AND z) R=&GT; (!x AND !y) 
                     */ 
</span>                    <a href="predtest.c.html#LN68"><span class='Ref_to_Macro'>iterate_begin</span></a><span class='Parentheses'>(</span>citem<span class='Delimiter'>, </span><a href="predtest.c.html#LN480"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN482"><span class='Ref_To_Local'>clause_info</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN80"><span class='Ref_to_Proto'>predicate_refuted_by_recurse</span></a><span class='Parentheses'>(</span>citem<span class='Delimiter'>, </span><a href="predtest.c.html#LN480"><span class='Ref_to_Parameter'>predicate</span></a><span class='Parentheses'>))</span> 
                        <span class='Delimiter'>{ 
</span>                            <a href="predtest.c.html#LN486"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                    <span class='Delimiter'>} 
</span>                    <a href="predtest.c.html#LN74"><span class='Ref_to_Macro'>iterate_end</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN482"><span class='Ref_To_Local'>clause_info</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>return</span> <a href="predtest.c.html#LN486"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span> 
                <span class='Control'>case</span> <a href="predtest.c.html#LN51"><span class='Ref_to_EnumConst'>CLASS_OR</span></a><span class='Operator'>: 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * AND-clause R=&GT; OR-clause if A refutes each of B's items 
                     */ 
</span>                    <a href="predtest.c.html#LN486"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                    <a href="predtest.c.html#LN68"><span class='Ref_to_Macro'>iterate_begin</span></a><span class='Parentheses'>(</span>pitem<span class='Delimiter'>, </span><a href="predtest.c.html#LN480"><span class='Ref_to_Parameter'>predicate</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN483"><span class='Ref_To_Local'>pred_info</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predtest.c.html#LN80"><span class='Ref_to_Proto'>predicate_refuted_by_recurse</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN480"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span>pitem<span class='Parentheses'>))</span> 
                        <span class='Delimiter'>{ 
</span>                            <a href="predtest.c.html#LN486"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                    <span class='Delimiter'>} 
</span>                    <a href="predtest.c.html#LN74"><span class='Ref_to_Macro'>iterate_end</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN483"><span class='Ref_To_Local'>pred_info</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>return</span> <a href="predtest.c.html#LN486"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span> 
                <span class='Control'>case</span> <a href="predtest.c.html#LN49"><span class='Ref_to_EnumConst'>CLASS_ATOM</span></a><span class='Operator'>: 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * If B is a NOT-clause, A R=&GT; B if A =&GT; B's arg 
                     */ 
</span>                    <a href="predtest.c.html#LN485"><span class='Ref_To_Local'>not_arg</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN94"><span class='Ref_to_Proto'>extract_not_arg</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN480"><span class='Ref_to_Parameter'>predicate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN485"><span class='Ref_To_Local'>not_arg</span></a> <span class='Operator'>&& 
</span>                        <a href="predtest.c.html#LN79"><span class='Ref_to_Proto'>predicate_implied_by_recurse</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN480"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN485"><span class='Ref_To_Local'>not_arg</span></a><span class='Parentheses'>))</span> 
                        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * AND-clause R=&GT; atom if any of A's items refutes B 
                     */ 
</span>                    <a href="predtest.c.html#LN486"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                    <a href="predtest.c.html#LN68"><span class='Ref_to_Macro'>iterate_begin</span></a><span class='Parentheses'>(</span>citem<span class='Delimiter'>, </span><a href="predtest.c.html#LN480"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN482"><span class='Ref_To_Local'>clause_info</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN80"><span class='Ref_to_Proto'>predicate_refuted_by_recurse</span></a><span class='Parentheses'>(</span>citem<span class='Delimiter'>, </span><a href="predtest.c.html#LN480"><span class='Ref_to_Parameter'>predicate</span></a><span class='Parentheses'>))</span> 
                        <span class='Delimiter'>{ 
</span>                            <a href="predtest.c.html#LN486"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                    <span class='Delimiter'>} 
</span>                    <a href="predtest.c.html#LN74"><span class='Ref_to_Macro'>iterate_end</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN482"><span class='Ref_To_Local'>clause_info</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>return</span> <a href="predtest.c.html#LN486"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch pclass &raquo; </span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="predtest.c.html#LN51"><span class='Ref_to_EnumConst'>CLASS_OR</span></a><span class='Operator'>: 
</span>            <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN484"><span class='Ref_To_Local'>pclass</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>case</span> <a href="predtest.c.html#LN51"><span class='Ref_to_EnumConst'>CLASS_OR</span></a><span class='Operator'>: 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * OR-clause R=&GT; OR-clause if A refutes each of B's items 
                     */ 
</span>                    <a href="predtest.c.html#LN486"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                    <a href="predtest.c.html#LN68"><span class='Ref_to_Macro'>iterate_begin</span></a><span class='Parentheses'>(</span>pitem<span class='Delimiter'>, </span><a href="predtest.c.html#LN480"><span class='Ref_to_Parameter'>predicate</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN483"><span class='Ref_To_Local'>pred_info</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predtest.c.html#LN80"><span class='Ref_to_Proto'>predicate_refuted_by_recurse</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN480"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span>pitem<span class='Parentheses'>))</span> 
                        <span class='Delimiter'>{ 
</span>                            <a href="predtest.c.html#LN486"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                    <span class='Delimiter'>} 
</span>                    <a href="predtest.c.html#LN74"><span class='Ref_to_Macro'>iterate_end</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN483"><span class='Ref_To_Local'>pred_info</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>return</span> <a href="predtest.c.html#LN486"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span> 
                <span class='Control'>case</span> <a href="predtest.c.html#LN50"><span class='Ref_to_EnumConst'>CLASS_AND</span></a><span class='Operator'>: 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * OR-clause R=&GT; AND-clause if each of A's items refutes 
                     * any of B's items. 
                     */ 
</span>                    <a href="predtest.c.html#LN486"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                    <a href="predtest.c.html#LN68"><span class='Ref_to_Macro'>iterate_begin</span></a><span class='Parentheses'>(</span>citem<span class='Delimiter'>, </span><a href="predtest.c.html#LN480"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN482"><span class='Ref_To_Local'>clause_info</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span><a name="LN609"></a>                        <span class='Keyword'>bool</span>        <span class='Declare_Local'>presult</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
                        <a href="predtest.c.html#LN68"><span class='Ref_to_Macro'>iterate_begin</span></a><span class='Parentheses'>(</span>pitem<span class='Delimiter'>, </span><a href="predtest.c.html#LN480"><span class='Ref_to_Parameter'>predicate</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN483"><span class='Ref_To_Local'>pred_info</span></a><span class='Parentheses'>) 
</span>                        <span class='Delimiter'>{ 
</span>                            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN80"><span class='Ref_to_Proto'>predicate_refuted_by_recurse</span></a><span class='Parentheses'>(</span>citem<span class='Delimiter'>, </span>pitem<span class='Parentheses'>))</span> 
                            <span class='Delimiter'>{ 
</span>                                <a href="predtest.c.html#LN609"><span class='Ref_To_Local'>presult</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                                <span class='Control'>break</span><span class='Delimiter'>; 
</span>                            <span class='Delimiter'>} 
</span>                        <span class='Delimiter'>} 
</span>                        <a href="predtest.c.html#LN74"><span class='Ref_to_Macro'>iterate_end</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN483"><span class='Ref_To_Local'>pred_info</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predtest.c.html#LN609"><span class='Ref_To_Local'>presult</span></a><span class='Parentheses'>) 
</span>                        <span class='Delimiter'>{ 
</span>                            <a href="predtest.c.html#LN486"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* citem refutes nothing */ 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                    <span class='Delimiter'>} 
</span>                    <a href="predtest.c.html#LN74"><span class='Ref_to_Macro'>iterate_end</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN482"><span class='Ref_To_Local'>clause_info</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>return</span> <a href="predtest.c.html#LN486"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span> 
                <span class='Control'>case</span> <a href="predtest.c.html#LN49"><span class='Ref_to_EnumConst'>CLASS_ATOM</span></a><span class='Operator'>: 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * If B is a NOT-clause, A R=&GT; B if A =&GT; B's arg 
                     */ 
</span>                    <a href="predtest.c.html#LN485"><span class='Ref_To_Local'>not_arg</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN94"><span class='Ref_to_Proto'>extract_not_arg</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN480"><span class='Ref_to_Parameter'>predicate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN485"><span class='Ref_To_Local'>not_arg</span></a> <span class='Operator'>&& 
</span>                        <a href="predtest.c.html#LN79"><span class='Ref_to_Proto'>predicate_implied_by_recurse</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN480"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN485"><span class='Ref_To_Local'>not_arg</span></a><span class='Parentheses'>))</span> 
                        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * OR-clause R=&GT; atom if each of A's items refutes B 
                     */ 
</span>                    <a href="predtest.c.html#LN486"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                    <a href="predtest.c.html#LN68"><span class='Ref_to_Macro'>iterate_begin</span></a><span class='Parentheses'>(</span>citem<span class='Delimiter'>, </span><a href="predtest.c.html#LN480"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN482"><span class='Ref_To_Local'>clause_info</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predtest.c.html#LN80"><span class='Ref_to_Proto'>predicate_refuted_by_recurse</span></a><span class='Parentheses'>(</span>citem<span class='Delimiter'>, </span><a href="predtest.c.html#LN480"><span class='Ref_to_Parameter'>predicate</span></a><span class='Parentheses'>))</span> 
                        <span class='Delimiter'>{ 
</span>                            <a href="predtest.c.html#LN486"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                    <span class='Delimiter'>} 
</span>                    <a href="predtest.c.html#LN74"><span class='Ref_to_Macro'>iterate_end</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN482"><span class='Ref_To_Local'>clause_info</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>return</span> <a href="predtest.c.html#LN486"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch pclass &raquo; </span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="predtest.c.html#LN49"><span class='Ref_to_EnumConst'>CLASS_ATOM</span></a><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * If A is a strong NOT-clause, A R=&GT; B if B equals A's arg 
             * 
             * We cannot make the stronger conclusion that B is refuted if B 
             * implies A's arg; that would only prove that B is not-TRUE, not 
             * that it's not NULL either.  Hence use equal() rather than 
             * predicate_implied_by_recurse().  We could do the latter if we 
             * ever had a need for the weak form of refutation. 
             */ 
</span>            <a href="predtest.c.html#LN485"><span class='Ref_To_Local'>not_arg</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN95"><span class='Ref_to_Proto'>extract_strong_not_arg</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN480"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN485"><span class='Ref_To_Local'>not_arg</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN626"><span class='Ref_to_Proto'>equal</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN480"><span class='Ref_to_Parameter'>predicate</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN485"><span class='Ref_To_Local'>not_arg</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN484"><span class='Ref_To_Local'>pclass</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>case</span> <a href="predtest.c.html#LN50"><span class='Ref_to_EnumConst'>CLASS_AND</span></a><span class='Operator'>: 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * atom R=&GT; AND-clause if A refutes any of B's items 
                     */ 
</span>                    <a href="predtest.c.html#LN486"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                    <a href="predtest.c.html#LN68"><span class='Ref_to_Macro'>iterate_begin</span></a><span class='Parentheses'>(</span>pitem<span class='Delimiter'>, </span><a href="predtest.c.html#LN480"><span class='Ref_to_Parameter'>predicate</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN483"><span class='Ref_To_Local'>pred_info</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN80"><span class='Ref_to_Proto'>predicate_refuted_by_recurse</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN480"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span>pitem<span class='Parentheses'>))</span> 
                        <span class='Delimiter'>{ 
</span>                            <a href="predtest.c.html#LN486"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                    <span class='Delimiter'>} 
</span>                    <a href="predtest.c.html#LN74"><span class='Ref_to_Macro'>iterate_end</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN483"><span class='Ref_To_Local'>pred_info</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>return</span> <a href="predtest.c.html#LN486"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span> 
                <span class='Control'>case</span> <a href="predtest.c.html#LN51"><span class='Ref_to_EnumConst'>CLASS_OR</span></a><span class='Operator'>: 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * atom R=&GT; OR-clause if A refutes each of B's items 
                     */ 
</span>                    <a href="predtest.c.html#LN486"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                    <a href="predtest.c.html#LN68"><span class='Ref_to_Macro'>iterate_begin</span></a><span class='Parentheses'>(</span>pitem<span class='Delimiter'>, </span><a href="predtest.c.html#LN480"><span class='Ref_to_Parameter'>predicate</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN483"><span class='Ref_To_Local'>pred_info</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predtest.c.html#LN80"><span class='Ref_to_Proto'>predicate_refuted_by_recurse</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN480"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span>pitem<span class='Parentheses'>))</span> 
                        <span class='Delimiter'>{ 
</span>                            <a href="predtest.c.html#LN486"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                    <span class='Delimiter'>} 
</span>                    <a href="predtest.c.html#LN74"><span class='Ref_to_Macro'>iterate_end</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN483"><span class='Ref_To_Local'>pred_info</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>return</span> <a href="predtest.c.html#LN486"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span> 
                <span class='Control'>case</span> <a href="predtest.c.html#LN49"><span class='Ref_to_EnumConst'>CLASS_ATOM</span></a><span class='Operator'>: 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * If B is a NOT-clause, A R=&GT; B if A =&GT; B's arg 
                     */ 
</span>                    <a href="predtest.c.html#LN485"><span class='Ref_To_Local'>not_arg</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN94"><span class='Ref_to_Proto'>extract_not_arg</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN480"><span class='Ref_to_Parameter'>predicate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN485"><span class='Ref_To_Local'>not_arg</span></a> <span class='Operator'>&& 
</span>                        <a href="predtest.c.html#LN79"><span class='Ref_to_Proto'>predicate_implied_by_recurse</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN480"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN485"><span class='Ref_To_Local'>not_arg</span></a><span class='Parentheses'>))</span> 
                        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * atom R=&GT; atom is the base case 
                     */ 
</span>                    <span class='Control'>return</span> 
                        <a href="predtest.c.html#LN93"><span class='Ref_to_Proto'>predicate_refuted_by_simple_clause</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN480"><span class='Ref_to_Parameter'>predicate</span></a><span class='Delimiter'>, 
</span>                                                           <a href="predtest.c.html#LN480"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch pclass &raquo; </span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch predicate_classify(cl... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* can't get here */ 
</span>    <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"predicate_classify returned a bogus value"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end predicate_refuted_by_recurse &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * predicate_classify 
 *    Classify an expression node as AND-type, OR-type, or neither (an atom). 
 * 
 * If the expression is classified as AND- or OR-type, then *info is filled 
 * in with the functions needed to iterate over its components. 
 * 
 * This function also implements enforcement of MAX_SAOP_ARRAY_SIZE: if a 
 * ScalarArrayOpExpr's array has too many elements, we just classify it as an 
 * atom.  (This will result in its being passed as-is to the simple_clause 
 * functions, which will fail to prove anything about it.)  Note that we 
 * cannot just stop after considering MAX_SAOP_ARRAY_SIZE elements; in general 
 * that would result in wrong proofs, rather than failing to prove anything. 
 */ 
</span><span class='Keyword'>static </span><a href="predtest.c.html#LN47"><span class='Ref_to_Typedef'>PredClass</span></a> 
<a name="LN748"></a><span class='Declare_Function'>predicate_classify</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Delimiter'>, </span><a href="predtest.c.html#LN54"><span class='Ref_to_Typedef'>PredIterInfo</span></a> <span class='Declare_Parameter'>info</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* Caller should not pass us NULL, nor a RestrictInfo clause */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predtest.c.html#LN748"><span class='Ref_to_Parameter'>clause</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN748"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we see a List, assume it's an implicit-AND list; this is the correct 
     * semantics for lists of RestrictInfo nodes. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN748"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="predtest.c.html#LN748"><span class='Ref_to_Parameter'>info</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN61"><span class='Ref_to_Member'>startup_fn</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN82"><span class='Ref_to_Proto'>list_startup_fn</span></a><span class='Delimiter'>; 
</span>        <a href="predtest.c.html#LN748"><span class='Ref_to_Parameter'>info</span></a><span class='Operator'>-&GT;</span>next_fn <span class='Operator'>= </span><a href="predtest.c.html#LN83"><span class='Ref_to_Proto'>list_next_fn</span></a><span class='Delimiter'>; 
</span>        <a href="predtest.c.html#LN748"><span class='Ref_to_Parameter'>info</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN65"><span class='Ref_to_Member'>cleanup_fn</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN84"><span class='Ref_to_Proto'>list_cleanup_fn</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <a href="predtest.c.html#LN50"><span class='Ref_to_EnumConst'>CLASS_AND</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Handle normal AND and OR boolean clauses */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/clauses.h.html#LN42"><span class='Ref_to_Proto'>and_clause</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN748"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="predtest.c.html#LN748"><span class='Ref_to_Parameter'>info</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN61"><span class='Ref_to_Member'>startup_fn</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN85"><span class='Ref_to_Proto'>boolexpr_startup_fn</span></a><span class='Delimiter'>; 
</span>        <a href="predtest.c.html#LN748"><span class='Ref_to_Parameter'>info</span></a><span class='Operator'>-&GT;</span>next_fn <span class='Operator'>= </span><a href="predtest.c.html#LN83"><span class='Ref_to_Proto'>list_next_fn</span></a><span class='Delimiter'>; 
</span>        <a href="predtest.c.html#LN748"><span class='Ref_to_Parameter'>info</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN65"><span class='Ref_to_Member'>cleanup_fn</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN84"><span class='Ref_to_Proto'>list_cleanup_fn</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <a href="predtest.c.html#LN50"><span class='Ref_to_EnumConst'>CLASS_AND</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/clauses.h.html#LN39"><span class='Ref_to_Proto'>or_clause</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN748"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="predtest.c.html#LN748"><span class='Ref_to_Parameter'>info</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN61"><span class='Ref_to_Member'>startup_fn</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN85"><span class='Ref_to_Proto'>boolexpr_startup_fn</span></a><span class='Delimiter'>; 
</span>        <a href="predtest.c.html#LN748"><span class='Ref_to_Parameter'>info</span></a><span class='Operator'>-&GT;</span>next_fn <span class='Operator'>= </span><a href="predtest.c.html#LN83"><span class='Ref_to_Proto'>list_next_fn</span></a><span class='Delimiter'>; 
</span>        <a href="predtest.c.html#LN748"><span class='Ref_to_Parameter'>info</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN65"><span class='Ref_to_Member'>cleanup_fn</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN84"><span class='Ref_to_Proto'>list_cleanup_fn</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <a href="predtest.c.html#LN51"><span class='Ref_to_EnumConst'>CLASS_OR</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Handle ScalarArrayOpExpr */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN748"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN534"><span class='Ref_to_Struct'>ScalarArrayOpExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN785"></a>        <a href="../../../include/nodes/primnodes.h.html#LN534"><span class='Ref_to_Struct'>ScalarArrayOpExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>saop</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN534"><span class='Ref_to_Struct'>ScalarArrayOpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN748"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>; 
</span><a name="LN786"></a>        <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>arraynode</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN115"><span class='Ref_to_Macro'>lsecond</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN785"><span class='Ref_To_Local'>saop</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN541"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We can break this down into an AND or OR structure, but only if we 
         * know how to iterate through expressions for the array's elements. 
         * We can do that if the array operand is a non-null constant or a 
         * simple ArrayExpr. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN786"><span class='Ref_To_Local'>arraynode</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN786"><span class='Ref_To_Local'>arraynode</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>            <span class='Operator'>!</span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN786"><span class='Ref_To_Local'>arraynode</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constisnull<span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span><a name="LN797"></a>            <a href="../../../include/utils/array.h.html#LN75"><span class='Ref_to_Typedef'>ArrayType</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>arrayval</span><span class='Delimiter'>; 
</span><a name="LN798"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>nelems</span><span class='Delimiter'>; 
</span> 
            <a href="predtest.c.html#LN797"><span class='Ref_To_Local'>arrayval</span></a> <span class='Operator'>= </span><a href="../../../include/utils/array.h.html#LN241"><span class='Ref_to_Macro'>DatumGetArrayTypeP</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN786"><span class='Ref_To_Local'>arraynode</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constvalue<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="predtest.c.html#LN798"><span class='Ref_To_Local'>nelems</span></a> <span class='Operator'>= </span><a href="../../utils/adt/arrayutils.c.html#LN73"><span class='Ref_to_Func'>ArrayGetNItems</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/array.h.html#LN270"><span class='Ref_to_Macro'>ARR_NDIM</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN797"><span class='Ref_To_Local'>arrayval</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="../../../include/utils/array.h.html#LN274"><span class='Ref_to_Macro'>ARR_DIMS</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN797"><span class='Ref_To_Local'>arrayval</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN798"><span class='Ref_To_Local'>nelems</span></a> <span class='Operator'>&LT;= </span><a href="predtest.c.html#LN37"><span class='Ref_to_Const'>MAX_SAOP_ARRAY_SIZE</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="predtest.c.html#LN748"><span class='Ref_to_Parameter'>info</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN61"><span class='Ref_to_Member'>startup_fn</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN86"><span class='Ref_to_Proto'>arrayconst_startup_fn</span></a><span class='Delimiter'>; 
</span>                <a href="predtest.c.html#LN748"><span class='Ref_to_Parameter'>info</span></a><span class='Operator'>-&GT;</span>next_fn <span class='Operator'>= </span><a href="predtest.c.html#LN87"><span class='Ref_to_Proto'>arrayconst_next_fn</span></a><span class='Delimiter'>; 
</span>                <a href="predtest.c.html#LN748"><span class='Ref_to_Parameter'>info</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN65"><span class='Ref_to_Member'>cleanup_fn</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN88"><span class='Ref_to_Proto'>arrayconst_cleanup_fn</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <a href="predtest.c.html#LN785"><span class='Ref_To_Local'>saop</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN539"><span class='Ref_to_Member'>useOr</span></a> <span class='Operator'>? </span><a href="predtest.c.html#LN51"><span class='Ref_to_EnumConst'>CLASS_OR</span></a> <span class='Operator'>: </span><a href="predtest.c.html#LN50"><span class='Ref_to_EnumConst'>CLASS_AND</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN786"><span class='Ref_To_Local'>arraynode</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN786"><span class='Ref_To_Local'>arraynode</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN947"><span class='Ref_to_Struct'>ArrayExpr</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>                 <span class='Operator'>!</span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN947"><span class='Ref_to_Struct'>ArrayExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> <a href="predtest.c.html#LN786"><span class='Ref_To_Local'>arraynode</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>multidims <span class='Operator'>&& 
</span>                 <a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN947"><span class='Ref_to_Struct'>ArrayExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN786"><span class='Ref_To_Local'>arraynode</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>elements<span class='Parentheses'>)</span> <span class='Operator'>&LT;= </span><a href="predtest.c.html#LN37"><span class='Ref_to_Const'>MAX_SAOP_ARRAY_SIZE</span></a><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <a href="predtest.c.html#LN748"><span class='Ref_to_Parameter'>info</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN61"><span class='Ref_to_Member'>startup_fn</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN89"><span class='Ref_to_Proto'>arrayexpr_startup_fn</span></a><span class='Delimiter'>; 
</span>            <a href="predtest.c.html#LN748"><span class='Ref_to_Parameter'>info</span></a><span class='Operator'>-&GT;</span>next_fn <span class='Operator'>= </span><a href="predtest.c.html#LN90"><span class='Ref_to_Proto'>arrayexpr_next_fn</span></a><span class='Delimiter'>; 
</span>            <a href="predtest.c.html#LN748"><span class='Ref_to_Parameter'>info</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN65"><span class='Ref_to_Member'>cleanup_fn</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN91"><span class='Ref_to_Proto'>arrayexpr_cleanup_fn</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <a href="predtest.c.html#LN785"><span class='Ref_To_Local'>saop</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN539"><span class='Ref_to_Member'>useOr</span></a> <span class='Operator'>? </span><a href="predtest.c.html#LN51"><span class='Ref_to_EnumConst'>CLASS_OR</span></a> <span class='Operator'>: </span><a href="predtest.c.html#LN50"><span class='Ref_to_EnumConst'>CLASS_AND</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IsA(clause,ScalarArra... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* None of the above, so it's an atom */ 
</span>    <span class='Control'>return</span> <a href="predtest.c.html#LN49"><span class='Ref_to_EnumConst'>CLASS_ATOM</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end predicate_classify &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * PredIterInfo routines for iterating over regular Lists.  The iteration 
 * state variable is the next ListCell to visit. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN830"></a><span class='Declare_Function'>list_startup_fn</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Delimiter'>, </span><a href="predtest.c.html#LN54"><span class='Ref_to_Typedef'>PredIterInfo</span></a> <span class='Declare_Parameter'>info</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="predtest.c.html#LN830"><span class='Ref_to_Parameter'>info</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN59"><span class='Ref_to_Member'>state</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN830"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN836"></a><span class='Declare_Function'>list_next_fn</span><span class='Parentheses'>(</span><a href="predtest.c.html#LN54"><span class='Ref_to_Typedef'>PredIterInfo</span></a> <span class='Declare_Parameter'>info</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN838"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN836"><span class='Ref_to_Parameter'>info</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN59"><span class='Ref_to_Member'>state</span></a><span class='Delimiter'>; 
</span><a name="LN839"></a>    <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>n</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN838"><span class='Ref_To_Local'>l</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="predtest.c.html#LN839"><span class='Ref_To_Local'>n</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN838"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predtest.c.html#LN836"><span class='Ref_to_Parameter'>info</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN59"><span class='Ref_to_Member'>state</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN838"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="predtest.c.html#LN839"><span class='Ref_To_Local'>n</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static void 
</span><a name="LN849"></a><span class='Declare_Function'>list_cleanup_fn</span><span class='Parentheses'>(</span><a href="predtest.c.html#LN54"><span class='Ref_to_Typedef'>PredIterInfo</span></a> <span class='Declare_Parameter'>info</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* Nothing to clean up */ 
</span><span class='Delimiter'>} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * BoolExpr needs its own startup function, but can use list_next_fn and 
 * list_cleanup_fn. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN859"></a><span class='Declare_Function'>boolexpr_startup_fn</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Delimiter'>, </span><a href="predtest.c.html#LN54"><span class='Ref_to_Typedef'>PredIterInfo</span></a> <span class='Declare_Parameter'>info</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="predtest.c.html#LN859"><span class='Ref_to_Parameter'>info</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN59"><span class='Ref_to_Member'>state</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN859"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>args<span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * PredIterInfo routines for iterating over a ScalarArrayOpExpr with a 
 * constant array operand. 
 */ 
</span><span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN870"></a>    <a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a>      <span class='Declare_Member'>opexpr</span><span class='Delimiter'>; 
</span><a name="LN871"></a>    <a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a>       <span class='Declare_Member'>constexpr</span><span class='Delimiter'>; 
</span><a name="LN872"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>next_elem</span><span class='Delimiter'>; 
</span><a name="LN873"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>num_elems</span><span class='Delimiter'>; 
</span><a name="LN874"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>      <span class='Operator'>*</span><span class='Declare_Member'>elem_values</span><span class='Delimiter'>; 
</span><a name="LN875"></a>    <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Member'>elem_nulls</span><span class='Delimiter'>; 
</span><a name="LN876"></a>} <span class='Declare_Typedef'>ArrayConstIterState</span><span class='Delimiter'>; 
</span> 
<span class='Keyword'>static void 
</span><a name="LN879"></a><span class='Declare_Function'>arrayconst_startup_fn</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Delimiter'>, </span><a href="predtest.c.html#LN54"><span class='Ref_to_Typedef'>PredIterInfo</span></a> <span class='Declare_Parameter'>info</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN881"></a>    <a href="../../../include/nodes/primnodes.h.html#LN534"><span class='Ref_to_Struct'>ScalarArrayOpExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>saop</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN534"><span class='Ref_to_Struct'>ScalarArrayOpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN879"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>; 
</span><a name="LN882"></a>    <a href="predtest.c.html#LN868"><span class='Ref_to_Typedef'>ArrayConstIterState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>state</span><span class='Delimiter'>; 
</span><a name="LN883"></a>    <a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>arrayconst</span><span class='Delimiter'>; 
</span><a name="LN884"></a>    <a href="../../../include/utils/array.h.html#LN75"><span class='Ref_to_Typedef'>ArrayType</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>arrayval</span><span class='Delimiter'>; 
</span><a name="LN885"></a>    <a href="../../../include/c.h.html#LN254"><span class='Ref_to_Typedef'>int16</span></a>       <span class='Declare_Local'>elmlen</span><span class='Delimiter'>; 
</span><a name="LN886"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>elmbyval</span><span class='Delimiter'>; 
</span><a name="LN887"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>elmalign</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Create working state struct */ 
</span>    <a href="predtest.c.html#LN882"><span class='Ref_To_Local'>state</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="predtest.c.html#LN868"><span class='Ref_to_Typedef'>ArrayConstIterState</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="predtest.c.html#LN868"><span class='Ref_to_Typedef'>ArrayConstIterState</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="predtest.c.html#LN879"><span class='Ref_to_Parameter'>info</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN59"><span class='Ref_to_Member'>state</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN882"><span class='Ref_To_Local'>state</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Deconstruct the array literal */ 
</span>    <a href="predtest.c.html#LN883"><span class='Ref_To_Local'>arrayconst</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN115"><span class='Ref_to_Macro'>lsecond</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN881"><span class='Ref_To_Local'>saop</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN541"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predtest.c.html#LN884"><span class='Ref_To_Local'>arrayval</span></a> <span class='Operator'>= </span><a href="../../../include/utils/array.h.html#LN241"><span class='Ref_to_Macro'>DatumGetArrayTypeP</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN883"><span class='Ref_To_Local'>arrayconst</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/utils/lsyscache.h.html#LN136"><span class='Ref_to_Proto'>get_typlenbyvalalign</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/array.h.html#LN272"><span class='Ref_to_Macro'>ARR_ELEMTYPE</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN884"><span class='Ref_To_Local'>arrayval</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <span class='Operator'>&</span><a href="predtest.c.html#LN885"><span class='Ref_To_Local'>elmlen</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predtest.c.html#LN886"><span class='Ref_To_Local'>elmbyval</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predtest.c.html#LN887"><span class='Ref_To_Local'>elmalign</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/utils/array.h.html#LN382"><span class='Ref_to_Proto'>deconstruct_array</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN884"><span class='Ref_To_Local'>arrayval</span></a><span class='Delimiter'>, 
</span>                      <a href="../../../include/utils/array.h.html#LN272"><span class='Ref_to_Macro'>ARR_ELEMTYPE</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN884"><span class='Ref_To_Local'>arrayval</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                      <a href="predtest.c.html#LN885"><span class='Ref_To_Local'>elmlen</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN886"><span class='Ref_To_Local'>elmbyval</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN887"><span class='Ref_To_Local'>elmalign</span></a><span class='Delimiter'>, 
</span>                      <span class='Operator'>&</span><a href="predtest.c.html#LN882"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN874"><span class='Ref_to_Member'>elem_values</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predtest.c.html#LN882"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN875"><span class='Ref_to_Member'>elem_nulls</span></a><span class='Delimiter'>, 
</span>                      <span class='Operator'>&</span><a href="predtest.c.html#LN882"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN873"><span class='Ref_to_Member'>num_elems</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Set up a dummy OpExpr to return as the per-item node */ 
</span>    <a href="predtest.c.html#LN882"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN870"><span class='Ref_to_Member'>opexpr</span></a><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN493"><span class='Ref_to_Member'>xpr</span></a><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN133"><span class='Ref_to_Member'>type</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN154"><span class='Ref_to_EnumConst'>T_OpExpr</span></a><span class='Delimiter'>; 
</span>    <a href="predtest.c.html#LN882"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN870"><span class='Ref_to_Member'>opexpr</span></a><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN494"><span class='Ref_to_Member'>opno</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN881"><span class='Ref_To_Local'>saop</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN537"><span class='Ref_to_Member'>opno</span></a><span class='Delimiter'>; 
</span>    <a href="predtest.c.html#LN882"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN870"><span class='Ref_to_Member'>opexpr</span></a><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN495"><span class='Ref_to_Member'>opfuncid</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN881"><span class='Ref_To_Local'>saop</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN538"><span class='Ref_to_Member'>opfuncid</span></a><span class='Delimiter'>; 
</span>    <a href="predtest.c.html#LN882"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN870"><span class='Ref_to_Member'>opexpr</span></a><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN496"><span class='Ref_to_Member'>opresulttype</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN17"><span class='Ref_to_Const'>BOOLOID</span></a><span class='Delimiter'>; 
</span>    <a href="predtest.c.html#LN882"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN870"><span class='Ref_to_Member'>opexpr</span></a><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN497"><span class='Ref_to_Member'>opretset</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="predtest.c.html#LN882"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN870"><span class='Ref_to_Member'>opexpr</span></a><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN498"><span class='Ref_to_Member'>opcollid</span></a> <span class='Operator'>= </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>    <a href="predtest.c.html#LN882"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN870"><span class='Ref_to_Member'>opexpr</span></a><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN499"><span class='Ref_to_Member'>inputcollid</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN881"><span class='Ref_To_Local'>saop</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN540"><span class='Ref_to_Member'>inputcollid</span></a><span class='Delimiter'>; 
</span>    <a href="predtest.c.html#LN882"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN870"><span class='Ref_to_Member'>opexpr</span></a><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN500"><span class='Ref_to_Member'>args</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN268"><span class='Ref_to_Proto'>list_copy</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN881"><span class='Ref_To_Local'>saop</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN541"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Set up a dummy Const node to hold the per-element values */ 
</span>    <a href="predtest.c.html#LN882"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>constexpr</span><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN190"><span class='Ref_to_Member'>xpr</span></a><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN133"><span class='Ref_to_Member'>type</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN146"><span class='Ref_to_EnumConst'>T_Const</span></a><span class='Delimiter'>; 
</span>    <a href="predtest.c.html#LN882"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>constexpr</span><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN191"><span class='Ref_to_Member'>consttype</span></a> <span class='Operator'>= </span><a href="../../../include/utils/array.h.html#LN272"><span class='Ref_to_Macro'>ARR_ELEMTYPE</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN884"><span class='Ref_To_Local'>arrayval</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predtest.c.html#LN882"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>constexpr</span><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN192"><span class='Ref_to_Member'>consttypmod</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <a href="predtest.c.html#LN882"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>constexpr</span><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN193"><span class='Ref_to_Member'>constcollid</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN883"><span class='Ref_To_Local'>arrayconst</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN193"><span class='Ref_to_Member'>constcollid</span></a><span class='Delimiter'>; 
</span>    <a href="predtest.c.html#LN882"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>constexpr</span><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN194"><span class='Ref_to_Member'>constlen</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN885"><span class='Ref_To_Local'>elmlen</span></a><span class='Delimiter'>; 
</span>    <a href="predtest.c.html#LN882"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>constexpr</span><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN198"><span class='Ref_to_Member'>constbyval</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN886"><span class='Ref_To_Local'>elmbyval</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN115"><span class='Ref_to_Macro'>lsecond</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN882"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN870"><span class='Ref_to_Member'>opexpr</span></a><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN500"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>) </span><span class='Operator'>= &</span><a href="predtest.c.html#LN882"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>constexpr</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Initialize iteration state */ 
</span>    <a href="predtest.c.html#LN882"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN872"><span class='Ref_to_Member'>next_elem</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end arrayconst_startup_fn &raquo; </span> 
 
<span class='Keyword'>static </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN928"></a><span class='Declare_Function'>arrayconst_next_fn</span><span class='Parentheses'>(</span><a href="predtest.c.html#LN54"><span class='Ref_to_Typedef'>PredIterInfo</span></a> <span class='Declare_Parameter'>info</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN930"></a>    <a href="predtest.c.html#LN868"><span class='Ref_to_Typedef'>ArrayConstIterState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>state</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="predtest.c.html#LN868"><span class='Ref_to_Typedef'>ArrayConstIterState</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN928"><span class='Ref_to_Parameter'>info</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN59"><span class='Ref_to_Member'>state</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN930"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN872"><span class='Ref_to_Member'>next_elem</span></a> <span class='Operator'>&GT;= </span><a href="predtest.c.html#LN930"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN873"><span class='Ref_to_Member'>num_elems</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="predtest.c.html#LN930"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>constexpr</span><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN930"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN874"><span class='Ref_to_Member'>elem_values</span></a><span class='Delimiter'>[</span><a href="predtest.c.html#LN930"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN872"><span class='Ref_to_Member'>next_elem</span></a><span class='Delimiter'>]; 
</span>    <a href="predtest.c.html#LN930"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>constexpr</span><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN196"><span class='Ref_to_Member'>constisnull</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN930"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN875"><span class='Ref_to_Member'>elem_nulls</span></a><span class='Delimiter'>[</span><a href="predtest.c.html#LN930"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN872"><span class='Ref_to_Member'>next_elem</span></a><span class='Delimiter'>]; 
</span>    <a href="predtest.c.html#LN930"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN872"><span class='Ref_to_Member'>next_elem</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predtest.c.html#LN930"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN870"><span class='Ref_to_Member'>opexpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static void 
</span><a name="LN941"></a><span class='Declare_Function'>arrayconst_cleanup_fn</span><span class='Parentheses'>(</span><a href="predtest.c.html#LN54"><span class='Ref_to_Typedef'>PredIterInfo</span></a> <span class='Declare_Parameter'>info</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN943"></a>    <a href="predtest.c.html#LN868"><span class='Ref_to_Typedef'>ArrayConstIterState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>state</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="predtest.c.html#LN868"><span class='Ref_to_Typedef'>ArrayConstIterState</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN941"><span class='Ref_to_Parameter'>info</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN59"><span class='Ref_to_Member'>state</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN943"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN874"><span class='Ref_to_Member'>elem_values</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN943"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN875"><span class='Ref_to_Member'>elem_nulls</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN265"><span class='Ref_to_Proto'>list_free</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN943"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN870"><span class='Ref_to_Member'>opexpr</span></a><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN500"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN943"><span class='Ref_To_Local'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * PredIterInfo routines for iterating over a ScalarArrayOpExpr with a 
 * one-dimensional ArrayExpr array operand. 
 */ 
</span><span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN957"></a>    <a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a>      <span class='Declare_Member'>opexpr</span><span class='Delimiter'>; 
</span><a name="LN958"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>next</span><span class='Delimiter'>; 
</span><a name="LN959"></a>} <span class='Declare_Typedef'>ArrayExprIterState</span><span class='Delimiter'>; 
</span> 
<span class='Keyword'>static void 
</span><a name="LN962"></a><span class='Declare_Function'>arrayexpr_startup_fn</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Delimiter'>, </span><a href="predtest.c.html#LN54"><span class='Ref_to_Typedef'>PredIterInfo</span></a> <span class='Declare_Parameter'>info</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN964"></a>    <a href="../../../include/nodes/primnodes.h.html#LN534"><span class='Ref_to_Struct'>ScalarArrayOpExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>saop</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN534"><span class='Ref_to_Struct'>ScalarArrayOpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN962"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>; 
</span><a name="LN965"></a>    <a href="predtest.c.html#LN955"><span class='Ref_to_Typedef'>ArrayExprIterState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>state</span><span class='Delimiter'>; 
</span><a name="LN966"></a>    <a href="../../../include/nodes/primnodes.h.html#LN947"><span class='Ref_to_Struct'>ArrayExpr</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>arrayexpr</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Create working state struct */ 
</span>    <a href="predtest.c.html#LN965"><span class='Ref_To_Local'>state</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="predtest.c.html#LN955"><span class='Ref_to_Typedef'>ArrayExprIterState</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="predtest.c.html#LN955"><span class='Ref_to_Typedef'>ArrayExprIterState</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="predtest.c.html#LN962"><span class='Ref_to_Parameter'>info</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN59"><span class='Ref_to_Member'>state</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN965"><span class='Ref_To_Local'>state</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Set up a dummy OpExpr to return as the per-item node */ 
</span>    <a href="predtest.c.html#LN965"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN957"><span class='Ref_to_Member'>opexpr</span></a><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN493"><span class='Ref_to_Member'>xpr</span></a><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN133"><span class='Ref_to_Member'>type</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN154"><span class='Ref_to_EnumConst'>T_OpExpr</span></a><span class='Delimiter'>; 
</span>    <a href="predtest.c.html#LN965"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN957"><span class='Ref_to_Member'>opexpr</span></a><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN494"><span class='Ref_to_Member'>opno</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN964"><span class='Ref_To_Local'>saop</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN537"><span class='Ref_to_Member'>opno</span></a><span class='Delimiter'>; 
</span>    <a href="predtest.c.html#LN965"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN957"><span class='Ref_to_Member'>opexpr</span></a><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN495"><span class='Ref_to_Member'>opfuncid</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN964"><span class='Ref_To_Local'>saop</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN538"><span class='Ref_to_Member'>opfuncid</span></a><span class='Delimiter'>; 
</span>    <a href="predtest.c.html#LN965"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN957"><span class='Ref_to_Member'>opexpr</span></a><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN496"><span class='Ref_to_Member'>opresulttype</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN17"><span class='Ref_to_Const'>BOOLOID</span></a><span class='Delimiter'>; 
</span>    <a href="predtest.c.html#LN965"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN957"><span class='Ref_to_Member'>opexpr</span></a><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN497"><span class='Ref_to_Member'>opretset</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="predtest.c.html#LN965"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN957"><span class='Ref_to_Member'>opexpr</span></a><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN498"><span class='Ref_to_Member'>opcollid</span></a> <span class='Operator'>= </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>    <a href="predtest.c.html#LN965"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN957"><span class='Ref_to_Member'>opexpr</span></a><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN499"><span class='Ref_to_Member'>inputcollid</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN964"><span class='Ref_To_Local'>saop</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN540"><span class='Ref_to_Member'>inputcollid</span></a><span class='Delimiter'>; 
</span>    <a href="predtest.c.html#LN965"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN957"><span class='Ref_to_Member'>opexpr</span></a><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN500"><span class='Ref_to_Member'>args</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN268"><span class='Ref_to_Proto'>list_copy</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN964"><span class='Ref_To_Local'>saop</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN541"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Initialize iteration variable to first member of ArrayExpr */ 
</span>    <a href="predtest.c.html#LN966"><span class='Ref_To_Local'>arrayexpr</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN947"><span class='Ref_to_Struct'>ArrayExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN115"><span class='Ref_to_Macro'>lsecond</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN964"><span class='Ref_To_Local'>saop</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN541"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predtest.c.html#LN965"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN958"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN966"><span class='Ref_To_Local'>arrayexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN953"><span class='Ref_to_Member'>elements</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end arrayexpr_startup_fn &raquo; </span> 
 
<span class='Keyword'>static </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN988"></a><span class='Declare_Function'>arrayexpr_next_fn</span><span class='Parentheses'>(</span><a href="predtest.c.html#LN54"><span class='Ref_to_Typedef'>PredIterInfo</span></a> <span class='Declare_Parameter'>info</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN990"></a>    <a href="predtest.c.html#LN955"><span class='Ref_to_Typedef'>ArrayExprIterState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>state</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="predtest.c.html#LN955"><span class='Ref_to_Typedef'>ArrayExprIterState</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN988"><span class='Ref_to_Parameter'>info</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN59"><span class='Ref_to_Member'>state</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN990"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN958"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN115"><span class='Ref_to_Macro'>lsecond</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN990"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN957"><span class='Ref_to_Member'>opexpr</span></a><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN500"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN990"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN958"><span class='Ref_to_Member'>next</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predtest.c.html#LN990"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN958"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN990"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN958"><span class='Ref_to_Member'>next</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predtest.c.html#LN990"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN957"><span class='Ref_to_Member'>opexpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static void 
</span><a name="LN1000"></a><span class='Declare_Function'>arrayexpr_cleanup_fn</span><span class='Parentheses'>(</span><a href="predtest.c.html#LN54"><span class='Ref_to_Typedef'>PredIterInfo</span></a> <span class='Declare_Parameter'>info</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1002"></a>    <a href="predtest.c.html#LN955"><span class='Ref_to_Typedef'>ArrayExprIterState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>state</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="predtest.c.html#LN955"><span class='Ref_to_Typedef'>ArrayExprIterState</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1000"><span class='Ref_to_Parameter'>info</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN59"><span class='Ref_to_Member'>state</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN265"><span class='Ref_to_Proto'>list_free</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1002"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN957"><span class='Ref_to_Member'>opexpr</span></a><span class='Operator'>.</span><a href="../../../include/nodes/primnodes.h.html#LN500"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1002"><span class='Ref_To_Local'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/*---------- 
 * predicate_implied_by_simple_clause 
 *    Does the predicate implication test for a "simple clause" predicate 
 *    and a "simple clause" restriction. 
 * 
 * We return TRUE if able to prove the implication, FALSE if not. 
 * 
 * We have three strategies for determining whether one simple clause 
 * implies another: 
 * 
 * A simple and general way is to see if they are equal(); this works for any 
 * kind of expression.  (Actually, there is an implied assumption that the 
 * functions in the expression are immutable, ie dependent only on their input 
 * arguments --- but this was checked for the predicate by the caller.) 
 * 
 * When the predicate is of the form "foo IS NOT NULL", we can conclude that 
 * the predicate is implied if the clause is a strict operator or function 
 * that has "foo" as an input.  In this case the clause must yield NULL when 
 * "foo" is NULL, which we can take as equivalent to FALSE because we know 
 * we are within an AND/OR subtree of a WHERE clause.  (Again, "foo" is 
 * already known immutable, so the clause will certainly always fail.) 
 * Also, if the clause is just "foo" (meaning it's a boolean variable), 
 * the predicate is implied since the clause can't be true if "foo" is NULL. 
 * 
 * Finally, if both clauses are binary operator expressions, we may be able 
 * to prove something using the system's knowledge about operators; those 
 * proof rules are encapsulated in operator_predicate_proof(). 
 *---------- 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN1039"></a><span class='Declare_Function'>predicate_implied_by_simple_clause</span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>predicate</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* Allow interrupting long proof attempts */ 
</span>    <a href="../../../include/miscadmin.h.html#LN99"><span class='Ref_to_Macro'>CHECK_FOR_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* First try the equal() test */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN626"><span class='Ref_to_Proto'>equal</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1039"><span class='Ref_to_Parameter'>predicate</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1039"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Next try the IS NOT NULL case */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1039"><span class='Ref_to_Parameter'>predicate</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1039"><span class='Ref_to_Parameter'>predicate</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>        <span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1039"><span class='Ref_to_Parameter'>predicate</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>nulltesttype <span class='Operator'>== </span><a href="../../../include/nodes/primnodes.h.html#LN1172"><span class='Ref_to_EnumConst'>IS_NOT_NULL</span></a><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1052"></a>        <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>nonnullarg</span> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1039"><span class='Ref_to_Parameter'>predicate</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>arg<span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* row IS NOT NULL does not act in the simple way we have in mind */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1039"><span class='Ref_to_Parameter'>predicate</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>argisrow<span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/clauses.h.html#LN19"><span class='Ref_to_Macro'>is_opclause</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1039"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>                <a href="predtest.c.html#LN96"><span class='Ref_to_Proto'>list_member_strip</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1039"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>args<span class='Delimiter'>, </span><a href="predtest.c.html#LN1052"><span class='Ref_To_Local'>nonnullarg</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>                <a href="../../../include/utils/lsyscache.h.html#LN104"><span class='Ref_to_Proto'>op_strict</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1039"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>opno<span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/clauses.h.html#LN20"><span class='Ref_to_Macro'>is_funcclause</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1039"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>                <a href="predtest.c.html#LN96"><span class='Ref_to_Proto'>list_member_strip</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1039"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>args<span class='Delimiter'>, </span><a href="predtest.c.html#LN1052"><span class='Ref_To_Local'>nonnullarg</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>                <a href="../../../include/utils/lsyscache.h.html#LN117"><span class='Ref_to_Proto'>func_strict</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1039"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>funcid<span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN626"><span class='Ref_to_Proto'>equal</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1039"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1052"><span class='Ref_To_Local'>nonnullarg</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* we can't succeed below... */ 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if predicate&&IsA(predic... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Else try operator-related knowledge */ 
</span>    <span class='Control'>return</span> <a href="predtest.c.html#LN97"><span class='Ref_to_Proto'>operator_predicate_proof</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1039"><span class='Ref_to_Parameter'>predicate</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1039"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end predicate_implied_by_simple_clause &raquo; </span> 
 
<span class='Comment_Multi_Line'>/*---------- 
 * predicate_refuted_by_simple_clause 
 *    Does the predicate refutation test for a "simple clause" predicate 
 *    and a "simple clause" restriction. 
 * 
 * We return TRUE if able to prove the refutation, FALSE if not. 
 * 
 * Unlike the implication case, checking for equal() clauses isn't 
 * helpful. 
 * 
 * When the predicate is of the form "foo IS NULL", we can conclude that 
 * the predicate is refuted if the clause is a strict operator or function 
 * that has "foo" as an input (see notes for implication case), or if the 
 * clause is "foo IS NOT NULL".  A clause "foo IS NULL" refutes a predicate 
 * "foo IS NOT NULL", but unfortunately does not refute strict predicates, 
 * because we are looking for strong refutation.  (The motivation for covering 
 * these cases is to support using IS NULL/IS NOT NULL as partition-defining 
 * constraints.) 
 * 
 * Finally, if both clauses are binary operator expressions, we may be able 
 * to prove something using the system's knowledge about operators; those 
 * proof rules are encapsulated in operator_predicate_proof(). 
 *---------- 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN1100"></a><span class='Declare_Function'>predicate_refuted_by_simple_clause</span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>predicate</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* Allow interrupting long proof attempts */ 
</span>    <a href="../../../include/miscadmin.h.html#LN99"><span class='Ref_to_Macro'>CHECK_FOR_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* A simple clause can't refute itself */ 
</span>    <span class='Comment_Multi_Line'>/* Worth checking because of relation_excluded_by_constraints() */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1100"><span class='Ref_to_Parameter'>predicate</span></a> <span class='Operator'>== </span><a href="predtest.c.html#LN1100"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Try the predicate-IS-NULL case */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1100"><span class='Ref_to_Parameter'>predicate</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1100"><span class='Ref_to_Parameter'>predicate</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>        <span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1100"><span class='Ref_to_Parameter'>predicate</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>nulltesttype <span class='Operator'>== </span><a href="../../../include/nodes/primnodes.h.html#LN1172"><span class='Ref_to_EnumConst'>IS_NULL</span></a><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1114"></a>        <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>isnullarg</span> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1100"><span class='Ref_to_Parameter'>predicate</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>arg<span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* row IS NULL does not act in the simple way we have in mind */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1100"><span class='Ref_to_Parameter'>predicate</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>argisrow<span class='Parentheses'>)</span> 
            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Any strict op/func on foo refutes foo IS NULL */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/clauses.h.html#LN19"><span class='Ref_to_Macro'>is_opclause</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1100"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>            <a href="predtest.c.html#LN96"><span class='Ref_to_Proto'>list_member_strip</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1100"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>args<span class='Delimiter'>, </span><a href="predtest.c.html#LN1114"><span class='Ref_To_Local'>isnullarg</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>            <a href="../../../include/utils/lsyscache.h.html#LN104"><span class='Ref_to_Proto'>op_strict</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1100"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>opno<span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/clauses.h.html#LN20"><span class='Ref_to_Macro'>is_funcclause</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1100"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>            <a href="predtest.c.html#LN96"><span class='Ref_to_Proto'>list_member_strip</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1100"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>args<span class='Delimiter'>, </span><a href="predtest.c.html#LN1114"><span class='Ref_To_Local'>isnullarg</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>            <a href="../../../include/utils/lsyscache.h.html#LN117"><span class='Ref_to_Proto'>func_strict</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1100"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>funcid<span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* foo IS NOT NULL refutes foo IS NULL */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1100"><span class='Ref_to_Parameter'>clause</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1100"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>            <span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> <a href="predtest.c.html#LN1100"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>nulltesttype <span class='Operator'>== </span><a href="../../../include/nodes/primnodes.h.html#LN1172"><span class='Ref_to_EnumConst'>IS_NOT_NULL</span></a> <span class='Operator'>&& 
</span>            <span class='Operator'>!</span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> <a href="predtest.c.html#LN1100"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>argisrow <span class='Operator'>&& 
</span>            <a href="../../../include/nodes/nodes.h.html#LN626"><span class='Ref_to_Proto'>equal</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1100"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>arg<span class='Delimiter'>, </span><a href="predtest.c.html#LN1114"><span class='Ref_To_Local'>isnullarg</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* we can't succeed below... */ 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if predicate&&IsA(predic... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Try the clause-IS-NULL case */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1100"><span class='Ref_to_Parameter'>clause</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1100"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>        <span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1100"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>nulltesttype <span class='Operator'>== </span><a href="../../../include/nodes/primnodes.h.html#LN1172"><span class='Ref_to_EnumConst'>IS_NULL</span></a><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1144"></a>        <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>isnullarg</span> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1100"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>arg<span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* row IS NULL does not act in the simple way we have in mind */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1100"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>argisrow<span class='Parentheses'>)</span> 
            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* foo IS NULL refutes foo IS NOT NULL */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1100"><span class='Ref_to_Parameter'>predicate</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1100"><span class='Ref_to_Parameter'>predicate</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>            <span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> <a href="predtest.c.html#LN1100"><span class='Ref_to_Parameter'>predicate</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>nulltesttype <span class='Operator'>== </span><a href="../../../include/nodes/primnodes.h.html#LN1172"><span class='Ref_to_EnumConst'>IS_NOT_NULL</span></a> <span class='Operator'>&& 
</span>            <span class='Operator'>!</span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> <a href="predtest.c.html#LN1100"><span class='Ref_to_Parameter'>predicate</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>argisrow <span class='Operator'>&& 
</span>            <a href="../../../include/nodes/nodes.h.html#LN626"><span class='Ref_to_Proto'>equal</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1100"><span class='Ref_to_Parameter'>predicate</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>arg<span class='Delimiter'>, </span><a href="predtest.c.html#LN1144"><span class='Ref_To_Local'>isnullarg</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* we can't succeed below... */ 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Else try operator-related knowledge */ 
</span>    <span class='Control'>return</span> <a href="predtest.c.html#LN97"><span class='Ref_to_Proto'>operator_predicate_proof</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1100"><span class='Ref_to_Parameter'>predicate</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1100"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end predicate_refuted_by_simple_clause &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * If clause asserts the non-truth of a subclause, return that subclause; 
 * otherwise return NULL. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN1170"></a><span class='Declare_Function'>extract_not_arg</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1170"><span class='Ref_to_Parameter'>clause</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1170"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1176"></a>        <a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>bexpr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1170"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1176"><span class='Ref_To_Local'>bexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN560"><span class='Ref_to_Member'>boolop</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/primnodes.h.html#LN554"><span class='Ref_to_EnumConst'>NOT_EXPR</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1176"><span class='Ref_To_Local'>bexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN561"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1170"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1198"><span class='Ref_to_Struct'>BooleanTest</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1183"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1198"><span class='Ref_to_Struct'>BooleanTest</span></a> <span class='Operator'>*</span><span class='Declare_Local'>btest</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1198"><span class='Ref_to_Struct'>BooleanTest</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1170"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1183"><span class='Ref_To_Local'>btest</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1202"><span class='Ref_to_Member'>booltesttype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/primnodes.h.html#LN1195"><span class='Ref_to_EnumConst'>IS_NOT_TRUE</span></a> <span class='Operator'>|| 
</span>            <a href="predtest.c.html#LN1183"><span class='Ref_To_Local'>btest</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1202"><span class='Ref_to_Member'>booltesttype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/primnodes.h.html#LN1195"><span class='Ref_to_EnumConst'>IS_FALSE</span></a> <span class='Operator'>|| 
</span>            <a href="predtest.c.html#LN1183"><span class='Ref_To_Local'>btest</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1202"><span class='Ref_to_Member'>booltesttype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/primnodes.h.html#LN1195"><span class='Ref_to_EnumConst'>IS_UNKNOWN</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1183"><span class='Ref_To_Local'>btest</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1201"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end extract_not_arg &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * If clause asserts the falsity of a subclause, return that subclause; 
 * otherwise return NULL. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN1198"></a><span class='Declare_Function'>extract_strong_not_arg</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1198"><span class='Ref_to_Parameter'>clause</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1198"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1204"></a>        <a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>bexpr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN557"><span class='Ref_to_Struct'>BoolExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1198"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1204"><span class='Ref_To_Local'>bexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN560"><span class='Ref_to_Member'>boolop</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/primnodes.h.html#LN554"><span class='Ref_to_EnumConst'>NOT_EXPR</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1204"><span class='Ref_To_Local'>bexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN561"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1198"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1198"><span class='Ref_to_Struct'>BooleanTest</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1211"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1198"><span class='Ref_to_Struct'>BooleanTest</span></a> <span class='Operator'>*</span><span class='Declare_Local'>btest</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1198"><span class='Ref_to_Struct'>BooleanTest</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1198"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1211"><span class='Ref_To_Local'>btest</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1202"><span class='Ref_to_Member'>booltesttype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/primnodes.h.html#LN1195"><span class='Ref_to_EnumConst'>IS_FALSE</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1211"><span class='Ref_To_Local'>btest</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1201"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end extract_strong_not_arg &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Check whether an Expr is equal() to any member of a list, ignoring 
 * any top-level RelabelType nodes.  This is legitimate for the purposes 
 * we use it for (matching IS [NOT] NULL arguments to arguments of strict 
 * functions) because RelabelType doesn't change null-ness.  It's helpful 
 * for cases such as a varchar argument of a strict function on text. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN1228"></a><span class='Declare_Function'>list_member_strip</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>datum</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1230"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>cell</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1228"><span class='Ref_to_Parameter'>datum</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1228"><span class='Ref_to_Parameter'>datum</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a><span class='Parentheses'>))</span> 
        <a href="predtest.c.html#LN1228"><span class='Ref_to_Parameter'>datum</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1228"><span class='Ref_to_Parameter'>datum</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>arg<span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1230"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1228"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1237"></a>        <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>elem</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1230"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1237"><span class='Ref_To_Local'>elem</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1237"><span class='Ref_To_Local'>elem</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a><span class='Parentheses'>))</span> 
            <a href="predtest.c.html#LN1237"><span class='Ref_To_Local'>elem</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1237"><span class='Ref_To_Local'>elem</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>arg<span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN626"><span class='Ref_to_Proto'>equal</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1237"><span class='Ref_To_Local'>elem</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1228"><span class='Ref_to_Parameter'>datum</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end list_member_strip &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Define "operator implication tables" for btree operators ("strategies"), 
 * and similar tables for refutation. 
 * 
 * The strategy numbers defined by btree indexes (see access/stratnum.h) are: 
 *      1 &LT;     2 &LT;=    3 =     4 &GT;=    5 &GT; 
 * and in addition we use 6 to represent &LT;&GT;.  &LT;&GT; is not a btree-indexable 
 * operator, but we assume here that if an equality operator of a btree 
 * opfamily has a negator operator, the negator behaves as &LT;&GT; for the opfamily. 
 * (This convention is also known to get_op_btree_interpretation().) 
 * 
 * BT_implies_table[] and BT_refutes_table[] are used for cases where we have 
 * two identical subexpressions and we want to know whether one operator 
 * expression implies or refutes the other.  That is, if the "clause" is 
 * EXPR1 clause_op EXPR2 and the "predicate" is EXPR1 pred_op EXPR2 for the 
 * same two (immutable) subexpressions: 
 *      BT_implies_table[clause_op-1][pred_op-1] 
 *          is true if the clause implies the predicate 
 *      BT_refutes_table[clause_op-1][pred_op-1] 
 *          is true if the clause refutes the predicate 
 * where clause_op and pred_op are strategy numbers (from 1 to 6) in the 
 * same btree opfamily.  For example, "x &LT; y" implies "x &LT;= y" and refutes 
 * "x &GT; y". 
 * 
 * BT_implic_table[] and BT_refute_table[] are used where we have two 
 * constants that we need to compare.  The interpretation of: 
 * 
 *      test_op = BT_implic_table[clause_op-1][pred_op-1] 
 * 
 * where test_op, clause_op and pred_op are strategy numbers (from 1 to 6) 
 * of btree operators, is as follows: 
 * 
 *   If you know, for some EXPR, that "EXPR clause_op CONST1" is true, and you 
 *   want to determine whether "EXPR pred_op CONST2" must also be true, then 
 *   you can use "CONST2 test_op CONST1" as a test.  If this test returns true, 
 *   then the predicate expression must be true; if the test returns false, 
 *   then the predicate expression may be false. 
 * 
 * For example, if clause is "Quantity &GT; 10" and pred is "Quantity &GT; 5" 
 * then we test "5 &LT;= 10" which evals to true, so clause implies pred. 
 * 
 * Similarly, the interpretation of a BT_refute_table entry is: 
 * 
 *   If you know, for some EXPR, that "EXPR clause_op CONST1" is true, and you 
 *   want to determine whether "EXPR pred_op CONST2" must be false, then 
 *   you can use "CONST2 test_op CONST1" as a test.  If this test returns true, 
 *   then the predicate expression must be false; if the test returns false, 
 *   then the predicate expression may be true. 
 * 
 * For example, if clause is "Quantity &GT; 10" and pred is "Quantity &LT; 5" 
 * then we test "5 &LT;= 10" which evals to true, so clause refutes pred. 
 * 
 * An entry where test_op == 0 means the implication cannot be determined. 
 */ 
</span> 
<a name="LN1305"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>BTLT</span> <a href="../../../include/access/stratnum.h.html#LN28"><span class='Ref_to_Const'>BTLessStrategyNumber</span></a> 
<a name="LN1306"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>BTLE</span> <a href="../../../include/access/stratnum.h.html#LN29"><span class='Ref_to_Const'>BTLessEqualStrategyNumber</span></a> 
<a name="LN1307"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>BTEQ</span> <a href="../../../include/access/stratnum.h.html#LN30"><span class='Ref_to_Const'>BTEqualStrategyNumber</span></a> 
<a name="LN1308"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>BTGE</span> <a href="../../../include/access/stratnum.h.html#LN31"><span class='Ref_to_Const'>BTGreaterEqualStrategyNumber</span></a> 
<a name="LN1309"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>BTGT</span> <a href="../../../include/access/stratnum.h.html#LN32"><span class='Ref_to_Const'>BTGreaterStrategyNumber</span></a> 
<a name="LN1310"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>BTNE</span> <a href="../../../include/nodes/primnodes.h.html#LN1023"><span class='Ref_to_EnumConst'>ROWCOMPARE_NE</span></a> 
 
<span class='Comment_Multi_Line'>/* We use "none" for 0/false to make the tables align nicely */ 
</span><a name="LN1313"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>none</span> <span class='Number'>0</span> 
 
<a name="LN1315"></a><span class='Keyword'>static const bool </span><span class='Declare_Var'>BT_implies_table</span><span class='Delimiter'>[</span><span class='Number'>6</span><span class='Delimiter'>][</span><span class='Number'>6</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Delimiter'>{ 
</span><span class='Comment_Multi_Line'>/* 
 *          The predicate operator: 
 *   LT    LE    EQ    GE    GT    NE 
 */ 
</span>    <span class='Delimiter'>{</span><span class='Boolean'>TRUE</span><span class='Delimiter'>, </span><span class='Boolean'>TRUE</span><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><span class='Boolean'>TRUE</span><span class='Delimiter'>},</span>       <span class='Comment_Single_Line'>/* LT */ 
</span>    <span class='Delimiter'>{</span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><span class='Boolean'>TRUE</span><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>},</span>       <span class='Comment_Single_Line'>/* LE */ 
</span>    <span class='Delimiter'>{</span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><span class='Boolean'>TRUE</span><span class='Delimiter'>, </span><span class='Boolean'>TRUE</span><span class='Delimiter'>, </span><span class='Boolean'>TRUE</span><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>},</span>       <span class='Comment_Single_Line'>/* EQ */ 
</span>    <span class='Delimiter'>{</span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><span class='Boolean'>TRUE</span><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>},</span>       <span class='Comment_Single_Line'>/* GE */ 
</span>    <span class='Delimiter'>{</span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><span class='Boolean'>TRUE</span><span class='Delimiter'>, </span><span class='Boolean'>TRUE</span><span class='Delimiter'>, </span><span class='Boolean'>TRUE</span><span class='Delimiter'>},</span>       <span class='Comment_Single_Line'>/* GT */ 
</span>    <span class='Delimiter'>{</span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><span class='Boolean'>TRUE</span><span class='Delimiter'>}</span>        <span class='Comment_Single_Line'>/* NE */ 
</span><span class='Delimiter'>}; 
</span> 
<a name="LN1328"></a><span class='Keyword'>static const bool </span><span class='Declare_Var'>BT_refutes_table</span><span class='Delimiter'>[</span><span class='Number'>6</span><span class='Delimiter'>][</span><span class='Number'>6</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Delimiter'>{ 
</span><span class='Comment_Multi_Line'>/* 
 *          The predicate operator: 
 *   LT    LE    EQ    GE    GT    NE 
 */ 
</span>    <span class='Delimiter'>{</span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><span class='Boolean'>TRUE</span><span class='Delimiter'>, </span><span class='Boolean'>TRUE</span><span class='Delimiter'>, </span><span class='Boolean'>TRUE</span><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>},</span>       <span class='Comment_Single_Line'>/* LT */ 
</span>    <span class='Delimiter'>{</span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><span class='Boolean'>TRUE</span><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>},</span>       <span class='Comment_Single_Line'>/* LE */ 
</span>    <span class='Delimiter'>{</span><span class='Boolean'>TRUE</span><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><span class='Boolean'>TRUE</span><span class='Delimiter'>, </span><span class='Boolean'>TRUE</span><span class='Delimiter'>},</span>       <span class='Comment_Single_Line'>/* EQ */ 
</span>    <span class='Delimiter'>{</span><span class='Boolean'>TRUE</span><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>},</span>       <span class='Comment_Single_Line'>/* GE */ 
</span>    <span class='Delimiter'>{</span><span class='Boolean'>TRUE</span><span class='Delimiter'>, </span><span class='Boolean'>TRUE</span><span class='Delimiter'>, </span><span class='Boolean'>TRUE</span><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>},</span>       <span class='Comment_Single_Line'>/* GT */ 
</span>    <span class='Delimiter'>{</span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><span class='Boolean'>TRUE</span><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>}</span>        <span class='Comment_Single_Line'>/* NE */ 
</span><span class='Delimiter'>}; 
</span> 
<a name="LN1341"></a><span class='Keyword'>static const </span><a href="../../../include/access/stratnum.h.html#LN21"><span class='Ref_to_Typedef'>StrategyNumber</span></a> <span class='Declare_Var'>BT_implic_table</span><span class='Delimiter'>[</span><span class='Number'>6</span><span class='Delimiter'>][</span><span class='Number'>6</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Delimiter'>{ 
</span><span class='Comment_Multi_Line'>/* 
 *          The predicate operator: 
 *   LT    LE    EQ    GE    GT    NE 
 */ 
</span>    <span class='Delimiter'>{</span><a href="predtest.c.html#LN1308"><span class='Ref_to_Const'>BTGE</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1308"><span class='Ref_to_Const'>BTGE</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1308"><span class='Ref_to_Const'>BTGE</span></a><span class='Delimiter'>},</span>       <span class='Comment_Single_Line'>/* LT */ 
</span>    <span class='Delimiter'>{</span><a href="predtest.c.html#LN1309"><span class='Ref_to_Const'>BTGT</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1308"><span class='Ref_to_Const'>BTGE</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1309"><span class='Ref_to_Const'>BTGT</span></a><span class='Delimiter'>},</span>       <span class='Comment_Single_Line'>/* LE */ 
</span>    <span class='Delimiter'>{</span><a href="predtest.c.html#LN1309"><span class='Ref_to_Const'>BTGT</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1308"><span class='Ref_to_Const'>BTGE</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1307"><span class='Ref_to_Const'>BTEQ</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1306"><span class='Ref_to_Const'>BTLE</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1305"><span class='Ref_to_Const'>BTLT</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1310"><span class='Ref_to_Const'>BTNE</span></a><span class='Delimiter'>},</span>       <span class='Comment_Single_Line'>/* EQ */ 
</span>    <span class='Delimiter'>{</span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1306"><span class='Ref_to_Const'>BTLE</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1305"><span class='Ref_to_Const'>BTLT</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1305"><span class='Ref_to_Const'>BTLT</span></a><span class='Delimiter'>},</span>       <span class='Comment_Single_Line'>/* GE */ 
</span>    <span class='Delimiter'>{</span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1306"><span class='Ref_to_Const'>BTLE</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1306"><span class='Ref_to_Const'>BTLE</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1306"><span class='Ref_to_Const'>BTLE</span></a><span class='Delimiter'>},</span>       <span class='Comment_Single_Line'>/* GT */ 
</span>    <span class='Delimiter'>{</span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1307"><span class='Ref_to_Const'>BTEQ</span></a><span class='Delimiter'>}</span>        <span class='Comment_Single_Line'>/* NE */ 
</span><span class='Delimiter'>}; 
</span> 
<a name="LN1354"></a><span class='Keyword'>static const </span><a href="../../../include/access/stratnum.h.html#LN21"><span class='Ref_to_Typedef'>StrategyNumber</span></a> <span class='Declare_Var'>BT_refute_table</span><span class='Delimiter'>[</span><span class='Number'>6</span><span class='Delimiter'>][</span><span class='Number'>6</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Delimiter'>{ 
</span><span class='Comment_Multi_Line'>/* 
 *          The predicate operator: 
 *   LT    LE    EQ    GE    GT    NE 
 */ 
</span>    <span class='Delimiter'>{</span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1308"><span class='Ref_to_Const'>BTGE</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1308"><span class='Ref_to_Const'>BTGE</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1308"><span class='Ref_to_Const'>BTGE</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>},</span>       <span class='Comment_Single_Line'>/* LT */ 
</span>    <span class='Delimiter'>{</span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1309"><span class='Ref_to_Const'>BTGT</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1309"><span class='Ref_to_Const'>BTGT</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1308"><span class='Ref_to_Const'>BTGE</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>},</span>       <span class='Comment_Single_Line'>/* LE */ 
</span>    <span class='Delimiter'>{</span><a href="predtest.c.html#LN1306"><span class='Ref_to_Const'>BTLE</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1305"><span class='Ref_to_Const'>BTLT</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1310"><span class='Ref_to_Const'>BTNE</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1309"><span class='Ref_to_Const'>BTGT</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1308"><span class='Ref_to_Const'>BTGE</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1307"><span class='Ref_to_Const'>BTEQ</span></a><span class='Delimiter'>},</span>       <span class='Comment_Single_Line'>/* EQ */ 
</span>    <span class='Delimiter'>{</span><a href="predtest.c.html#LN1306"><span class='Ref_to_Const'>BTLE</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1305"><span class='Ref_to_Const'>BTLT</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1305"><span class='Ref_to_Const'>BTLT</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>},</span>       <span class='Comment_Single_Line'>/* GE */ 
</span>    <span class='Delimiter'>{</span><a href="predtest.c.html#LN1306"><span class='Ref_to_Const'>BTLE</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1306"><span class='Ref_to_Const'>BTLE</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1306"><span class='Ref_to_Const'>BTLE</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>},</span>       <span class='Comment_Single_Line'>/* GT */ 
</span>    <span class='Delimiter'>{</span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1307"><span class='Ref_to_Const'>BTEQ</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1313"><span class='Ref_to_Const'>none</span></a><span class='Delimiter'>}</span>        <span class='Comment_Single_Line'>/* NE */ 
</span><span class='Delimiter'>}; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * operator_predicate_proof 
 *    Does the predicate implication or refutation test for a "simple clause" 
 *    predicate and a "simple clause" restriction, when both are operator 
 *    clauses using related operators and identical input expressions. 
 * 
 * When refute_it == false, we want to prove the predicate true; 
 * when refute_it == true, we want to prove the predicate false. 
 * (There is enough common code to justify handling these two cases 
 * in one routine.)  We return TRUE if able to make the proof, FALSE 
 * if not able to prove it. 
 * 
 * We can make proofs involving several expression forms (here "foo" and "bar" 
 * represent subexpressions that are identical according to equal()): 
 *  "foo op1 bar" refutes "foo op2 bar" if op1 is op2's negator 
 *  "foo op1 bar" implies "bar op2 foo" if op1 is op2's commutator 
 *  "foo op1 bar" refutes "bar op2 foo" if op1 is negator of op2's commutator 
 *  "foo op1 bar" can imply/refute "foo op2 bar" based on btree semantics 
 *  "foo op1 bar" can imply/refute "bar op2 foo" based on btree semantics 
 *  "foo op1 const1" can imply/refute "foo op2 const2" based on btree semantics 
 * 
 * For the last three cases, op1 and op2 have to be members of the same btree 
 * operator family.  When both subexpressions are identical, the idea is that, 
 * for instance, x &LT; y implies x &LT;= y, independently of exactly what x and y 
 * are.  If we have two different constants compared to the same expression 
 * foo, we have to execute a comparison between the two constant values 
 * in order to determine the result; for instance, foo &LT; c1 implies foo &LT; c2 
 * if c1 &LT;= c2.  We assume it's safe to compare the constants at plan time 
 * if the comparison operator is immutable. 
 * 
 * Note: all the operators and subexpressions have to be immutable for the 
 * proof to be safe.  We assume the predicate expression is entirely immutable, 
 * so no explicit check on the subexpressions is needed here, but in some 
 * cases we need an extra check of operator immutability.  In particular, 
 * btree opfamilies can contain cross-type operators that are merely stable, 
 * and we dare not make deductions with those. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN1406"></a><span class='Declare_Function'>operator_predicate_proof</span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>predicate</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>refute_it</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1408"></a>    <a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>pred_opexpr</span><span class='Delimiter'>, 
</span><a name="LN1409"></a>               <span class='Operator'>*</span><span class='Declare_Local'>clause_opexpr</span><span class='Delimiter'>; 
</span><a name="LN1410"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>pred_collation</span><span class='Delimiter'>, 
</span><a name="LN1411"></a>                <span class='Declare_Local'>clause_collation</span><span class='Delimiter'>; 
</span><a name="LN1412"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>pred_op</span><span class='Delimiter'>, 
</span><a name="LN1413"></a>                <span class='Declare_Local'>clause_op</span><span class='Delimiter'>, 
</span><a name="LN1414"></a>                <span class='Declare_Local'>test_op</span><span class='Delimiter'>; 
</span><a name="LN1415"></a>    <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>pred_leftop</span><span class='Delimiter'>, 
</span><a name="LN1416"></a>               <span class='Operator'>*</span><span class='Declare_Local'>pred_rightop</span><span class='Delimiter'>, 
</span><a name="LN1417"></a>               <span class='Operator'>*</span><span class='Declare_Local'>clause_leftop</span><span class='Delimiter'>, 
</span><a name="LN1418"></a>               <span class='Operator'>*</span><span class='Declare_Local'>clause_rightop</span><span class='Delimiter'>; 
</span><a name="LN1419"></a>    <a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>pred_const</span><span class='Delimiter'>, 
</span><a name="LN1420"></a>               <span class='Operator'>*</span><span class='Declare_Local'>clause_const</span><span class='Delimiter'>; 
</span><a name="LN1421"></a>    <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>test_expr</span><span class='Delimiter'>; 
</span><a name="LN1422"></a>    <a href="../../../include/nodes/execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>test_exprstate</span><span class='Delimiter'>; 
</span><a name="LN1423"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>test_result</span><span class='Delimiter'>; 
</span><a name="LN1424"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isNull</span><span class='Delimiter'>; 
</span><a name="LN1425"></a>    <a href="../../../include/nodes/execnodes.h.html#LN402"><span class='Ref_to_Struct'>EState</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>estate</span><span class='Delimiter'>; 
</span><a name="LN1426"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Both expressions must be binary opclauses, else we can't do anything. 
     * 
     * Note: in future we might extend this logic to other operator-based 
     * constructs such as DistinctExpr.  But the planner isn't very smart 
     * about DistinctExpr in general, and this probably isn't the first place 
     * to fix if you want to improve that. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/optimizer/clauses.h.html#LN19"><span class='Ref_to_Macro'>is_opclause</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1406"><span class='Ref_to_Parameter'>predicate</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="predtest.c.html#LN1408"><span class='Ref_To_Local'>pred_opexpr</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1406"><span class='Ref_to_Parameter'>predicate</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1408"><span class='Ref_To_Local'>pred_opexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN500"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>2</span><span class='Parentheses'>)</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/optimizer/clauses.h.html#LN19"><span class='Ref_to_Macro'>is_opclause</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1406"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="predtest.c.html#LN1409"><span class='Ref_To_Local'>clause_opexpr</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1406"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1409"><span class='Ref_To_Local'>clause_opexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN500"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>2</span><span class='Parentheses'>)</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If they're marked with different collations then we can't do anything. 
     * This is a cheap test so let's get it out of the way early. 
     */ 
</span>    <a href="predtest.c.html#LN1410"><span class='Ref_To_Local'>pred_collation</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN1408"><span class='Ref_To_Local'>pred_opexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN499"><span class='Ref_to_Member'>inputcollid</span></a><span class='Delimiter'>; 
</span>    <a href="predtest.c.html#LN1411"><span class='Ref_To_Local'>clause_collation</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN1409"><span class='Ref_To_Local'>clause_opexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN499"><span class='Ref_to_Member'>inputcollid</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1410"><span class='Ref_To_Local'>pred_collation</span></a> <span class='Operator'>!= </span><a href="predtest.c.html#LN1411"><span class='Ref_To_Local'>clause_collation</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Grab the operator OIDs now too.  We may commute these below. */ 
</span>    <a href="predtest.c.html#LN1412"><span class='Ref_To_Local'>pred_op</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN1408"><span class='Ref_To_Local'>pred_opexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN494"><span class='Ref_to_Member'>opno</span></a><span class='Delimiter'>; 
</span>    <a href="predtest.c.html#LN1413"><span class='Ref_To_Local'>clause_op</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN1409"><span class='Ref_To_Local'>clause_opexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN494"><span class='Ref_to_Member'>opno</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We have to match up at least one pair of input expressions. 
     */ 
</span>    <a href="predtest.c.html#LN1415"><span class='Ref_To_Local'>pred_leftop</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1408"><span class='Ref_To_Local'>pred_opexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN500"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predtest.c.html#LN1416"><span class='Ref_To_Local'>pred_rightop</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN115"><span class='Ref_to_Macro'>lsecond</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1408"><span class='Ref_To_Local'>pred_opexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN500"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predtest.c.html#LN1417"><span class='Ref_To_Local'>clause_leftop</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1409"><span class='Ref_To_Local'>clause_opexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN500"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predtest.c.html#LN1418"><span class='Ref_To_Local'>clause_rightop</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN115"><span class='Ref_to_Macro'>lsecond</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1409"><span class='Ref_To_Local'>clause_opexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN500"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN626"><span class='Ref_to_Proto'>equal</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1415"><span class='Ref_To_Local'>pred_leftop</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1417"><span class='Ref_To_Local'>clause_leftop</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN626"><span class='Ref_to_Proto'>equal</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1416"><span class='Ref_To_Local'>pred_rightop</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1418"><span class='Ref_To_Local'>clause_rightop</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* We have x op1 y and x op2 y */ 
</span>            <span class='Control'>return</span> <a href="predtest.c.html#LN99"><span class='Ref_to_Proto'>operator_same_subexprs_proof</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1412"><span class='Ref_To_Local'>pred_op</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1413"><span class='Ref_To_Local'>clause_op</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1406"><span class='Ref_to_Parameter'>refute_it</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Fail unless rightops are both Consts */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1416"><span class='Ref_To_Local'>pred_rightop</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| !</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1416"><span class='Ref_To_Local'>pred_rightop</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="predtest.c.html#LN1419"><span class='Ref_To_Local'>pred_const</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1416"><span class='Ref_To_Local'>pred_rightop</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1418"><span class='Ref_To_Local'>clause_rightop</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| !</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1418"><span class='Ref_To_Local'>clause_rightop</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="predtest.c.html#LN1420"><span class='Ref_To_Local'>clause_const</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1418"><span class='Ref_To_Local'>clause_rightop</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN626"><span class='Ref_to_Proto'>equal</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1416"><span class='Ref_To_Local'>pred_rightop</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1418"><span class='Ref_To_Local'>clause_rightop</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Fail unless leftops are both Consts */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1415"><span class='Ref_To_Local'>pred_leftop</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| !</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1415"><span class='Ref_To_Local'>pred_leftop</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="predtest.c.html#LN1419"><span class='Ref_To_Local'>pred_const</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1415"><span class='Ref_To_Local'>pred_leftop</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1417"><span class='Ref_To_Local'>clause_leftop</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| !</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1417"><span class='Ref_To_Local'>clause_leftop</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="predtest.c.html#LN1420"><span class='Ref_To_Local'>clause_const</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1417"><span class='Ref_To_Local'>clause_leftop</span></a><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Commute both operators so we can assume Consts are on the right */ 
</span>        <a href="predtest.c.html#LN1412"><span class='Ref_To_Local'>pred_op</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN106"><span class='Ref_to_Proto'>get_commutator</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1412"><span class='Ref_To_Local'>pred_op</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1412"><span class='Ref_To_Local'>pred_op</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="predtest.c.html#LN1413"><span class='Ref_To_Local'>clause_op</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN106"><span class='Ref_to_Proto'>get_commutator</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1413"><span class='Ref_To_Local'>clause_op</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1413"><span class='Ref_To_Local'>clause_op</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN626"><span class='Ref_to_Proto'>equal</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1415"><span class='Ref_To_Local'>pred_leftop</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1418"><span class='Ref_To_Local'>clause_rightop</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN626"><span class='Ref_to_Proto'>equal</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1416"><span class='Ref_To_Local'>pred_rightop</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1417"><span class='Ref_To_Local'>clause_leftop</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* We have x op1 y and y op2 x */ 
</span>            <span class='Comment_Multi_Line'>/* Commute pred_op that we can treat this like a straight match */ 
</span>            <a href="predtest.c.html#LN1412"><span class='Ref_To_Local'>pred_op</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN106"><span class='Ref_to_Proto'>get_commutator</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1412"><span class='Ref_To_Local'>pred_op</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1412"><span class='Ref_To_Local'>pred_op</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <a href="predtest.c.html#LN99"><span class='Ref_to_Proto'>operator_same_subexprs_proof</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1412"><span class='Ref_To_Local'>pred_op</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1413"><span class='Ref_To_Local'>clause_op</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1406"><span class='Ref_to_Parameter'>refute_it</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Fail unless pred_rightop/clause_leftop are both Consts */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1416"><span class='Ref_To_Local'>pred_rightop</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| !</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1416"><span class='Ref_To_Local'>pred_rightop</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="predtest.c.html#LN1419"><span class='Ref_To_Local'>pred_const</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1416"><span class='Ref_To_Local'>pred_rightop</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1417"><span class='Ref_To_Local'>clause_leftop</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| !</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1417"><span class='Ref_To_Local'>clause_leftop</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="predtest.c.html#LN1420"><span class='Ref_To_Local'>clause_const</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1417"><span class='Ref_To_Local'>clause_leftop</span></a><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* Commute clause_op so we can assume Consts are on the right */ 
</span>            <a href="predtest.c.html#LN1413"><span class='Ref_To_Local'>clause_op</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN106"><span class='Ref_to_Proto'>get_commutator</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1413"><span class='Ref_To_Local'>clause_op</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1413"><span class='Ref_To_Local'>clause_op</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if equal(pred_leftop,cla... &raquo; </span> 
    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN626"><span class='Ref_to_Proto'>equal</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1416"><span class='Ref_To_Local'>pred_rightop</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1417"><span class='Ref_To_Local'>clause_leftop</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Fail unless pred_leftop/clause_rightop are both Consts */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1415"><span class='Ref_To_Local'>pred_leftop</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| !</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1415"><span class='Ref_To_Local'>pred_leftop</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="predtest.c.html#LN1419"><span class='Ref_To_Local'>pred_const</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1415"><span class='Ref_To_Local'>pred_leftop</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1418"><span class='Ref_To_Local'>clause_rightop</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| !</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1418"><span class='Ref_To_Local'>clause_rightop</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="predtest.c.html#LN1420"><span class='Ref_To_Local'>clause_const</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1418"><span class='Ref_To_Local'>clause_rightop</span></a><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Commute pred_op so we can assume Consts are on the right */ 
</span>        <a href="predtest.c.html#LN1412"><span class='Ref_To_Local'>pred_op</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN106"><span class='Ref_to_Proto'>get_commutator</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1412"><span class='Ref_To_Local'>pred_op</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1412"><span class='Ref_To_Local'>pred_op</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Failed to match up any of the subexpressions, so we lose */ 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We have two identical subexpressions, and two other subexpressions that 
     * are not identical but are both Consts; and we have commuted the 
     * operators if necessary so that the Consts are on the right.  We'll need 
     * to compare the Consts' values.  If either is NULL, fail. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1419"><span class='Ref_To_Local'>pred_const</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN196"><span class='Ref_to_Member'>constisnull</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1420"><span class='Ref_To_Local'>clause_const</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN196"><span class='Ref_to_Member'>constisnull</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Lookup the constant-comparison operator using the system catalogs and 
     * the operator implication tables. 
     */ 
</span>    <a href="predtest.c.html#LN1414"><span class='Ref_To_Local'>test_op</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN103"><span class='Ref_to_Proto'>get_btree_test_op</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1412"><span class='Ref_To_Local'>pred_op</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1413"><span class='Ref_To_Local'>clause_op</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1406"><span class='Ref_to_Parameter'>refute_it</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1414"><span class='Ref_To_Local'>test_op</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* couldn't find a suitable comparison operator */ 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Evaluate the test.  For this we need an EState. 
     */ 
</span>    <a href="predtest.c.html#LN1425"><span class='Ref_To_Local'>estate</span></a> <span class='Operator'>= </span><a href="../../executor/execUtils.c.html#LN78"><span class='Ref_to_Func'>CreateExecutorState</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* We can use the estate's working context to avoid memory leaks. */ 
</span>    <a href="predtest.c.html#LN1426"><span class='Ref_To_Local'>oldcontext</span></a> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1425"><span class='Ref_To_Local'>estate</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/execnodes.h.html#LN447"><span class='Ref_to_Member'>es_query_cxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Build expression tree */ 
</span>    <a href="predtest.c.html#LN1421"><span class='Ref_To_Local'>test_expr</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/clauses.h.html#LN29"><span class='Ref_to_Proto'>make_opclause</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1414"><span class='Ref_To_Local'>test_op</span></a><span class='Delimiter'>, 
</span>                              <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN17"><span class='Ref_to_Const'>BOOLOID</span></a><span class='Delimiter'>, 
</span>                              <span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                              <span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1419"><span class='Ref_To_Local'>pred_const</span></a><span class='Delimiter'>, 
</span>                              <span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1420"><span class='Ref_To_Local'>clause_const</span></a><span class='Delimiter'>, 
</span>                              <a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                              <a href="predtest.c.html#LN1410"><span class='Ref_To_Local'>pred_collation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Fill in opfuncids */ 
</span>    <a href="../../../include/nodes/nodeFuncs.h.html#LN45"><span class='Ref_to_Proto'>fix_opfuncids</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predtest.c.html#LN1421"><span class='Ref_To_Local'>test_expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Prepare it for execution */ 
</span>    <a href="predtest.c.html#LN1422"><span class='Ref_To_Local'>test_exprstate</span></a> <span class='Operator'>= </span><a href="../../executor/execExpr.c.html#LN111"><span class='Ref_to_Func'>ExecInitExpr</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1421"><span class='Ref_To_Local'>test_expr</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* And execute it. */ 
</span>    <a href="predtest.c.html#LN1423"><span class='Ref_To_Local'>test_result</span></a> <span class='Operator'>= </span><a href="../../../include/executor/executor.h.html#LN279"><span class='Ref_to_Func'>ExecEvalExprSwitchContext</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1422"><span class='Ref_To_Local'>test_exprstate</span></a><span class='Delimiter'>, 
</span>                                            <a href="../../../include/executor/executor.h.html#LN455"><span class='Ref_to_Macro'>GetPerTupleExprContext</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1425"><span class='Ref_To_Local'>estate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                            <span class='Operator'>&</span><a href="predtest.c.html#LN1424"><span class='Ref_To_Local'>isNull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Get back to outer memory context */ 
</span>    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1426"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Release all the junk we just created */ 
</span>    <a href="../../executor/execUtils.c.html#LN176"><span class='Ref_to_Func'>FreeExecutorState</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1425"><span class='Ref_To_Local'>estate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1424"><span class='Ref_To_Local'>isNull</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Treat a null result as non-proof ... but it's a tad fishy ... */ 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, </span><span class='String'>"null predicate test result"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <a href="../../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1423"><span class='Ref_To_Local'>test_result</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end operator_predicate_proof &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * operator_same_subexprs_proof 
 *    Assuming that EXPR1 clause_op EXPR2 is true, try to prove or refute 
 *    EXPR1 pred_op EXPR2. 
 * 
 * Return TRUE if able to make the proof, false if not able to prove it. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN1624"></a><span class='Declare_Function'>operator_same_subexprs_proof</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>pred_op</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>clause_op</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>refute_it</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * A simple and general rule is that the predicate is proven if clause_op 
     * and pred_op are the same, or refuted if they are each other's negators. 
     * We need not check immutability since the pred_op is already known 
     * immutable.  (Actually, by this point we may have the commutator of a 
     * known-immutable pred_op, but that should certainly be immutable too. 
     * Likewise we don't worry whether the pred_op's negator is immutable.) 
     * 
     * Note: the "same" case won't get here if we actually had EXPR1 clause_op 
     * EXPR2 and EXPR1 pred_op EXPR2, because the overall-expression-equality 
     * test in predicate_implied_by_simple_clause would have caught it.  But 
     * we can see the same operator after having commuted the pred_op. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1624"><span class='Ref_to_Parameter'>refute_it</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/lsyscache.h.html#LN107"><span class='Ref_to_Proto'>get_negator</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1624"><span class='Ref_to_Parameter'>pred_op</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="predtest.c.html#LN1624"><span class='Ref_to_Parameter'>clause_op</span></a><span class='Parentheses'>)</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1624"><span class='Ref_to_Parameter'>pred_op</span></a> <span class='Operator'>== </span><a href="predtest.c.html#LN1624"><span class='Ref_to_Parameter'>clause_op</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Otherwise, see if we can determine the implication by finding the 
     * operators' relationship via some btree opfamily. 
     */ 
</span>    <span class='Control'>return</span> <a href="predtest.c.html#LN101"><span class='Ref_to_Proto'>operator_same_subexprs_lookup</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1624"><span class='Ref_to_Parameter'>pred_op</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1624"><span class='Ref_to_Parameter'>clause_op</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1624"><span class='Ref_to_Parameter'>refute_it</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end operator_same_subexprs_proof &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * We use a lookaside table to cache the result of btree proof operator 
 * lookups, since the actual lookup is pretty expensive and doesn't change 
 * for any given pair of operators (at least as long as pg_amop doesn't 
 * change).  A single hash entry stores both implication and refutation 
 * results for a given pair of operators; but note we may have determined 
 * only one of those sets of results as yet. 
 */ 
</span><a name="LN1666"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>OprProofCacheKey</span> 
<span class='Delimiter'>{ 
</span><a name="LN1668"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>pred_op</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* predicate operator */ 
</span><a name="LN1669"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>clause_op</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* clause operator */ 
</span><a name="LN1670"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>OprProofCacheKey</span><span class='Delimiter'>; 
</span> 
<a name="LN1672"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>OprProofCacheEntry</span> 
<span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* the hash lookup key MUST BE FIRST */ 
</span><a name="LN1675"></a>    <a href="predtest.c.html#LN1666"><span class='Ref_to_Struct'>OprProofCacheKey</span></a> <span class='Declare_Member'>key</span><span class='Delimiter'>; 
</span> 
<a name="LN1677"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>have_implic</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* do we know the implication result? */ 
</span><a name="LN1678"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>have_refute</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* do we know the refutation result? */ 
</span><a name="LN1679"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>same_subexprs_implies</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* X clause_op Y implies X pred_op Y? */ 
</span><a name="LN1680"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>same_subexprs_refutes</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* X clause_op Y refutes X pred_op Y? */ 
</span><a name="LN1681"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>implic_test_op</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* OID of the test operator, or 0 if none */ 
</span><a name="LN1682"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>refute_test_op</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* OID of the test operator, or 0 if none */ 
</span><a name="LN1683"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>OprProofCacheEntry</span><span class='Delimiter'>; 
</span> 
<a name="LN1685"></a><span class='Keyword'>static </span><a href="../../utils/hash/dynahash.c.html#LN192"><span class='Ref_to_Struct'>HTAB</span></a> <span class='Operator'>*</span><span class='Declare_Var'>OprProofCacheHash</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * lookup_proof_cache 
 *    Get, and fill in if necessary, the appropriate cache entry. 
 */ 
</span><span class='Keyword'>static </span><a href="predtest.c.html#LN1672"><span class='Ref_to_Struct'>OprProofCacheEntry</span></a> <span class='Operator'>* 
</span><a name="LN1693"></a><span class='Declare_Function'>lookup_proof_cache</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>pred_op</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>clause_op</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>refute_it</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1695"></a>    <a href="predtest.c.html#LN1666"><span class='Ref_to_Struct'>OprProofCacheKey</span></a> <span class='Declare_Local'>key</span><span class='Delimiter'>; 
</span><a name="LN1696"></a>    <a href="predtest.c.html#LN1672"><span class='Ref_to_Struct'>OprProofCacheEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>cache_entry</span><span class='Delimiter'>; 
</span><a name="LN1697"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>cfound</span><span class='Delimiter'>; 
</span><a name="LN1698"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>same_subexprs</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN1699"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>test_op</span> <span class='Operator'>= </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span><a name="LN1700"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN1701"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>pred_op_infos</span><span class='Delimiter'>, 
</span><a name="LN1702"></a>               <span class='Operator'>*</span><span class='Declare_Local'>clause_op_infos</span><span class='Delimiter'>; 
</span><a name="LN1703"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lcp</span><span class='Delimiter'>, 
</span><a name="LN1704"></a>               <span class='Operator'>*</span><span class='Declare_Local'>lcc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Find or make a cache entry for this pair of operators. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1685"><span class='Ref_to_Global_Var'>OprProofCacheHash</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* First time through: initialize the hash table */ 
</span><a name="LN1712"></a>        <a href="../../../include/utils/hsearch.h.html#LN64"><span class='Ref_to_Struct'>HASHCTL</span></a>     <span class='Declare_Local'>ctl</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predtest.c.html#LN1712"><span class='Ref_To_Local'>ctl</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="predtest.c.html#LN1712"><span class='Ref_To_Local'>ctl</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="predtest.c.html#LN1712"><span class='Ref_To_Local'>ctl</span></a><span class='Operator'>.</span><a href="../../../include/utils/hsearch.h.html#LN71"><span class='Ref_to_Member'>keysize</span></a> <span class='Operator'>= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="predtest.c.html#LN1666"><span class='Ref_to_Struct'>OprProofCacheKey</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="predtest.c.html#LN1712"><span class='Ref_To_Local'>ctl</span></a><span class='Operator'>.</span><a href="../../../include/utils/hsearch.h.html#LN72"><span class='Ref_to_Member'>entrysize</span></a> <span class='Operator'>= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="predtest.c.html#LN1672"><span class='Ref_to_Struct'>OprProofCacheEntry</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="predtest.c.html#LN1685"><span class='Ref_to_Global_Var'>OprProofCacheHash</span></a> <span class='Operator'>= </span><a href="../../../include/utils/hsearch.h.html#LN121"><span class='Ref_to_Proto'>hash_create</span></a><span class='Parentheses'>(</span><span class='String'>"Btree proof lookup cache"</span><span class='Delimiter'>, </span><span class='Number'>256</span><span class='Delimiter'>, 
</span>                                        <span class='Operator'>&</span><a href="predtest.c.html#LN1712"><span class='Ref_To_Local'>ctl</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/hsearch.h.html#LN86"><span class='Ref_to_Const'>HASH_ELEM</span></a> <span class='Operator'>| </span><a href="../../../include/utils/hsearch.h.html#LN87"><span class='Ref_to_Const'>HASH_BLOBS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Arrange to flush cache on pg_amop changes */ 
</span>        <a href="../../../include/utils/inval.h.html#LN55"><span class='Ref_to_Proto'>CacheRegisterSyscacheCallback</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/syscache.h.html#LN36"><span class='Ref_to_EnumConst'>AMOPOPID</span></a><span class='Delimiter'>, 
</span>                                      <a href="predtest.c.html#LN104"><span class='Ref_to_Proto'>InvalidateOprProofCacheCallBack</span></a><span class='Delimiter'>, 
</span>                                      <span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="predtest.c.html#LN1695"><span class='Ref_To_Local'>key</span></a><span class='Operator'>.</span><a href="predtest.c.html#LN1668"><span class='Ref_to_Member'>pred_op</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN1693"><span class='Ref_to_Parameter'>pred_op</span></a><span class='Delimiter'>; 
</span>    <a href="predtest.c.html#LN1695"><span class='Ref_To_Local'>key</span></a><span class='Operator'>.</span><a href="predtest.c.html#LN1669"><span class='Ref_to_Member'>clause_op</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN1693"><span class='Ref_to_Parameter'>clause_op</span></a><span class='Delimiter'>; 
</span>    <a href="predtest.c.html#LN1696"><span class='Ref_To_Local'>cache_entry</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="predtest.c.html#LN1672"><span class='Ref_to_Struct'>OprProofCacheEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/utils/hsearch.h.html#LN125"><span class='Ref_to_Proto'>hash_search</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1685"><span class='Ref_to_Global_Var'>OprProofCacheHash</span></a><span class='Delimiter'>, 
</span>                                                     <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="predtest.c.html#LN1695"><span class='Ref_To_Local'>key</span></a><span class='Delimiter'>, 
</span>                                                     <a href="../../../include/utils/hsearch.h.html#LN105"><span class='Ref_to_EnumConst'>HASH_ENTER</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predtest.c.html#LN1697"><span class='Ref_To_Local'>cfound</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predtest.c.html#LN1697"><span class='Ref_To_Local'>cfound</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* new cache entry, set it invalid */ 
</span>        <a href="predtest.c.html#LN1696"><span class='Ref_To_Local'>cache_entry</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN1677"><span class='Ref_to_Member'>have_implic</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="predtest.c.html#LN1696"><span class='Ref_To_Local'>cache_entry</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN1678"><span class='Ref_to_Member'>have_refute</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* pre-existing cache entry, see if we know the answer yet */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1693"><span class='Ref_to_Parameter'>refute_it</span></a> <span class='Operator'>? </span><a href="predtest.c.html#LN1696"><span class='Ref_To_Local'>cache_entry</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN1678"><span class='Ref_to_Member'>have_refute</span></a> <span class='Operator'>: </span><a href="predtest.c.html#LN1696"><span class='Ref_To_Local'>cache_entry</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN1677"><span class='Ref_to_Member'>have_implic</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <a href="predtest.c.html#LN1696"><span class='Ref_To_Local'>cache_entry</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Try to find a btree opfamily containing the given operators. 
     * 
     * We must find a btree opfamily that contains both operators, else the 
     * implication can't be determined.  Also, the opfamily must contain a 
     * suitable test operator taking the operators' righthand datatypes. 
     * 
     * If there are multiple matching opfamilies, assume we can use any one to 
     * determine the logical relationship of the two operators and the correct 
     * corresponding test operator.  This should work for any logically 
     * consistent opfamilies. 
     * 
     * Note that we can determine the operators' relationship for 
     * same-subexprs cases even from an opfamily that lacks a usable test 
     * operator.  This can happen in cases with incomplete sets of cross-type 
     * comparison operators. 
     */ 
</span>    <a href="predtest.c.html#LN1702"><span class='Ref_To_Local'>clause_op_infos</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN81"><span class='Ref_to_Proto'>get_op_btree_interpretation</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1693"><span class='Ref_to_Parameter'>clause_op</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1702"><span class='Ref_To_Local'>clause_op_infos</span></a><span class='Parentheses'>) 
</span>        <a href="predtest.c.html#LN1701"><span class='Ref_To_Local'>pred_op_infos</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN81"><span class='Ref_to_Proto'>get_op_btree_interpretation</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1693"><span class='Ref_to_Parameter'>pred_op</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span>    <span class='Comment_Single_Line'>/* no point in looking */ 
</span>        <a href="predtest.c.html#LN1701"><span class='Ref_To_Local'>pred_op_infos</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1703"><span class='Ref_To_Local'>lcp</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1701"><span class='Ref_To_Local'>pred_op_infos</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1769"></a>        <a href="../../../include/utils/lsyscache.h.html#LN20"><span class='Ref_to_Struct'>OpBtreeInterpretation</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pred_op_info</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1703"><span class='Ref_To_Local'>lcp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1770"></a>        <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>opfamily_id</span> <span class='Operator'>= </span><a href="predtest.c.html#LN1769"><span class='Ref_To_Local'>pred_op_info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/lsyscache.h.html#LN22"><span class='Ref_to_Member'>opfamily_id</span></a><span class='Delimiter'>; 
</span> 
        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1704"><span class='Ref_To_Local'>lcc</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1702"><span class='Ref_To_Local'>clause_op_infos</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1774"></a>            <a href="../../../include/utils/lsyscache.h.html#LN20"><span class='Ref_to_Struct'>OpBtreeInterpretation</span></a> <span class='Operator'>*</span><span class='Declare_Local'>clause_op_info</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1704"><span class='Ref_To_Local'>lcc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1775"></a>            <a href="../../../include/access/stratnum.h.html#LN21"><span class='Ref_to_Typedef'>StrategyNumber</span></a> <span class='Declare_Local'>pred_strategy</span><span class='Delimiter'>, 
</span><a name="LN1776"></a>                        <span class='Declare_Local'>clause_strategy</span><span class='Delimiter'>, 
</span><a name="LN1777"></a>                        <span class='Declare_Local'>test_strategy</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Must find them in same opfamily */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1770"><span class='Ref_To_Local'>opfamily_id</span></a> <span class='Operator'>!= </span><a href="predtest.c.html#LN1774"><span class='Ref_To_Local'>clause_op_info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/lsyscache.h.html#LN22"><span class='Ref_to_Member'>opfamily_id</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* Lefttypes should match */ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predtest.c.html#LN1774"><span class='Ref_To_Local'>clause_op_info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/lsyscache.h.html#LN24"><span class='Ref_to_Member'>oplefttype</span></a> <span class='Operator'>== </span><a href="predtest.c.html#LN1769"><span class='Ref_To_Local'>pred_op_info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/lsyscache.h.html#LN24"><span class='Ref_to_Member'>oplefttype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="predtest.c.html#LN1775"><span class='Ref_To_Local'>pred_strategy</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN1769"><span class='Ref_To_Local'>pred_op_info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/lsyscache.h.html#LN23"><span class='Ref_to_Member'>strategy</span></a><span class='Delimiter'>; 
</span>            <a href="predtest.c.html#LN1776"><span class='Ref_To_Local'>clause_strategy</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN1774"><span class='Ref_To_Local'>clause_op_info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/lsyscache.h.html#LN23"><span class='Ref_to_Member'>strategy</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Check to see if we can make a proof for same-subexpressions 
             * cases based on the operators' relationship in this opfamily. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1693"><span class='Ref_to_Parameter'>refute_it</span></a><span class='Parentheses'>) 
</span>                <a href="predtest.c.html#LN1698"><span class='Ref_To_Local'>same_subexprs</span></a> <span class='Operator'>|= </span><a href="predtest.c.html#LN1328"><span class='Ref_to_Global_Var'>BT_refutes_table</span></a><span class='Delimiter'>[</span><a href="predtest.c.html#LN1776"><span class='Ref_To_Local'>clause_strategy</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>][</span><a href="predtest.c.html#LN1775"><span class='Ref_To_Local'>pred_strategy</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span>            <span class='Control'>else</span> 
                <a href="predtest.c.html#LN1698"><span class='Ref_To_Local'>same_subexprs</span></a> <span class='Operator'>|= </span><a href="predtest.c.html#LN1315"><span class='Ref_to_Global_Var'>BT_implies_table</span></a><span class='Delimiter'>[</span><a href="predtest.c.html#LN1776"><span class='Ref_To_Local'>clause_strategy</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>][</span><a href="predtest.c.html#LN1775"><span class='Ref_To_Local'>pred_strategy</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Look up the "test" strategy number in the implication table 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1693"><span class='Ref_to_Parameter'>refute_it</span></a><span class='Parentheses'>) 
</span>                <a href="predtest.c.html#LN1777"><span class='Ref_To_Local'>test_strategy</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN1354"><span class='Ref_to_Global_Var'>BT_refute_table</span></a><span class='Delimiter'>[</span><a href="predtest.c.html#LN1776"><span class='Ref_To_Local'>clause_strategy</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>][</span><a href="predtest.c.html#LN1775"><span class='Ref_To_Local'>pred_strategy</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span>            <span class='Control'>else</span> 
                <a href="predtest.c.html#LN1777"><span class='Ref_To_Local'>test_strategy</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN1341"><span class='Ref_to_Global_Var'>BT_implic_table</span></a><span class='Delimiter'>[</span><a href="predtest.c.html#LN1776"><span class='Ref_To_Local'>clause_strategy</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>][</span><a href="predtest.c.html#LN1775"><span class='Ref_To_Local'>pred_strategy</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1777"><span class='Ref_To_Local'>test_strategy</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Can't determine implication using this interpretation */ 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * See if opfamily has an operator for the test strategy and the 
             * datatypes. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1777"><span class='Ref_To_Local'>test_strategy</span></a> <span class='Operator'>== </span><a href="predtest.c.html#LN1310"><span class='Ref_to_Const'>BTNE</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="predtest.c.html#LN1699"><span class='Ref_To_Local'>test_op</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN70"><span class='Ref_to_Proto'>get_opfamily_member</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1770"><span class='Ref_To_Local'>opfamily_id</span></a><span class='Delimiter'>, 
</span>                                              <a href="predtest.c.html#LN1769"><span class='Ref_To_Local'>pred_op_info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/lsyscache.h.html#LN25"><span class='Ref_to_Member'>oprighttype</span></a><span class='Delimiter'>, 
</span>                                              <a href="predtest.c.html#LN1774"><span class='Ref_To_Local'>clause_op_info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/lsyscache.h.html#LN25"><span class='Ref_to_Member'>oprighttype</span></a><span class='Delimiter'>, 
</span>                                              <a href="../../../include/access/stratnum.h.html#LN30"><span class='Ref_to_Const'>BTEqualStrategyNumber</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1699"><span class='Ref_To_Local'>test_op</span></a><span class='Parentheses'>))</span> 
                    <a href="predtest.c.html#LN1699"><span class='Ref_To_Local'>test_op</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN107"><span class='Ref_to_Proto'>get_negator</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1699"><span class='Ref_To_Local'>test_op</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <a href="predtest.c.html#LN1699"><span class='Ref_To_Local'>test_op</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN70"><span class='Ref_to_Proto'>get_opfamily_member</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1770"><span class='Ref_To_Local'>opfamily_id</span></a><span class='Delimiter'>, 
</span>                                              <a href="predtest.c.html#LN1769"><span class='Ref_To_Local'>pred_op_info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/lsyscache.h.html#LN25"><span class='Ref_to_Member'>oprighttype</span></a><span class='Delimiter'>, 
</span>                                              <a href="predtest.c.html#LN1774"><span class='Ref_To_Local'>clause_op_info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/lsyscache.h.html#LN25"><span class='Ref_to_Member'>oprighttype</span></a><span class='Delimiter'>, 
</span>                                              <a href="predtest.c.html#LN1777"><span class='Ref_To_Local'>test_strategy</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1699"><span class='Ref_To_Local'>test_op</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Last check: test_op must be immutable. 
             * 
             * Note that we require only the test_op to be immutable, not the 
             * original clause_op.  (pred_op is assumed to have been checked 
             * immutable by the caller.)  Essentially we are assuming that the 
             * opfamily is consistent even if it contains operators that are 
             * merely stable. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/lsyscache.h.html#LN105"><span class='Ref_to_Proto'>op_volatile</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1699"><span class='Ref_To_Local'>test_op</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="../../../include/catalog/pg_proc.h.html#LN5482"><span class='Ref_to_Const'>PROVOLATILE_IMMUTABLE</span></a><span class='Parentheses'>)</span> 
            <span class='Delimiter'>{ 
</span>                <a href="predtest.c.html#LN1700"><span class='Ref_To_Local'>found</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1700"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN266"><span class='Ref_to_Proto'>list_free_deep</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1701"><span class='Ref_To_Local'>pred_op_infos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN266"><span class='Ref_to_Proto'>list_free_deep</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1702"><span class='Ref_To_Local'>clause_op_infos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predtest.c.html#LN1700"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* couldn't find a suitable comparison operator */ 
</span>        <a href="predtest.c.html#LN1699"><span class='Ref_To_Local'>test_op</span></a> <span class='Operator'>= </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we think we were able to prove something about same-subexpressions 
     * cases, check to make sure the clause_op is immutable before believing 
     * it completely.  (Usually, the clause_op would be immutable if the 
     * pred_op is, but it's not entirely clear that this must be true in all 
     * cases, so let's check.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1698"><span class='Ref_To_Local'>same_subexprs</span></a> <span class='Operator'>&& 
</span>        <a href="../../../include/utils/lsyscache.h.html#LN105"><span class='Ref_to_Proto'>op_volatile</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1693"><span class='Ref_to_Parameter'>clause_op</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="../../../include/catalog/pg_proc.h.html#LN5482"><span class='Ref_to_Const'>PROVOLATILE_IMMUTABLE</span></a><span class='Parentheses'>)</span> 
        <a href="predtest.c.html#LN1698"><span class='Ref_To_Local'>same_subexprs</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Cache the results, whether positive or negative */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1693"><span class='Ref_to_Parameter'>refute_it</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="predtest.c.html#LN1696"><span class='Ref_To_Local'>cache_entry</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN1682"><span class='Ref_to_Member'>refute_test_op</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN1699"><span class='Ref_To_Local'>test_op</span></a><span class='Delimiter'>; 
</span>        <a href="predtest.c.html#LN1696"><span class='Ref_To_Local'>cache_entry</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN1680"><span class='Ref_to_Member'>same_subexprs_refutes</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN1698"><span class='Ref_To_Local'>same_subexprs</span></a><span class='Delimiter'>; 
</span>        <a href="predtest.c.html#LN1696"><span class='Ref_To_Local'>cache_entry</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN1678"><span class='Ref_to_Member'>have_refute</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="predtest.c.html#LN1696"><span class='Ref_To_Local'>cache_entry</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN1681"><span class='Ref_to_Member'>implic_test_op</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN1699"><span class='Ref_To_Local'>test_op</span></a><span class='Delimiter'>; 
</span>        <a href="predtest.c.html#LN1696"><span class='Ref_To_Local'>cache_entry</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN1679"><span class='Ref_to_Member'>same_subexprs_implies</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN1698"><span class='Ref_To_Local'>same_subexprs</span></a><span class='Delimiter'>; 
</span>        <a href="predtest.c.html#LN1696"><span class='Ref_To_Local'>cache_entry</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN1677"><span class='Ref_to_Member'>have_implic</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="predtest.c.html#LN1696"><span class='Ref_To_Local'>cache_entry</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end lookup_proof_cache &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * operator_same_subexprs_lookup 
 *    Convenience subroutine to look up the cached answer for 
 *    same-subexpressions cases. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN1898"></a><span class='Declare_Function'>operator_same_subexprs_lookup</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>pred_op</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>clause_op</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>refute_it</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1900"></a>    <a href="predtest.c.html#LN1672"><span class='Ref_to_Struct'>OprProofCacheEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>cache_entry</span><span class='Delimiter'>; 
</span> 
    <a href="predtest.c.html#LN1900"><span class='Ref_To_Local'>cache_entry</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN1692"><span class='Ref_to_Func'>lookup_proof_cache</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1898"><span class='Ref_to_Parameter'>pred_op</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1898"><span class='Ref_to_Parameter'>clause_op</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1898"><span class='Ref_to_Parameter'>refute_it</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1898"><span class='Ref_to_Parameter'>refute_it</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="predtest.c.html#LN1900"><span class='Ref_To_Local'>cache_entry</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN1680"><span class='Ref_to_Member'>same_subexprs_refutes</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <span class='Control'>return</span> <a href="predtest.c.html#LN1900"><span class='Ref_To_Local'>cache_entry</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN1679"><span class='Ref_to_Member'>same_subexprs_implies</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * get_btree_test_op 
 *    Identify the comparison operator needed for a btree-operator 
 *    proof or refutation involving comparison of constants. 
 * 
 * Given the truth of a clause "var clause_op const1", we are attempting to 
 * prove or refute a predicate "var pred_op const2".  The identities of the 
 * two operators are sufficient to determine the operator (if any) to compare 
 * const2 to const1 with. 
 * 
 * Returns the OID of the operator to use, or InvalidOid if no proof is 
 * possible. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> 
<a name="LN1923"></a><span class='Declare_Function'>get_btree_test_op</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>pred_op</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>clause_op</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>refute_it</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1925"></a>    <a href="predtest.c.html#LN1672"><span class='Ref_to_Struct'>OprProofCacheEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>cache_entry</span><span class='Delimiter'>; 
</span> 
    <a href="predtest.c.html#LN1925"><span class='Ref_To_Local'>cache_entry</span></a> <span class='Operator'>= </span><a href="predtest.c.html#LN1692"><span class='Ref_to_Func'>lookup_proof_cache</span></a><span class='Parentheses'>(</span><a href="predtest.c.html#LN1923"><span class='Ref_to_Parameter'>pred_op</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1923"><span class='Ref_to_Parameter'>clause_op</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1923"><span class='Ref_to_Parameter'>refute_it</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predtest.c.html#LN1923"><span class='Ref_to_Parameter'>refute_it</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="predtest.c.html#LN1925"><span class='Ref_To_Local'>cache_entry</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN1682"><span class='Ref_to_Member'>refute_test_op</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <span class='Control'>return</span> <a href="predtest.c.html#LN1925"><span class='Ref_To_Local'>cache_entry</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN1681"><span class='Ref_to_Member'>implic_test_op</span></a><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Callback for pg_amop inval events 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1939"></a><span class='Declare_Function'>InvalidateOprProofCacheCallBack</span><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>arg</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>cacheid</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Parameter'>hashvalue</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1941"></a>    <a href="../../../include/utils/hsearch.h.html#LN111"><span class='Ref_to_Typedef'>HASH_SEQ_STATUS</span></a> <span class='Declare_Local'>status</span><span class='Delimiter'>; 
</span><a name="LN1942"></a>    <a href="predtest.c.html#LN1672"><span class='Ref_to_Struct'>OprProofCacheEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>hentry</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predtest.c.html#LN1685"><span class='Ref_to_Global_Var'>OprProofCacheHash</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Currently we just reset all entries; hard to be smarter ... */ 
</span>    <a href="../../../include/utils/hsearch.h.html#LN134"><span class='Ref_to_Proto'>hash_seq_init</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predtest.c.html#LN1941"><span class='Ref_To_Local'>status</span></a><span class='Delimiter'>, </span><a href="predtest.c.html#LN1685"><span class='Ref_to_Global_Var'>OprProofCacheHash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>while</span> <span class='Parentheses'>((</span><a href="predtest.c.html#LN1942"><span class='Ref_To_Local'>hentry</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="predtest.c.html#LN1672"><span class='Ref_to_Struct'>OprProofCacheEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/utils/hsearch.h.html#LN135"><span class='Ref_to_Proto'>hash_seq_search</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predtest.c.html#LN1941"><span class='Ref_To_Local'>status</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <a href="predtest.c.html#LN1942"><span class='Ref_To_Local'>hentry</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN1677"><span class='Ref_to_Member'>have_implic</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="predtest.c.html#LN1942"><span class='Ref_To_Local'>hentry</span></a><span class='Operator'>-&GT;</span><a href="predtest.c.html#LN1678"><span class='Ref_to_Member'>have_refute</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
} 
</span></pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>