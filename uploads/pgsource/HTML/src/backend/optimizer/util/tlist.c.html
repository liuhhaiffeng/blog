<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\optimizer\util\tlist.c</title>
<LINK REL=StyleSheet HREF="../../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\optimizer\util\tlist.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:43 2017
</td></tr>
<tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * tlist.c 
 *    Target list manipulation routines 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * 
 * IDENTIFICATION 
 *    src/backend/optimizer/util/tlist.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"nodes/makefuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/nodeFuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/cost.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/tlist.h"</span> 
 
 
<span class='Comment_Multi_Line'>/* Test if an expression node represents a SRF call.  Beware multiple eval! */ 
</span><a name="LN23"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>IS_SRF_CALL</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN23"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& </span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) (</span><a href="tlist.c.html#LN23"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>funcretset<span class='Parentheses'>)</span> <span class='Operator'>|| \ 
</span>     <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN23"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& </span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) (</span><a href="tlist.c.html#LN23"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>opretset<span class='Parentheses'>))</span> 
 
<span class='Comment_Multi_Line'>/* Workspace for split_pathtarget_walker */ 
</span><span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN30"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>input_target_exprs</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* exprs available from input */ 
</span><a name="LN31"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>level_srfs</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* list of lists of SRF exprs */ 
</span><a name="LN32"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>level_input_vars</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* vars needed by SRFs of each level */ 
</span><a name="LN33"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>level_input_srfs</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* SRFs needed by SRFs of each level */ 
</span><a name="LN34"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>current_input_vars</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* vars needed in current subexpr */ 
</span><a name="LN35"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>current_input_srfs</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* SRFs needed in current subexpr */ 
</span><a name="LN36"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>current_depth</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* max SRF depth in current subexpr */ 
</span><a name="LN37"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>split_pathtarget_context</span><span class='Delimiter'>; 
</span> 
<a name="LN39"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>split_pathtarget_walker</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, 
</span><a name="LN40"></a>                        <a href="tlist.c.html#LN28"><span class='Ref_to_Typedef'>split_pathtarget_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/***************************************************************************** 
 *      Target list creation and searching utilities 
 *****************************************************************************/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * tlist_member 
 *    Finds the (first) member of the given tlist whose expression is 
 *    equal() to the given expression.  Result is NULL if no such member. 
 */ 
</span><a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>* 
</span><a name="LN53"></a><span class='Declare_Function'>tlist_member</span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>targetlist</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN55"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>temp</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN55"><span class='Ref_To_Local'>temp</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN53"><span class='Ref_to_Parameter'>targetlist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN59"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tlentry</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN55"><span class='Ref_To_Local'>temp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN626"><span class='Ref_to_Proto'>equal</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN53"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN59"><span class='Ref_To_Local'>tlentry</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <a href="tlist.c.html#LN59"><span class='Ref_To_Local'>tlentry</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * tlist_member_ignore_relabel 
 *    Same as above, except that we ignore top-level RelabelType nodes 
 *    while checking for a match.  This is needed for some scenarios 
 *    involving binary-compatible sort operations. 
 */ 
</span><a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>* 
</span><a name="LN74"></a><span class='Declare_Function'>tlist_member_ignore_relabel</span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>targetlist</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN76"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>temp</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="tlist.c.html#LN74"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN74"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a><span class='Parentheses'>))</span> 
        <a href="tlist.c.html#LN74"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tlist.c.html#LN74"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>arg<span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN76"><span class='Ref_To_Local'>temp</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN74"><span class='Ref_to_Parameter'>targetlist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN83"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tlentry</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN76"><span class='Ref_To_Local'>temp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN84"></a>        <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>tlexpr</span> <span class='Operator'>= </span><a href="tlist.c.html#LN83"><span class='Ref_To_Local'>tlentry</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="tlist.c.html#LN84"><span class='Ref_To_Local'>tlexpr</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN84"><span class='Ref_To_Local'>tlexpr</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a><span class='Parentheses'>))</span> 
            <a href="tlist.c.html#LN84"><span class='Ref_To_Local'>tlexpr</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tlist.c.html#LN84"><span class='Ref_To_Local'>tlexpr</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>arg<span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN626"><span class='Ref_to_Proto'>equal</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN74"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN84"><span class='Ref_To_Local'>tlexpr</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <a href="tlist.c.html#LN83"><span class='Ref_To_Local'>tlentry</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end tlist_member_ignore_relabel &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * tlist_member_match_var 
 *    Same as above, except that we match the provided Var on the basis 
 *    of varno/varattno/varlevelsup/vartype only, rather than full equal(). 
 * 
 * This is needed in some cases where we can't be sure of an exact typmod 
 * match.  For safety, though, we insist on vartype match. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>* 
</span><a name="LN104"></a><span class='Declare_Function'>tlist_member_match_var</span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>var</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>targetlist</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN106"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>temp</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN106"><span class='Ref_To_Local'>temp</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN104"><span class='Ref_to_Parameter'>targetlist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN110"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tlentry</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN106"><span class='Ref_To_Local'>temp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN111"></a>        <a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>tlvar</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tlist.c.html#LN110"><span class='Ref_To_Local'>tlentry</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tlist.c.html#LN111"><span class='Ref_To_Local'>tlvar</span></a> <span class='Operator'>|| !</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN111"><span class='Ref_To_Local'>tlvar</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tlist.c.html#LN104"><span class='Ref_to_Parameter'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN165"><span class='Ref_to_Member'>varno</span></a> <span class='Operator'>== </span><a href="tlist.c.html#LN111"><span class='Ref_To_Local'>tlvar</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN165"><span class='Ref_to_Member'>varno</span></a> <span class='Operator'>&& 
</span>            <a href="tlist.c.html#LN104"><span class='Ref_to_Parameter'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a> <span class='Operator'>== </span><a href="tlist.c.html#LN111"><span class='Ref_To_Local'>tlvar</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a> <span class='Operator'>&& 
</span>            <a href="tlist.c.html#LN104"><span class='Ref_to_Parameter'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN172"><span class='Ref_to_Member'>varlevelsup</span></a> <span class='Operator'>== </span><a href="tlist.c.html#LN111"><span class='Ref_To_Local'>tlvar</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN172"><span class='Ref_to_Member'>varlevelsup</span></a> <span class='Operator'>&& 
</span>            <a href="tlist.c.html#LN104"><span class='Ref_to_Parameter'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN169"><span class='Ref_to_Member'>vartype</span></a> <span class='Operator'>== </span><a href="tlist.c.html#LN111"><span class='Ref_To_Local'>tlvar</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN169"><span class='Ref_to_Member'>vartype</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <a href="tlist.c.html#LN110"><span class='Ref_To_Local'>tlentry</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end tlist_member_match_var &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * add_to_flat_tlist 
 *      Add more items to a flattened tlist (if they're not already in it) 
 * 
 * 'tlist' is the flattened tlist 
 * 'exprs' is a list of expressions (usually, but not necessarily, Vars) 
 * 
 * Returns the extended tlist. 
 */ 
</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN134"></a><span class='Declare_Function'>add_to_flat_tlist</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tlist</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>exprs</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN136"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>next_resno</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN134"><span class='Ref_to_Parameter'>tlist</span></a><span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span><a name="LN137"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN137"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN134"><span class='Ref_to_Parameter'>exprs</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN141"></a>        <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN137"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/optimizer/tlist.h.html#LN19"><span class='Ref_to_Proto'>tlist_member</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN141"><span class='Ref_To_Local'>expr</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN134"><span class='Ref_to_Parameter'>tlist</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN145"></a>            <a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span><span class='Delimiter'>; 
</span> 
            <a href="tlist.c.html#LN145"><span class='Ref_To_Local'>tle</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/makefuncs.h.html#LN40"><span class='Ref_to_Proto'>makeTargetEntry</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN141"><span class='Ref_To_Local'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>,</span>     <span class='Comment_Single_Line'>/* copy needed?? */ 
</span>                                  <a href="tlist.c.html#LN136"><span class='Ref_To_Local'>next_resno</span></a><span class='Operator'>++</span><span class='Delimiter'>, 
</span>                                  <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                  <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="tlist.c.html#LN134"><span class='Ref_to_Parameter'>tlist</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN134"><span class='Ref_to_Parameter'>tlist</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN145"><span class='Ref_To_Local'>tle</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <a href="tlist.c.html#LN134"><span class='Ref_to_Parameter'>tlist</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end add_to_flat_tlist &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * get_tlist_exprs 
 *      Get just the expression subtrees of a tlist 
 * 
 * Resjunk columns are ignored unless includeJunk is true 
 */ 
</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN165"></a><span class='Declare_Function'>get_tlist_exprs</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tlist</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>includeJunk</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN167"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN168"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN168"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN165"><span class='Ref_to_Parameter'>tlist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN172"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN168"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tlist.c.html#LN172"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1373"><span class='Ref_to_Member'>resjunk</span></a> <span class='Operator'>&& !</span><a href="tlist.c.html#LN165"><span class='Ref_to_Parameter'>includeJunk</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <a href="tlist.c.html#LN167"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN167"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN172"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <a href="tlist.c.html#LN167"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * count_nonjunk_tlist_entries 
 *      What it says ... 
 */ 
</span><span class='Keyword'>int 
</span><a name="LN188"></a><span class='Declare_Function'>count_nonjunk_tlist_entries</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tlist</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN190"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>len</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN191"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN191"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN188"><span class='Ref_to_Parameter'>tlist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN195"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN191"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tlist.c.html#LN195"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1373"><span class='Ref_to_Member'>resjunk</span></a><span class='Parentheses'>) 
</span>            <a href="tlist.c.html#LN190"><span class='Ref_To_Local'>len</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <a href="tlist.c.html#LN190"><span class='Ref_To_Local'>len</span></a><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * tlist_same_exprs 
 *      Check whether two target lists contain the same expressions 
 * 
 * Note: this function is used to decide whether it's safe to jam a new tlist 
 * into a non-projection-capable plan node.  Obviously we can't do that unless 
 * the node's tlist shows it already returns the column values we want. 
 * However, we can ignore the TargetEntry attributes resname, ressortgroupref, 
 * resorigtbl, resorigcol, and resjunk, because those are only labelings that 
 * don't affect the row values computed by the node.  (Moreover, if we didn't 
 * ignore them, we'd frequently fail to make the desired optimization, since 
 * the planner tends to not bother to make resname etc. valid in intermediate 
 * plan nodes.)  Note that on success, the caller must still jam the desired 
 * tlist into the plan node, else it won't have the desired labeling fields. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN220"></a><span class='Declare_Function'>tlist_same_exprs</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tlist1</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tlist2</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN222"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc1</span><span class='Delimiter'>, 
</span><a name="LN223"></a>               <span class='Operator'>*</span><span class='Declare_Local'>lc2</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN220"><span class='Ref_to_Parameter'>tlist1</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN220"><span class='Ref_to_Parameter'>tlist2</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* not same length, so can't match */ 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN179"><span class='Ref_to_Macro'>forboth</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN222"><span class='Ref_To_Local'>lc1</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN220"><span class='Ref_to_Parameter'>tlist1</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN223"><span class='Ref_To_Local'>lc2</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN220"><span class='Ref_to_Parameter'>tlist2</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN230"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle1</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN222"><span class='Ref_To_Local'>lc1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN231"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle2</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN223"><span class='Ref_To_Local'>lc2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/nodes.h.html#LN626"><span class='Ref_to_Proto'>equal</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN230"><span class='Ref_To_Local'>tle1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN231"><span class='Ref_To_Local'>tle2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end tlist_same_exprs &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Does tlist have same output datatypes as listed in colTypes? 
 * 
 * Resjunk columns are ignored if junkOK is true; otherwise presence of 
 * a resjunk column will always cause a 'false' result. 
 * 
 * Note: currently no callers care about comparing typmods. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN250"></a><span class='Declare_Function'>tlist_same_datatypes</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tlist</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>colTypes</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>junkOK</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN252"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span><a name="LN253"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>curColType</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN250"><span class='Ref_to_Parameter'>colTypes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN252"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN250"><span class='Ref_to_Parameter'>tlist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN257"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN252"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tlist.c.html#LN257"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1373"><span class='Ref_to_Member'>resjunk</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tlist.c.html#LN250"><span class='Ref_to_Parameter'>junkOK</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tlist.c.html#LN253"><span class='Ref_To_Local'>curColType</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* tlist longer than colTypes */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tlist.c.html#LN257"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Parentheses'>)</span> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN107"><span class='Ref_to_Macro'>lfirst_oid</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN253"><span class='Ref_To_Local'>curColType</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="tlist.c.html#LN253"><span class='Ref_To_Local'>curColType</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN253"><span class='Ref_To_Local'>curColType</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tlist.c.html#LN253"><span class='Ref_To_Local'>curColType</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* tlist shorter than colTypes */ 
</span>    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end tlist_same_datatypes &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Does tlist have same exposed collations as listed in colCollations? 
 * 
 * Identical logic to the above, but for collations. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN284"></a><span class='Declare_Function'>tlist_same_collations</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tlist</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>colCollations</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>junkOK</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN286"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span><a name="LN287"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>curColColl</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN284"><span class='Ref_to_Parameter'>colCollations</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN286"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN284"><span class='Ref_to_Parameter'>tlist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN291"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN286"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tlist.c.html#LN291"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1373"><span class='Ref_to_Member'>resjunk</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tlist.c.html#LN284"><span class='Ref_to_Parameter'>junkOK</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tlist.c.html#LN287"><span class='Ref_To_Local'>curColColl</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* tlist longer than colCollations */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodeFuncs.h.html#LN38"><span class='Ref_to_Proto'>exprCollation</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tlist.c.html#LN291"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Parentheses'>)</span> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN107"><span class='Ref_to_Macro'>lfirst_oid</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN287"><span class='Ref_To_Local'>curColColl</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="tlist.c.html#LN287"><span class='Ref_To_Local'>curColColl</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN287"><span class='Ref_To_Local'>curColColl</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tlist.c.html#LN287"><span class='Ref_To_Local'>curColColl</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* tlist shorter than colCollations */ 
</span>    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end tlist_same_collations &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * apply_tlist_labeling 
 *      Apply the TargetEntry labeling attributes of src_tlist to dest_tlist 
 * 
 * This is useful for reattaching column names etc to a plan's final output 
 * targetlist. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN320"></a><span class='Declare_Function'>apply_tlist_labeling</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>dest_tlist</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>src_tlist</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN322"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>ld</span><span class='Delimiter'>, 
</span><a name="LN323"></a>               <span class='Operator'>*</span><span class='Declare_Local'>ls</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN320"><span class='Ref_to_Parameter'>dest_tlist</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN320"><span class='Ref_to_Parameter'>src_tlist</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN179"><span class='Ref_to_Macro'>forboth</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN322"><span class='Ref_To_Local'>ld</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN320"><span class='Ref_to_Parameter'>dest_tlist</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN323"><span class='Ref_To_Local'>ls</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN320"><span class='Ref_to_Parameter'>src_tlist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN328"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>dest_tle</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN322"><span class='Ref_To_Local'>ld</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN329"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>src_tle</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN323"><span class='Ref_To_Local'>ls</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tlist.c.html#LN328"><span class='Ref_To_Local'>dest_tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1367"><span class='Ref_to_Member'>resno</span></a> <span class='Operator'>== </span><a href="tlist.c.html#LN329"><span class='Ref_To_Local'>src_tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1367"><span class='Ref_to_Member'>resno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="tlist.c.html#LN328"><span class='Ref_To_Local'>dest_tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1368"><span class='Ref_to_Member'>resname</span></a> <span class='Operator'>= </span><a href="tlist.c.html#LN329"><span class='Ref_To_Local'>src_tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1368"><span class='Ref_to_Member'>resname</span></a><span class='Delimiter'>; 
</span>        <a href="tlist.c.html#LN328"><span class='Ref_To_Local'>dest_tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1369"><span class='Ref_to_Member'>ressortgroupref</span></a> <span class='Operator'>= </span><a href="tlist.c.html#LN329"><span class='Ref_To_Local'>src_tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1369"><span class='Ref_to_Member'>ressortgroupref</span></a><span class='Delimiter'>; 
</span>        <a href="tlist.c.html#LN328"><span class='Ref_To_Local'>dest_tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1371"><span class='Ref_to_Member'>resorigtbl</span></a> <span class='Operator'>= </span><a href="tlist.c.html#LN329"><span class='Ref_To_Local'>src_tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1371"><span class='Ref_to_Member'>resorigtbl</span></a><span class='Delimiter'>; 
</span>        <a href="tlist.c.html#LN328"><span class='Ref_To_Local'>dest_tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1372"><span class='Ref_to_Member'>resorigcol</span></a> <span class='Operator'>= </span><a href="tlist.c.html#LN329"><span class='Ref_To_Local'>src_tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1372"><span class='Ref_to_Member'>resorigcol</span></a><span class='Delimiter'>; 
</span>        <a href="tlist.c.html#LN328"><span class='Ref_To_Local'>dest_tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1373"><span class='Ref_to_Member'>resjunk</span></a> <span class='Operator'>= </span><a href="tlist.c.html#LN329"><span class='Ref_To_Local'>src_tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1373"><span class='Ref_to_Member'>resjunk</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end apply_tlist_labeling &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * get_sortgroupref_tle 
 *      Find the targetlist entry matching the given SortGroupRef index, 
 *      and return it. 
 */ 
</span><a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>* 
</span><a name="LN347"></a><span class='Declare_Function'>get_sortgroupref_tle</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> <span class='Declare_Parameter'>sortref</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>targetList</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN349"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN349"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN347"><span class='Ref_to_Parameter'>targetList</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN353"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN349"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tlist.c.html#LN353"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1369"><span class='Ref_to_Member'>ressortgroupref</span></a> <span class='Operator'>== </span><a href="tlist.c.html#LN347"><span class='Ref_to_Parameter'>sortref</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <a href="tlist.c.html#LN353"><span class='Ref_To_Local'>tle</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"ORDER/GROUP BY expression not found in targetlist"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>;</span>                <span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span><span class='Delimiter'>} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * get_sortgroupclause_tle 
 *      Find the targetlist entry matching the given SortGroupClause 
 *      by ressortgroupref, and return it. 
 */ 
</span><a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>* 
</span><a name="LN369"></a><span class='Declare_Function'>get_sortgroupclause_tle</span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sgClause</span><span class='Delimiter'>, 
</span><a name="LN370"></a>                        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>targetList</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="../../../include/optimizer/tlist.h.html#LN35"><span class='Ref_to_Proto'>get_sortgroupref_tle</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN369"><span class='Ref_to_Parameter'>sgClause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1164"><span class='Ref_to_Member'>tleSortGroupRef</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN370"><span class='Ref_to_Parameter'>targetList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * get_sortgroupclause_expr 
 *      Find the targetlist entry matching the given SortGroupClause 
 *      by ressortgroupref, and return its expression. 
 */ 
</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN381"></a><span class='Declare_Function'>get_sortgroupclause_expr</span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sgClause</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>targetList</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN383"></a>    <a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span> <span class='Operator'>= </span><a href="../../../include/optimizer/tlist.h.html#LN37"><span class='Ref_to_Proto'>get_sortgroupclause_tle</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN381"><span class='Ref_to_Parameter'>sgClause</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN381"><span class='Ref_to_Parameter'>targetList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tlist.c.html#LN383"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * get_sortgrouplist_exprs 
 *      Given a list of SortGroupClauses, build a list 
 *      of the referenced targetlist expressions. 
 */ 
</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN394"></a><span class='Declare_Function'>get_sortgrouplist_exprs</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sgClauses</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>targetList</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN396"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN397"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN397"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN394"><span class='Ref_to_Parameter'>sgClauses</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN401"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sortcl</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN397"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN402"></a>        <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>sortexpr</span><span class='Delimiter'>; 
</span> 
        <a href="tlist.c.html#LN402"><span class='Ref_To_Local'>sortexpr</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/tlist.h.html#LN39"><span class='Ref_to_Proto'>get_sortgroupclause_expr</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN401"><span class='Ref_To_Local'>sortcl</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN394"><span class='Ref_to_Parameter'>targetList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="tlist.c.html#LN396"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN396"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN402"><span class='Ref_To_Local'>sortexpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <a href="tlist.c.html#LN396"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/***************************************************************************** 
 *      Functions to extract data from a list of SortGroupClauses 
 * 
 * These don't really belong in tlist.c, but they are sort of related to the 
 * functions just above, and they don't seem to deserve their own file. 
 *****************************************************************************/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * get_sortgroupref_clause 
 *      Find the SortGroupClause matching the given SortGroupRef index, 
 *      and return it. 
 */ 
</span><a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>* 
</span><a name="LN424"></a><span class='Declare_Function'>get_sortgroupref_clause</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> <span class='Declare_Parameter'>sortref</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clauses</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN426"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN426"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN424"><span class='Ref_to_Parameter'>clauses</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN430"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>cl</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN426"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tlist.c.html#LN430"><span class='Ref_To_Local'>cl</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1164"><span class='Ref_to_Member'>tleSortGroupRef</span></a> <span class='Operator'>== </span><a href="tlist.c.html#LN424"><span class='Ref_to_Parameter'>sortref</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <a href="tlist.c.html#LN430"><span class='Ref_To_Local'>cl</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"ORDER/GROUP BY expression not found in list"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>;</span>                <span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span><span class='Delimiter'>} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * get_sortgroupref_clause_noerr 
 *      As above, but return NULL rather than throwing an error if not found. 
 */ 
</span><a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>* 
</span><a name="LN445"></a><span class='Declare_Function'>get_sortgroupref_clause_noerr</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> <span class='Declare_Parameter'>sortref</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clauses</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN447"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN447"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN445"><span class='Ref_to_Parameter'>clauses</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN451"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>cl</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN447"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tlist.c.html#LN451"><span class='Ref_To_Local'>cl</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1164"><span class='Ref_to_Member'>tleSortGroupRef</span></a> <span class='Operator'>== </span><a href="tlist.c.html#LN445"><span class='Ref_to_Parameter'>sortref</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <a href="tlist.c.html#LN451"><span class='Ref_To_Local'>cl</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * extract_grouping_ops - make an array of the equality operator OIDs 
 *      for a SortGroupClause list 
 */ 
</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>* 
</span><a name="LN465"></a><span class='Declare_Function'>extract_grouping_ops</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>groupClause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN467"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numCols</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN465"><span class='Ref_to_Parameter'>groupClause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN468"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>colno</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN469"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>groupOperators</span><span class='Delimiter'>; 
</span><a name="LN470"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>glitem</span><span class='Delimiter'>; 
</span> 
    <a href="tlist.c.html#LN469"><span class='Ref_To_Local'>groupOperators</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="tlist.c.html#LN467"><span class='Ref_To_Local'>numCols</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN470"><span class='Ref_To_Local'>glitem</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN465"><span class='Ref_to_Parameter'>groupClause</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN476"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>groupcl</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN470"><span class='Ref_To_Local'>glitem</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="tlist.c.html#LN469"><span class='Ref_To_Local'>groupOperators</span></a><span class='Delimiter'>[</span><a href="tlist.c.html#LN468"><span class='Ref_To_Local'>colno</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="tlist.c.html#LN476"><span class='Ref_To_Local'>groupcl</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1165"><span class='Ref_to_Member'>eqop</span></a><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN469"><span class='Ref_To_Local'>groupOperators</span></a><span class='Delimiter'>[</span><a href="tlist.c.html#LN468"><span class='Ref_To_Local'>colno</span></a><span class='Delimiter'>]</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="tlist.c.html#LN468"><span class='Ref_To_Local'>colno</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="tlist.c.html#LN469"><span class='Ref_To_Local'>groupOperators</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end extract_grouping_ops &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * extract_grouping_cols - make an array of the grouping column resnos 
 *      for a SortGroupClause list 
 */ 
</span><a href="../../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a> <span class='Operator'>* 
</span><a name="LN491"></a><span class='Declare_Function'>extract_grouping_cols</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>groupClause</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tlist</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN493"></a>    <a href="../../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a> <span class='Operator'>*</span><span class='Declare_Local'>grpColIdx</span><span class='Delimiter'>; 
</span><a name="LN494"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numCols</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN491"><span class='Ref_to_Parameter'>groupClause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN495"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>colno</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN496"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>glitem</span><span class='Delimiter'>; 
</span> 
    <a href="tlist.c.html#LN493"><span class='Ref_To_Local'>grpColIdx</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="tlist.c.html#LN494"><span class='Ref_To_Local'>numCols</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN496"><span class='Ref_To_Local'>glitem</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN491"><span class='Ref_to_Parameter'>groupClause</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN502"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>groupcl</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN496"><span class='Ref_To_Local'>glitem</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN503"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span> <span class='Operator'>= </span><a href="../../../include/optimizer/tlist.h.html#LN37"><span class='Ref_to_Proto'>get_sortgroupclause_tle</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN502"><span class='Ref_To_Local'>groupcl</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN491"><span class='Ref_to_Parameter'>tlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="tlist.c.html#LN493"><span class='Ref_To_Local'>grpColIdx</span></a><span class='Delimiter'>[</span><a href="tlist.c.html#LN495"><span class='Ref_To_Local'>colno</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="tlist.c.html#LN503"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1367"><span class='Ref_to_Member'>resno</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="tlist.c.html#LN493"><span class='Ref_To_Local'>grpColIdx</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end extract_grouping_cols &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * grouping_is_sortable - is it possible to implement grouping list by sorting? 
 * 
 * This is easy since the parser will have included a sortop if one exists. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN517"></a><span class='Declare_Function'>grouping_is_sortable</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>groupClause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN519"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>glitem</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN519"><span class='Ref_To_Local'>glitem</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN517"><span class='Ref_to_Parameter'>groupClause</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN523"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>groupcl</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN519"><span class='Ref_To_Local'>glitem</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN523"><span class='Ref_To_Local'>groupcl</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1166"><span class='Ref_to_Member'>sortop</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * grouping_is_hashable - is it possible to implement grouping list by hashing? 
 * 
 * We rely on the parser to have set the hashable flag correctly. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN537"></a><span class='Declare_Function'>grouping_is_hashable</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>groupClause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN539"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>glitem</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN539"><span class='Ref_To_Local'>glitem</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN537"><span class='Ref_to_Parameter'>groupClause</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN543"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>groupcl</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN539"><span class='Ref_To_Local'>glitem</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tlist.c.html#LN543"><span class='Ref_To_Local'>groupcl</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1168"><span class='Ref_to_Member'>hashable</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/***************************************************************************** 
 *      PathTarget manipulation functions 
 * 
 * PathTarget is a somewhat stripped-down version of a full targetlist; it 
 * omits all the TargetEntry decoration except (optionally) sortgroupref data, 
 * and it adds evaluation cost and output data width info. 
 *****************************************************************************/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * make_pathtarget_from_tlist 
 *    Construct a PathTarget equivalent to the given targetlist. 
 * 
 * This leaves the cost and width fields as zeroes.  Most callers will want 
 * to use create_pathtarget(), so as to get those set. 
 */ 
</span><a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>* 
</span><a name="LN568"></a><span class='Declare_Function'>make_pathtarget_from_tlist</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tlist</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN570"></a>    <a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Local'>target</span> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN571"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN572"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <a href="tlist.c.html#LN570"><span class='Ref_To_Local'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN883"><span class='Ref_to_Member'>sortgrouprefs</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN568"><span class='Ref_to_Parameter'>tlist</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="tlist.c.html#LN571"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN572"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN568"><span class='Ref_to_Parameter'>tlist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN579"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN572"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="tlist.c.html#LN570"><span class='Ref_To_Local'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN570"><span class='Ref_To_Local'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN579"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="tlist.c.html#LN570"><span class='Ref_To_Local'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN883"><span class='Ref_to_Member'>sortgrouprefs</span></a><span class='Delimiter'>[</span><a href="tlist.c.html#LN571"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="tlist.c.html#LN579"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1369"><span class='Ref_to_Member'>ressortgroupref</span></a><span class='Delimiter'>; 
</span>        <a href="tlist.c.html#LN571"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="tlist.c.html#LN570"><span class='Ref_To_Local'>target</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end make_pathtarget_from_tlist &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * make_tlist_from_pathtarget 
 *    Construct a targetlist from a PathTarget. 
 */ 
</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN594"></a><span class='Declare_Function'>make_tlist_from_pathtarget</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>target</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN596"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>tlist</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN597"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN598"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <a href="tlist.c.html#LN597"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN598"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN594"><span class='Ref_to_Parameter'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN603"></a>        <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN598"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN604"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span><span class='Delimiter'>; 
</span> 
        <a href="tlist.c.html#LN604"><span class='Ref_To_Local'>tle</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/makefuncs.h.html#LN40"><span class='Ref_to_Proto'>makeTargetEntry</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN603"><span class='Ref_To_Local'>expr</span></a><span class='Delimiter'>, 
</span>                              <a href="tlist.c.html#LN597"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                              <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                              <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tlist.c.html#LN594"><span class='Ref_to_Parameter'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN883"><span class='Ref_to_Member'>sortgrouprefs</span></a><span class='Parentheses'>) 
</span>            <a href="tlist.c.html#LN604"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1369"><span class='Ref_to_Member'>ressortgroupref</span></a> <span class='Operator'>= </span><a href="tlist.c.html#LN594"><span class='Ref_to_Parameter'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN883"><span class='Ref_to_Member'>sortgrouprefs</span></a><span class='Delimiter'>[</span><a href="tlist.c.html#LN597"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>        <a href="tlist.c.html#LN596"><span class='Ref_To_Local'>tlist</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN596"><span class='Ref_To_Local'>tlist</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN604"><span class='Ref_To_Local'>tle</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="tlist.c.html#LN597"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="tlist.c.html#LN596"><span class='Ref_To_Local'>tlist</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end make_tlist_from_pathtarget &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * copy_pathtarget 
 *    Copy a PathTarget. 
 * 
 * The new PathTarget has its own List cells, but shares the underlying 
 * target expression trees with the old one.  We duplicate the List cells 
 * so that items can be added to one target without damaging the other. 
 */ 
</span><a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>* 
</span><a name="LN628"></a><span class='Declare_Function'>copy_pathtarget</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>src</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN630"></a>    <a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Local'>dst</span> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Copy scalar fields */ 
</span>    memcpy<span class='Parentheses'>(</span><a href="tlist.c.html#LN630"><span class='Ref_To_Local'>dst</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN628"><span class='Ref_to_Parameter'>src</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* Shallow-copy the expression list */ 
</span>    <a href="tlist.c.html#LN630"><span class='Ref_To_Local'>dst</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN268"><span class='Ref_to_Proto'>list_copy</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN628"><span class='Ref_to_Parameter'>src</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* Duplicate sortgrouprefs if any (if not, the memcpy handled this) */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tlist.c.html#LN628"><span class='Ref_to_Parameter'>src</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN883"><span class='Ref_to_Member'>sortgrouprefs</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN639"></a>        <a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Local'>nbytes</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN628"><span class='Ref_to_Parameter'>src</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="tlist.c.html#LN630"><span class='Ref_To_Local'>dst</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN883"><span class='Ref_to_Member'>sortgrouprefs</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN639"><span class='Ref_To_Local'>nbytes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        memcpy<span class='Parentheses'>(</span><a href="tlist.c.html#LN630"><span class='Ref_To_Local'>dst</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN883"><span class='Ref_to_Member'>sortgrouprefs</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN628"><span class='Ref_to_Parameter'>src</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN883"><span class='Ref_to_Member'>sortgrouprefs</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN639"><span class='Ref_To_Local'>nbytes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <a href="tlist.c.html#LN630"><span class='Ref_To_Local'>dst</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * create_empty_pathtarget 
 *    Create an empty (zero columns, zero cost) PathTarget. 
 */ 
</span><a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>* 
</span><a name="LN652"></a><span class='Declare_Function'>create_empty_pathtarget</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* This is easy, but we don't want callers to hard-wire this ... */ 
</span>    <span class='Control'>return</span> <a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * add_column_to_pathtarget 
 *      Append a target column to the PathTarget. 
 * 
 * As with make_pathtarget_from_tlist, we leave it to the caller to update 
 * the cost and width fields. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN666"></a><span class='Declare_Function'>add_column_to_pathtarget</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>target</span><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>expr</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> <span class='Declare_Parameter'>sortgroupref</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* Updating the exprs list is easy ... */ 
</span>    <a href="tlist.c.html#LN666"><span class='Ref_to_Parameter'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN666"><span class='Ref_to_Parameter'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN666"><span class='Ref_to_Parameter'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* ... the sortgroupref data, a bit less so */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tlist.c.html#LN666"><span class='Ref_to_Parameter'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN883"><span class='Ref_to_Member'>sortgrouprefs</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN673"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>nexprs</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN666"><span class='Ref_to_Parameter'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* This might look inefficient, but actually it's usually cheap */ 
</span>        <a href="tlist.c.html#LN666"><span class='Ref_to_Parameter'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN883"><span class='Ref_to_Member'>sortgrouprefs</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../../include/common/fe_memutils.h.html#LN36"><span class='Ref_to_Proto'>repalloc</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN666"><span class='Ref_to_Parameter'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN883"><span class='Ref_to_Member'>sortgrouprefs</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN673"><span class='Ref_To_Local'>nexprs</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="tlist.c.html#LN666"><span class='Ref_to_Parameter'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN883"><span class='Ref_to_Member'>sortgrouprefs</span></a><span class='Delimiter'>[</span><a href="tlist.c.html#LN673"><span class='Ref_To_Local'>nexprs</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="tlist.c.html#LN666"><span class='Ref_to_Parameter'>sortgroupref</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tlist.c.html#LN666"><span class='Ref_to_Parameter'>sortgroupref</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Adding sortgroupref labeling to a previously unlabeled target */ 
</span><a name="LN683"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>nexprs</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN666"><span class='Ref_to_Parameter'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="tlist.c.html#LN666"><span class='Ref_to_Parameter'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN883"><span class='Ref_to_Member'>sortgrouprefs</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN683"><span class='Ref_To_Local'>nexprs</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="tlist.c.html#LN666"><span class='Ref_to_Parameter'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN883"><span class='Ref_to_Member'>sortgrouprefs</span></a><span class='Delimiter'>[</span><a href="tlist.c.html#LN683"><span class='Ref_To_Local'>nexprs</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="tlist.c.html#LN666"><span class='Ref_to_Parameter'>sortgroupref</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end add_column_to_pathtarget &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * add_new_column_to_pathtarget 
 *      Append a target column to the PathTarget, but only if it's not 
 *      equal() to any pre-existing target expression. 
 * 
 * The caller cannot specify a sortgroupref, since it would be unclear how 
 * to merge that with a pre-existing column. 
 * 
 * As with make_pathtarget_from_tlist, we leave it to the caller to update 
 * the cost and width fields. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN702"></a><span class='Declare_Function'>add_new_column_to_pathtarget</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>target</span><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>expr</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/pg_list.h.html#LN228"><span class='Ref_to_Proto'>list_member</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN702"><span class='Ref_to_Parameter'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN702"><span class='Ref_to_Parameter'>expr</span></a><span class='Parentheses'>))</span> 
        <a href="../../../include/optimizer/tlist.h.html#LN58"><span class='Ref_to_Proto'>add_column_to_pathtarget</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN702"><span class='Ref_to_Parameter'>target</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN702"><span class='Ref_to_Parameter'>expr</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * add_new_columns_to_pathtarget 
 *      Apply add_new_column_to_pathtarget() for each element of the list. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN713"></a><span class='Declare_Function'>add_new_columns_to_pathtarget</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>target</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>exprs</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN715"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN715"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN713"><span class='Ref_to_Parameter'>exprs</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN719"></a>        <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN715"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/optimizer/tlist.h.html#LN60"><span class='Ref_to_Proto'>add_new_column_to_pathtarget</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN713"><span class='Ref_to_Parameter'>target</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN719"><span class='Ref_To_Local'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * apply_pathtarget_labeling_to_tlist 
 *      Apply any sortgrouprefs in the PathTarget to matching tlist entries 
 * 
 * Here, we do not assume that the tlist entries are one-for-one with the 
 * PathTarget.  The intended use of this function is to deal with cases 
 * where createplan.c has decided to use some other tlist and we have 
 * to identify what matches exist. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN735"></a><span class='Declare_Function'>apply_pathtarget_labeling_to_tlist</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tlist</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>target</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN737"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN738"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Nothing to do if PathTarget has no sortgrouprefs data */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tlist.c.html#LN735"><span class='Ref_to_Parameter'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN883"><span class='Ref_to_Member'>sortgrouprefs</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <a href="tlist.c.html#LN737"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN738"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN735"><span class='Ref_to_Parameter'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN747"></a>        <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN738"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN748"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tlist.c.html#LN735"><span class='Ref_to_Parameter'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN883"><span class='Ref_to_Member'>sortgrouprefs</span></a><span class='Delimiter'>[</span><a href="tlist.c.html#LN737"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * For Vars, use tlist_member_match_var's weakened matching rule; 
             * this allows us to deal with some cases where a set-returning 
             * function has been inlined, so that we now have more knowledge 
             * about what it returns than we did when the original Var was 
             * created.  Otherwise, use regular equal() to find the matching 
             * TLE.  (In current usage, only the Var case is actually needed; 
             * but it seems best to have sane behavior here for non-Vars too.) 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tlist.c.html#LN747"><span class='Ref_To_Local'>expr</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN747"><span class='Ref_To_Local'>expr</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>))</span> 
                <a href="tlist.c.html#LN748"><span class='Ref_To_Local'>tle</span></a> <span class='Operator'>= </span><a href="tlist.c.html#LN103"><span class='Ref_to_Func'>tlist_member_match_var</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tlist.c.html#LN747"><span class='Ref_To_Local'>expr</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN735"><span class='Ref_to_Parameter'>tlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="tlist.c.html#LN748"><span class='Ref_To_Local'>tle</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/tlist.h.html#LN19"><span class='Ref_to_Proto'>tlist_member</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN747"><span class='Ref_To_Local'>expr</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN735"><span class='Ref_to_Parameter'>tlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Complain if noplace for the sortgrouprefs label, or if we'd 
             * have to label a column twice.  (The case where it already has 
             * the desired label probably can't happen, but we may as well 
             * allow for it.) 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tlist.c.html#LN748"><span class='Ref_To_Local'>tle</span></a><span class='Parentheses'>) 
</span>                <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"ORDER/GROUP BY expression not found in targetlist"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tlist.c.html#LN748"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1369"><span class='Ref_to_Member'>ressortgroupref</span></a> <span class='Operator'>!= </span><span class='Number'>0</span> <span class='Operator'>&& 
</span>                <a href="tlist.c.html#LN748"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1369"><span class='Ref_to_Member'>ressortgroupref</span></a> <span class='Operator'>!= </span><a href="tlist.c.html#LN735"><span class='Ref_to_Parameter'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN883"><span class='Ref_to_Member'>sortgrouprefs</span></a><span class='Delimiter'>[</span><a href="tlist.c.html#LN737"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>                <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"targetlist item has multiple sortgroupref labels"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="tlist.c.html#LN748"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1369"><span class='Ref_to_Member'>ressortgroupref</span></a> <span class='Operator'>= </span><a href="tlist.c.html#LN735"><span class='Ref_to_Parameter'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN883"><span class='Ref_to_Member'>sortgrouprefs</span></a><span class='Delimiter'>[</span><a href="tlist.c.html#LN737"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if target-&GT;sortgrouprefs... &raquo; </span> 
        <a href="tlist.c.html#LN737"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end apply_pathtarget_labeling_to_tlist &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * split_pathtarget_at_srfs 
 *      Split given PathTarget into multiple levels to position SRFs safely 
 * 
 * The executor can only handle set-returning functions that appear at the 
 * top level of the targetlist of a ProjectSet plan node.  If we have any SRFs 
 * that are not at top level, we need to split up the evaluation into multiple 
 * plan levels in which each level satisfies this constraint.  This function 
 * creates appropriate PathTarget(s) for each level. 
 * 
 * As an example, consider the tlist expression 
 *      x + srf1(srf2(y + z)) 
 * This expression should appear as-is in the top PathTarget, but below that 
 * we must have a PathTarget containing 
 *      x, srf1(srf2(y + z)) 
 * and below that, another PathTarget containing 
 *      x, srf2(y + z) 
 * and below that, another PathTarget containing 
 *      x, y, z 
 * When these tlists are processed by setrefs.c, subexpressions that match 
 * output expressions of the next lower tlist will be replaced by Vars, 
 * so that what the executor gets are tlists looking like 
 *      Var1 + Var2 
 *      Var1, srf1(Var2) 
 *      Var1, srf2(Var2 + Var3) 
 *      x, y, z 
 * which satisfy the desired property. 
 * 
 * Another example is 
 *      srf1(x), srf2(srf3(y)) 
 * That must appear as-is in the top PathTarget, but below that we need 
 *      srf1(x), srf3(y) 
 * That is, each SRF must be computed at a level corresponding to the nesting 
 * depth of SRFs within its arguments. 
 * 
 * In some cases, a SRF has already been evaluated in some previous plan level 
 * and we shouldn't expand it again (that is, what we see in the target is 
 * already meant as a reference to a lower subexpression).  So, don't expand 
 * any tlist expressions that appear in input_target, if that's not NULL. 
 * 
 * The outputs of this function are two parallel lists, one a list of 
 * PathTargets and the other an integer list of bool flags indicating 
 * whether the corresponding PathTarget contains any evaluatable SRFs. 
 * The lists are given in the order they'd need to be evaluated in, with 
 * the "lowest" PathTarget first.  So the last list entry is always the 
 * originally given PathTarget, and any entries before it indicate evaluation 
 * levels that must be inserted below it.  The first list entry must not 
 * contain any SRFs (other than ones duplicating input_target entries), since 
 * it will typically be attached to a plan node that cannot evaluate SRFs. 
 * 
 * Note: using a list for the flags may seem like overkill, since there 
 * are only a few possible patterns for which levels contain SRFs. 
 * But this representation decouples callers from that knowledge. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN839"></a><span class='Declare_Function'>split_pathtarget_at_srfs</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN840"></a>                         <a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>target</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>input_target</span><span class='Delimiter'>, 
</span><a name="LN841"></a>                         <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>targets</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>targets_contain_srfs</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN843"></a>    <a href="tlist.c.html#LN28"><span class='Ref_to_Typedef'>split_pathtarget_context</span></a> <span class='Declare_Local'>context</span><span class='Delimiter'>; 
</span><a name="LN844"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>max_depth</span><span class='Delimiter'>; 
</span><a name="LN845"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>need_extra_projection</span><span class='Delimiter'>; 
</span><a name="LN846"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>prev_level_tlist</span><span class='Delimiter'>; 
</span><a name="LN847"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>, 
</span><a name="LN848"></a>               <span class='Operator'>*</span><span class='Declare_Local'>lc1</span><span class='Delimiter'>, 
</span><a name="LN849"></a>               <span class='Operator'>*</span><span class='Declare_Local'>lc2</span><span class='Delimiter'>, 
</span><a name="LN850"></a>               <span class='Operator'>*</span><span class='Declare_Local'>lc3</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * It's not unusual for planner.c to pass us two physically identical 
     * targets, in which case we can conclude without further ado that all 
     * expressions are available from the input.  (The logic below would 
     * arrive at the same conclusion, but much more tediously.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tlist.c.html#LN840"><span class='Ref_to_Parameter'>target</span></a> <span class='Operator'>== </span><a href="tlist.c.html#LN840"><span class='Ref_to_Parameter'>input_target</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Operator'>*</span><a href="tlist.c.html#LN841"><span class='Ref_to_Parameter'>targets</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN840"><span class='Ref_to_Parameter'>target</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="tlist.c.html#LN841"><span class='Ref_to_Parameter'>targets_contain_srfs</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN144"><span class='Ref_to_Macro'>list_make1_int</span></a><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Pass any input_target exprs down to split_pathtarget_walker() */ 
</span>    <a href="tlist.c.html#LN843"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="tlist.c.html#LN30"><span class='Ref_to_Member'>input_target_exprs</span></a> <span class='Operator'>= </span><a href="tlist.c.html#LN840"><span class='Ref_to_Parameter'>input_target</span></a> <span class='Operator'>? </span><a href="tlist.c.html#LN840"><span class='Ref_to_Parameter'>input_target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a> <span class='Operator'>: </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Initialize with empty level-zero lists, and no levels after that. 
     * (Note: we could dispense with representing level zero explicitly, since 
     * it will never receive any SRFs, but then we'd have to special-case that 
     * level when we get to building result PathTargets.  Level zero describes 
     * the SRF-free PathTarget that will be given to the input plan node.) 
     */ 
</span>    <a href="tlist.c.html#LN843"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="tlist.c.html#LN31"><span class='Ref_to_Member'>level_srfs</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="tlist.c.html#LN843"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="tlist.c.html#LN32"><span class='Ref_to_Member'>level_input_vars</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="tlist.c.html#LN843"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="tlist.c.html#LN33"><span class='Ref_to_Member'>level_input_srfs</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Initialize data we'll accumulate across all the target expressions */ 
</span>    <a href="tlist.c.html#LN843"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="tlist.c.html#LN34"><span class='Ref_to_Member'>current_input_vars</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="tlist.c.html#LN843"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="tlist.c.html#LN35"><span class='Ref_to_Member'>current_input_srfs</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="tlist.c.html#LN844"><span class='Ref_To_Local'>max_depth</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="tlist.c.html#LN845"><span class='Ref_To_Local'>need_extra_projection</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Scan each expression in the PathTarget looking for SRFs */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN847"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN840"><span class='Ref_to_Parameter'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN888"></a>        <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>node</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN847"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Find all SRFs and Vars (and Var-like nodes) in this expression, and 
         * enter them into appropriate lists within the context struct. 
         */ 
</span>        <a href="tlist.c.html#LN843"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="tlist.c.html#LN36"><span class='Ref_to_Member'>current_depth</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="tlist.c.html#LN39"><span class='Ref_to_Proto'>split_pathtarget_walker</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN888"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tlist.c.html#LN843"><span class='Ref_To_Local'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* An expression containing no SRFs is of no further interest */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tlist.c.html#LN843"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="tlist.c.html#LN36"><span class='Ref_to_Member'>current_depth</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Track max SRF nesting depth over the whole PathTarget.  Also, if 
         * this expression establishes a new max depth, we no longer care 
         * whether previous expressions contained nested SRFs; we can handle 
         * any required projection for them in the final ProjectSet node. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tlist.c.html#LN844"><span class='Ref_To_Local'>max_depth</span></a> <span class='Operator'>&LT; </span><a href="tlist.c.html#LN843"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="tlist.c.html#LN36"><span class='Ref_to_Member'>current_depth</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="tlist.c.html#LN844"><span class='Ref_To_Local'>max_depth</span></a> <span class='Operator'>= </span><a href="tlist.c.html#LN843"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="tlist.c.html#LN36"><span class='Ref_to_Member'>current_depth</span></a><span class='Delimiter'>; 
</span>            <a href="tlist.c.html#LN845"><span class='Ref_To_Local'>need_extra_projection</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If any maximum-depth SRF is not at the top level of its expression, 
         * we'll need an extra Result node to compute the top-level scalar 
         * expression. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tlist.c.html#LN844"><span class='Ref_To_Local'>max_depth</span></a> <span class='Operator'>== </span><a href="tlist.c.html#LN843"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="tlist.c.html#LN36"><span class='Ref_to_Member'>current_depth</span></a> <span class='Operator'>&& !</span><a href="tlist.c.html#LN23"><span class='Ref_to_Macro'>IS_SRF_CALL</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN888"><span class='Ref_To_Local'>node</span></a><span class='Parentheses'>))</span> 
            <a href="tlist.c.html#LN845"><span class='Ref_To_Local'>need_extra_projection</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we found no SRFs needing evaluation (maybe they were all present in 
     * input_target, or maybe they were all removed by const-simplification), 
     * then no ProjectSet is needed; fall out. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tlist.c.html#LN844"><span class='Ref_To_Local'>max_depth</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Operator'>*</span><a href="tlist.c.html#LN841"><span class='Ref_to_Parameter'>targets</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN840"><span class='Ref_to_Parameter'>target</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="tlist.c.html#LN841"><span class='Ref_to_Parameter'>targets_contain_srfs</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN144"><span class='Ref_to_Macro'>list_make1_int</span></a><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The Vars and SRF outputs needed at top level can be added to the last 
     * level_input lists if we don't need an extra projection step.  If we do 
     * need one, add a SRF-free level to the lists. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tlist.c.html#LN845"><span class='Ref_To_Local'>need_extra_projection</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="tlist.c.html#LN843"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="tlist.c.html#LN31"><span class='Ref_to_Member'>level_srfs</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN843"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="tlist.c.html#LN31"><span class='Ref_to_Member'>level_srfs</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="tlist.c.html#LN843"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="tlist.c.html#LN32"><span class='Ref_to_Member'>level_input_vars</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN843"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="tlist.c.html#LN32"><span class='Ref_to_Member'>level_input_vars</span></a><span class='Delimiter'>, 
</span>                                           <a href="tlist.c.html#LN843"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="tlist.c.html#LN34"><span class='Ref_to_Member'>current_input_vars</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="tlist.c.html#LN843"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="tlist.c.html#LN33"><span class='Ref_to_Member'>level_input_srfs</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN843"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="tlist.c.html#LN33"><span class='Ref_to_Member'>level_input_srfs</span></a><span class='Delimiter'>, 
</span>                                           <a href="tlist.c.html#LN843"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="tlist.c.html#LN35"><span class='Ref_to_Member'>current_input_srfs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="tlist.c.html#LN847"><span class='Ref_To_Local'>lc</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN222"><span class='Ref_to_Proto'>list_nth_cell</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN843"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="tlist.c.html#LN32"><span class='Ref_to_Member'>level_input_vars</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN844"><span class='Ref_To_Local'>max_depth</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN847"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN847"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="tlist.c.html#LN843"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="tlist.c.html#LN34"><span class='Ref_to_Member'>current_input_vars</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="tlist.c.html#LN847"><span class='Ref_To_Local'>lc</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN222"><span class='Ref_to_Proto'>list_nth_cell</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN843"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="tlist.c.html#LN33"><span class='Ref_to_Member'>level_input_srfs</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN844"><span class='Ref_To_Local'>max_depth</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN847"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN847"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="tlist.c.html#LN843"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="tlist.c.html#LN35"><span class='Ref_to_Member'>current_input_srfs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now construct the output PathTargets.  The original target can be used 
     * as-is for the last one, but we need to construct a new SRF-free target 
     * representing what the preceding plan node has to emit, as well as a 
     * target for each intermediate ProjectSet node. 
     */ 
</span>    <span class='Operator'>*</span><a href="tlist.c.html#LN841"><span class='Ref_to_Parameter'>targets</span></a> <span class='Operator'>= *</span><a href="tlist.c.html#LN841"><span class='Ref_to_Parameter'>targets_contain_srfs</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="tlist.c.html#LN846"><span class='Ref_To_Local'>prev_level_tlist</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN202"><span class='Ref_to_Macro'>forthree</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN848"><span class='Ref_To_Local'>lc1</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN843"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="tlist.c.html#LN31"><span class='Ref_to_Member'>level_srfs</span></a><span class='Delimiter'>, 
</span>             <a href="tlist.c.html#LN849"><span class='Ref_To_Local'>lc2</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN843"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="tlist.c.html#LN32"><span class='Ref_to_Member'>level_input_vars</span></a><span class='Delimiter'>, 
</span>             <a href="tlist.c.html#LN850"><span class='Ref_To_Local'>lc3</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN843"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="tlist.c.html#LN33"><span class='Ref_to_Member'>level_input_srfs</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN968"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>level_srfs</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN848"><span class='Ref_To_Local'>lc1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN969"></a>        <a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Local'>ntarget</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN848"><span class='Ref_To_Local'>lc1</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <a href="tlist.c.html#LN969"><span class='Ref_To_Local'>ntarget</span></a> <span class='Operator'>= </span><a href="tlist.c.html#LN840"><span class='Ref_to_Parameter'>target</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="tlist.c.html#LN969"><span class='Ref_To_Local'>ntarget</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/tlist.h.html#LN57"><span class='Ref_to_Proto'>create_empty_pathtarget</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * This target should actually evaluate any SRFs of the current 
             * level, and it needs to propagate forward any Vars needed by 
             * later levels, as well as SRFs computed earlier and needed by 
             * later levels.  We rely on add_new_columns_to_pathtarget() to 
             * remove duplicate items.  Also, for safety, make a separate copy 
             * of each item for each PathTarget. 
             */ 
</span>            <a href="../../../include/optimizer/tlist.h.html#LN61"><span class='Ref_to_Proto'>add_new_columns_to_pathtarget</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN969"><span class='Ref_To_Local'>ntarget</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN968"><span class='Ref_To_Local'>level_srfs</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="../../../include/nodes/pg_list.h.html#LN168"><span class='Ref_to_Macro'>for_each_cell</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN847"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN849"><span class='Ref_To_Local'>lc2</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span><a name="LN990"></a>                <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>input_vars</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN847"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="../../../include/optimizer/tlist.h.html#LN61"><span class='Ref_to_Proto'>add_new_columns_to_pathtarget</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN969"><span class='Ref_To_Local'>ntarget</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN990"><span class='Ref_To_Local'>input_vars</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <a href="../../../include/nodes/pg_list.h.html#LN168"><span class='Ref_to_Macro'>for_each_cell</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN847"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN850"><span class='Ref_To_Local'>lc3</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span><a name="LN996"></a>                <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>input_srfs</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN847"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN997"></a>                <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lcx</span><span class='Delimiter'>; 
</span> 
                <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN997"><span class='Ref_To_Local'>lcx</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN996"><span class='Ref_To_Local'>input_srfs</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN1001"></a>                    <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>srf</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN997"><span class='Ref_To_Local'>lcx</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN228"><span class='Ref_to_Proto'>list_member</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN846"><span class='Ref_To_Local'>prev_level_tlist</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN1001"><span class='Ref_To_Local'>srf</span></a><span class='Parentheses'>))</span> 
                        <a href="../../../include/optimizer/tlist.h.html#LN60"><span class='Ref_to_Proto'>add_new_column_to_pathtarget</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN969"><span class='Ref_To_Local'>ntarget</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN1001"><span class='Ref_To_Local'>srf</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span>            <a href="../../../include/optimizer/cost.h.html#LN189"><span class='Ref_to_Proto'>set_pathtarget_cost_width</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN839"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN969"><span class='Ref_To_Local'>ntarget</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* 
         * Add current target and does-it-compute-SRFs flag to output lists. 
         */ 
</span>        <span class='Operator'>*</span><a href="tlist.c.html#LN841"><span class='Ref_to_Parameter'>targets</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="tlist.c.html#LN841"><span class='Ref_to_Parameter'>targets</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN969"><span class='Ref_To_Local'>ntarget</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="tlist.c.html#LN841"><span class='Ref_to_Parameter'>targets_contain_srfs</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN144"><span class='Ref_to_Func'>lappend_int</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="tlist.c.html#LN841"><span class='Ref_to_Parameter'>targets_contain_srfs</span></a><span class='Delimiter'>, 
</span>                                            <span class='Parentheses'>(</span><a href="tlist.c.html#LN968"><span class='Ref_To_Local'>level_srfs</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Remember this level's output for next pass */ 
</span>        <a href="tlist.c.html#LN846"><span class='Ref_To_Local'>prev_level_tlist</span></a> <span class='Operator'>= </span><a href="tlist.c.html#LN969"><span class='Ref_To_Local'>ntarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end split_pathtarget_at_srfs &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Recursively examine expressions for split_pathtarget_at_srfs. 
 * 
 * Note we make no effort here to prevent duplicate entries in the output 
 * lists.  Duplicates will be gotten rid of later. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN1029"></a><span class='Declare_Function'>split_pathtarget_walker</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><a href="tlist.c.html#LN28"><span class='Ref_to_Typedef'>split_pathtarget_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * A subexpression that matches an expression already computed in 
     * input_target can be treated like a Var (which indeed it will be after 
     * setrefs.c gets done with it), even if it's actually a SRF.  Record it 
     * as being needed for the current expression, and ignore any 
     * substructure. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN228"><span class='Ref_to_Proto'>list_member</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="tlist.c.html#LN30"><span class='Ref_to_Member'>input_target_exprs</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="tlist.c.html#LN34"><span class='Ref_to_Member'>current_input_vars</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="tlist.c.html#LN34"><span class='Ref_to_Member'>current_input_vars</span></a><span class='Delimiter'>, 
</span>                                              <a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Vars and Var-like constructs are expected to be gotten from the input, 
     * too.  We assume that these constructs cannot contain any SRFs (if one 
     * does, there will be an executor failure from a misplaced SRF). 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1846"><span class='Ref_to_Struct'>PlaceHolderVar</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN337"><span class='Ref_to_Struct'>GroupingFunc</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN351"><span class='Ref_to_Struct'>WindowFunc</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="tlist.c.html#LN34"><span class='Ref_to_Member'>current_input_vars</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="tlist.c.html#LN34"><span class='Ref_to_Member'>current_input_vars</span></a><span class='Delimiter'>, 
</span>                                              <a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If it's a SRF, recursively examine its inputs, determine its level, and 
     * make appropriate entries in the output lists. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tlist.c.html#LN23"><span class='Ref_to_Macro'>IS_SRF_CALL</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1070"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>save_input_vars</span> <span class='Operator'>= </span><a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="tlist.c.html#LN34"><span class='Ref_to_Member'>current_input_vars</span></a><span class='Delimiter'>; 
</span><a name="LN1071"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>save_input_srfs</span> <span class='Operator'>= </span><a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="tlist.c.html#LN35"><span class='Ref_to_Member'>current_input_srfs</span></a><span class='Delimiter'>; 
</span><a name="LN1072"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>save_current_depth</span> <span class='Operator'>= </span><a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="tlist.c.html#LN36"><span class='Ref_to_Member'>current_depth</span></a><span class='Delimiter'>; 
</span><a name="LN1073"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>srf_depth</span><span class='Delimiter'>; 
</span><a name="LN1074"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
        <a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="tlist.c.html#LN34"><span class='Ref_to_Member'>current_input_vars</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>        <a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="tlist.c.html#LN35"><span class='Ref_to_Member'>current_input_srfs</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>        <a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="tlist.c.html#LN36"><span class='Ref_to_Member'>current_depth</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
        <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="../../../include/nodes/nodeFuncs.h.html#LN52"><span class='Ref_to_Proto'>expression_tree_walker</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN39"><span class='Ref_to_Proto'>split_pathtarget_walker</span></a><span class='Delimiter'>, 
</span>                                      <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Depth is one more than any SRF below it */ 
</span>        <a href="tlist.c.html#LN1073"><span class='Ref_To_Local'>srf_depth</span></a> <span class='Operator'>= </span><a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="tlist.c.html#LN36"><span class='Ref_to_Member'>current_depth</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* If new record depth, initialize another level of output lists */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tlist.c.html#LN1073"><span class='Ref_To_Local'>srf_depth</span></a> <span class='Operator'>&GT;= </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="tlist.c.html#LN31"><span class='Ref_to_Member'>level_srfs</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="tlist.c.html#LN31"><span class='Ref_to_Member'>level_srfs</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="tlist.c.html#LN31"><span class='Ref_to_Member'>level_srfs</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="tlist.c.html#LN32"><span class='Ref_to_Member'>level_input_vars</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="tlist.c.html#LN32"><span class='Ref_to_Member'>level_input_vars</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="tlist.c.html#LN33"><span class='Ref_to_Member'>level_input_srfs</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="tlist.c.html#LN33"><span class='Ref_to_Member'>level_input_srfs</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Record this SRF as needing to be evaluated at appropriate level */ 
</span>        <a href="tlist.c.html#LN1074"><span class='Ref_To_Local'>lc</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN222"><span class='Ref_to_Proto'>list_nth_cell</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="tlist.c.html#LN31"><span class='Ref_to_Member'>level_srfs</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN1073"><span class='Ref_To_Local'>srf_depth</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN1074"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN1074"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Record its inputs as being needed at the same level */ 
</span>        <a href="tlist.c.html#LN1074"><span class='Ref_To_Local'>lc</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN222"><span class='Ref_to_Proto'>list_nth_cell</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="tlist.c.html#LN32"><span class='Ref_to_Member'>level_input_vars</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN1073"><span class='Ref_To_Local'>srf_depth</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN1074"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN1074"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="tlist.c.html#LN34"><span class='Ref_to_Member'>current_input_vars</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="tlist.c.html#LN1074"><span class='Ref_To_Local'>lc</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN222"><span class='Ref_to_Proto'>list_nth_cell</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="tlist.c.html#LN33"><span class='Ref_to_Member'>level_input_srfs</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN1073"><span class='Ref_To_Local'>srf_depth</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN1074"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN1074"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="tlist.c.html#LN35"><span class='Ref_to_Member'>current_input_srfs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Restore caller-level state and update it for presence of this SRF. 
         * Notice we report the SRF itself as being needed for evaluation of 
         * surrounding expression. 
         */ 
</span>        <a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="tlist.c.html#LN34"><span class='Ref_to_Member'>current_input_vars</span></a> <span class='Operator'>= </span><a href="tlist.c.html#LN1070"><span class='Ref_To_Local'>save_input_vars</span></a><span class='Delimiter'>; 
</span>        <a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="tlist.c.html#LN35"><span class='Ref_to_Member'>current_input_srfs</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN1071"><span class='Ref_To_Local'>save_input_srfs</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="tlist.c.html#LN36"><span class='Ref_to_Member'>current_depth</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN10"><span class='Ref_to_Macro'>Max</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN1072"><span class='Ref_To_Local'>save_current_depth</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN1073"><span class='Ref_To_Local'>srf_depth</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* We're done here */ 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IS_SRF_CALL(node) &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Otherwise, the node is a scalar (non-set) expression, so recurse to 
     * examine its inputs. 
     */ 
</span>    <span class='Control'>return</span> <a href="../../../include/nodes/nodeFuncs.h.html#LN52"><span class='Ref_to_Proto'>expression_tree_walker</span></a><span class='Parentheses'>(</span><a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="tlist.c.html#LN39"><span class='Ref_to_Proto'>split_pathtarget_walker</span></a><span class='Delimiter'>, 
</span>                                  <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tlist.c.html#LN1029"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end split_pathtarget_walker &raquo; </span> 
</pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>