<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\parser\analyze.c</title>
<LINK REL=StyleSheet HREF="../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\parser\analyze.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:43 2017
</td></tr>
<tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
</span><span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * analyze.c 
 *    transform the raw parse tree into a query tree 
 * 
 * For optimizable statements, we are careful to obtain a suitable lock on 
 * each referenced table, and other modules of the backend preserve or 
 * re-obtain these locks before depending on the results.  It is therefore 
 * okay to do significant semantic analysis of these statements.  For 
 * utility commands, no locks are obtained here (and if they were, we could 
 * not be sure we'd still have them at execution).  Hence the general rule 
 * for utility commands is to just dump them into a Query node untransformed. 
 * DECLARE CURSOR, EXPLAIN, and CREATE TABLE AS are exceptions because they 
 * contain optimizable statements, which we should transform. 
 * 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 *  src/backend/parser/analyze.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span> 
<span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/sysattr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_type.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"miscadmin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/makefuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/nodeFuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/var.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/analyze.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_agg.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_clause.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_coerce.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_collate.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_cte.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_oper.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_param.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_relation.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_target.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parsetree.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"rewrite/rewriteManip.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/rel.h"</span> 
 
 
<span class='Comment_Multi_Line'>/* Hook for plugins to get control at end of parse analysis */ 
</span><a name="LN48"></a><a href="../../include/parser/analyze.h.html#LN19"><span class='Ref_to_Typedef'>post_parse_analyze_hook_type</span></a> <span class='Declare_Var'>post_parse_analyze_hook</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
<a name="LN50"></a><span class='Keyword'>static </span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>transformOptionalSelectInto</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>parseTree</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN51"></a><span class='Keyword'>static </span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>transformDeleteStmt</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN1432"><span class='Ref_to_Struct'>DeleteStmt</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stmt</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN52"></a><span class='Keyword'>static </span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>transformInsertStmt</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN1416"><span class='Ref_to_Struct'>InsertStmt</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stmt</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN53"></a><span class='Keyword'>static </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>transformInsertRow</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>exprlist</span><span class='Delimiter'>, 
</span><a name="LN54"></a>                   <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stmtcols</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>icolumns</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>attrnos</span><span class='Delimiter'>, 
</span><a name="LN55"></a>                   <span class='Keyword'>bool </span><span class='Declare_Parameter'>strip_indirection</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN56"></a><span class='Keyword'>static </span><a href="../../include/nodes/primnodes.h.html#LN1482"><span class='Ref_to_Struct'>OnConflictExpr</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>transformOnConflictClause</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, 
</span><a name="LN57"></a>                          <a href="../../include/nodes/parsenodes.h.html#LN1323"><span class='Ref_to_Struct'>OnConflictClause</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>onConflictClause</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN58"></a><span class='Keyword'>static int</span>  <span class='Declare_Prototype'>count_rowexpr_columns</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>expr</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN59"></a><span class='Keyword'>static </span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>transformSelectStmt</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN1478"><span class='Ref_to_Struct'>SelectStmt</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stmt</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN60"></a><span class='Keyword'>static </span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>transformValuesClause</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN1478"><span class='Ref_to_Struct'>SelectStmt</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stmt</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN61"></a><span class='Keyword'>static </span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>transformSetOperationStmt</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN1478"><span class='Ref_to_Struct'>SelectStmt</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stmt</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN62"></a><span class='Keyword'>static </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>transformSetOperationTree</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN1478"><span class='Ref_to_Struct'>SelectStmt</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stmt</span><span class='Delimiter'>, 
</span><a name="LN63"></a>                          <span class='Keyword'>bool </span><span class='Declare_Parameter'>isTopLevel</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>targetlist</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN64"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>determineRecursiveColTypes</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, 
</span><a name="LN65"></a>                           <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>larg</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>nrtargetlist</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN66"></a><span class='Keyword'>static </span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>transformUpdateStmt</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN1446"><span class='Ref_to_Struct'>UpdateStmt</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stmt</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN67"></a><span class='Keyword'>static </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>transformReturningList</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>returningList</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN68"></a><span class='Keyword'>static </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>transformUpdateTargetList</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, 
</span><a name="LN69"></a>                          <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>targetList</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN70"></a><span class='Keyword'>static </span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>transformDeclareCursorStmt</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, 
</span><a name="LN71"></a>                           <a href="../../include/nodes/parsenodes.h.html#LN2612"><span class='Ref_to_Struct'>DeclareCursorStmt</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stmt</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN72"></a><span class='Keyword'>static </span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>transformExplainStmt</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, 
</span><a name="LN73"></a>                     <a href="../../include/nodes/parsenodes.h.html#LN3088"><span class='Ref_to_Struct'>ExplainStmt</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stmt</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN74"></a><span class='Keyword'>static </span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>transformCreateTableAsStmt</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, 
</span><a name="LN75"></a>                           <a href="../../include/nodes/parsenodes.h.html#LN3108"><span class='Ref_to_Struct'>CreateTableAsStmt</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stmt</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN76"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>transformLockingClause</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>qry</span><span class='Delimiter'>, 
</span><a name="LN77"></a>                       <a href="../../include/nodes/parsenodes.h.html#LN734"><span class='Ref_to_Struct'>LockingClause</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>lc</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>pushedDown</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#ifdef</span> RAW_EXPRESSION_COVERAGE_TEST 
<a name="LN79"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>test_raw_expression_coverage</span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * parse_analyze 
 *      Analyze a raw parse tree and transform it to Query form. 
 * 
 * Optionally, information about $n parameter types can be supplied. 
 * References to $n indexes not defined by paramTypes[] are disallowed. 
 * 
 * The result is a Query node.  Optimizable statements require considerable 
 * transformation, while utility-type statements are simply hung off 
 * a dummy CMD_UTILITY Query node. 
 */ 
</span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>* 
</span><a name="LN95"></a><span class='Declare_Function'>parse_analyze</span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1396"><span class='Ref_to_Struct'>RawStmt</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>parseTree</span><span class='Delimiter'>, </span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>sourceText</span><span class='Delimiter'>, 
</span><a name="LN96"></a>              <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>paramTypes</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>numParams</span><span class='Delimiter'>, 
</span><a name="LN97"></a>              <a href="../utils/misc/queryenvironment.c.html#LN31"><span class='Ref_to_Struct'>QueryEnvironment</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>queryEnv</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN99"></a>    <a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pstate</span> <span class='Operator'>= </span><a href="parse_node.c.html#LN42"><span class='Ref_to_Func'>make_parsestate</span></a><span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN100"></a>    <a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>query</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="analyze.c.html#LN95"><span class='Ref_to_Parameter'>sourceText</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* required as of 8.4 */ 
</span> 
    <a href="analyze.c.html#LN99"><span class='Ref_To_Local'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN167"><span class='Ref_to_Member'>p_sourcetext</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN95"><span class='Ref_to_Parameter'>sourceText</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN96"><span class='Ref_to_Parameter'>numParams</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="../../include/parser/parse_param.h.html#LN17"><span class='Ref_to_Proto'>parse_fixed_parameters</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN99"><span class='Ref_To_Local'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN96"><span class='Ref_to_Parameter'>paramTypes</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN96"><span class='Ref_to_Parameter'>numParams</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="analyze.c.html#LN99"><span class='Ref_To_Local'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN191"><span class='Ref_to_Member'>p_queryEnv</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN97"><span class='Ref_to_Parameter'>queryEnv</span></a><span class='Delimiter'>; 
</span> 
    <a href="analyze.c.html#LN100"><span class='Ref_To_Local'>query</span></a> <span class='Operator'>= </span><a href="../../include/parser/analyze.h.html#LN34"><span class='Ref_to_Proto'>transformTopLevelStmt</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN99"><span class='Ref_To_Local'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN95"><span class='Ref_to_Parameter'>parseTree</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN48"><span class='Ref_to_Global_Var'>post_parse_analyze_hook</span></a><span class='Parentheses'>) 
</span>        <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="analyze.c.html#LN48"><span class='Ref_to_Global_Var'>post_parse_analyze_hook</span></a><span class='Parentheses'>) (</span><a href="analyze.c.html#LN99"><span class='Ref_To_Local'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN100"><span class='Ref_To_Local'>query</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="parse_node.c.html#LN75"><span class='Ref_to_Func'>free_parsestate</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN99"><span class='Ref_To_Local'>pstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="analyze.c.html#LN100"><span class='Ref_To_Local'>query</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end parse_analyze &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * parse_analyze_varparams 
 * 
 * This variant is used when it's okay to deduce information about $n 
 * symbol datatypes from context.  The passed-in paramTypes[] array can 
 * be modified or enlarged (via repalloc). 
 */ 
</span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>* 
</span><a name="LN129"></a><span class='Declare_Function'>parse_analyze_varparams</span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1396"><span class='Ref_to_Struct'>RawStmt</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>parseTree</span><span class='Delimiter'>, </span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>sourceText</span><span class='Delimiter'>, 
</span><a name="LN130"></a>                        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>paramTypes</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Operator'>*</span><span class='Declare_Parameter'>numParams</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN132"></a>    <a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pstate</span> <span class='Operator'>= </span><a href="parse_node.c.html#LN42"><span class='Ref_to_Func'>make_parsestate</span></a><span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN133"></a>    <a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>query</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="analyze.c.html#LN129"><span class='Ref_to_Parameter'>sourceText</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* required as of 8.4 */ 
</span> 
    <a href="analyze.c.html#LN132"><span class='Ref_To_Local'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN167"><span class='Ref_to_Member'>p_sourcetext</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN129"><span class='Ref_to_Parameter'>sourceText</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../include/parser/parse_param.h.html#LN19"><span class='Ref_to_Proto'>parse_variable_parameters</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN132"><span class='Ref_To_Local'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN130"><span class='Ref_to_Parameter'>paramTypes</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN130"><span class='Ref_to_Parameter'>numParams</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="analyze.c.html#LN133"><span class='Ref_To_Local'>query</span></a> <span class='Operator'>= </span><a href="../../include/parser/analyze.h.html#LN34"><span class='Ref_to_Proto'>transformTopLevelStmt</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN132"><span class='Ref_To_Local'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN129"><span class='Ref_to_Parameter'>parseTree</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* make sure all is well with parameter types */ 
</span>    <a href="../../include/parser/parse_param.h.html#LN21"><span class='Ref_to_Proto'>check_variable_parameters</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN132"><span class='Ref_To_Local'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN133"><span class='Ref_To_Local'>query</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN48"><span class='Ref_to_Global_Var'>post_parse_analyze_hook</span></a><span class='Parentheses'>) 
</span>        <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="analyze.c.html#LN48"><span class='Ref_to_Global_Var'>post_parse_analyze_hook</span></a><span class='Parentheses'>) (</span><a href="analyze.c.html#LN132"><span class='Ref_To_Local'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN133"><span class='Ref_To_Local'>query</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="parse_node.c.html#LN75"><span class='Ref_to_Func'>free_parsestate</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN132"><span class='Ref_To_Local'>pstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="analyze.c.html#LN133"><span class='Ref_To_Local'>query</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end parse_analyze_varparams &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * parse_sub_analyze 
 *      Entry point for recursively analyzing a sub-statement. 
 */ 
</span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>* 
</span><a name="LN159"></a><span class='Declare_Function'>parse_sub_analyze</span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>parseTree</span><span class='Delimiter'>, </span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>parentParseState</span><span class='Delimiter'>, 
</span><a name="LN160"></a>                  <a href="../../include/nodes/parsenodes.h.html#LN1339"><span class='Ref_to_Struct'>CommonTableExpr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>parentCTE</span><span class='Delimiter'>, 
</span><a name="LN161"></a>                  <span class='Keyword'>bool </span><span class='Declare_Parameter'>locked_from_parent</span><span class='Delimiter'>, 
</span><a name="LN162"></a>                  <span class='Keyword'>bool </span><span class='Declare_Parameter'>resolve_unknowns</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN164"></a>    <a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pstate</span> <span class='Operator'>= </span><a href="parse_node.c.html#LN42"><span class='Ref_to_Func'>make_parsestate</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN159"><span class='Ref_to_Parameter'>parentParseState</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN165"></a>    <a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>query</span><span class='Delimiter'>; 
</span> 
    <a href="analyze.c.html#LN164"><span class='Ref_To_Local'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN177"><span class='Ref_to_Member'>p_parent_cte</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN160"><span class='Ref_to_Parameter'>parentCTE</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN164"><span class='Ref_To_Local'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN186"><span class='Ref_to_Member'>p_locked_from_parent</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN161"><span class='Ref_to_Parameter'>locked_from_parent</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN164"><span class='Ref_To_Local'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN188"><span class='Ref_to_Member'>p_resolve_unknowns</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN162"><span class='Ref_to_Parameter'>resolve_unknowns</span></a><span class='Delimiter'>; 
</span> 
    <a href="analyze.c.html#LN165"><span class='Ref_To_Local'>query</span></a> <span class='Operator'>= </span><a href="../../include/parser/analyze.h.html#LN35"><span class='Ref_to_Proto'>transformStmt</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN164"><span class='Ref_To_Local'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN159"><span class='Ref_to_Parameter'>parseTree</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="parse_node.c.html#LN75"><span class='Ref_to_Func'>free_parsestate</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN164"><span class='Ref_To_Local'>pstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="analyze.c.html#LN165"><span class='Ref_To_Local'>query</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * transformTopLevelStmt - 
 *    transform a Parse tree into a Query tree. 
 * 
 * This function is just responsible for transferring statement location data 
 * from the RawStmt into the finished Query. 
 */ 
</span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>* 
</span><a name="LN186"></a><span class='Declare_Function'>transformTopLevelStmt</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN1396"><span class='Ref_to_Struct'>RawStmt</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>parseTree</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN188"></a>    <a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* We're at top level, so allow SELECT INTO */ 
</span>    <a href="analyze.c.html#LN188"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN50"><span class='Ref_to_Proto'>transformOptionalSelectInto</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN186"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN186"><span class='Ref_to_Parameter'>parseTree</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1399"><span class='Ref_to_Member'>stmt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="analyze.c.html#LN188"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN179"><span class='Ref_to_Member'>stmt_location</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN186"><span class='Ref_to_Parameter'>parseTree</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1400"><span class='Ref_to_Member'>stmt_location</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN188"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN180"><span class='Ref_to_Member'>stmt_len</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN186"><span class='Ref_to_Parameter'>parseTree</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1401"><span class='Ref_to_Member'>stmt_len</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="analyze.c.html#LN188"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * transformOptionalSelectInto - 
 *    If SELECT has INTO, convert it to CREATE TABLE AS. 
 * 
 * The only thing we do here that we don't do in transformStmt() is to 
 * convert SELECT ... INTO into CREATE TABLE AS.  Since utility statements 
 * aren't allowed within larger statements, this is only allowed at the top 
 * of the parse tree, and so we only try it before entering the recursive 
 * transformStmt() processing. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>* 
</span><a name="LN210"></a><span class='Declare_Function'>transformOptionalSelectInto</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>parseTree</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN210"><span class='Ref_to_Parameter'>parseTree</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN1478"><span class='Ref_to_Struct'>SelectStmt</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN214"></a>        <a href="../../include/nodes/parsenodes.h.html#LN1478"><span class='Ref_to_Struct'>SelectStmt</span></a> <span class='Operator'>*</span><span class='Declare_Local'>stmt</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1478"><span class='Ref_to_Struct'>SelectStmt</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN210"><span class='Ref_to_Parameter'>parseTree</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* If it's a set-operation tree, drill down to leftmost SelectStmt */ 
</span>        <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN214"><span class='Ref_To_Local'>stmt</span></a> <span class='Operator'>&& </span><a href="analyze.c.html#LN214"><span class='Ref_To_Local'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1518"><span class='Ref_to_Member'>op</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/parsenodes.h.html#LN1472"><span class='Ref_to_EnumConst'>SETOP_NONE</span></a><span class='Parentheses'>) 
</span>            <a href="analyze.c.html#LN214"><span class='Ref_To_Local'>stmt</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN214"><span class='Ref_To_Local'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1520"><span class='Ref_to_Member'>larg</span></a><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="analyze.c.html#LN214"><span class='Ref_To_Local'>stmt</span></a> <span class='Operator'>&& </span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN214"><span class='Ref_To_Local'>stmt</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN1478"><span class='Ref_to_Struct'>SelectStmt</span></a><span class='Parentheses'>) </span><span class='Operator'>&&</span><a href="analyze.c.html#LN214"><span class='Ref_To_Local'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1520"><span class='Ref_to_Member'>larg</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN214"><span class='Ref_To_Local'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1487"><span class='Ref_to_Member'>intoClause</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN223"></a>            <a href="../../include/nodes/parsenodes.h.html#LN3108"><span class='Ref_to_Struct'>CreateTableAsStmt</span></a> <span class='Operator'>*</span><span class='Declare_Local'>ctas</span> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN3108"><span class='Ref_to_Struct'>CreateTableAsStmt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="analyze.c.html#LN223"><span class='Ref_To_Local'>ctas</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3111"><span class='Ref_to_Member'>query</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN210"><span class='Ref_to_Parameter'>parseTree</span></a><span class='Delimiter'>; 
</span>            <a href="analyze.c.html#LN223"><span class='Ref_To_Local'>ctas</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3112"><span class='Ref_to_Member'>into</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN214"><span class='Ref_To_Local'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1487"><span class='Ref_to_Member'>intoClause</span></a><span class='Delimiter'>; 
</span>            <a href="analyze.c.html#LN223"><span class='Ref_To_Local'>ctas</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3113"><span class='Ref_to_Member'>relkind</span></a> <span class='Operator'>= </span><a href="../../include/nodes/parsenodes.h.html#LN1622"><span class='Ref_to_EnumConst'>OBJECT_TABLE</span></a><span class='Delimiter'>; 
</span>            <a href="analyze.c.html#LN223"><span class='Ref_To_Local'>ctas</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3114"><span class='Ref_to_Member'>is_select_into</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Remove the intoClause from the SelectStmt.  This makes it safe 
             * for transformSelectStmt to complain if it finds intoClause set 
             * (implying that the INTO appeared in a disallowed place). 
             */ 
</span>            <a href="analyze.c.html#LN214"><span class='Ref_To_Local'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1487"><span class='Ref_to_Member'>intoClause</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
            <a href="analyze.c.html#LN210"><span class='Ref_to_Parameter'>parseTree</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN223"><span class='Ref_To_Local'>ctas</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IsA(parseTree,SelectS... &raquo; </span> 
 
    <span class='Control'>return</span> <a href="../../include/parser/analyze.h.html#LN35"><span class='Ref_to_Proto'>transformStmt</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN210"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN210"><span class='Ref_to_Parameter'>parseTree</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end transformOptionalSelectInto &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * transformStmt - 
 *    recursively transform a Parse tree into a Query tree. 
 */ 
</span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>* 
</span><a name="LN249"></a><span class='Declare_Function'>transformStmt</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>parseTree</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN251"></a>    <a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We apply RAW_EXPRESSION_COVERAGE_TEST testing to basic DML statements; 
     * we can't just run it on everything because raw_expression_tree_walker() 
     * doesn't claim to handle utility statements. 
     */ 
</span><span class='Directive'>#ifdef</span> RAW_EXPRESSION_COVERAGE_TEST 
    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN513"><span class='Ref_to_Macro'>nodeTag</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN249"><span class='Ref_to_Parameter'>parseTree</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN308"><span class='Ref_to_EnumConst'>T_SelectStmt</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN305"><span class='Ref_to_EnumConst'>T_InsertStmt</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN307"><span class='Ref_to_EnumConst'>T_UpdateStmt</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN306"><span class='Ref_to_EnumConst'>T_DeleteStmt</span></a><span class='Operator'>: 
</span>            <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN79"><span class='Ref_to_Proto'>test_raw_expression_coverage</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN249"><span class='Ref_to_Parameter'>parseTree</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>default</span><span class='Operator'>: 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span><span class='Directive'>#endif</span>   <span class='Comment_Single_Line'>/* RAW_EXPRESSION_COVERAGE_TEST */ 
</span> 
    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN513"><span class='Ref_to_Macro'>nodeTag</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN249"><span class='Ref_to_Parameter'>parseTree</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Optimizable statements 
             */ 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN305"><span class='Ref_to_EnumConst'>T_InsertStmt</span></a><span class='Operator'>: 
</span>            <a href="analyze.c.html#LN251"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN52"><span class='Ref_to_Proto'>transformInsertStmt</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN249"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1416"><span class='Ref_to_Struct'>InsertStmt</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN249"><span class='Ref_to_Parameter'>parseTree</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN306"><span class='Ref_to_EnumConst'>T_DeleteStmt</span></a><span class='Operator'>: 
</span>            <a href="analyze.c.html#LN251"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN51"><span class='Ref_to_Proto'>transformDeleteStmt</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN249"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1432"><span class='Ref_to_Struct'>DeleteStmt</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN249"><span class='Ref_to_Parameter'>parseTree</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN307"><span class='Ref_to_EnumConst'>T_UpdateStmt</span></a><span class='Operator'>: 
</span>            <a href="analyze.c.html#LN251"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN66"><span class='Ref_to_Proto'>transformUpdateStmt</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN249"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1446"><span class='Ref_to_Struct'>UpdateStmt</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN249"><span class='Ref_to_Parameter'>parseTree</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN308"><span class='Ref_to_EnumConst'>T_SelectStmt</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span><a name="LN291"></a>                <a href="../../include/nodes/parsenodes.h.html#LN1478"><span class='Ref_to_Struct'>SelectStmt</span></a> <span class='Operator'>*</span><span class='Declare_Local'>n</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1478"><span class='Ref_to_Struct'>SelectStmt</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN249"><span class='Ref_to_Parameter'>parseTree</span></a><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN291"><span class='Ref_To_Local'>n</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1503"><span class='Ref_to_Member'>valuesLists</span></a><span class='Parentheses'>) 
</span>                    <a href="analyze.c.html#LN251"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN60"><span class='Ref_to_Proto'>transformValuesClause</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN249"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN291"><span class='Ref_To_Local'>n</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN291"><span class='Ref_To_Local'>n</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1518"><span class='Ref_to_Member'>op</span></a> <span class='Operator'>== </span><a href="../../include/nodes/parsenodes.h.html#LN1472"><span class='Ref_to_EnumConst'>SETOP_NONE</span></a><span class='Parentheses'>) 
</span>                    <a href="analyze.c.html#LN251"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN59"><span class='Ref_to_Proto'>transformSelectStmt</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN249"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN291"><span class='Ref_To_Local'>n</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>else</span> 
                    <a href="analyze.c.html#LN251"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN61"><span class='Ref_to_Proto'>transformSetOperationStmt</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN249"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN291"><span class='Ref_To_Local'>n</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Special cases 
             */ 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN369"><span class='Ref_to_EnumConst'>T_DeclareCursorStmt</span></a><span class='Operator'>: 
</span>            <a href="analyze.c.html#LN251"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN70"><span class='Ref_to_Proto'>transformDeclareCursorStmt</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN249"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                            <span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN2612"><span class='Ref_to_Struct'>DeclareCursorStmt</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN249"><span class='Ref_to_Parameter'>parseTree</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN341"><span class='Ref_to_EnumConst'>T_ExplainStmt</span></a><span class='Operator'>: 
</span>            <a href="analyze.c.html#LN251"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN72"><span class='Ref_to_Proto'>transformExplainStmt</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN249"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                          <span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN3088"><span class='Ref_to_Struct'>ExplainStmt</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN249"><span class='Ref_to_Parameter'>parseTree</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN342"><span class='Ref_to_EnumConst'>T_CreateTableAsStmt</span></a><span class='Operator'>: 
</span>            <a href="analyze.c.html#LN251"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN74"><span class='Ref_to_Proto'>transformCreateTableAsStmt</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN249"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                            <span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN3108"><span class='Ref_to_Struct'>CreateTableAsStmt</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN249"><span class='Ref_to_Parameter'>parseTree</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>default</span><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * other statements don't require any transformation; just return 
             * the original parsetree with a Query node plastered on top. 
             */ 
</span>            <a href="analyze.c.html#LN251"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="analyze.c.html#LN251"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN109"><span class='Ref_to_Member'>commandType</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN654"><span class='Ref_to_EnumConst'>CMD_UTILITY</span></a><span class='Delimiter'>; 
</span>            <a href="analyze.c.html#LN251"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN117"><span class='Ref_to_Member'>utilityStmt</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN249"><span class='Ref_to_Parameter'>parseTree</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch nodeTag(parseTree) &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Mark as original query until we learn differently */ 
</span>    <a href="analyze.c.html#LN251"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN111"><span class='Ref_to_Member'>querySource</span></a> <span class='Operator'>= </span><a href="../../include/nodes/parsenodes.h.html#LN39"><span class='Ref_to_EnumConst'>QSRC_ORIGINAL</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN251"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN115"><span class='Ref_to_Member'>canSetTag</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="analyze.c.html#LN251"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end transformStmt &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * analyze_requires_snapshot 
 *      Returns true if a snapshot must be set before doing parse analysis 
 *      on the given raw parse tree. 
 * 
 * Classification here should match transformStmt(). 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN347"></a><span class='Declare_Function'>analyze_requires_snapshot</span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1396"><span class='Ref_to_Struct'>RawStmt</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>parseTree</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN349"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN513"><span class='Ref_to_Macro'>nodeTag</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN347"><span class='Ref_to_Parameter'>parseTree</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1399"><span class='Ref_to_Member'>stmt</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Optimizable statements 
             */ 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN305"><span class='Ref_to_EnumConst'>T_InsertStmt</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN306"><span class='Ref_to_EnumConst'>T_DeleteStmt</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN307"><span class='Ref_to_EnumConst'>T_UpdateStmt</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN308"><span class='Ref_to_EnumConst'>T_SelectStmt</span></a><span class='Operator'>: 
</span>            <a href="analyze.c.html#LN349"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Special cases 
             */ 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN369"><span class='Ref_to_EnumConst'>T_DeclareCursorStmt</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN341"><span class='Ref_to_EnumConst'>T_ExplainStmt</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN342"><span class='Ref_to_EnumConst'>T_CreateTableAsStmt</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* yes, because we must analyze the contained statement */ 
</span>            <a href="analyze.c.html#LN349"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>default</span><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* other utility statements don't have any real parse analysis */ 
</span>            <a href="analyze.c.html#LN349"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch nodeTag(parseTree-&GT;st... &raquo; </span> 
 
    <span class='Control'>return</span> <a href="analyze.c.html#LN349"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end analyze_requires_snapshot &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * transformDeleteStmt - 
 *    transforms a Delete Statement 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>* 
</span><a name="LN387"></a><span class='Declare_Function'>transformDeleteStmt</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN1432"><span class='Ref_to_Struct'>DeleteStmt</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stmt</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN389"></a>    <a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>qry</span> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN390"></a>    <a href="../../include/parser/parse_node.h.html#LN239"><span class='Ref_to_Struct'>ParseNamespaceItem</span></a> <span class='Operator'>*</span><span class='Declare_Local'>nsitem</span><span class='Delimiter'>; 
</span><a name="LN391"></a>    <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>qual</span><span class='Delimiter'>; 
</span> 
    <a href="analyze.c.html#LN389"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN109"><span class='Ref_to_Member'>commandType</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN653"><span class='Ref_to_EnumConst'>CMD_DELETE</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* process the WITH clause independently of all else */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN387"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1439"><span class='Ref_to_Member'>withClause</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="analyze.c.html#LN389"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN127"><span class='Ref_to_Member'>hasRecursive</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN387"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1439"><span class='Ref_to_Member'>withClause</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1298"><span class='Ref_to_Member'>recursive</span></a><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN389"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN132"><span class='Ref_to_Member'>cteList</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_cte.h.html#LN18"><span class='Ref_to_Proto'>transformWithClause</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN387"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN387"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1439"><span class='Ref_to_Member'>withClause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN389"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN128"><span class='Ref_to_Member'>hasModifyingCTE</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN387"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN199"><span class='Ref_to_Member'>p_hasModifyingCTE</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* set up range table with just the result rel */ 
</span>    <a href="analyze.c.html#LN389"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN119"><span class='Ref_to_Member'>resultRelation</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_clause.h.html#LN19"><span class='Ref_to_Proto'>setTargetTable</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN387"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN387"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1435"><span class='Ref_to_Member'>relation</span></a><span class='Delimiter'>, 
</span>                                         <a href="analyze.c.html#LN387"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1435"><span class='Ref_to_Member'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN68"><span class='Ref_to_Member'>inh</span></a><span class='Delimiter'>, 
</span>                                         <span class='Boolean'>true</span><span class='Delimiter'>, 
</span>                                         <a href="../../include/nodes/parsenodes.h.html#LN74"><span class='Ref_to_Const'>ACL_DELETE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* grab the namespace item made by setTargetTable */ 
</span>    <a href="analyze.c.html#LN390"><span class='Ref_To_Local'>nsitem</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN239"><span class='Ref_to_Struct'>ParseNamespaceItem</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN130"><span class='Ref_to_Macro'>llast</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN387"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN172"><span class='Ref_to_Member'>p_namespace</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* there's no DISTINCT in DELETE */ 
</span>    <a href="analyze.c.html#LN389"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN153"><span class='Ref_to_Member'>distinctClause</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* subqueries in USING cannot access the result relation */ 
</span>    <a href="analyze.c.html#LN390"><span class='Ref_To_Local'>nsitem</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN244"><span class='Ref_to_Member'>p_lateral_only</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN390"><span class='Ref_To_Local'>nsitem</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN245"><span class='Ref_to_Member'>p_lateral_ok</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The USING clause is non-standard SQL syntax, and is equivalent in 
     * functionality to the FROM list that can be specified for UPDATE. The 
     * USING keyword is used rather than FROM because FROM is already a 
     * keyword in the DELETE syntax. 
     */ 
</span>    <a href="../../include/parser/parse_clause.h.html#LN18"><span class='Ref_to_Proto'>transformFromClause</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN387"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN387"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1436"><span class='Ref_to_Member'>usingClause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* remaining clauses can reference the result relation normally */ 
</span>    <a href="analyze.c.html#LN390"><span class='Ref_To_Local'>nsitem</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN244"><span class='Ref_to_Member'>p_lateral_only</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN390"><span class='Ref_To_Local'>nsitem</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN245"><span class='Ref_to_Member'>p_lateral_ok</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <a href="analyze.c.html#LN391"><span class='Ref_To_Local'>qual</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_clause.h.html#LN23"><span class='Ref_to_Proto'>transformWhereClause</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN387"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN387"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1437"><span class='Ref_to_Member'>whereClause</span></a><span class='Delimiter'>, 
</span>                                <a href="../../include/parser/parse_node.h.html#LN40"><span class='Ref_to_EnumConst'>EXPR_KIND_WHERE</span></a><span class='Delimiter'>, </span><span class='String'>"WHERE"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="analyze.c.html#LN389"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN143"><span class='Ref_to_Member'>returningList</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN67"><span class='Ref_to_Proto'>transformReturningList</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN387"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN387"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1438"><span class='Ref_to_Member'>returningList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* done building the range table and jointree */ 
</span>    <a href="analyze.c.html#LN389"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN134"><span class='Ref_to_Member'>rtable</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN387"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN389"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN135"><span class='Ref_to_Member'>jointree</span></a> <span class='Operator'>= </span><a href="../../include/nodes/makefuncs.h.html#LN47"><span class='Ref_to_Proto'>makeFromExpr</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN387"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN170"><span class='Ref_to_Member'>p_joinlist</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN391"><span class='Ref_To_Local'>qual</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="analyze.c.html#LN389"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN125"><span class='Ref_to_Member'>hasSubLinks</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN387"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN198"><span class='Ref_to_Member'>p_hasSubLinks</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN389"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN123"><span class='Ref_to_Member'>hasWindowFuncs</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN387"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN196"><span class='Ref_to_Member'>p_hasWindowFuncs</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN389"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN124"><span class='Ref_to_Member'>hasTargetSRFs</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN387"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN197"><span class='Ref_to_Member'>p_hasTargetSRFs</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN389"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN122"><span class='Ref_to_Member'>hasAggs</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN387"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN195"><span class='Ref_to_Member'>p_hasAggs</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN387"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN195"><span class='Ref_to_Member'>p_hasAggs</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/parser/parse_agg.h.html#LN26"><span class='Ref_to_Proto'>parseCheckAggregates</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN387"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN389"><span class='Ref_To_Local'>qry</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/parser/parse_collate.h.html#LN18"><span class='Ref_to_Proto'>assign_query_collations</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN387"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN389"><span class='Ref_To_Local'>qry</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="analyze.c.html#LN389"><span class='Ref_To_Local'>qry</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end transformDeleteStmt &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * transformInsertStmt - 
 *    transform an Insert Statement 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>* 
</span><a name="LN457"></a><span class='Declare_Function'>transformInsertStmt</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN1416"><span class='Ref_to_Struct'>InsertStmt</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stmt</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN459"></a>    <a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>qry</span> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN460"></a>    <a href="../../include/nodes/parsenodes.h.html#LN1478"><span class='Ref_to_Struct'>SelectStmt</span></a> <span class='Operator'>*</span><span class='Declare_Local'>selectStmt</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1478"><span class='Ref_to_Struct'>SelectStmt</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1421"><span class='Ref_to_Member'>selectStmt</span></a><span class='Delimiter'>; 
</span><a name="LN461"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>exprList</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN462"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isGeneralSelect</span><span class='Delimiter'>; 
</span><a name="LN463"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>sub_rtable</span><span class='Delimiter'>; 
</span><a name="LN464"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>sub_namespace</span><span class='Delimiter'>; 
</span><a name="LN465"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>icolumns</span><span class='Delimiter'>; 
</span><a name="LN466"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>attrnos</span><span class='Delimiter'>; 
</span><a name="LN467"></a>    <a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span><span class='Delimiter'>; 
</span><a name="LN468"></a>    <a href="../../include/nodes/primnodes.h.html#LN1415"><span class='Ref_to_Struct'>RangeTblRef</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rtr</span><span class='Delimiter'>; 
</span><a name="LN469"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>icols</span><span class='Delimiter'>; 
</span><a name="LN470"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>attnos</span><span class='Delimiter'>; 
</span><a name="LN471"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span><a name="LN472"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isOnConflictUpdate</span><span class='Delimiter'>; 
</span><a name="LN473"></a>    <a href="../../include/nodes/parsenodes.h.html#LN69"><span class='Ref_to_Typedef'>AclMode</span></a>     <span class='Declare_Local'>targetPerms</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* There can't be any outer WITH to worry about */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN175"><span class='Ref_to_Member'>p_ctenamespace</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="analyze.c.html#LN459"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN109"><span class='Ref_to_Member'>commandType</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN652"><span class='Ref_to_EnumConst'>CMD_INSERT</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN180"><span class='Ref_to_Member'>p_is_insert</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* process the WITH clause independently of all else */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1424"><span class='Ref_to_Member'>withClause</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="analyze.c.html#LN459"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN127"><span class='Ref_to_Member'>hasRecursive</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1424"><span class='Ref_to_Member'>withClause</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1298"><span class='Ref_to_Member'>recursive</span></a><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN459"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN132"><span class='Ref_to_Member'>cteList</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_cte.h.html#LN18"><span class='Ref_to_Proto'>transformWithClause</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1424"><span class='Ref_to_Member'>withClause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN459"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN128"><span class='Ref_to_Member'>hasModifyingCTE</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN199"><span class='Ref_to_Member'>p_hasModifyingCTE</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="analyze.c.html#LN459"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>override </span><span class='Operator'>= </span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>override</span><span class='Delimiter'>; 
</span> 
    <a href="analyze.c.html#LN472"><span class='Ref_To_Local'>isOnConflictUpdate</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1422"><span class='Ref_to_Member'>onConflictClause</span></a> <span class='Operator'>&& 
</span>                        <a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1422"><span class='Ref_to_Member'>onConflictClause</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1326"><span class='Ref_to_Member'>action</span></a> <span class='Operator'>== </span><a href="../../include/nodes/nodes.h.html#LN801"><span class='Ref_to_EnumConst'>ONCONFLICT_UPDATE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We have three cases to deal with: DEFAULT VALUES (selectStmt == NULL), 
     * VALUES list, or general SELECT input.  We special-case VALUES, both for 
     * efficiency and so we can handle DEFAULT specifications. 
     * 
     * The grammar allows attaching ORDER BY, LIMIT, FOR UPDATE, or WITH to a 
     * VALUES clause.  If we have any of those, treat it as a general SELECT; 
     * so it will work, but you can't use DEFAULT items together with those. 
     */ 
</span>    <a href="analyze.c.html#LN462"><span class='Ref_To_Local'>isGeneralSelect</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="analyze.c.html#LN460"><span class='Ref_To_Local'>selectStmt</span></a> <span class='Operator'>&& </span><span class='Parentheses'>(</span><a href="analyze.c.html#LN460"><span class='Ref_To_Local'>selectStmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1503"><span class='Ref_to_Member'>valuesLists</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>|| 
</span>                                      <a href="analyze.c.html#LN460"><span class='Ref_To_Local'>selectStmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1509"><span class='Ref_to_Member'>sortClause</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>|| 
</span>                                      <a href="analyze.c.html#LN460"><span class='Ref_To_Local'>selectStmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1510"><span class='Ref_to_Member'>limitOffset</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL </span><span class='Operator'>|| 
</span>                                      <a href="analyze.c.html#LN460"><span class='Ref_To_Local'>selectStmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1511"><span class='Ref_to_Member'>limitCount</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL </span><span class='Operator'>|| 
</span>                                      <a href="analyze.c.html#LN460"><span class='Ref_To_Local'>selectStmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1512"><span class='Ref_to_Member'>lockingClause</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>|| 
</span>                                      <a href="analyze.c.html#LN460"><span class='Ref_To_Local'>selectStmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1513"><span class='Ref_to_Member'>withClause</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If a non-nil rangetable/namespace was passed in, and we are doing 
     * INSERT/SELECT, arrange to pass the rangetable/namespace down to the 
     * SELECT.  This can only happen if we are inside a CREATE RULE, and in 
     * that case we want the rule's OLD and NEW rtable entries to appear as 
     * part of the SELECT's rtable, not as outer references for it.  (Kluge!) 
     * The SELECT's joinlist is not affected however.  We must do this before 
     * adding the target table to the INSERT's rtable. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN462"><span class='Ref_To_Local'>isGeneralSelect</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="analyze.c.html#LN463"><span class='Ref_To_Local'>sub_rtable</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN464"><span class='Ref_To_Local'>sub_namespace</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN172"><span class='Ref_to_Member'>p_namespace</span></a><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN172"><span class='Ref_to_Member'>p_namespace</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="analyze.c.html#LN463"><span class='Ref_To_Local'>sub_rtable</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* not used, but keep compiler quiet */ 
</span>        <a href="analyze.c.html#LN464"><span class='Ref_To_Local'>sub_namespace</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Must get write lock on INSERT target table before scanning SELECT, else 
     * we will grab the wrong kind of initial lock if the target table is also 
     * mentioned in the SELECT part.  Note that the target table is not added 
     * to the joinlist or namespace. 
     */ 
</span>    <a href="analyze.c.html#LN473"><span class='Ref_To_Local'>targetPerms</span></a> <span class='Operator'>= </span><a href="../../include/nodes/parsenodes.h.html#LN71"><span class='Ref_to_Const'>ACL_INSERT</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN472"><span class='Ref_To_Local'>isOnConflictUpdate</span></a><span class='Parentheses'>) 
</span>        <a href="analyze.c.html#LN473"><span class='Ref_To_Local'>targetPerms</span></a> <span class='Operator'>|= </span><a href="../../include/nodes/parsenodes.h.html#LN73"><span class='Ref_to_Const'>ACL_UPDATE</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN459"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN119"><span class='Ref_to_Member'>resultRelation</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_clause.h.html#LN19"><span class='Ref_to_Proto'>setTargetTable</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1419"><span class='Ref_to_Member'>relation</span></a><span class='Delimiter'>, 
</span>                                         <span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><a href="analyze.c.html#LN473"><span class='Ref_To_Local'>targetPerms</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Validate stmt-&GT;cols list, or build default list if no list given */ 
</span>    <a href="analyze.c.html#LN465"><span class='Ref_To_Local'>icolumns</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_target.h.html#LN38"><span class='Ref_to_Proto'>checkInsertTargets</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1420"><span class='Ref_to_Member'>cols</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="analyze.c.html#LN466"><span class='Ref_To_Local'>attrnos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN465"><span class='Ref_To_Local'>icolumns</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN466"><span class='Ref_To_Local'>attrnos</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Determine which variant of INSERT we have. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN460"><span class='Ref_To_Local'>selectStmt</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We have INSERT ... DEFAULT VALUES.  We can handle this case by 
         * emitting an empty targetlist --- all columns will be defaulted when 
         * the planner expands the targetlist. 
         */ 
</span>        <a href="analyze.c.html#LN461"><span class='Ref_To_Local'>exprList</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN462"><span class='Ref_To_Local'>isGeneralSelect</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We make the sub-pstate a child of the outer pstate so that it can 
         * see any Param definitions supplied from above.  Since the outer 
         * pstate's rtable and namespace are presently empty, there are no 
         * side-effects of exposing names the sub-SELECT shouldn't be able to 
         * see. 
         */ 
</span><a name="LN569"></a>        <a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sub_pstate</span> <span class='Operator'>= </span><a href="parse_node.c.html#LN42"><span class='Ref_to_Func'>make_parsestate</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN570"></a>        <a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>selectQuery</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Process the source SELECT. 
         * 
         * It is important that this be handled just like a standalone SELECT; 
         * otherwise the behavior of SELECT within INSERT might be different 
         * from a stand-alone SELECT. (Indeed, Postgres up through 6.5 had 
         * bugs of just that nature...) 
         * 
         * The sole exception is that we prevent resolving unknown-type 
         * outputs as TEXT.  This does not change the semantics since if the 
         * column type matters semantically, it would have been resolved to 
         * something else anyway.  Doing this lets us resolve such outputs as 
         * the target column's type, which we handle below. 
         */ 
</span>        <a href="analyze.c.html#LN569"><span class='Ref_To_Local'>sub_pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN463"><span class='Ref_To_Local'>sub_rtable</span></a><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN569"><span class='Ref_To_Local'>sub_pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN169"><span class='Ref_to_Member'>p_joinexprs</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* sub_rtable has no joins */ 
</span>        <a href="analyze.c.html#LN569"><span class='Ref_To_Local'>sub_pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN172"><span class='Ref_to_Member'>p_namespace</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN464"><span class='Ref_To_Local'>sub_namespace</span></a><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN569"><span class='Ref_To_Local'>sub_pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN188"><span class='Ref_to_Member'>p_resolve_unknowns</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
        <a href="analyze.c.html#LN570"><span class='Ref_To_Local'>selectQuery</span></a> <span class='Operator'>= </span><a href="../../include/parser/analyze.h.html#LN35"><span class='Ref_to_Proto'>transformStmt</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN569"><span class='Ref_To_Local'>sub_pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1421"><span class='Ref_to_Member'>selectStmt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="parse_node.c.html#LN75"><span class='Ref_to_Func'>free_parsestate</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN569"><span class='Ref_To_Local'>sub_pstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* The grammar should have produced a SELECT */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN570"><span class='Ref_To_Local'>selectQuery</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>            <a href="analyze.c.html#LN570"><span class='Ref_To_Local'>selectQuery</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN109"><span class='Ref_to_Member'>commandType</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/nodes.h.html#LN650"><span class='Ref_to_EnumConst'>CMD_SELECT</span></a><span class='Parentheses'>)</span> 
            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unexpected non-SELECT command in INSERT ... SELECT"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Make the source be a subquery in the INSERT's rangetable, and add 
         * it to the INSERT's joinlist. 
         */ 
</span>        <a href="analyze.c.html#LN467"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_relation.h.html#LN74"><span class='Ref_to_Proto'>addRangeTableEntryForSubquery</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                            <a href="analyze.c.html#LN570"><span class='Ref_To_Local'>selectQuery</span></a><span class='Delimiter'>, 
</span>                                            <a href="../../include/nodes/makefuncs.h.html#LN63"><span class='Ref_to_Proto'>makeAlias</span></a><span class='Parentheses'>(</span><span class='String'>"*SELECT*"</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                            <span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                                            <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN468"><span class='Ref_To_Local'>rtr</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN1415"><span class='Ref_to_Struct'>RangeTblRef</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* assume new rte is at end */ 
</span>        <a href="analyze.c.html#LN468"><span class='Ref_To_Local'>rtr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1418"><span class='Ref_to_Member'>rtindex</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="analyze.c.html#LN467"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>== </span><a href="../../include/parser/parsetree.h.html#LN30"><span class='Ref_to_Macro'>rt_fetch</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN468"><span class='Ref_To_Local'>rtr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1418"><span class='Ref_to_Member'>rtindex</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN170"><span class='Ref_to_Member'>p_joinlist</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN170"><span class='Ref_to_Member'>p_joinlist</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN468"><span class='Ref_To_Local'>rtr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/*---------- 
         * Generate an expression list for the INSERT that selects all the 
         * non-resjunk columns from the subquery.  (INSERT's tlist must be 
         * separate from the subquery's tlist because we may add columns, 
         * insert datatype coercions, etc.) 
         * 
         * HACK: unknown-type constants and params in the SELECT's targetlist 
         * are copied up as-is rather than being referenced as subquery 
         * outputs.  This is to ensure that when we try to coerce them to 
         * the target column's datatype, the right things happen (see 
         * special cases in coerce_type).  Otherwise, this fails: 
         *      INSERT INTO foo SELECT 'bar', ... FROM baz 
         *---------- 
         */ 
</span>        <a href="analyze.c.html#LN461"><span class='Ref_To_Local'>exprList</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>        <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN471"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN570"><span class='Ref_To_Local'>selectQuery</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN632"></a>            <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN471"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN633"></a>            <a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>expr</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN632"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1373"><span class='Ref_to_Member'>resjunk</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN632"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a> <span class='Operator'>&& 
</span>                <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN632"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>) </span><span class='Operator'>||</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN632"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN240"><span class='Ref_to_Struct'>Param</span></a><span class='Parentheses'>))</span> <span class='Operator'>&& 
</span>                <a href="../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN632"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Parentheses'>)</span> <span class='Operator'>== </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN43"><span class='Ref_to_Const'>UNKNOWNOID</span></a><span class='Parentheses'>)</span> 
                <a href="analyze.c.html#LN633"><span class='Ref_To_Local'>expr</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN632"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span><a name="LN643"></a>                <a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>var</span> <span class='Operator'>= </span><a href="../../include/nodes/makefuncs.h.html#LN32"><span class='Ref_to_Proto'>makeVarFromTargetEntry</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN468"><span class='Ref_To_Local'>rtr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1418"><span class='Ref_to_Member'>rtindex</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN632"><span class='Ref_To_Local'>tle</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="analyze.c.html#LN643"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN177"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN632"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="analyze.c.html#LN633"><span class='Ref_To_Local'>expr</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN643"><span class='Ref_To_Local'>var</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <a href="analyze.c.html#LN461"><span class='Ref_To_Local'>exprList</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN461"><span class='Ref_To_Local'>exprList</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN633"><span class='Ref_To_Local'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Prepare row for assignment to target table */ 
</span>        <a href="analyze.c.html#LN461"><span class='Ref_To_Local'>exprList</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN53"><span class='Ref_to_Proto'>transformInsertRow</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN461"><span class='Ref_To_Local'>exprList</span></a><span class='Delimiter'>, 
</span>                                      <a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1420"><span class='Ref_to_Member'>cols</span></a><span class='Delimiter'>, 
</span>                                      <a href="analyze.c.html#LN465"><span class='Ref_To_Local'>icolumns</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN466"><span class='Ref_To_Local'>attrnos</span></a><span class='Delimiter'>, 
</span>                                      <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if isGeneralSelect &raquo; </span> 
    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN460"><span class='Ref_To_Local'>selectStmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1503"><span class='Ref_to_Member'>valuesLists</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Process INSERT ... VALUES with multiple VALUES sublists. We 
         * generate a VALUES RTE holding the transformed expression lists, and 
         * build up a targetlist containing Vars that reference the VALUES 
         * RTE. 
         */ 
</span><a name="LN665"></a>        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>exprsLists</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN666"></a>        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>coltypes</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN667"></a>        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>coltypmods</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN668"></a>        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>colcollations</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN669"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>sublist_length</span> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span><a name="LN670"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>lateral</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="analyze.c.html#LN460"><span class='Ref_To_Local'>selectStmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1487"><span class='Ref_to_Member'>intoClause</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN471"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN460"><span class='Ref_To_Local'>selectStmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1503"><span class='Ref_to_Member'>valuesLists</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN676"></a>            <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>sublist</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN471"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Do basic expression transformation (same as a ROW() expr, but 
             * allow SetToDefault at top level) 
             */ 
</span>            <a href="analyze.c.html#LN676"><span class='Ref_To_Local'>sublist</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_target.h.html#LN21"><span class='Ref_to_Proto'>transformExpressionList</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN676"><span class='Ref_To_Local'>sublist</span></a><span class='Delimiter'>, 
</span>                                              <a href="../../include/parser/parse_node.h.html#LN57"><span class='Ref_to_EnumConst'>EXPR_KIND_VALUES</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * All the sublists must be the same length, *after* 
             * transformation (which might expand '*' into multiple items). 
             * The VALUES RTE can't handle anything different. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN669"><span class='Ref_To_Local'>sublist_length</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Remember post-transformation length of first sublist */ 
</span>                <a href="analyze.c.html#LN669"><span class='Ref_To_Local'>sublist_length</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN676"><span class='Ref_To_Local'>sublist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN669"><span class='Ref_To_Local'>sublist_length</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN676"><span class='Ref_To_Local'>sublist</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_SYNTAX_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"VALUES lists must all be the same length"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                            <a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN676"><span class='Ref_To_Local'>sublist</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Prepare row for assignment to target table.  We process any 
             * indirection on the target column specs normally but then strip 
             * off the resulting field/array assignment nodes, since we don't 
             * want the parsed statement to contain copies of those in each 
             * VALUES row.  (It's annoying to have to transform the 
             * indirection specs over and over like this, but avoiding it 
             * would take some really messy refactoring of 
             * transformAssignmentIndirection.) 
             */ 
</span>            <a href="analyze.c.html#LN676"><span class='Ref_To_Local'>sublist</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN53"><span class='Ref_to_Proto'>transformInsertRow</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN676"><span class='Ref_To_Local'>sublist</span></a><span class='Delimiter'>, 
</span>                                         <a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1420"><span class='Ref_to_Member'>cols</span></a><span class='Delimiter'>, 
</span>                                         <a href="analyze.c.html#LN465"><span class='Ref_To_Local'>icolumns</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN466"><span class='Ref_To_Local'>attrnos</span></a><span class='Delimiter'>, 
</span>                                         <span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * We must assign collations now because assign_query_collations 
             * doesn't process rangetable entries.  We just assign all the 
             * collations independently in each row, and don't worry about 
             * whether they are consistent vertically.  The outer INSERT query 
             * isn't going to care about the collations of the VALUES columns, 
             * so it's not worth the effort to identify a common collation for 
             * each one here.  (But note this does have one user-visible 
             * consequence: INSERT ... VALUES won't complain about conflicting 
             * explicit COLLATEs in a column, whereas the same VALUES 
             * construct in another context would complain.) 
             */ 
</span>            <a href="../../include/parser/parse_collate.h.html#LN20"><span class='Ref_to_Proto'>assign_list_collations</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN676"><span class='Ref_To_Local'>sublist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="analyze.c.html#LN665"><span class='Ref_To_Local'>exprsLists</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN665"><span class='Ref_To_Local'>exprsLists</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN676"><span class='Ref_To_Local'>sublist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Construct column type/typmod/collation lists for the VALUES RTE. 
         * Every expression in each column has been coerced to the type/typmod 
         * of the corresponding target column or subfield, so it's sufficient 
         * to look at the exprType/exprTypmod of the first row.  We don't care 
         * about the collation labeling, so just fill in InvalidOid for that. 
         */ 
</span>        <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN471"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN665"><span class='Ref_To_Local'>exprsLists</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN745"></a>            <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>val</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN471"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="analyze.c.html#LN666"><span class='Ref_To_Local'>coltypes</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN162"><span class='Ref_to_Func'>lappend_oid</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN666"><span class='Ref_To_Local'>coltypes</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN745"><span class='Ref_To_Local'>val</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="analyze.c.html#LN667"><span class='Ref_To_Local'>coltypmods</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN144"><span class='Ref_to_Func'>lappend_int</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN667"><span class='Ref_To_Local'>coltypmods</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/nodeFuncs.h.html#LN32"><span class='Ref_to_Proto'>exprTypmod</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN745"><span class='Ref_To_Local'>val</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="analyze.c.html#LN668"><span class='Ref_To_Local'>colcollations</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN162"><span class='Ref_to_Func'>lappend_oid</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN668"><span class='Ref_To_Local'>colcollations</span></a><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Ordinarily there can't be any current-level Vars in the expression 
         * lists, because the namespace was empty ... but if we're inside 
         * CREATE RULE, then NEW/OLD references might appear.  In that case we 
         * have to mark the VALUES RTE as LATERAL. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a><span class='Parentheses'>)</span> <span class='Operator'>!= </span><span class='Number'>1</span> <span class='Operator'>&& 
</span>            <a href="../../include/optimizer/var.h.html#LN34"><span class='Ref_to_Proto'>contain_vars_of_level</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN665"><span class='Ref_To_Local'>exprsLists</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>))</span> 
            <a href="analyze.c.html#LN670"><span class='Ref_To_Local'>lateral</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Generate the VALUES RTE 
         */ 
</span>        <a href="analyze.c.html#LN467"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_relation.h.html#LN86"><span class='Ref_to_Proto'>addRangeTableEntryForValues</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN665"><span class='Ref_To_Local'>exprsLists</span></a><span class='Delimiter'>, 
</span>                                          <a href="analyze.c.html#LN666"><span class='Ref_To_Local'>coltypes</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN667"><span class='Ref_To_Local'>coltypmods</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN668"><span class='Ref_To_Local'>colcollations</span></a><span class='Delimiter'>, 
</span>                                          <span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><a href="analyze.c.html#LN670"><span class='Ref_To_Local'>lateral</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN468"><span class='Ref_To_Local'>rtr</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN1415"><span class='Ref_to_Struct'>RangeTblRef</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* assume new rte is at end */ 
</span>        <a href="analyze.c.html#LN468"><span class='Ref_To_Local'>rtr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1418"><span class='Ref_to_Member'>rtindex</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="analyze.c.html#LN467"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>== </span><a href="../../include/parser/parsetree.h.html#LN30"><span class='Ref_to_Macro'>rt_fetch</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN468"><span class='Ref_To_Local'>rtr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1418"><span class='Ref_to_Member'>rtindex</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN170"><span class='Ref_to_Member'>p_joinlist</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN170"><span class='Ref_to_Member'>p_joinlist</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN468"><span class='Ref_To_Local'>rtr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Generate list of Vars referencing the RTE 
         */ 
</span>        <a href="../../include/parser/parse_relation.h.html#LN120"><span class='Ref_to_Proto'>expandRTE</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN467"><span class='Ref_To_Local'>rte</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN468"><span class='Ref_To_Local'>rtr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1418"><span class='Ref_to_Member'>rtindex</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="analyze.c.html#LN461"><span class='Ref_To_Local'>exprList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Re-apply any indirection on the target column specs to the Vars 
         */ 
</span>        <a href="analyze.c.html#LN461"><span class='Ref_To_Local'>exprList</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN53"><span class='Ref_to_Proto'>transformInsertRow</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN461"><span class='Ref_To_Local'>exprList</span></a><span class='Delimiter'>, 
</span>                                      <a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1420"><span class='Ref_to_Member'>cols</span></a><span class='Delimiter'>, 
</span>                                      <a href="analyze.c.html#LN465"><span class='Ref_To_Local'>icolumns</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN466"><span class='Ref_To_Local'>attrnos</span></a><span class='Delimiter'>, 
</span>                                      <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if list_length(selectStm... &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Process INSERT ... VALUES with a single VALUES sublist.  We treat 
         * this case separately for efficiency.  The sublist is just computed 
         * directly as the Query's targetlist, with no VALUES RTE.  So it 
         * works just like a SELECT without any FROM. 
         */ 
</span><a name="LN795"></a>        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>valuesLists</span> <span class='Operator'>= </span><a href="analyze.c.html#LN460"><span class='Ref_To_Local'>selectStmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1503"><span class='Ref_to_Member'>valuesLists</span></a><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN795"><span class='Ref_To_Local'>valuesLists</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="analyze.c.html#LN460"><span class='Ref_To_Local'>selectStmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1487"><span class='Ref_to_Member'>intoClause</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Do basic expression transformation (same as a ROW() expr, but allow 
         * SetToDefault at top level) 
         */ 
</span>        <a href="analyze.c.html#LN461"><span class='Ref_To_Local'>exprList</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_target.h.html#LN21"><span class='Ref_to_Proto'>transformExpressionList</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                           <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN795"><span class='Ref_To_Local'>valuesLists</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                           <a href="../../include/parser/parse_node.h.html#LN58"><span class='Ref_to_EnumConst'>EXPR_KIND_VALUES_SINGLE</span></a><span class='Delimiter'>, 
</span>                                           <span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Prepare row for assignment to target table */ 
</span>        <a href="analyze.c.html#LN461"><span class='Ref_To_Local'>exprList</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN53"><span class='Ref_to_Proto'>transformInsertRow</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN461"><span class='Ref_To_Local'>exprList</span></a><span class='Delimiter'>, 
</span>                                      <a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1420"><span class='Ref_to_Member'>cols</span></a><span class='Delimiter'>, 
</span>                                      <a href="analyze.c.html#LN465"><span class='Ref_To_Local'>icolumns</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN466"><span class='Ref_To_Local'>attrnos</span></a><span class='Delimiter'>, 
</span>                                      <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Generate query's target list using the computed list of expressions. 
     * Also, mark all the target columns as needing insert permissions. 
     */ 
</span>    <a href="analyze.c.html#LN467"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN179"><span class='Ref_to_Member'>p_target_rangetblentry</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN459"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN469"><span class='Ref_To_Local'>icols</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN465"><span class='Ref_To_Local'>icolumns</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN470"><span class='Ref_To_Local'>attnos</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN466"><span class='Ref_To_Local'>attrnos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN471"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN461"><span class='Ref_To_Local'>exprList</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN826"></a>        <a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN471"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN827"></a>        <a href="../../include/nodes/parsenodes.h.html#LN436"><span class='Ref_to_Struct'>ResTarget</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>col</span><span class='Delimiter'>; 
</span><a name="LN828"></a>        <a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a>  <span class='Declare_Local'>attr_num</span><span class='Delimiter'>; 
</span><a name="LN829"></a>        <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span><span class='Delimiter'>; 
</span> 
        <a href="analyze.c.html#LN827"><span class='Ref_To_Local'>col</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN108"><span class='Ref_to_Macro'>lfirst_node</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN436"><span class='Ref_to_Struct'>ResTarget</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN469"><span class='Ref_To_Local'>icols</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN828"><span class='Ref_To_Local'>attr_num</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN106"><span class='Ref_to_Macro'>lfirst_int</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN470"><span class='Ref_To_Local'>attnos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="analyze.c.html#LN829"><span class='Ref_To_Local'>tle</span></a> <span class='Operator'>= </span><a href="../../include/nodes/makefuncs.h.html#LN40"><span class='Ref_to_Proto'>makeTargetEntry</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN826"><span class='Ref_To_Local'>expr</span></a><span class='Delimiter'>, 
</span>                              <a href="analyze.c.html#LN828"><span class='Ref_To_Local'>attr_num</span></a><span class='Delimiter'>, 
</span>                              <a href="analyze.c.html#LN827"><span class='Ref_To_Local'>col</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN439"><span class='Ref_to_Member'>name</span></a><span class='Delimiter'>, 
</span>                              <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN459"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN459"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN829"><span class='Ref_To_Local'>tle</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="analyze.c.html#LN467"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1030"><span class='Ref_to_Member'>insertedCols</span></a> <span class='Operator'>= </span><a href="../../include/nodes/bitmapset.h.html#LN89"><span class='Ref_to_Proto'>bms_add_member</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN467"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1030"><span class='Ref_to_Member'>insertedCols</span></a><span class='Delimiter'>, 
</span>                              <a href="analyze.c.html#LN828"><span class='Ref_To_Local'>attr_num</span></a> <span class='Operator'>- </span><a href="../../include/access/sysattr.h.html#LN27"><span class='Ref_to_Const'>FirstLowInvalidHeapAttributeNumber</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="analyze.c.html#LN469"><span class='Ref_To_Local'>icols</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN469"><span class='Ref_To_Local'>icols</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN470"><span class='Ref_To_Local'>attnos</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN470"><span class='Ref_To_Local'>attnos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Process ON CONFLICT, if any. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1422"><span class='Ref_to_Member'>onConflictClause</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Bail out if target relation is partitioned table */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN179"><span class='Ref_to_Member'>p_target_rangetblentry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN948"><span class='Ref_to_Member'>relkind</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_class.h.html#LN167"><span class='Ref_to_Const'>RELKIND_PARTITIONED_TABLE</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"ON CONFLICT clause is not supported with partitioned tables"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <a href="analyze.c.html#LN459"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN141"><span class='Ref_to_Member'>onConflict</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN56"><span class='Ref_to_Proto'>transformOnConflictClause</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                                    <a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1422"><span class='Ref_to_Member'>onConflictClause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we have a RETURNING clause, we need to add the target relation to 
     * the query namespace before processing it, so that Var references in 
     * RETURNING will work.  Also, remove any namespace entries added in a 
     * sub-SELECT or VALUES list. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1423"><span class='Ref_to_Member'>returningList</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN172"><span class='Ref_to_Member'>p_namespace</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>        <a href="../../include/parser/parse_relation.h.html#LN114"><span class='Ref_to_Proto'>addRTEtoQuery</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN179"><span class='Ref_to_Member'>p_target_rangetblentry</span></a><span class='Delimiter'>, 
</span>                      <span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN459"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN143"><span class='Ref_to_Member'>returningList</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN67"><span class='Ref_to_Proto'>transformReturningList</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                                    <a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1423"><span class='Ref_to_Member'>returningList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* done building the range table and jointree */ 
</span>    <a href="analyze.c.html#LN459"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN134"><span class='Ref_to_Member'>rtable</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN459"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN135"><span class='Ref_to_Member'>jointree</span></a> <span class='Operator'>= </span><a href="../../include/nodes/makefuncs.h.html#LN47"><span class='Ref_to_Proto'>makeFromExpr</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN170"><span class='Ref_to_Member'>p_joinlist</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="analyze.c.html#LN459"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN124"><span class='Ref_to_Member'>hasTargetSRFs</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN197"><span class='Ref_to_Member'>p_hasTargetSRFs</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN459"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN125"><span class='Ref_to_Member'>hasSubLinks</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN198"><span class='Ref_to_Member'>p_hasSubLinks</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../include/parser/parse_collate.h.html#LN18"><span class='Ref_to_Proto'>assign_query_collations</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN457"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN459"><span class='Ref_To_Local'>qry</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="analyze.c.html#LN459"><span class='Ref_To_Local'>qry</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end transformInsertStmt &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Prepare an INSERT row for assignment to the target table. 
 * 
 * exprlist: transformed expressions for source values; these might come from 
 * a VALUES row, or be Vars referencing a sub-SELECT or VALUES RTE output. 
 * stmtcols: original target-columns spec for INSERT (we just test for NIL) 
 * icolumns: effective target-columns spec (list of ResTarget) 
 * attrnos: integer column numbers (must be same length as icolumns) 
 * strip_indirection: if true, remove any field/array assignment nodes 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN898"></a><span class='Declare_Function'>transformInsertRow</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>exprlist</span><span class='Delimiter'>, 
</span><a name="LN899"></a>                   <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stmtcols</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>icolumns</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>attrnos</span><span class='Delimiter'>, 
</span><a name="LN900"></a>                   <span class='Keyword'>bool </span><span class='Declare_Parameter'>strip_indirection</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN902"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span><a name="LN903"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span><a name="LN904"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>icols</span><span class='Delimiter'>; 
</span><a name="LN905"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>attnos</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Check length of expr list.  It must not have more expressions than 
     * there are target columns.  We allow fewer, but only if no explicit 
     * columns list was given (the remaining columns are implicitly 
     * defaulted).  Note we must check this *after* transformation because 
     * that could expand '*' into multiple items. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN898"><span class='Ref_to_Parameter'>exprlist</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT; </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN899"><span class='Ref_to_Parameter'>icolumns</span></a><span class='Parentheses'>))</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_SYNTAX_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"INSERT has more expressions than target columns"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN898"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                    <a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN223"><span class='Ref_to_Proto'>list_nth</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN898"><span class='Ref_to_Parameter'>exprlist</span></a><span class='Delimiter'>, 
</span>                                                  <a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN899"><span class='Ref_to_Parameter'>icolumns</span></a><span class='Parentheses'>))))))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN899"><span class='Ref_to_Parameter'>stmtcols</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>&& 
</span>        <a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN898"><span class='Ref_to_Parameter'>exprlist</span></a><span class='Parentheses'>) </span><span class='Operator'>&LT; </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN899"><span class='Ref_to_Parameter'>icolumns</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We can get here for cases like INSERT ... SELECT (a,b,c) FROM ... 
         * where the user accidentally created a RowExpr instead of separate 
         * columns.  Add a suitable hint if that seems to be the problem, 
         * because the main error message is quite misleading for this case. 
         * (If there's no stmtcols, you'll get something about data type 
         * mismatch, which is less misleading so we don't worry about giving a 
         * hint in that case.) 
         */ 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_SYNTAX_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"INSERT has more target columns than expressions"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <span class='Parentheses'>((</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN898"><span class='Ref_to_Parameter'>exprlist</span></a><span class='Parentheses'>)</span> <span class='Operator'>== </span><span class='Number'>1</span> <span class='Operator'>&& 
</span>                   <a href="analyze.c.html#LN58"><span class='Ref_to_Proto'>count_rowexpr_columns</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN898"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN898"><span class='Ref_to_Parameter'>exprlist</span></a><span class='Parentheses'>))</span> <span class='Operator'>== 
</span>                   <a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN899"><span class='Ref_to_Parameter'>icolumns</span></a><span class='Parentheses'>))</span> <span class='Operator'>? 
</span>                  <a href="../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"The insertion source is a row expression containing the same number of columns expected by the INSERT. Did you accidentally use extra parentheses?"</span><span class='Parentheses'>)</span> <span class='Operator'>: </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN898"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                    <a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN223"><span class='Ref_to_Proto'>list_nth</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN899"><span class='Ref_to_Parameter'>icolumns</span></a><span class='Delimiter'>, 
</span>                                                  <a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN898"><span class='Ref_to_Parameter'>exprlist</span></a><span class='Parentheses'>))))))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if stmtcols!=NIL&&list_l... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Prepare columns for assignment to target table. 
     */ 
</span>    <a href="analyze.c.html#LN902"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN904"><span class='Ref_To_Local'>icols</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN899"><span class='Ref_to_Parameter'>icolumns</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN905"><span class='Ref_To_Local'>attnos</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN899"><span class='Ref_to_Parameter'>attrnos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN903"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN898"><span class='Ref_to_Parameter'>exprlist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN953"></a>        <a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN903"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN954"></a>        <a href="../../include/nodes/parsenodes.h.html#LN436"><span class='Ref_to_Struct'>ResTarget</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>col</span><span class='Delimiter'>; 
</span> 
        <a href="analyze.c.html#LN954"><span class='Ref_To_Local'>col</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN108"><span class='Ref_to_Macro'>lfirst_node</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN436"><span class='Ref_to_Struct'>ResTarget</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN904"><span class='Ref_To_Local'>icols</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="analyze.c.html#LN953"><span class='Ref_To_Local'>expr</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_target.h.html#LN28"><span class='Ref_to_Proto'>transformAssignedExpr</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN898"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN953"><span class='Ref_To_Local'>expr</span></a><span class='Delimiter'>, 
</span>                                     <a href="../../include/parser/parse_node.h.html#LN48"><span class='Ref_to_EnumConst'>EXPR_KIND_INSERT_TARGET</span></a><span class='Delimiter'>, 
</span>                                     <a href="analyze.c.html#LN954"><span class='Ref_To_Local'>col</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN439"><span class='Ref_to_Member'>name</span></a><span class='Delimiter'>, 
</span>                                     <a href="../../include/nodes/pg_list.h.html#LN106"><span class='Ref_to_Macro'>lfirst_int</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN905"><span class='Ref_To_Local'>attnos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                     <a href="analyze.c.html#LN954"><span class='Ref_To_Local'>col</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN440"><span class='Ref_to_Member'>indirection</span></a><span class='Delimiter'>, 
</span>                                     <a href="analyze.c.html#LN954"><span class='Ref_To_Local'>col</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN442"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN900"><span class='Ref_to_Parameter'>strip_indirection</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN953"><span class='Ref_To_Local'>expr</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN953"><span class='Ref_To_Local'>expr</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN763"><span class='Ref_to_Struct'>FieldStore</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span><a name="LN971"></a>                    <a href="../../include/nodes/primnodes.h.html#LN763"><span class='Ref_to_Struct'>FieldStore</span></a> <span class='Operator'>*</span><span class='Declare_Local'>fstore</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN763"><span class='Ref_to_Struct'>FieldStore</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN953"><span class='Ref_To_Local'>expr</span></a><span class='Delimiter'>; 
</span> 
                    <a href="analyze.c.html#LN953"><span class='Ref_To_Local'>expr</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN971"><span class='Ref_To_Local'>fstore</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN767"><span class='Ref_to_Member'>newvals</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN953"><span class='Ref_To_Local'>expr</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN395"><span class='Ref_to_Struct'>ArrayRef</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span><a name="LN977"></a>                    <a href="../../include/nodes/primnodes.h.html#LN395"><span class='Ref_to_Struct'>ArrayRef</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>aref</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN395"><span class='Ref_to_Struct'>ArrayRef</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN953"><span class='Ref_To_Local'>expr</span></a><span class='Delimiter'>; 
</span> 
                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN977"><span class='Ref_To_Local'>aref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN408"><span class='Ref_to_Member'>refassgnexpr</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>                        <span class='Control'>break</span><span class='Delimiter'>; 
</span>                    <a href="analyze.c.html#LN953"><span class='Ref_To_Local'>expr</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN977"><span class='Ref_To_Local'>aref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN408"><span class='Ref_to_Member'>refassgnexpr</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>else</span> 
                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if strip_indirection &raquo; </span> 
 
        <a href="analyze.c.html#LN902"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN902"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN953"><span class='Ref_To_Local'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="analyze.c.html#LN904"><span class='Ref_To_Local'>icols</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN904"><span class='Ref_To_Local'>icols</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN905"><span class='Ref_To_Local'>attnos</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN905"><span class='Ref_To_Local'>attnos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="analyze.c.html#LN902"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end transformInsertRow &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * transformOnConflictClause - 
 *    transforms an OnConflictClause in an INSERT 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/primnodes.h.html#LN1482"><span class='Ref_to_Struct'>OnConflictExpr</span></a> <span class='Operator'>* 
</span><a name="LN1002"></a><span class='Declare_Function'>transformOnConflictClause</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, 
</span><a name="LN1003"></a>                          <a href="../../include/nodes/parsenodes.h.html#LN1323"><span class='Ref_to_Struct'>OnConflictClause</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>onConflictClause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1005"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>arbiterElems</span><span class='Delimiter'>; 
</span><a name="LN1006"></a>    <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>arbiterWhere</span><span class='Delimiter'>; 
</span><a name="LN1007"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>arbiterConstraint</span><span class='Delimiter'>; 
</span><a name="LN1008"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>onConflictSet</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN1009"></a>    <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>onConflictWhere</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN1010"></a>    <a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>exclRte</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN1011"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>exclRelIndex</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1012"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>exclRelTlist</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN1013"></a>    <a href="../../include/nodes/primnodes.h.html#LN1482"><span class='Ref_to_Struct'>OnConflictExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Process the arbiter clause, ON CONFLICT ON (...) */ 
</span>    <a href="../../include/parser/parse_clause.h.html#LN43"><span class='Ref_to_Proto'>transformOnConflictArbiter</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1002"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1003"><span class='Ref_to_Parameter'>onConflictClause</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="analyze.c.html#LN1005"><span class='Ref_To_Local'>arbiterElems</span></a><span class='Delimiter'>, 
</span>                               <span class='Operator'>&</span><a href="analyze.c.html#LN1006"><span class='Ref_To_Local'>arbiterWhere</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="analyze.c.html#LN1007"><span class='Ref_To_Local'>arbiterConstraint</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Process DO UPDATE */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1003"><span class='Ref_to_Parameter'>onConflictClause</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1326"><span class='Ref_to_Member'>action</span></a> <span class='Operator'>== </span><a href="../../include/nodes/nodes.h.html#LN801"><span class='Ref_to_EnumConst'>ONCONFLICT_UPDATE</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1022"></a>        <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>targetrel</span> <span class='Operator'>= </span><a href="analyze.c.html#LN1002"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN178"><span class='Ref_to_Member'>p_target_relation</span></a><span class='Delimiter'>; 
</span><a name="LN1023"></a>        <a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>var</span><span class='Delimiter'>; 
</span><a name="LN1024"></a>        <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>te</span><span class='Delimiter'>; 
</span><a name="LN1025"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>attno</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * All INSERT expressions have been parsed, get ready for potentially 
         * existing SET statements that need to be processed like an UPDATE. 
         */ 
</span>        <a href="analyze.c.html#LN1002"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN180"><span class='Ref_to_Member'>p_is_insert</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Add range table entry for the EXCLUDED pseudo relation; relkind is 
         * set to composite to signal that we're not dealing with an actual 
         * relation. 
         */ 
</span>        <a href="analyze.c.html#LN1010"><span class='Ref_To_Local'>exclRte</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_relation.h.html#LN69"><span class='Ref_to_Proto'>addRangeTableEntryForRelation</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1002"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                                <a href="analyze.c.html#LN1022"><span class='Ref_To_Local'>targetrel</span></a><span class='Delimiter'>, 
</span>                                                <a href="../../include/nodes/makefuncs.h.html#LN63"><span class='Ref_to_Proto'>makeAlias</span></a><span class='Parentheses'>(</span><span class='String'>"excluded"</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                <span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN1010"><span class='Ref_To_Local'>exclRte</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN948"><span class='Ref_to_Member'>relkind</span></a> <span class='Operator'>= </span><a href="../../include/catalog/pg_class.h.html#LN165"><span class='Ref_to_Const'>RELKIND_COMPOSITE_TYPE</span></a><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN1011"><span class='Ref_To_Local'>exclRelIndex</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1002"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Build a targetlist representing the columns of the EXCLUDED pseudo 
         * relation.  Have to be careful to use resnos that correspond to 
         * attnos of the underlying relation. 
         */ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1025"><span class='Ref_To_Local'>attno</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="analyze.c.html#LN1025"><span class='Ref_To_Local'>attno</span></a> <span class='Operator'>&LT; </span><a href="analyze.c.html#LN1022"><span class='Ref_To_Local'>targetrel</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relnatts<span class='Delimiter'>; </span><a href="analyze.c.html#LN1025"><span class='Ref_To_Local'>attno</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1052"></a>            <a href="../../include/catalog/pg_attribute.h.html#LN186"><span class='Ref_to_Typedef'>Form_pg_attribute</span></a> <span class='Declare_Local'>attr</span> <span class='Operator'>= </span><a href="analyze.c.html#LN1022"><span class='Ref_To_Local'>targetrel</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN114"><span class='Ref_to_Member'>rd_att</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tupdesc.h.html#LN73"><span class='Ref_to_Member'>attrs</span></a><span class='Delimiter'>[</span><a href="analyze.c.html#LN1025"><span class='Ref_To_Local'>attno</span></a><span class='Delimiter'>]; 
</span><a name="LN1053"></a>            <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>name</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1052"><span class='Ref_To_Local'>attr</span></a><span class='Operator'>-&GT;</span>attisdropped<span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * can't use atttypid here, but it doesn't really matter what 
                 * type the Const claims to be. 
                 */ 
</span>                <a href="analyze.c.html#LN1023"><span class='Ref_To_Local'>var</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/makefuncs.h.html#LN57"><span class='Ref_to_Proto'>makeNullConst</span></a><span class='Parentheses'>(</span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN24"><span class='Ref_to_Const'>INT4OID</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="analyze.c.html#LN1053"><span class='Ref_To_Local'>name</span></a> <span class='Operator'>= </span><span class='String'>""</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <a href="analyze.c.html#LN1023"><span class='Ref_To_Local'>var</span></a> <span class='Operator'>= </span><a href="../../include/nodes/makefuncs.h.html#LN25"><span class='Ref_to_Proto'>makeVar</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1011"><span class='Ref_To_Local'>exclRelIndex</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1025"><span class='Ref_To_Local'>attno</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                              <a href="analyze.c.html#LN1052"><span class='Ref_To_Local'>attr</span></a><span class='Operator'>-&GT;</span>atttypid<span class='Delimiter'>, </span><a href="analyze.c.html#LN1052"><span class='Ref_To_Local'>attr</span></a><span class='Operator'>-&GT;</span>atttypmod<span class='Delimiter'>, 
</span>                              <a href="analyze.c.html#LN1052"><span class='Ref_To_Local'>attr</span></a><span class='Operator'>-&GT;</span>attcollation<span class='Delimiter'>, 
</span>                              <span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="analyze.c.html#LN1053"><span class='Ref_To_Local'>name</span></a> <span class='Operator'>= </span><a href="../../include/common/fe_memutils.h.html#LN32"><span class='Ref_to_Proto'>pstrdup</span></a><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN498"><span class='Ref_to_Macro'>NameStr</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1052"><span class='Ref_To_Local'>attr</span></a><span class='Operator'>-&GT;</span>attname<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <a href="analyze.c.html#LN1024"><span class='Ref_To_Local'>te</span></a> <span class='Operator'>= </span><a href="../../include/nodes/makefuncs.h.html#LN40"><span class='Ref_to_Proto'>makeTargetEntry</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN1023"><span class='Ref_To_Local'>var</span></a><span class='Delimiter'>, 
</span>                                 <a href="analyze.c.html#LN1025"><span class='Ref_To_Local'>attno</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                                 <a href="analyze.c.html#LN1053"><span class='Ref_To_Local'>name</span></a><span class='Delimiter'>, 
</span>                                 <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* don't require select access yet */ 
</span>            <a href="analyze.c.html#LN1012"><span class='Ref_To_Local'>exclRelTlist</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1012"><span class='Ref_To_Local'>exclRelTlist</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1024"><span class='Ref_To_Local'>te</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for attno=0;attno&LT;targetr... &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* 
         * Add a whole-row-Var entry to support references to "EXCLUDED.*". 
         * Like the other entries in exclRelTlist, its resno must match the 
         * Var's varattno, else the wrong things happen while resolving 
         * references in setrefs.c.  This is against normal conventions for 
         * targetlists, but it's okay since we don't use this as a real tlist. 
         */ 
</span>        <a href="analyze.c.html#LN1023"><span class='Ref_To_Local'>var</span></a> <span class='Operator'>= </span><a href="../../include/nodes/makefuncs.h.html#LN25"><span class='Ref_to_Proto'>makeVar</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1011"><span class='Ref_To_Local'>exclRelIndex</span></a><span class='Delimiter'>, </span><a href="../../include/access/attnum.h.html#LN22"><span class='Ref_to_Const'>InvalidAttrNumber</span></a><span class='Delimiter'>, 
</span>                      <a href="analyze.c.html#LN1022"><span class='Ref_To_Local'>targetrel</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>reltype<span class='Delimiter'>, 
</span>                      <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN1024"><span class='Ref_To_Local'>te</span></a> <span class='Operator'>= </span><a href="../../include/nodes/makefuncs.h.html#LN40"><span class='Ref_to_Proto'>makeTargetEntry</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN1023"><span class='Ref_To_Local'>var</span></a><span class='Delimiter'>, </span><a href="../../include/access/attnum.h.html#LN22"><span class='Ref_to_Const'>InvalidAttrNumber</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN1012"><span class='Ref_To_Local'>exclRelTlist</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1012"><span class='Ref_To_Local'>exclRelTlist</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1024"><span class='Ref_To_Local'>te</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Add EXCLUDED and the target RTE to the namespace, so that they can 
         * be used in the UPDATE statement. 
         */ 
</span>        <a href="../../include/parser/parse_relation.h.html#LN114"><span class='Ref_to_Proto'>addRTEtoQuery</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1002"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1010"><span class='Ref_To_Local'>exclRte</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/parser/parse_relation.h.html#LN114"><span class='Ref_to_Proto'>addRTEtoQuery</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1002"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1002"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN179"><span class='Ref_to_Member'>p_target_rangetblentry</span></a><span class='Delimiter'>, 
</span>                      <span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="analyze.c.html#LN1008"><span class='Ref_To_Local'>onConflictSet</span></a> <span class='Operator'>= 
</span>            <a href="analyze.c.html#LN68"><span class='Ref_to_Proto'>transformUpdateTargetList</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1002"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1003"><span class='Ref_to_Parameter'>onConflictClause</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1328"><span class='Ref_to_Member'>targetList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="analyze.c.html#LN1009"><span class='Ref_To_Local'>onConflictWhere</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_clause.h.html#LN23"><span class='Ref_to_Proto'>transformWhereClause</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1002"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                               <a href="analyze.c.html#LN1003"><span class='Ref_to_Parameter'>onConflictClause</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1329"><span class='Ref_to_Member'>whereClause</span></a><span class='Delimiter'>, 
</span>                                               <a href="../../include/parser/parse_node.h.html#LN40"><span class='Ref_to_EnumConst'>EXPR_KIND_WHERE</span></a><span class='Delimiter'>, </span><span class='String'>"WHERE"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if onConflictClause-&GT;act... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Finally, build ON CONFLICT DO [NOTHING | UPDATE] expression */ 
</span>    <a href="analyze.c.html#LN1013"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN1482"><span class='Ref_to_Struct'>OnConflictExpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="analyze.c.html#LN1013"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1485"><span class='Ref_to_Member'>action</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1003"><span class='Ref_to_Parameter'>onConflictClause</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1326"><span class='Ref_to_Member'>action</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN1013"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1488"><span class='Ref_to_Member'>arbiterElems</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1005"><span class='Ref_To_Local'>arbiterElems</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN1013"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1490"><span class='Ref_to_Member'>arbiterWhere</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1006"><span class='Ref_To_Local'>arbiterWhere</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN1013"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1491"><span class='Ref_to_Member'>constraint</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1007"><span class='Ref_To_Local'>arbiterConstraint</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN1013"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1494"><span class='Ref_to_Member'>onConflictSet</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1008"><span class='Ref_To_Local'>onConflictSet</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN1013"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1495"><span class='Ref_to_Member'>onConflictWhere</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1009"><span class='Ref_To_Local'>onConflictWhere</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN1013"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1496"><span class='Ref_to_Member'>exclRelIndex</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1011"><span class='Ref_To_Local'>exclRelIndex</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN1013"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1497"><span class='Ref_to_Member'>exclRelTlist</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1012"><span class='Ref_To_Local'>exclRelTlist</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="analyze.c.html#LN1013"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end transformOnConflictClause &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * count_rowexpr_columns - 
 *    get number of columns contained in a ROW() expression; 
 *    return -1 if expression isn't a RowExpr or a Var referencing one. 
 * 
 * This is currently used only for hint purposes, so we aren't terribly 
 * tense about recognizing all possible cases.  The Var case is interesting 
 * because that's what we'll get in the INSERT ... SELECT (...) case. 
 */ 
</span><span class='Keyword'>static int 
</span><a name="LN1137"></a><span class='Declare_Function'>count_rowexpr_columns</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>expr</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1137"><span class='Ref_to_Parameter'>expr</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1137"><span class='Ref_to_Parameter'>expr</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN981"><span class='Ref_to_Struct'>RowExpr</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(((</span><a href="../../include/nodes/primnodes.h.html#LN981"><span class='Ref_to_Struct'>RowExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN1137"><span class='Ref_to_Parameter'>expr</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>args<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1137"><span class='Ref_to_Parameter'>expr</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1145"></a>        <a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>var</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN1137"><span class='Ref_to_Parameter'>expr</span></a><span class='Delimiter'>; 
</span><a name="LN1146"></a>        <a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a>  <span class='Declare_Local'>attnum</span> <span class='Operator'>= </span><a href="analyze.c.html#LN1145"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1146"><span class='Ref_To_Local'>attnum</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="analyze.c.html#LN1145"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN169"><span class='Ref_to_Member'>vartype</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN679"><span class='Ref_to_Const'>RECORDOID</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1150"></a>            <a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span><span class='Delimiter'>; 
</span> 
            <a href="analyze.c.html#LN1150"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_relation.h.html#LN50"><span class='Ref_to_Proto'>GetRTEByRangeTablePosn</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1137"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1145"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN165"><span class='Ref_to_Member'>varno</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1145"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN172"><span class='Ref_to_Member'>varlevelsup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1150"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../include/nodes/parsenodes.h.html#LN923"><span class='Ref_to_EnumConst'>RTE_SUBQUERY</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Subselect-in-FROM: examine sub-select's output expr */ 
</span><a name="LN1156"></a>                <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>ste</span> <span class='Operator'>= </span><a href="../../include/parser/parsetree.h.html#LN69"><span class='Ref_to_Proto'>get_tle_by_resno</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1150"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN954"><span class='Ref_to_Member'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Delimiter'>, 
</span>                                                    <a href="analyze.c.html#LN1146"><span class='Ref_To_Local'>attnum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1156"><span class='Ref_To_Local'>ste</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| </span><a href="analyze.c.html#LN1156"><span class='Ref_To_Local'>ste</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1373"><span class='Ref_to_Member'>resjunk</span></a><span class='Parentheses'>) 
</span>                    <span class='Control'>return</span> <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>                <a href="analyze.c.html#LN1137"><span class='Ref_to_Parameter'>expr</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN1156"><span class='Ref_To_Local'>ste</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1137"><span class='Ref_to_Parameter'>expr</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN981"><span class='Ref_to_Struct'>RowExpr</span></a><span class='Parentheses'>))</span> 
                    <span class='Control'>return</span> <a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(((</span><a href="../../include/nodes/primnodes.h.html#LN981"><span class='Ref_to_Struct'>RowExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN1137"><span class='Ref_to_Parameter'>expr</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>args<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IsA(expr,Var) &raquo; </span> 
    <span class='Control'>return</span> <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end count_rowexpr_columns &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * transformSelectStmt - 
 *    transforms a Select Statement 
 * 
 * Note: this covers only cases with no set operations and no VALUES lists; 
 * see below for the other cases. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>* 
</span><a name="LN1179"></a><span class='Declare_Function'>transformSelectStmt</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN1478"><span class='Ref_to_Struct'>SelectStmt</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stmt</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1181"></a>    <a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>qry</span> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1182"></a>    <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>qual</span><span class='Delimiter'>; 
</span><a name="LN1183"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
    <a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN109"><span class='Ref_to_Member'>commandType</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN650"><span class='Ref_to_EnumConst'>CMD_SELECT</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* process the WITH clause independently of all else */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1513"><span class='Ref_to_Member'>withClause</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN127"><span class='Ref_to_Member'>hasRecursive</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1513"><span class='Ref_to_Member'>withClause</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1298"><span class='Ref_to_Member'>recursive</span></a><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN132"><span class='Ref_to_Member'>cteList</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_cte.h.html#LN18"><span class='Ref_to_Proto'>transformWithClause</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1513"><span class='Ref_to_Member'>withClause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN128"><span class='Ref_to_Member'>hasModifyingCTE</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN199"><span class='Ref_to_Member'>p_hasModifyingCTE</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Complain if we get called from someplace where INTO is not allowed */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1487"><span class='Ref_to_Member'>intoClause</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_SYNTAX_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"SELECT ... INTO is not allowed here"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                  <a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1487"><span class='Ref_to_Member'>intoClause</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* make FOR UPDATE/FOR SHARE info available to addRangeTableEntry */ 
</span>    <a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN185"><span class='Ref_to_Member'>p_locking_clause</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1512"><span class='Ref_to_Member'>lockingClause</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* make WINDOW info available for window functions, too */ 
</span>    <a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN181"><span class='Ref_to_Member'>p_windowdefs</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1493"><span class='Ref_to_Member'>windowClause</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* process the FROM clause */ 
</span>    <a href="../../include/parser/parse_clause.h.html#LN18"><span class='Ref_to_Proto'>transformFromClause</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1489"><span class='Ref_to_Member'>fromClause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* transform targetlist */ 
</span>    <a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_target.h.html#LN19"><span class='Ref_to_Proto'>transformTargetList</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1488"><span class='Ref_to_Member'>targetList</span></a><span class='Delimiter'>, 
</span>                                          <a href="../../include/parser/parse_node.h.html#LN47"><span class='Ref_to_EnumConst'>EXPR_KIND_SELECT_TARGET</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* mark column origins */ 
</span>    <a href="../../include/parser/parse_target.h.html#LN24"><span class='Ref_to_Proto'>markTargetListOrigins</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* transform WHERE */ 
</span>    <a href="analyze.c.html#LN1182"><span class='Ref_To_Local'>qual</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_clause.h.html#LN23"><span class='Ref_to_Proto'>transformWhereClause</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1490"><span class='Ref_to_Member'>whereClause</span></a><span class='Delimiter'>, 
</span>                                <a href="../../include/parser/parse_node.h.html#LN40"><span class='Ref_to_EnumConst'>EXPR_KIND_WHERE</span></a><span class='Delimiter'>, </span><span class='String'>"WHERE"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* initial processing of HAVING clause is much like WHERE clause */ 
</span>    <a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_clause.h.html#LN23"><span class='Ref_to_Proto'>transformWhereClause</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1492"><span class='Ref_to_Member'>havingClause</span></a><span class='Delimiter'>, 
</span>                                           <a href="../../include/parser/parse_node.h.html#LN41"><span class='Ref_to_EnumConst'>EXPR_KIND_HAVING</span></a><span class='Delimiter'>, </span><span class='String'>"HAVING"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Transform sorting/grouping stuff.  Do ORDER BY first because both 
     * transformGroupClause and transformDistinctClause need the results. Note 
     * that these functions can also change the targetList, so it's passed to 
     * them by reference. 
     */ 
</span>    <a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN155"><span class='Ref_to_Member'>sortClause</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_clause.h.html#LN31"><span class='Ref_to_Proto'>transformSortClause</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                          <a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1509"><span class='Ref_to_Member'>sortClause</span></a><span class='Delimiter'>, 
</span>                                          <span class='Operator'>&</span><a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Delimiter'>, 
</span>                                          <a href="../../include/parser/parse_node.h.html#LN52"><span class='Ref_to_EnumConst'>EXPR_KIND_ORDER_BY</span></a><span class='Delimiter'>, 
</span>                                          <span class='Boolean'>false </span><span class='Comment_Multi_Line'>/* allow SQL92 rules */ </span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_clause.h.html#LN27"><span class='Ref_to_Proto'>transformGroupClause</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                            <a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1491"><span class='Ref_to_Member'>groupClause</span></a><span class='Delimiter'>, 
</span>                                            <span class='Operator'>&</span><a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN147"><span class='Ref_to_Member'>groupingSets</span></a><span class='Delimiter'>, 
</span>                                            <span class='Operator'>&</span><a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Delimiter'>, 
</span>                                            <a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN155"><span class='Ref_to_Member'>sortClause</span></a><span class='Delimiter'>, 
</span>                                            <a href="../../include/parser/parse_node.h.html#LN51"><span class='Ref_to_EnumConst'>EXPR_KIND_GROUP_BY</span></a><span class='Delimiter'>, 
</span>                                            <span class='Boolean'>false </span><span class='Comment_Multi_Line'>/* allow SQL92 rules */ </span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1485"><span class='Ref_to_Member'>distinctClause</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN153"><span class='Ref_to_Member'>distinctClause</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN126"><span class='Ref_to_Member'>hasDistinctOn</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1485"><span class='Ref_to_Member'>distinctClause</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* We had SELECT DISTINCT */ 
</span>        <a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN153"><span class='Ref_to_Member'>distinctClause</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_clause.h.html#LN39"><span class='Ref_to_Proto'>transformDistinctClause</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                                      <span class='Operator'>&</span><a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Delimiter'>, 
</span>                                                      <a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN155"><span class='Ref_to_Member'>sortClause</span></a><span class='Delimiter'>, 
</span>                                                      <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN126"><span class='Ref_to_Member'>hasDistinctOn</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* We had SELECT DISTINCT ON */ 
</span>        <a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN153"><span class='Ref_to_Member'>distinctClause</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_clause.h.html#LN41"><span class='Ref_to_Proto'>transformDistinctOnClause</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                                        <a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1485"><span class='Ref_to_Member'>distinctClause</span></a><span class='Delimiter'>, 
</span>                                                        <span class='Operator'>&</span><a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Delimiter'>, 
</span>                                                        <a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN155"><span class='Ref_to_Member'>sortClause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN126"><span class='Ref_to_Member'>hasDistinctOn</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* transform LIMIT */ 
</span>    <a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN157"><span class='Ref_to_Member'>limitOffset</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_clause.h.html#LN25"><span class='Ref_to_Proto'>transformLimitClause</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1510"><span class='Ref_to_Member'>limitOffset</span></a><span class='Delimiter'>, 
</span>                                            <a href="../../include/parser/parse_node.h.html#LN55"><span class='Ref_to_EnumConst'>EXPR_KIND_OFFSET</span></a><span class='Delimiter'>, </span><span class='String'>"OFFSET"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN158"><span class='Ref_to_Member'>limitCount</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_clause.h.html#LN25"><span class='Ref_to_Proto'>transformLimitClause</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1511"><span class='Ref_to_Member'>limitCount</span></a><span class='Delimiter'>, 
</span>                                           <a href="../../include/parser/parse_node.h.html#LN54"><span class='Ref_to_EnumConst'>EXPR_KIND_LIMIT</span></a><span class='Delimiter'>, </span><span class='String'>"LIMIT"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* transform window clauses after we have seen all window functions */ 
</span>    <a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN151"><span class='Ref_to_Member'>windowClause</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_clause.h.html#LN35"><span class='Ref_to_Proto'>transformWindowDefinitions</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                                   <a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN181"><span class='Ref_to_Member'>p_windowdefs</span></a><span class='Delimiter'>, 
</span>                                                   <span class='Operator'>&</span><a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* resolve any still-unresolved output columns as being type text */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN188"><span class='Ref_to_Member'>p_resolve_unknowns</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/parser/parse_target.h.html#LN23"><span class='Ref_to_Proto'>resolveTargetListUnknowns</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN134"><span class='Ref_to_Member'>rtable</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN135"><span class='Ref_to_Member'>jointree</span></a> <span class='Operator'>= </span><a href="../../include/nodes/makefuncs.h.html#LN47"><span class='Ref_to_Proto'>makeFromExpr</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN170"><span class='Ref_to_Member'>p_joinlist</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1182"><span class='Ref_To_Local'>qual</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN125"><span class='Ref_to_Member'>hasSubLinks</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN198"><span class='Ref_to_Member'>p_hasSubLinks</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN123"><span class='Ref_to_Member'>hasWindowFuncs</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN196"><span class='Ref_to_Member'>p_hasWindowFuncs</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN124"><span class='Ref_to_Member'>hasTargetSRFs</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN197"><span class='Ref_to_Member'>p_hasTargetSRFs</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN122"><span class='Ref_to_Member'>hasAggs</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN195"><span class='Ref_to_Member'>p_hasAggs</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN195"><span class='Ref_to_Member'>p_hasAggs</span></a> <span class='Operator'>|| </span><a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a> <span class='Operator'>|| </span><a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN147"><span class='Ref_to_Member'>groupingSets</span></a> <span class='Operator'>|| </span><a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/parser/parse_agg.h.html#LN26"><span class='Ref_to_Proto'>parseCheckAggregates</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1183"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1512"><span class='Ref_to_Member'>lockingClause</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="analyze.c.html#LN76"><span class='Ref_to_Proto'>transformLockingClause</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Delimiter'>, 
</span>                               <span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN734"><span class='Ref_to_Struct'>LockingClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1183"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../include/parser/parse_collate.h.html#LN18"><span class='Ref_to_Proto'>assign_query_collations</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1179"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="analyze.c.html#LN1181"><span class='Ref_To_Local'>qry</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end transformSelectStmt &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * transformValuesClause - 
 *    transforms a VALUES clause that's being used as a standalone SELECT 
 * 
 * We build a Query containing a VALUES RTE, rather as if one had written 
 *          SELECT * FROM (VALUES ...) AS "*VALUES*" 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>* 
</span><a name="LN1315"></a><span class='Declare_Function'>transformValuesClause</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN1478"><span class='Ref_to_Struct'>SelectStmt</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stmt</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1317"></a>    <a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>qry</span> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1318"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>exprsLists</span><span class='Delimiter'>; 
</span><a name="LN1319"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>coltypes</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN1320"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>coltypmods</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN1321"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>colcollations</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN1322"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>      <span class='Operator'>**</span><span class='Declare_Local'>colexprs</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN1323"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>sublist_length</span> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span><a name="LN1324"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>lateral</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN1325"></a>    <a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span><span class='Delimiter'>; 
</span><a name="LN1326"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>rtindex</span><span class='Delimiter'>; 
</span><a name="LN1327"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span><a name="LN1328"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc2</span><span class='Delimiter'>; 
</span><a name="LN1329"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <a href="analyze.c.html#LN1317"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN109"><span class='Ref_to_Member'>commandType</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN650"><span class='Ref_to_EnumConst'>CMD_SELECT</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Most SELECT stuff doesn't apply in a VALUES clause */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1485"><span class='Ref_to_Member'>distinctClause</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1487"><span class='Ref_to_Member'>intoClause</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1488"><span class='Ref_to_Member'>targetList</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1489"><span class='Ref_to_Member'>fromClause</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1490"><span class='Ref_to_Member'>whereClause</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1491"><span class='Ref_to_Member'>groupClause</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1492"><span class='Ref_to_Member'>havingClause</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1493"><span class='Ref_to_Member'>windowClause</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1518"><span class='Ref_to_Member'>op</span></a> <span class='Operator'>== </span><a href="../../include/nodes/parsenodes.h.html#LN1472"><span class='Ref_to_EnumConst'>SETOP_NONE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* process the WITH clause independently of all else */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1513"><span class='Ref_to_Member'>withClause</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="analyze.c.html#LN1317"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN127"><span class='Ref_to_Member'>hasRecursive</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1513"><span class='Ref_to_Member'>withClause</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1298"><span class='Ref_to_Member'>recursive</span></a><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN1317"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN132"><span class='Ref_to_Member'>cteList</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_cte.h.html#LN18"><span class='Ref_to_Proto'>transformWithClause</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1513"><span class='Ref_to_Member'>withClause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN1317"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN128"><span class='Ref_to_Member'>hasModifyingCTE</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN199"><span class='Ref_to_Member'>p_hasModifyingCTE</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * For each row of VALUES, transform the raw expressions. 
     * 
     * Note that the intermediate representation we build is column-organized 
     * not row-organized.  That simplifies the type and collation processing 
     * below. 
     */ 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1327"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1503"><span class='Ref_to_Member'>valuesLists</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1361"></a>        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>sublist</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1327"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Do basic expression transformation (same as a ROW() expr, but here 
         * we disallow SetToDefault) 
         */ 
</span>        <a href="analyze.c.html#LN1361"><span class='Ref_To_Local'>sublist</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_target.h.html#LN21"><span class='Ref_to_Proto'>transformExpressionList</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1361"><span class='Ref_To_Local'>sublist</span></a><span class='Delimiter'>, 
</span>                                          <a href="../../include/parser/parse_node.h.html#LN57"><span class='Ref_to_EnumConst'>EXPR_KIND_VALUES</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * All the sublists must be the same length, *after* transformation 
         * (which might expand '*' into multiple items).  The VALUES RTE can't 
         * handle anything different. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1323"><span class='Ref_To_Local'>sublist_length</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Remember post-transformation length of first sublist */ 
</span>            <a href="analyze.c.html#LN1323"><span class='Ref_To_Local'>sublist_length</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1361"><span class='Ref_To_Local'>sublist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* and allocate array for per-column lists */ 
</span>            <a href="analyze.c.html#LN1322"><span class='Ref_To_Local'>colexprs</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1323"><span class='Ref_To_Local'>sublist_length</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1323"><span class='Ref_To_Local'>sublist_length</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1361"><span class='Ref_To_Local'>sublist</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_SYNTAX_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"VALUES lists must all be the same length"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                        <a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN1361"><span class='Ref_To_Local'>sublist</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Build per-column expression lists */ 
</span>        <a href="analyze.c.html#LN1329"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1328"><span class='Ref_To_Local'>lc2</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1361"><span class='Ref_To_Local'>sublist</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1395"></a>            <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>col</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1328"><span class='Ref_To_Local'>lc2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="analyze.c.html#LN1322"><span class='Ref_To_Local'>colexprs</span></a><span class='Delimiter'>[</span><a href="analyze.c.html#LN1329"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1322"><span class='Ref_To_Local'>colexprs</span></a><span class='Delimiter'>[</span><a href="analyze.c.html#LN1329"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], </span><a href="analyze.c.html#LN1395"><span class='Ref_To_Local'>col</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="analyze.c.html#LN1329"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Release sub-list's cells to save memory */ 
</span>        <a href="../../include/nodes/pg_list.h.html#LN265"><span class='Ref_to_Proto'>list_free</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1361"><span class='Ref_To_Local'>sublist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now resolve the common types of the columns, and coerce everything to 
     * those types.  Then identify the common typmod and common collation, if 
     * any, of each column. 
     * 
     * We must do collation processing now because (1) assign_query_collations 
     * doesn't process rangetable entries, and (2) we need to label the VALUES 
     * RTE with column collations for use in the outer query.  We don't 
     * consider conflict of implicit collations to be an error here; instead 
     * the column will just show InvalidOid as its collation, and you'll get a 
     * failure later if that results in failure to resolve a collation. 
     * 
     * Note we modify the per-column expression lists in-place. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1329"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="analyze.c.html#LN1329"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="analyze.c.html#LN1323"><span class='Ref_To_Local'>sublist_length</span></a><span class='Delimiter'>; </span><a href="analyze.c.html#LN1329"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1421"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>coltype</span><span class='Delimiter'>; 
</span><a name="LN1422"></a>        <a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>coltypmod</span> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span><a name="LN1423"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>colcoll</span><span class='Delimiter'>; 
</span><a name="LN1424"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>first</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
        <a href="analyze.c.html#LN1421"><span class='Ref_To_Local'>coltype</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN68"><span class='Ref_to_Proto'>select_common_type</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1322"><span class='Ref_To_Local'>colexprs</span></a><span class='Delimiter'>[</span><a href="analyze.c.html#LN1329"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], </span><span class='String'>"VALUES"</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1327"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1322"><span class='Ref_To_Local'>colexprs</span></a><span class='Delimiter'>[</span><a href="analyze.c.html#LN1329"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1430"></a>            <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>col</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1327"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="analyze.c.html#LN1430"><span class='Ref_To_Local'>col</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN70"><span class='Ref_to_Proto'>coerce_to_common_type</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1430"><span class='Ref_To_Local'>col</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1421"><span class='Ref_To_Local'>coltype</span></a><span class='Delimiter'>, </span><span class='String'>"VALUES"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1327"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN1430"><span class='Ref_To_Local'>col</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1424"><span class='Ref_To_Local'>first</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="analyze.c.html#LN1422"><span class='Ref_To_Local'>coltypmod</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN32"><span class='Ref_to_Proto'>exprTypmod</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1430"><span class='Ref_To_Local'>col</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="analyze.c.html#LN1424"><span class='Ref_To_Local'>first</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* As soon as we see a non-matching typmod, fall back to -1 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1422"><span class='Ref_To_Local'>coltypmod</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="analyze.c.html#LN1422"><span class='Ref_To_Local'>coltypmod</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/nodeFuncs.h.html#LN32"><span class='Ref_to_Proto'>exprTypmod</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1430"><span class='Ref_To_Local'>col</span></a><span class='Parentheses'>))</span> 
                    <a href="analyze.c.html#LN1422"><span class='Ref_To_Local'>coltypmod</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="analyze.c.html#LN1423"><span class='Ref_To_Local'>colcoll</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_collate.h.html#LN24"><span class='Ref_to_Proto'>select_common_collation</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1322"><span class='Ref_To_Local'>colexprs</span></a><span class='Delimiter'>[</span><a href="analyze.c.html#LN1329"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="analyze.c.html#LN1319"><span class='Ref_To_Local'>coltypes</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN162"><span class='Ref_to_Func'>lappend_oid</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1319"><span class='Ref_To_Local'>coltypes</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1421"><span class='Ref_To_Local'>coltype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN1320"><span class='Ref_To_Local'>coltypmods</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN144"><span class='Ref_to_Func'>lappend_int</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1320"><span class='Ref_To_Local'>coltypmods</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1422"><span class='Ref_To_Local'>coltypmod</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN1321"><span class='Ref_To_Local'>colcollations</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN162"><span class='Ref_to_Func'>lappend_oid</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1321"><span class='Ref_To_Local'>colcollations</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1423"><span class='Ref_To_Local'>colcoll</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;sublist_length;... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Finally, rearrange the coerced expressions into row-organized lists. 
     */ 
</span>    <a href="analyze.c.html#LN1318"><span class='Ref_To_Local'>exprsLists</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1327"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1322"><span class='Ref_To_Local'>colexprs</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1460"></a>        <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>col</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1327"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1461"></a>        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>sublist</span><span class='Delimiter'>; 
</span> 
        <a href="analyze.c.html#LN1461"><span class='Ref_To_Local'>sublist</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1460"><span class='Ref_To_Local'>col</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN1318"><span class='Ref_To_Local'>exprsLists</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1318"><span class='Ref_To_Local'>exprsLists</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1461"><span class='Ref_To_Local'>sublist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../include/nodes/pg_list.h.html#LN265"><span class='Ref_to_Proto'>list_free</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1322"><span class='Ref_To_Local'>colexprs</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1329"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="analyze.c.html#LN1329"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="analyze.c.html#LN1323"><span class='Ref_To_Local'>sublist_length</span></a><span class='Delimiter'>; </span><a href="analyze.c.html#LN1329"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../include/nodes/pg_list.h.html#LN179"><span class='Ref_to_Macro'>forboth</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1327"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1322"><span class='Ref_To_Local'>colexprs</span></a><span class='Delimiter'>[</span><a href="analyze.c.html#LN1329"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], </span><a href="analyze.c.html#LN1328"><span class='Ref_To_Local'>lc2</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1318"><span class='Ref_To_Local'>exprsLists</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1471"></a>            <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>col</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1327"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1472"></a>            <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>sublist</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1328"><span class='Ref_To_Local'>lc2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* sublist pointer in exprsLists won't need adjustment */ 
</span>            <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1472"><span class='Ref_To_Local'>sublist</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1471"><span class='Ref_To_Local'>col</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="../../include/nodes/pg_list.h.html#LN265"><span class='Ref_to_Proto'>list_free</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1322"><span class='Ref_To_Local'>colexprs</span></a><span class='Delimiter'>[</span><a href="analyze.c.html#LN1329"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Ordinarily there can't be any current-level Vars in the expression 
     * lists, because the namespace was empty ... but if we're inside CREATE 
     * RULE, then NEW/OLD references might appear.  In that case we have to 
     * mark the VALUES RTE as LATERAL. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>&& 
</span>        <a href="../../include/optimizer/var.h.html#LN34"><span class='Ref_to_Proto'>contain_vars_of_level</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN1318"><span class='Ref_To_Local'>exprsLists</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>))</span> 
        <a href="analyze.c.html#LN1324"><span class='Ref_To_Local'>lateral</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Generate the VALUES RTE 
     */ 
</span>    <a href="analyze.c.html#LN1325"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_relation.h.html#LN86"><span class='Ref_to_Proto'>addRangeTableEntryForValues</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1318"><span class='Ref_To_Local'>exprsLists</span></a><span class='Delimiter'>, 
</span>                                      <a href="analyze.c.html#LN1319"><span class='Ref_To_Local'>coltypes</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1320"><span class='Ref_To_Local'>coltypmods</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1321"><span class='Ref_To_Local'>colcollations</span></a><span class='Delimiter'>, 
</span>                                      <span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><a href="analyze.c.html#LN1324"><span class='Ref_To_Local'>lateral</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/parser/parse_relation.h.html#LN114"><span class='Ref_to_Proto'>addRTEtoQuery</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1325"><span class='Ref_To_Local'>rte</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* assume new rte is at end */ 
</span>    <a href="analyze.c.html#LN1326"><span class='Ref_To_Local'>rtindex</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="analyze.c.html#LN1325"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>== </span><a href="../../include/parser/parsetree.h.html#LN30"><span class='Ref_to_Macro'>rt_fetch</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1326"><span class='Ref_To_Local'>rtindex</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Generate a targetlist as though expanding "*" 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN183"><span class='Ref_to_Member'>p_next_resno</span></a> <span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN1317"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_relation.h.html#LN123"><span class='Ref_to_Proto'>expandRelAttrs</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1325"><span class='Ref_To_Local'>rte</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1326"><span class='Ref_To_Local'>rtindex</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The grammar allows attaching ORDER BY, LIMIT, and FOR UPDATE to a 
     * VALUES, so cope. 
     */ 
</span>    <a href="analyze.c.html#LN1317"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN155"><span class='Ref_to_Member'>sortClause</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_clause.h.html#LN31"><span class='Ref_to_Proto'>transformSortClause</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                          <a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1509"><span class='Ref_to_Member'>sortClause</span></a><span class='Delimiter'>, 
</span>                                          <span class='Operator'>&</span><a href="analyze.c.html#LN1317"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Delimiter'>, 
</span>                                          <a href="../../include/parser/parse_node.h.html#LN52"><span class='Ref_to_EnumConst'>EXPR_KIND_ORDER_BY</span></a><span class='Delimiter'>, 
</span>                                          <span class='Boolean'>false </span><span class='Comment_Multi_Line'>/* allow SQL92 rules */ </span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="analyze.c.html#LN1317"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN157"><span class='Ref_to_Member'>limitOffset</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_clause.h.html#LN25"><span class='Ref_to_Proto'>transformLimitClause</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1510"><span class='Ref_to_Member'>limitOffset</span></a><span class='Delimiter'>, 
</span>                                            <a href="../../include/parser/parse_node.h.html#LN55"><span class='Ref_to_EnumConst'>EXPR_KIND_OFFSET</span></a><span class='Delimiter'>, </span><span class='String'>"OFFSET"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN1317"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN158"><span class='Ref_to_Member'>limitCount</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_clause.h.html#LN25"><span class='Ref_to_Proto'>transformLimitClause</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1511"><span class='Ref_to_Member'>limitCount</span></a><span class='Delimiter'>, 
</span>                                           <a href="../../include/parser/parse_node.h.html#LN54"><span class='Ref_to_EnumConst'>EXPR_KIND_LIMIT</span></a><span class='Delimiter'>, </span><span class='String'>"LIMIT"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1512"><span class='Ref_to_Member'>lockingClause</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>        <span class='Comment_Multi_Line'>/*------ 
          translator: %s is a SQL row locking clause such as FOR UPDATE */ 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"%s cannot be applied to VALUES"</span><span class='Delimiter'>, 
</span>                        <a href="../../include/parser/analyze.h.html#LN39"><span class='Ref_to_Proto'>LCS_asString</span></a><span class='Parentheses'>(((</span><a href="../../include/nodes/parsenodes.h.html#LN734"><span class='Ref_to_Struct'>LockingClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                                <a href="../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1512"><span class='Ref_to_Member'>lockingClause</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>strength<span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span> 
    <a href="analyze.c.html#LN1317"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN134"><span class='Ref_to_Member'>rtable</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN1317"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN135"><span class='Ref_to_Member'>jointree</span></a> <span class='Operator'>= </span><a href="../../include/nodes/makefuncs.h.html#LN47"><span class='Ref_to_Proto'>makeFromExpr</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN170"><span class='Ref_to_Member'>p_joinlist</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="analyze.c.html#LN1317"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN125"><span class='Ref_to_Member'>hasSubLinks</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN198"><span class='Ref_to_Member'>p_hasSubLinks</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../include/parser/parse_collate.h.html#LN18"><span class='Ref_to_Proto'>assign_query_collations</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1315"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1317"><span class='Ref_To_Local'>qry</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="analyze.c.html#LN1317"><span class='Ref_To_Local'>qry</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end transformValuesClause &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * transformSetOperationStmt - 
 *    transforms a set-operations tree 
 * 
 * A set-operation tree is just a SELECT, but with UNION/INTERSECT/EXCEPT 
 * structure to it.  We must transform each leaf SELECT and build up a top- 
 * level Query that contains the leaf SELECTs as subqueries in its rangetable. 
 * The tree of set operations is converted into the setOperations field of 
 * the top-level Query. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>* 
</span><a name="LN1553"></a><span class='Declare_Function'>transformSetOperationStmt</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN1478"><span class='Ref_to_Struct'>SelectStmt</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stmt</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1555"></a>    <a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>qry</span> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1556"></a>    <a href="../../include/nodes/parsenodes.h.html#LN1478"><span class='Ref_to_Struct'>SelectStmt</span></a> <span class='Operator'>*</span><span class='Declare_Local'>leftmostSelect</span><span class='Delimiter'>; 
</span><a name="LN1557"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>leftmostRTI</span><span class='Delimiter'>; 
</span><a name="LN1558"></a>    <a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>leftmostQuery</span><span class='Delimiter'>; 
</span><a name="LN1559"></a>    <a href="../../include/nodes/parsenodes.h.html#LN1545"><span class='Ref_to_Struct'>SetOperationStmt</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sostmt</span><span class='Delimiter'>; 
</span><a name="LN1560"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>sortClause</span><span class='Delimiter'>; 
</span><a name="LN1561"></a>    <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>limitOffset</span><span class='Delimiter'>; 
</span><a name="LN1562"></a>    <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>limitCount</span><span class='Delimiter'>; 
</span><a name="LN1563"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>lockingClause</span><span class='Delimiter'>; 
</span><a name="LN1564"></a>    <a href="../../include/nodes/parsenodes.h.html#LN1294"><span class='Ref_to_Struct'>WithClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>withClause</span><span class='Delimiter'>; 
</span><a name="LN1565"></a>    <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>node</span><span class='Delimiter'>; 
</span><a name="LN1566"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>left_tlist</span><span class='Delimiter'>, 
</span><a name="LN1567"></a>               <span class='Operator'>*</span><span class='Declare_Local'>lct</span><span class='Delimiter'>, 
</span><a name="LN1568"></a>               <span class='Operator'>*</span><span class='Declare_Local'>lcm</span><span class='Delimiter'>, 
</span><a name="LN1569"></a>               <span class='Operator'>*</span><span class='Declare_Local'>lcc</span><span class='Delimiter'>, 
</span><a name="LN1570"></a>               <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span><a name="LN1571"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>targetvars</span><span class='Delimiter'>, 
</span><a name="LN1572"></a>               <span class='Operator'>*</span><span class='Declare_Local'>targetnames</span><span class='Delimiter'>, 
</span><a name="LN1573"></a>               <span class='Operator'>*</span><span class='Declare_Local'>sv_namespace</span><span class='Delimiter'>; 
</span><a name="LN1574"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>sv_rtable_length</span><span class='Delimiter'>; 
</span><a name="LN1575"></a>    <a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>jrte</span><span class='Delimiter'>; 
</span><a name="LN1576"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>tllen</span><span class='Delimiter'>; 
</span> 
    <a href="analyze.c.html#LN1555"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN109"><span class='Ref_to_Member'>commandType</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN650"><span class='Ref_to_EnumConst'>CMD_SELECT</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Find leftmost leaf SelectStmt.  We currently only need to do this in 
     * order to deliver a suitable error message if there's an INTO clause 
     * there, implying the set-op tree is in a context that doesn't allow 
     * INTO.  (transformSetOperationTree would throw error anyway, but it 
     * seems worth the trouble to throw a different error for non-leftmost 
     * INTO, so we produce that error in transformSetOperationTree.) 
     */ 
</span>    <a href="analyze.c.html#LN1556"><span class='Ref_To_Local'>leftmostSelect</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1520"><span class='Ref_to_Member'>larg</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1556"><span class='Ref_To_Local'>leftmostSelect</span></a> <span class='Operator'>&& </span><a href="analyze.c.html#LN1556"><span class='Ref_To_Local'>leftmostSelect</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1518"><span class='Ref_to_Member'>op</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/parsenodes.h.html#LN1472"><span class='Ref_to_EnumConst'>SETOP_NONE</span></a><span class='Parentheses'>) 
</span>        <a href="analyze.c.html#LN1556"><span class='Ref_To_Local'>leftmostSelect</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1556"><span class='Ref_To_Local'>leftmostSelect</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1520"><span class='Ref_to_Member'>larg</span></a><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="analyze.c.html#LN1556"><span class='Ref_To_Local'>leftmostSelect</span></a> <span class='Operator'>&& </span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1556"><span class='Ref_To_Local'>leftmostSelect</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN1478"><span class='Ref_to_Struct'>SelectStmt</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>           <a href="analyze.c.html#LN1556"><span class='Ref_To_Local'>leftmostSelect</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1520"><span class='Ref_to_Member'>larg</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1556"><span class='Ref_To_Local'>leftmostSelect</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1487"><span class='Ref_to_Member'>intoClause</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_SYNTAX_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"SELECT ... INTO is not allowed here"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                        <a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN1556"><span class='Ref_To_Local'>leftmostSelect</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1487"><span class='Ref_to_Member'>intoClause</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We need to extract ORDER BY and other top-level clauses here and not 
     * let transformSetOperationTree() see them --- else it'll just recurse 
     * right back here! 
     */ 
</span>    <a href="analyze.c.html#LN1560"><span class='Ref_To_Local'>sortClause</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1509"><span class='Ref_to_Member'>sortClause</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN1561"><span class='Ref_To_Local'>limitOffset</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1510"><span class='Ref_to_Member'>limitOffset</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN1562"><span class='Ref_To_Local'>limitCount</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1511"><span class='Ref_to_Member'>limitCount</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN1563"><span class='Ref_To_Local'>lockingClause</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1512"><span class='Ref_to_Member'>lockingClause</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN1564"><span class='Ref_To_Local'>withClause</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1513"><span class='Ref_to_Member'>withClause</span></a><span class='Delimiter'>; 
</span> 
    <a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1509"><span class='Ref_to_Member'>sortClause</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1510"><span class='Ref_to_Member'>limitOffset</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1511"><span class='Ref_to_Member'>limitCount</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1512"><span class='Ref_to_Member'>lockingClause</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1513"><span class='Ref_to_Member'>withClause</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* We don't support FOR UPDATE/SHARE with set ops at the moment. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1563"><span class='Ref_To_Local'>lockingClause</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>        <span class='Comment_Multi_Line'>/*------ 
          translator: %s is a SQL row locking clause such as FOR UPDATE */ 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"%s is not allowed with UNION/INTERSECT/EXCEPT"</span><span class='Delimiter'>, 
</span>                        <a href="../../include/parser/analyze.h.html#LN39"><span class='Ref_to_Proto'>LCS_asString</span></a><span class='Parentheses'>(((</span><a href="../../include/nodes/parsenodes.h.html#LN734"><span class='Ref_to_Struct'>LockingClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                                      <a href="../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1563"><span class='Ref_To_Local'>lockingClause</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>strength<span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Process the WITH clause independently of all else */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1564"><span class='Ref_To_Local'>withClause</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="analyze.c.html#LN1555"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN127"><span class='Ref_to_Member'>hasRecursive</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1564"><span class='Ref_To_Local'>withClause</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1298"><span class='Ref_to_Member'>recursive</span></a><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN1555"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN132"><span class='Ref_to_Member'>cteList</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_cte.h.html#LN18"><span class='Ref_to_Proto'>transformWithClause</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1564"><span class='Ref_To_Local'>withClause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN1555"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN128"><span class='Ref_to_Member'>hasModifyingCTE</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN199"><span class='Ref_to_Member'>p_hasModifyingCTE</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Recursively transform the components of the tree. 
     */ 
</span>    <a href="analyze.c.html#LN1559"><span class='Ref_To_Local'>sostmt</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN575"><span class='Ref_to_Macro'>castNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1545"><span class='Ref_to_Struct'>SetOperationStmt</span></a><span class='Delimiter'>, 
</span>                      <a href="analyze.c.html#LN62"><span class='Ref_to_Proto'>transformSetOperationTree</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>stmt</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="analyze.c.html#LN1559"><span class='Ref_To_Local'>sostmt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN1555"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN162"><span class='Ref_to_Member'>setOperations</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN1559"><span class='Ref_To_Local'>sostmt</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Re-find leftmost SELECT (now it's a sub-query in rangetable) 
     */ 
</span>    <a href="analyze.c.html#LN1565"><span class='Ref_To_Local'>node</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1559"><span class='Ref_To_Local'>sostmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1550"><span class='Ref_to_Member'>larg</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1565"><span class='Ref_To_Local'>node</span></a> <span class='Operator'>&& </span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1565"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN1545"><span class='Ref_to_Struct'>SetOperationStmt</span></a><span class='Parentheses'>))</span> 
        <a href="analyze.c.html#LN1565"><span class='Ref_To_Local'>node</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/nodes/parsenodes.h.html#LN1545"><span class='Ref_to_Struct'>SetOperationStmt</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN1565"><span class='Ref_To_Local'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>larg<span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="analyze.c.html#LN1565"><span class='Ref_To_Local'>node</span></a> <span class='Operator'>&& </span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1565"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN1415"><span class='Ref_to_Struct'>RangeTblRef</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN1557"><span class='Ref_To_Local'>leftmostRTI</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN1415"><span class='Ref_to_Struct'>RangeTblRef</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN1565"><span class='Ref_To_Local'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>rtindex<span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN1558"><span class='Ref_To_Local'>leftmostQuery</span></a> <span class='Operator'>= </span><a href="../../include/parser/parsetree.h.html#LN30"><span class='Ref_to_Macro'>rt_fetch</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1557"><span class='Ref_To_Local'>leftmostRTI</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>subquery<span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="analyze.c.html#LN1558"><span class='Ref_To_Local'>leftmostQuery</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Generate dummy targetlist for outer query using column names of 
     * leftmost select and common datatypes/collations of topmost set 
     * operation.  Also make lists of the dummy vars and their names for use 
     * in parsing ORDER BY. 
     * 
     * Note: we use leftmostRTI as the varno of the dummy variables. It 
     * shouldn't matter too much which RT index they have, as long as they 
     * have one that corresponds to a real RT entry; else funny things may 
     * happen when the tree is mashed by rule rewriting. 
     */ 
</span>    <a href="analyze.c.html#LN1555"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN1571"><span class='Ref_To_Local'>targetvars</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN1572"><span class='Ref_To_Local'>targetnames</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN1566"><span class='Ref_To_Local'>left_tlist</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1558"><span class='Ref_To_Local'>leftmostQuery</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN202"><span class='Ref_to_Macro'>forthree</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1567"><span class='Ref_To_Local'>lct</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1559"><span class='Ref_To_Local'>sostmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1555"><span class='Ref_to_Member'>colTypes</span></a><span class='Delimiter'>, 
</span>             <a href="analyze.c.html#LN1568"><span class='Ref_To_Local'>lcm</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1559"><span class='Ref_To_Local'>sostmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1556"><span class='Ref_to_Member'>colTypmods</span></a><span class='Delimiter'>, 
</span>             <a href="analyze.c.html#LN1569"><span class='Ref_To_Local'>lcc</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1559"><span class='Ref_To_Local'>sostmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1557"><span class='Ref_to_Member'>colCollations</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1674"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>colType</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN107"><span class='Ref_to_Macro'>lfirst_oid</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1567"><span class='Ref_To_Local'>lct</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1675"></a>        <a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>colTypmod</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN106"><span class='Ref_to_Macro'>lfirst_int</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1568"><span class='Ref_To_Local'>lcm</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1676"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>colCollation</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN107"><span class='Ref_to_Macro'>lfirst_oid</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1569"><span class='Ref_To_Local'>lcc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1677"></a>        <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>lefttle</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1566"><span class='Ref_To_Local'>left_tlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1678"></a>        <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>colName</span><span class='Delimiter'>; 
</span><a name="LN1679"></a>        <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span><span class='Delimiter'>; 
</span><a name="LN1680"></a>        <a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>var</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="analyze.c.html#LN1677"><span class='Ref_To_Local'>lefttle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1373"><span class='Ref_to_Member'>resjunk</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN1678"><span class='Ref_To_Local'>colName</span></a> <span class='Operator'>= </span><a href="../../include/common/fe_memutils.h.html#LN32"><span class='Ref_to_Proto'>pstrdup</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1677"><span class='Ref_To_Local'>lefttle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1368"><span class='Ref_to_Member'>resname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN1680"><span class='Ref_To_Local'>var</span></a> <span class='Operator'>= </span><a href="../../include/nodes/makefuncs.h.html#LN25"><span class='Ref_to_Proto'>makeVar</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1557"><span class='Ref_To_Local'>leftmostRTI</span></a><span class='Delimiter'>, 
</span>                      <a href="analyze.c.html#LN1677"><span class='Ref_To_Local'>lefttle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1367"><span class='Ref_to_Member'>resno</span></a><span class='Delimiter'>, 
</span>                      <a href="analyze.c.html#LN1674"><span class='Ref_To_Local'>colType</span></a><span class='Delimiter'>, 
</span>                      <a href="analyze.c.html#LN1675"><span class='Ref_To_Local'>colTypmod</span></a><span class='Delimiter'>, 
</span>                      <a href="analyze.c.html#LN1676"><span class='Ref_To_Local'>colCollation</span></a><span class='Delimiter'>, 
</span>                      <span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN1680"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN177"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN1677"><span class='Ref_To_Local'>lefttle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN1679"><span class='Ref_To_Local'>tle</span></a> <span class='Operator'>= </span><a href="../../include/nodes/makefuncs.h.html#LN40"><span class='Ref_to_Proto'>makeTargetEntry</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN1680"><span class='Ref_To_Local'>var</span></a><span class='Delimiter'>, 
</span>                              <span class='Parentheses'>(</span><a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a><span class='Parentheses'>) </span><a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN183"><span class='Ref_to_Member'>p_next_resno</span></a><span class='Operator'>++</span><span class='Delimiter'>, 
</span>                              <a href="analyze.c.html#LN1678"><span class='Ref_To_Local'>colName</span></a><span class='Delimiter'>, 
</span>                              <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN1555"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1555"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1679"><span class='Ref_To_Local'>tle</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN1571"><span class='Ref_To_Local'>targetvars</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1571"><span class='Ref_To_Local'>targetvars</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1680"><span class='Ref_To_Local'>var</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN1572"><span class='Ref_To_Local'>targetnames</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1572"><span class='Ref_To_Local'>targetnames</span></a><span class='Delimiter'>, </span><a href="../nodes/value.c.html#LN51"><span class='Ref_to_Func'>makeString</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1678"><span class='Ref_To_Local'>colName</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN1566"><span class='Ref_To_Local'>left_tlist</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1566"><span class='Ref_To_Local'>left_tlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * As a first step towards supporting sort clauses that are expressions 
     * using the output columns, generate a namespace entry that makes the 
     * output columns visible.  A Join RTE node is handy for this, since we 
     * can easily control the Vars generated upon matches. 
     * 
     * Note: we don't yet do anything useful with such cases, but at least 
     * "ORDER BY upper(foo)" will draw the right error message rather than 
     * "foo not found". 
     */ 
</span>    <a href="analyze.c.html#LN1574"><span class='Ref_To_Local'>sv_rtable_length</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="analyze.c.html#LN1575"><span class='Ref_To_Local'>jrte</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_relation.h.html#LN99"><span class='Ref_to_Proto'>addRangeTableEntryForJoin</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                     <a href="analyze.c.html#LN1572"><span class='Ref_To_Local'>targetnames</span></a><span class='Delimiter'>, 
</span>                                     <a href="../../include/nodes/nodes.h.html#LN677"><span class='Ref_to_EnumConst'>JOIN_INNER</span></a><span class='Delimiter'>, 
</span>                                     <a href="analyze.c.html#LN1571"><span class='Ref_To_Local'>targetvars</span></a><span class='Delimiter'>, 
</span>                                     <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                     <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="analyze.c.html#LN1573"><span class='Ref_To_Local'>sv_namespace</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN172"><span class='Ref_to_Member'>p_namespace</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN172"><span class='Ref_to_Member'>p_namespace</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* add jrte to column namespace only */ 
</span>    <a href="../../include/parser/parse_relation.h.html#LN114"><span class='Ref_to_Proto'>addRTEtoQuery</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1575"><span class='Ref_To_Local'>jrte</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * For now, we don't support resjunk sort clauses on the output of a 
     * setOperation tree --- you can only use the SQL92-spec options of 
     * selecting an output column by name or number.  Enforce by checking that 
     * transformSortClause doesn't add any items to tlist. 
     */ 
</span>    <a href="analyze.c.html#LN1576"><span class='Ref_To_Local'>tllen</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1555"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="analyze.c.html#LN1555"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN155"><span class='Ref_to_Member'>sortClause</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_clause.h.html#LN31"><span class='Ref_to_Proto'>transformSortClause</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                          <a href="analyze.c.html#LN1560"><span class='Ref_To_Local'>sortClause</span></a><span class='Delimiter'>, 
</span>                                          <span class='Operator'>&</span><a href="analyze.c.html#LN1555"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Delimiter'>, 
</span>                                          <a href="../../include/parser/parse_node.h.html#LN52"><span class='Ref_to_EnumConst'>EXPR_KIND_ORDER_BY</span></a><span class='Delimiter'>, 
</span>                                          <span class='Boolean'>false </span><span class='Comment_Multi_Line'>/* allow SQL92 rules */ </span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* restore namespace, remove jrte from rtable */ 
</span>    <a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN172"><span class='Ref_to_Member'>p_namespace</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1573"><span class='Ref_To_Local'>sv_namespace</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN220"><span class='Ref_to_Proto'>list_truncate</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1574"><span class='Ref_To_Local'>sv_rtable_length</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1576"><span class='Ref_To_Local'>tllen</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1555"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Parentheses'>))</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"invalid UNION/INTERSECT/EXCEPT ORDER BY clause"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"Only result column names can be used, not expressions or functions."</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"Add the expression/function to every SELECT, or move the UNION into a FROM clause."</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                           <a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN223"><span class='Ref_to_Proto'>list_nth</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1555"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1576"><span class='Ref_To_Local'>tllen</span></a><span class='Parentheses'>)))))</span><span class='Delimiter'>; 
</span> 
    <a href="analyze.c.html#LN1555"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN157"><span class='Ref_to_Member'>limitOffset</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_clause.h.html#LN25"><span class='Ref_to_Proto'>transformLimitClause</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1561"><span class='Ref_To_Local'>limitOffset</span></a><span class='Delimiter'>, 
</span>                                            <a href="../../include/parser/parse_node.h.html#LN55"><span class='Ref_to_EnumConst'>EXPR_KIND_OFFSET</span></a><span class='Delimiter'>, </span><span class='String'>"OFFSET"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN1555"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN158"><span class='Ref_to_Member'>limitCount</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_clause.h.html#LN25"><span class='Ref_to_Proto'>transformLimitClause</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1562"><span class='Ref_To_Local'>limitCount</span></a><span class='Delimiter'>, 
</span>                                           <a href="../../include/parser/parse_node.h.html#LN54"><span class='Ref_to_EnumConst'>EXPR_KIND_LIMIT</span></a><span class='Delimiter'>, </span><span class='String'>"LIMIT"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="analyze.c.html#LN1555"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN134"><span class='Ref_to_Member'>rtable</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN1555"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN135"><span class='Ref_to_Member'>jointree</span></a> <span class='Operator'>= </span><a href="../../include/nodes/makefuncs.h.html#LN47"><span class='Ref_to_Proto'>makeFromExpr</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN170"><span class='Ref_to_Member'>p_joinlist</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="analyze.c.html#LN1555"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN125"><span class='Ref_to_Member'>hasSubLinks</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN198"><span class='Ref_to_Member'>p_hasSubLinks</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN1555"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN123"><span class='Ref_to_Member'>hasWindowFuncs</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN196"><span class='Ref_to_Member'>p_hasWindowFuncs</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN1555"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN124"><span class='Ref_to_Member'>hasTargetSRFs</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN197"><span class='Ref_to_Member'>p_hasTargetSRFs</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN1555"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN122"><span class='Ref_to_Member'>hasAggs</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN195"><span class='Ref_to_Member'>p_hasAggs</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN195"><span class='Ref_to_Member'>p_hasAggs</span></a> <span class='Operator'>|| </span><a href="analyze.c.html#LN1555"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a> <span class='Operator'>|| </span><a href="analyze.c.html#LN1555"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN147"><span class='Ref_to_Member'>groupingSets</span></a> <span class='Operator'>|| </span><a href="analyze.c.html#LN1555"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/parser/parse_agg.h.html#LN26"><span class='Ref_to_Proto'>parseCheckAggregates</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1555"><span class='Ref_To_Local'>qry</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1570"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1563"><span class='Ref_To_Local'>lockingClause</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="analyze.c.html#LN76"><span class='Ref_to_Proto'>transformLockingClause</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1555"><span class='Ref_To_Local'>qry</span></a><span class='Delimiter'>, 
</span>                               <span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN734"><span class='Ref_to_Struct'>LockingClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1570"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../include/parser/parse_collate.h.html#LN18"><span class='Ref_to_Proto'>assign_query_collations</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1553"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1555"><span class='Ref_To_Local'>qry</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="analyze.c.html#LN1555"><span class='Ref_To_Local'>qry</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end transformSetOperationStmt &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * transformSetOperationTree 
 *      Recursively transform leaves and internal nodes of a set-op tree 
 * 
 * In addition to returning the transformed node, if targetlist isn't NULL 
 * then we return a list of its non-resjunk TargetEntry nodes.  For a leaf 
 * set-op node these are the actual targetlist entries; otherwise they are 
 * dummy entries created to carry the type, typmod, collation, and location 
 * (for error messages) of each output column of the set-op node.  This info 
 * is needed only during the internal recursion of this function, so outside 
 * callers pass NULL for targetlist.  Note: the reason for passing the 
 * actual targetlist entries of a leaf node is so that upper levels can 
 * replace UNKNOWN Consts with properly-coerced constants. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN1794"></a><span class='Declare_Function'>transformSetOperationTree</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN1478"><span class='Ref_to_Struct'>SelectStmt</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stmt</span><span class='Delimiter'>, 
</span><a name="LN1795"></a>                          <span class='Keyword'>bool </span><span class='Declare_Parameter'>isTopLevel</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>targetlist</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1797"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isLeaf</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>stmt</span></a> <span class='Operator'>&& </span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>stmt</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN1478"><span class='Ref_to_Struct'>SelectStmt</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Guard against stack overflow due to overly complex set-expressions */ 
</span>    <a href="../../include/miscadmin.h.html#LN275"><span class='Ref_to_Proto'>check_stack_depth</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Validity-check both leaf and internal SELECTs for disallowed ops. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1487"><span class='Ref_to_Member'>intoClause</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_SYNTAX_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"INTO is only allowed on first SELECT of UNION/INTERSECT/EXCEPT"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                  <a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1487"><span class='Ref_to_Member'>intoClause</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* We don't support FOR UPDATE/SHARE with set ops at the moment. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1512"><span class='Ref_to_Member'>lockingClause</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>        <span class='Comment_Multi_Line'>/*------ 
          translator: %s is a SQL row locking clause such as FOR UPDATE */ 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"%s is not allowed with UNION/INTERSECT/EXCEPT"</span><span class='Delimiter'>, 
</span>                        <a href="../../include/parser/analyze.h.html#LN39"><span class='Ref_to_Proto'>LCS_asString</span></a><span class='Parentheses'>(((</span><a href="../../include/nodes/parsenodes.h.html#LN734"><span class='Ref_to_Struct'>LockingClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                                <a href="../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1512"><span class='Ref_to_Member'>lockingClause</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>strength<span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If an internal node of a set-op tree has ORDER BY, LIMIT, FOR UPDATE, 
     * or WITH clauses attached, we need to treat it like a leaf node to 
     * generate an independent sub-Query tree.  Otherwise, it can be 
     * represented by a SetOperationStmt node underneath the parent Query. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1518"><span class='Ref_to_Member'>op</span></a> <span class='Operator'>== </span><a href="../../include/nodes/parsenodes.h.html#LN1472"><span class='Ref_to_EnumConst'>SETOP_NONE</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1520"><span class='Ref_to_Member'>larg</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>&& </span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1521"><span class='Ref_to_Member'>rarg</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN1797"><span class='Ref_To_Local'>isLeaf</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1520"><span class='Ref_to_Member'>larg</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL </span><span class='Operator'>&& </span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1521"><span class='Ref_to_Member'>rarg</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1509"><span class='Ref_to_Member'>sortClause</span></a> <span class='Operator'>|| </span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1510"><span class='Ref_to_Member'>limitOffset</span></a> <span class='Operator'>|| </span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1511"><span class='Ref_to_Member'>limitCount</span></a> <span class='Operator'>|| 
</span>            <a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1512"><span class='Ref_to_Member'>lockingClause</span></a> <span class='Operator'>|| </span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1513"><span class='Ref_to_Member'>withClause</span></a><span class='Parentheses'>) 
</span>            <a href="analyze.c.html#LN1797"><span class='Ref_To_Local'>isLeaf</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="analyze.c.html#LN1797"><span class='Ref_To_Local'>isLeaf</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1797"><span class='Ref_To_Local'>isLeaf</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Process leaf SELECT */ 
</span><a name="LN1848"></a>        <a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>selectQuery</span><span class='Delimiter'>; 
</span><a name="LN1849"></a>        <span class='Keyword'>char</span>        <span class='Declare_Local'>selectName</span><span class='Delimiter'>[</span><span class='Number'>32</span><span class='Delimiter'>]; 
</span><a name="LN1850"></a>        <a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span>rte <span class='Declare_Local'>PG_USED_FOR_ASSERTS_ONLY</span><span class='Delimiter'>; 
</span><a name="LN1851"></a>        <a href="../../include/nodes/primnodes.h.html#LN1415"><span class='Ref_to_Struct'>RangeTblRef</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rtr</span><span class='Delimiter'>; 
</span><a name="LN1852"></a>        <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>tl</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Transform SelectStmt into a Query. 
         * 
         * This works the same as SELECT transformation normally would, except 
         * that we prevent resolving unknown-type outputs as TEXT.  This does 
         * not change the subquery's semantics since if the column type 
         * matters semantically, it would have been resolved to something else 
         * anyway.  Doing this lets us resolve such outputs using 
         * select_common_type(), below. 
         * 
         * Note: previously transformed sub-queries don't affect the parsing 
         * of this sub-query, because they are not in the toplevel pstate's 
         * namespace list. 
         */ 
</span>        <a href="analyze.c.html#LN1848"><span class='Ref_To_Local'>selectQuery</span></a> <span class='Operator'>= </span><a href="../../include/parser/analyze.h.html#LN29"><span class='Ref_to_Proto'>parse_sub_analyze</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>stmt</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                        <span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Check for bogus references to Vars on the current query level (but 
         * upper-level references are okay). Normally this can't happen 
         * because the namespace will be empty, but it could happen if we are 
         * inside a rule. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN172"><span class='Ref_to_Member'>p_namespace</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/optimizer/var.h.html#LN34"><span class='Ref_to_Proto'>contain_vars_of_level</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN1848"><span class='Ref_To_Local'>selectQuery</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Parentheses'>))</span> 
                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_COLUMN_REFERENCE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"UNION/INTERSECT/EXCEPT member statement cannot refer to other relations of same query level"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                             <a href="../../include/optimizer/var.h.html#LN35"><span class='Ref_to_Proto'>locate_var_of_level</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN1848"><span class='Ref_To_Local'>selectQuery</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Extract a list of the non-junk TLEs for upper-level processing. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1795"><span class='Ref_to_Parameter'>targetlist</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Operator'>*</span><a href="analyze.c.html#LN1795"><span class='Ref_to_Parameter'>targetlist</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>            <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1852"><span class='Ref_To_Local'>tl</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1848"><span class='Ref_To_Local'>selectQuery</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN1895"></a>                <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1852"><span class='Ref_To_Local'>tl</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="analyze.c.html#LN1895"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1373"><span class='Ref_to_Member'>resjunk</span></a><span class='Parentheses'>) 
</span>                    <span class='Operator'>*</span><a href="analyze.c.html#LN1795"><span class='Ref_to_Parameter'>targetlist</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="analyze.c.html#LN1795"><span class='Ref_to_Parameter'>targetlist</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1895"><span class='Ref_To_Local'>tle</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Make the leaf query be a subquery in the top-level rangetable. 
         */ 
</span>        <a href="../../pl/plperl/plperl.h.html#LN60"><span class='Ref_to_Macro'>snprintf</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1849"><span class='Ref_To_Local'>selectName</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="analyze.c.html#LN1849"><span class='Ref_To_Local'>selectName</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='String'>"*SELECT* %d"</span><span class='Delimiter'>, 
</span>                 <a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a><span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        rte <span class='Operator'>= </span><a href="../../include/parser/parse_relation.h.html#LN74"><span class='Ref_to_Proto'>addRangeTableEntryForSubquery</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                            <a href="analyze.c.html#LN1848"><span class='Ref_To_Local'>selectQuery</span></a><span class='Delimiter'>, 
</span>                                            <a href="../../include/nodes/makefuncs.h.html#LN63"><span class='Ref_to_Proto'>makeAlias</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1849"><span class='Ref_To_Local'>selectName</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                            <span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                                            <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Return a RangeTblRef to replace the SelectStmt in the set-op tree. 
         */ 
</span>        <a href="analyze.c.html#LN1851"><span class='Ref_To_Local'>rtr</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN1415"><span class='Ref_to_Struct'>RangeTblRef</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* assume new rte is at end */ 
</span>        <a href="analyze.c.html#LN1851"><span class='Ref_To_Local'>rtr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1418"><span class='Ref_to_Member'>rtindex</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span>rte <span class='Operator'>== </span><a href="../../include/parser/parsetree.h.html#LN30"><span class='Ref_to_Macro'>rt_fetch</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1851"><span class='Ref_To_Local'>rtr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1418"><span class='Ref_to_Member'>rtindex</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN1851"><span class='Ref_To_Local'>rtr</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if isLeaf &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Process an internal node (set operation node) */ 
</span><a name="LN1925"></a>        <a href="../../include/nodes/parsenodes.h.html#LN1545"><span class='Ref_to_Struct'>SetOperationStmt</span></a> <span class='Operator'>*</span><span class='Declare_Local'>op</span> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1545"><span class='Ref_to_Struct'>SetOperationStmt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1926"></a>        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>ltargetlist</span><span class='Delimiter'>; 
</span><a name="LN1927"></a>        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>rtargetlist</span><span class='Delimiter'>; 
</span><a name="LN1928"></a>        <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>ltl</span><span class='Delimiter'>; 
</span><a name="LN1929"></a>        <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>rtl</span><span class='Delimiter'>; 
</span><a name="LN1930"></a>        <span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Local'>context</span><span class='Delimiter'>; 
</span> 
        <a href="analyze.c.html#LN1930"><span class='Ref_To_Local'>context</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1518"><span class='Ref_to_Member'>op</span></a> <span class='Operator'>== </span><a href="../../include/nodes/parsenodes.h.html#LN1473"><span class='Ref_to_EnumConst'>SETOP_UNION</span></a> <span class='Operator'>? </span><span class='String'>"UNION"</span> <span class='Operator'>: 
</span>                   <span class='Parentheses'>(</span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1518"><span class='Ref_to_Member'>op</span></a> <span class='Operator'>== </span><a href="../../include/nodes/parsenodes.h.html#LN1474"><span class='Ref_to_EnumConst'>SETOP_INTERSECT</span></a> <span class='Operator'>? </span><span class='String'>"INTERSECT"</span> <span class='Operator'>: 
</span>                    <span class='String'>"EXCEPT"</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <a href="analyze.c.html#LN1925"><span class='Ref_To_Local'>op</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1548"><span class='Ref_to_Member'>op</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1518"><span class='Ref_to_Member'>op</span></a><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN1925"><span class='Ref_To_Local'>op</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1549"><span class='Ref_to_Member'>all</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1519"><span class='Ref_to_Member'>all</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Recursively transform the left child node. 
         */ 
</span>        <a href="analyze.c.html#LN1925"><span class='Ref_To_Local'>op</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1550"><span class='Ref_to_Member'>larg</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN62"><span class='Ref_to_Proto'>transformSetOperationTree</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1520"><span class='Ref_to_Member'>larg</span></a><span class='Delimiter'>, 
</span>                                             <span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                                             <span class='Operator'>&</span><a href="analyze.c.html#LN1926"><span class='Ref_To_Local'>ltargetlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If we are processing a recursive union query, now is the time to 
         * examine the non-recursive term's output columns and mark the 
         * containing CTE as having those result columns.  We should do this 
         * only at the topmost setop of the CTE, of course. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1795"><span class='Ref_to_Parameter'>isTopLevel</span></a> <span class='Operator'>&& 
</span>            <a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN177"><span class='Ref_to_Member'>p_parent_cte</span></a> <span class='Operator'>&& 
</span>            <a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN177"><span class='Ref_to_Member'>p_parent_cte</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1348"><span class='Ref_to_Member'>cterecursive</span></a><span class='Parentheses'>) 
</span>            <a href="analyze.c.html#LN64"><span class='Ref_to_Proto'>determineRecursiveColTypes</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1925"><span class='Ref_To_Local'>op</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1550"><span class='Ref_to_Member'>larg</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1926"><span class='Ref_To_Local'>ltargetlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Recursively transform the right child node. 
         */ 
</span>        <a href="analyze.c.html#LN1925"><span class='Ref_To_Local'>op</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1551"><span class='Ref_to_Member'>rarg</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN62"><span class='Ref_to_Proto'>transformSetOperationTree</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1521"><span class='Ref_to_Member'>rarg</span></a><span class='Delimiter'>, 
</span>                                             <span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                                             <span class='Operator'>&</span><a href="analyze.c.html#LN1927"><span class='Ref_To_Local'>rtargetlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Verify that the two children have the same number of non-junk 
         * columns, and determine the types of the merged output columns. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1926"><span class='Ref_To_Local'>ltargetlist</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1927"><span class='Ref_To_Local'>rtargetlist</span></a><span class='Parentheses'>))</span> 
            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_SYNTAX_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"each %s query must have the same number of columns"</span><span class='Delimiter'>, 
</span>                        <a href="analyze.c.html#LN1930"><span class='Ref_To_Local'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                        <a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN1927"><span class='Ref_To_Local'>rtargetlist</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1795"><span class='Ref_to_Parameter'>targetlist</span></a><span class='Parentheses'>) 
</span>            <span class='Operator'>*</span><a href="analyze.c.html#LN1795"><span class='Ref_to_Parameter'>targetlist</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN1925"><span class='Ref_To_Local'>op</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1555"><span class='Ref_to_Member'>colTypes</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN1925"><span class='Ref_To_Local'>op</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1556"><span class='Ref_to_Member'>colTypmods</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN1925"><span class='Ref_To_Local'>op</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1557"><span class='Ref_to_Member'>colCollations</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN1925"><span class='Ref_To_Local'>op</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1558"><span class='Ref_to_Member'>groupClauses</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>        <a href="../../include/nodes/pg_list.h.html#LN179"><span class='Ref_to_Macro'>forboth</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1928"><span class='Ref_To_Local'>ltl</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1926"><span class='Ref_To_Local'>ltargetlist</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1929"><span class='Ref_To_Local'>rtl</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1927"><span class='Ref_To_Local'>rtargetlist</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1984"></a>            <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>ltle</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1928"><span class='Ref_To_Local'>ltl</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1985"></a>            <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rtle</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1929"><span class='Ref_To_Local'>rtl</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1986"></a>            <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>lcolnode</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN1984"><span class='Ref_To_Local'>ltle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Delimiter'>; 
</span><a name="LN1987"></a>            <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>rcolnode</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN1985"><span class='Ref_To_Local'>rtle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Delimiter'>; 
</span><a name="LN1988"></a>            <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>lcoltype</span> <span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1986"><span class='Ref_To_Local'>lcolnode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1989"></a>            <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>rcoltype</span> <span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1987"><span class='Ref_To_Local'>rcolnode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1990"></a>            <a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>lcoltypmod</span> <span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN32"><span class='Ref_to_Proto'>exprTypmod</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1986"><span class='Ref_To_Local'>lcolnode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1991"></a>            <a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>rcoltypmod</span> <span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN32"><span class='Ref_to_Proto'>exprTypmod</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1987"><span class='Ref_To_Local'>rcolnode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1992"></a>            <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>bestexpr</span><span class='Delimiter'>; 
</span><a name="LN1993"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>bestlocation</span><span class='Delimiter'>; 
</span><a name="LN1994"></a>            <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>rescoltype</span><span class='Delimiter'>; 
</span><a name="LN1995"></a>            <a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>rescoltypmod</span><span class='Delimiter'>; 
</span><a name="LN1996"></a>            <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>rescolcoll</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* select common type, same as CASE et al */ 
</span>            <a href="analyze.c.html#LN1994"><span class='Ref_To_Local'>rescoltype</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN68"><span class='Ref_to_Proto'>select_common_type</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                            <a href="../../include/nodes/pg_list.h.html#LN139"><span class='Ref_to_Macro'>list_make2</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1986"><span class='Ref_To_Local'>lcolnode</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1987"><span class='Ref_To_Local'>rcolnode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                            <a href="analyze.c.html#LN1930"><span class='Ref_To_Local'>context</span></a><span class='Delimiter'>, 
</span>                                            <span class='Operator'>&</span><a href="analyze.c.html#LN1992"><span class='Ref_To_Local'>bestexpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="analyze.c.html#LN1993"><span class='Ref_To_Local'>bestlocation</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1992"><span class='Ref_To_Local'>bestexpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* if same type and same typmod, use typmod; else default */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1988"><span class='Ref_To_Local'>lcoltype</span></a> <span class='Operator'>== </span><a href="analyze.c.html#LN1989"><span class='Ref_To_Local'>rcoltype</span></a> <span class='Operator'>&& </span><a href="analyze.c.html#LN1990"><span class='Ref_To_Local'>lcoltypmod</span></a> <span class='Operator'>== </span><a href="analyze.c.html#LN1991"><span class='Ref_To_Local'>rcoltypmod</span></a><span class='Parentheses'>) 
</span>                <a href="analyze.c.html#LN1995"><span class='Ref_To_Local'>rescoltypmod</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1990"><span class='Ref_To_Local'>lcoltypmod</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="analyze.c.html#LN1995"><span class='Ref_To_Local'>rescoltypmod</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Verify the coercions are actually possible.  If not, we'd fail 
             * later anyway, but we want to fail now while we have sufficient 
             * context to produce an error cursor position. 
             * 
             * For all non-UNKNOWN-type cases, we verify coercibility but we 
             * don't modify the child's expression, for fear of changing the 
             * child query's semantics. 
             * 
             * If a child expression is an UNKNOWN-type Const or Param, we 
             * want to replace it with the coerced expression.  This can only 
             * happen when the child is a leaf set-op node.  It's safe to 
             * replace the expression because if the child query's semantics 
             * depended on the type of this output column, it'd have already 
             * coerced the UNKNOWN to something else.  We want to do this 
             * because (a) we want to verify that a Const is valid for the 
             * target type, or resolve the actual type of an UNKNOWN Param, 
             * and (b) we want to avoid unnecessary discrepancies between the 
             * output type of the child query and the resolved target type. 
             * Such a discrepancy would disable optimization in the planner. 
             * 
             * If it's some other UNKNOWN-type node, eg a Var, we do nothing 
             * (knowing that coerce_to_common_type would fail).  The planner 
             * is sometimes able to fold an UNKNOWN Var to a constant before 
             * it has to coerce the type, so failing now would just break 
             * cases that might work. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1988"><span class='Ref_To_Local'>lcoltype</span></a> <span class='Operator'>!= </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN43"><span class='Ref_to_Const'>UNKNOWNOID</span></a><span class='Parentheses'>) 
</span>                <a href="analyze.c.html#LN1986"><span class='Ref_To_Local'>lcolnode</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN70"><span class='Ref_to_Proto'>coerce_to_common_type</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1986"><span class='Ref_To_Local'>lcolnode</span></a><span class='Delimiter'>, 
</span>                                                 <a href="analyze.c.html#LN1994"><span class='Ref_To_Local'>rescoltype</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1930"><span class='Ref_To_Local'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1986"><span class='Ref_To_Local'>lcolnode</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>                     <a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1986"><span class='Ref_To_Local'>lcolnode</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN240"><span class='Ref_to_Struct'>Param</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="analyze.c.html#LN1986"><span class='Ref_To_Local'>lcolnode</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN70"><span class='Ref_to_Proto'>coerce_to_common_type</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1986"><span class='Ref_To_Local'>lcolnode</span></a><span class='Delimiter'>, 
</span>                                                 <a href="analyze.c.html#LN1994"><span class='Ref_To_Local'>rescoltype</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1930"><span class='Ref_To_Local'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="analyze.c.html#LN1984"><span class='Ref_To_Local'>ltle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN1986"><span class='Ref_To_Local'>lcolnode</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1989"><span class='Ref_To_Local'>rcoltype</span></a> <span class='Operator'>!= </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN43"><span class='Ref_to_Const'>UNKNOWNOID</span></a><span class='Parentheses'>) 
</span>                <a href="analyze.c.html#LN1987"><span class='Ref_To_Local'>rcolnode</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN70"><span class='Ref_to_Proto'>coerce_to_common_type</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1987"><span class='Ref_To_Local'>rcolnode</span></a><span class='Delimiter'>, 
</span>                                                 <a href="analyze.c.html#LN1994"><span class='Ref_To_Local'>rescoltype</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1930"><span class='Ref_To_Local'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1987"><span class='Ref_To_Local'>rcolnode</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>                     <a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1987"><span class='Ref_To_Local'>rcolnode</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN240"><span class='Ref_to_Struct'>Param</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="analyze.c.html#LN1987"><span class='Ref_To_Local'>rcolnode</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN70"><span class='Ref_to_Proto'>coerce_to_common_type</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1987"><span class='Ref_To_Local'>rcolnode</span></a><span class='Delimiter'>, 
</span>                                                 <a href="analyze.c.html#LN1994"><span class='Ref_To_Local'>rescoltype</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1930"><span class='Ref_To_Local'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="analyze.c.html#LN1985"><span class='Ref_To_Local'>rtle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN1987"><span class='Ref_To_Local'>rcolnode</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Select common collation.  A common collation is required for 
             * all set operators except UNION ALL; see SQL:2008 7.13 &LT;query 
             * expression&GT; Syntax Rule 15c.  (If we fail to identify a common 
             * collation for a UNION ALL column, the curCollations element 
             * will be set to InvalidOid, which may result in a runtime error 
             * if something at a higher query level wants to use the column's 
             * collation.) 
             */ 
</span>            <a href="analyze.c.html#LN1996"><span class='Ref_To_Local'>rescolcoll</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_collate.h.html#LN24"><span class='Ref_to_Proto'>select_common_collation</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                              <a href="../../include/nodes/pg_list.h.html#LN139"><span class='Ref_to_Macro'>list_make2</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1986"><span class='Ref_To_Local'>lcolnode</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1987"><span class='Ref_To_Local'>rcolnode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                         <span class='Parentheses'>(</span><a href="analyze.c.html#LN1925"><span class='Ref_To_Local'>op</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1548"><span class='Ref_to_Member'>op</span></a> <span class='Operator'>== </span><a href="../../include/nodes/parsenodes.h.html#LN1473"><span class='Ref_to_EnumConst'>SETOP_UNION</span></a> <span class='Operator'>&& </span><a href="analyze.c.html#LN1925"><span class='Ref_To_Local'>op</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1549"><span class='Ref_to_Member'>all</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* emit results */ 
</span>            <a href="analyze.c.html#LN1925"><span class='Ref_To_Local'>op</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1555"><span class='Ref_to_Member'>colTypes</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN162"><span class='Ref_to_Func'>lappend_oid</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1925"><span class='Ref_To_Local'>op</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1555"><span class='Ref_to_Member'>colTypes</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1994"><span class='Ref_To_Local'>rescoltype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="analyze.c.html#LN1925"><span class='Ref_To_Local'>op</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1556"><span class='Ref_to_Member'>colTypmods</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN144"><span class='Ref_to_Func'>lappend_int</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1925"><span class='Ref_To_Local'>op</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1556"><span class='Ref_to_Member'>colTypmods</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1995"><span class='Ref_To_Local'>rescoltypmod</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="analyze.c.html#LN1925"><span class='Ref_To_Local'>op</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1557"><span class='Ref_to_Member'>colCollations</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN162"><span class='Ref_to_Func'>lappend_oid</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1925"><span class='Ref_To_Local'>op</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1557"><span class='Ref_to_Member'>colCollations</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1996"><span class='Ref_To_Local'>rescolcoll</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * For all cases except UNION ALL, identify the grouping operators 
             * (and, if available, sorting operators) that will be used to 
             * eliminate duplicates. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1925"><span class='Ref_To_Local'>op</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1548"><span class='Ref_to_Member'>op</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/parsenodes.h.html#LN1473"><span class='Ref_to_EnumConst'>SETOP_UNION</span></a> <span class='Operator'>|| !</span><a href="analyze.c.html#LN1925"><span class='Ref_To_Local'>op</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1549"><span class='Ref_to_Member'>all</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN2084"></a>                <a href="../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>grpcl</span> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2085"></a>                <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>sortop</span><span class='Delimiter'>; 
</span><a name="LN2086"></a>                <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>eqop</span><span class='Delimiter'>; 
</span><a name="LN2087"></a>                <span class='Keyword'>bool</span>        <span class='Declare_Local'>hashable</span><span class='Delimiter'>; 
</span><a name="LN2088"></a>                <a href="../../include/parser/parse_node.h.html#LN249"><span class='Ref_to_Struct'>ParseCallbackState</span></a> <span class='Declare_Local'>pcbstate</span><span class='Delimiter'>; 
</span> 
                <a href="parse_node.c.html#LN143"><span class='Ref_to_Func'>setup_parser_errposition_callback</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="analyze.c.html#LN2088"><span class='Ref_To_Local'>pcbstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN1794"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                                  <a href="analyze.c.html#LN1993"><span class='Ref_To_Local'>bestlocation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* determine the eqop and optional sortop */ 
</span>                <a href="../../include/parser/parse_oper.h.html#LN47"><span class='Ref_to_Proto'>get_sort_group_operators</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1994"><span class='Ref_To_Local'>rescoltype</span></a><span class='Delimiter'>, 
</span>                                         <span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                                         <span class='Operator'>&</span><a href="analyze.c.html#LN2085"><span class='Ref_To_Local'>sortop</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="analyze.c.html#LN2086"><span class='Ref_To_Local'>eqop</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                         <span class='Operator'>&</span><a href="analyze.c.html#LN2087"><span class='Ref_To_Local'>hashable</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="parse_node.c.html#LN159"><span class='Ref_to_Func'>cancel_parser_errposition_callback</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="analyze.c.html#LN2088"><span class='Ref_To_Local'>pcbstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* we don't have a tlist yet, so can't assign sortgrouprefs */ 
</span>                <a href="analyze.c.html#LN2084"><span class='Ref_To_Local'>grpcl</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1164"><span class='Ref_to_Member'>tleSortGroupRef</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>                <a href="analyze.c.html#LN2084"><span class='Ref_To_Local'>grpcl</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1165"><span class='Ref_to_Member'>eqop</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN2086"><span class='Ref_To_Local'>eqop</span></a><span class='Delimiter'>; 
</span>                <a href="analyze.c.html#LN2084"><span class='Ref_To_Local'>grpcl</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1166"><span class='Ref_to_Member'>sortop</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN2085"><span class='Ref_To_Local'>sortop</span></a><span class='Delimiter'>; 
</span>                <a href="analyze.c.html#LN2084"><span class='Ref_To_Local'>grpcl</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1167"><span class='Ref_to_Member'>nulls_first</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* OK with or without sortop */ 
</span>                <a href="analyze.c.html#LN2084"><span class='Ref_To_Local'>grpcl</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1168"><span class='Ref_to_Member'>hashable</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN2087"><span class='Ref_To_Local'>hashable</span></a><span class='Delimiter'>; 
</span> 
                <a href="analyze.c.html#LN1925"><span class='Ref_To_Local'>op</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1558"><span class='Ref_to_Member'>groupClauses</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN1925"><span class='Ref_To_Local'>op</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1558"><span class='Ref_to_Member'>groupClauses</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2084"><span class='Ref_To_Local'>grpcl</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if op-&GT;op!=SETOP_UNION||... &raquo; </span> 
 
            <span class='Comment_Multi_Line'>/* 
             * Construct a dummy tlist entry to return.  We use a SetToDefault 
             * node for the expression, since it carries exactly the fields 
             * needed, but any other expression node type would do as well. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN1795"><span class='Ref_to_Parameter'>targetlist</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN2118"></a>                <a href="../../include/nodes/primnodes.h.html#LN1251"><span class='Ref_to_Struct'>SetToDefault</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rescolnode</span> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN1251"><span class='Ref_to_Struct'>SetToDefault</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2119"></a>                <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>restle</span><span class='Delimiter'>; 
</span> 
                <a href="analyze.c.html#LN2118"><span class='Ref_To_Local'>rescolnode</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1254"><span class='Ref_to_Member'>typeId</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1994"><span class='Ref_To_Local'>rescoltype</span></a><span class='Delimiter'>; 
</span>                <a href="analyze.c.html#LN2118"><span class='Ref_To_Local'>rescolnode</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1255"><span class='Ref_to_Member'>typeMod</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1995"><span class='Ref_To_Local'>rescoltypmod</span></a><span class='Delimiter'>; 
</span>                <a href="analyze.c.html#LN2118"><span class='Ref_To_Local'>rescolnode</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1256"><span class='Ref_to_Member'>collation</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1996"><span class='Ref_To_Local'>rescolcoll</span></a><span class='Delimiter'>; 
</span>                <a href="analyze.c.html#LN2118"><span class='Ref_To_Local'>rescolnode</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1257"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN1993"><span class='Ref_To_Local'>bestlocation</span></a><span class='Delimiter'>; 
</span>                <a href="analyze.c.html#LN2119"><span class='Ref_To_Local'>restle</span></a> <span class='Operator'>= </span><a href="../../include/nodes/makefuncs.h.html#LN40"><span class='Ref_to_Proto'>makeTargetEntry</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN2118"><span class='Ref_To_Local'>rescolnode</span></a><span class='Delimiter'>, 
</span>                                         <span class='Number'>0</span><span class='Delimiter'>,</span>     <span class='Comment_Single_Line'>/* no need to set resno */ 
</span>                                         <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                         <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Operator'>*</span><a href="analyze.c.html#LN1795"><span class='Ref_to_Parameter'>targetlist</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="analyze.c.html#LN1795"><span class='Ref_to_Parameter'>targetlist</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2119"><span class='Ref_To_Local'>restle</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN1925"><span class='Ref_To_Local'>op</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end transformSetOperationTree &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Process the outputs of the non-recursive term of a recursive union 
 * to set up the parent CTE's columns 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2142"></a><span class='Declare_Function'>determineRecursiveColTypes</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>larg</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>nrtargetlist</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2144"></a>    <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>node</span><span class='Delimiter'>; 
</span><a name="LN2145"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>leftmostRTI</span><span class='Delimiter'>; 
</span><a name="LN2146"></a>    <a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>leftmostQuery</span><span class='Delimiter'>; 
</span><a name="LN2147"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>targetList</span><span class='Delimiter'>; 
</span><a name="LN2148"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>left_tlist</span><span class='Delimiter'>; 
</span><a name="LN2149"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>nrtl</span><span class='Delimiter'>; 
</span><a name="LN2150"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>next_resno</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Find leftmost leaf SELECT 
     */ 
</span>    <a href="analyze.c.html#LN2144"><span class='Ref_To_Local'>node</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN2142"><span class='Ref_to_Parameter'>larg</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN2144"><span class='Ref_To_Local'>node</span></a> <span class='Operator'>&& </span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2144"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN1545"><span class='Ref_to_Struct'>SetOperationStmt</span></a><span class='Parentheses'>))</span> 
        <a href="analyze.c.html#LN2144"><span class='Ref_To_Local'>node</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/nodes/parsenodes.h.html#LN1545"><span class='Ref_to_Struct'>SetOperationStmt</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN2144"><span class='Ref_To_Local'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>larg<span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="analyze.c.html#LN2144"><span class='Ref_To_Local'>node</span></a> <span class='Operator'>&& </span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2144"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN1415"><span class='Ref_to_Struct'>RangeTblRef</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN2145"><span class='Ref_To_Local'>leftmostRTI</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN1415"><span class='Ref_to_Struct'>RangeTblRef</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN2144"><span class='Ref_To_Local'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>rtindex<span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN2146"><span class='Ref_To_Local'>leftmostQuery</span></a> <span class='Operator'>= </span><a href="../../include/parser/parsetree.h.html#LN30"><span class='Ref_to_Macro'>rt_fetch</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2145"><span class='Ref_To_Local'>leftmostRTI</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2142"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>subquery<span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="analyze.c.html#LN2146"><span class='Ref_To_Local'>leftmostQuery</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Generate dummy targetlist using column names of leftmost select and 
     * dummy result expressions of the non-recursive term. 
     */ 
</span>    <a href="analyze.c.html#LN2147"><span class='Ref_To_Local'>targetList</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN2148"><span class='Ref_To_Local'>left_tlist</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2146"><span class='Ref_To_Local'>leftmostQuery</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN2150"><span class='Ref_To_Local'>next_resno</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2149"><span class='Ref_To_Local'>nrtl</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2142"><span class='Ref_to_Parameter'>nrtargetlist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2173"></a>        <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>nrtle</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2149"><span class='Ref_To_Local'>nrtl</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2174"></a>        <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>lefttle</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2148"><span class='Ref_To_Local'>left_tlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2175"></a>        <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>colName</span><span class='Delimiter'>; 
</span><a name="LN2176"></a>        <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="analyze.c.html#LN2174"><span class='Ref_To_Local'>lefttle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1373"><span class='Ref_to_Member'>resjunk</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN2175"><span class='Ref_To_Local'>colName</span></a> <span class='Operator'>= </span><a href="../../include/common/fe_memutils.h.html#LN32"><span class='Ref_to_Proto'>pstrdup</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2174"><span class='Ref_To_Local'>lefttle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1368"><span class='Ref_to_Member'>resname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN2176"><span class='Ref_To_Local'>tle</span></a> <span class='Operator'>= </span><a href="../../include/nodes/makefuncs.h.html#LN40"><span class='Ref_to_Proto'>makeTargetEntry</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2173"><span class='Ref_To_Local'>nrtle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Delimiter'>, 
</span>                              <a href="analyze.c.html#LN2150"><span class='Ref_To_Local'>next_resno</span></a><span class='Operator'>++</span><span class='Delimiter'>, 
</span>                              <a href="analyze.c.html#LN2175"><span class='Ref_To_Local'>colName</span></a><span class='Delimiter'>, 
</span>                              <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN2147"><span class='Ref_To_Local'>targetList</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2147"><span class='Ref_To_Local'>targetList</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2176"><span class='Ref_To_Local'>tle</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN2148"><span class='Ref_To_Local'>left_tlist</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2148"><span class='Ref_To_Local'>left_tlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Now build CTE's output column info using dummy targetlist */ 
</span>    <a href="../../include/parser/parse_cte.h.html#LN20"><span class='Ref_to_Proto'>analyzeCTETargetList</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2142"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2142"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN177"><span class='Ref_to_Member'>p_parent_cte</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2147"><span class='Ref_To_Local'>targetList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end determineRecursiveColTypes &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * transformUpdateStmt - 
 *    transforms an update statement 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>* 
</span><a name="LN2198"></a><span class='Declare_Function'>transformUpdateStmt</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN1446"><span class='Ref_to_Struct'>UpdateStmt</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stmt</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2200"></a>    <a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>qry</span> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2201"></a>    <a href="../../include/parser/parse_node.h.html#LN239"><span class='Ref_to_Struct'>ParseNamespaceItem</span></a> <span class='Operator'>*</span><span class='Declare_Local'>nsitem</span><span class='Delimiter'>; 
</span><a name="LN2202"></a>    <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>qual</span><span class='Delimiter'>; 
</span> 
    <a href="analyze.c.html#LN2200"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN109"><span class='Ref_to_Member'>commandType</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN651"><span class='Ref_to_EnumConst'>CMD_UPDATE</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN2198"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN180"><span class='Ref_to_Member'>p_is_insert</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* process the WITH clause independently of all else */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN2198"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1454"><span class='Ref_to_Member'>withClause</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="analyze.c.html#LN2200"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN127"><span class='Ref_to_Member'>hasRecursive</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN2198"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1454"><span class='Ref_to_Member'>withClause</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1298"><span class='Ref_to_Member'>recursive</span></a><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN2200"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN132"><span class='Ref_to_Member'>cteList</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_cte.h.html#LN18"><span class='Ref_to_Proto'>transformWithClause</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2198"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2198"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1454"><span class='Ref_to_Member'>withClause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN2200"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN128"><span class='Ref_to_Member'>hasModifyingCTE</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN2198"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN199"><span class='Ref_to_Member'>p_hasModifyingCTE</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="analyze.c.html#LN2200"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN119"><span class='Ref_to_Member'>resultRelation</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_clause.h.html#LN19"><span class='Ref_to_Proto'>setTargetTable</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2198"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2198"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1449"><span class='Ref_to_Member'>relation</span></a><span class='Delimiter'>, 
</span>                                         <a href="analyze.c.html#LN2198"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1449"><span class='Ref_to_Member'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN68"><span class='Ref_to_Member'>inh</span></a><span class='Delimiter'>, 
</span>                                         <span class='Boolean'>true</span><span class='Delimiter'>, 
</span>                                         <a href="../../include/nodes/parsenodes.h.html#LN73"><span class='Ref_to_Const'>ACL_UPDATE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* grab the namespace item made by setTargetTable */ 
</span>    <a href="analyze.c.html#LN2201"><span class='Ref_To_Local'>nsitem</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN239"><span class='Ref_to_Struct'>ParseNamespaceItem</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN130"><span class='Ref_to_Macro'>llast</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2198"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN172"><span class='Ref_to_Member'>p_namespace</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* subqueries in FROM cannot access the result relation */ 
</span>    <a href="analyze.c.html#LN2201"><span class='Ref_To_Local'>nsitem</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN244"><span class='Ref_to_Member'>p_lateral_only</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN2201"><span class='Ref_To_Local'>nsitem</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN245"><span class='Ref_to_Member'>p_lateral_ok</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * the FROM clause is non-standard SQL syntax. We used to be able to do 
     * this with REPLACE in POSTQUEL so we keep the feature. 
     */ 
</span>    <a href="../../include/parser/parse_clause.h.html#LN18"><span class='Ref_to_Proto'>transformFromClause</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2198"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2198"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1452"><span class='Ref_to_Member'>fromClause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* remaining clauses can reference the result relation normally */ 
</span>    <a href="analyze.c.html#LN2201"><span class='Ref_To_Local'>nsitem</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN244"><span class='Ref_to_Member'>p_lateral_only</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN2201"><span class='Ref_To_Local'>nsitem</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN245"><span class='Ref_to_Member'>p_lateral_ok</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <a href="analyze.c.html#LN2202"><span class='Ref_To_Local'>qual</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_clause.h.html#LN23"><span class='Ref_to_Proto'>transformWhereClause</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2198"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2198"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1451"><span class='Ref_to_Member'>whereClause</span></a><span class='Delimiter'>, 
</span>                                <a href="../../include/parser/parse_node.h.html#LN40"><span class='Ref_to_EnumConst'>EXPR_KIND_WHERE</span></a><span class='Delimiter'>, </span><span class='String'>"WHERE"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="analyze.c.html#LN2200"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN143"><span class='Ref_to_Member'>returningList</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN67"><span class='Ref_to_Proto'>transformReturningList</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2198"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2198"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1453"><span class='Ref_to_Member'>returningList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now we are done with SELECT-like processing, and can get on with 
     * transforming the target list to match the UPDATE target columns. 
     */ 
</span>    <a href="analyze.c.html#LN2200"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN68"><span class='Ref_to_Proto'>transformUpdateTargetList</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2198"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2198"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1450"><span class='Ref_to_Member'>targetList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="analyze.c.html#LN2200"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN134"><span class='Ref_to_Member'>rtable</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN2198"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN2200"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN135"><span class='Ref_to_Member'>jointree</span></a> <span class='Operator'>= </span><a href="../../include/nodes/makefuncs.h.html#LN47"><span class='Ref_to_Proto'>makeFromExpr</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2198"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN170"><span class='Ref_to_Member'>p_joinlist</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2202"><span class='Ref_To_Local'>qual</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="analyze.c.html#LN2200"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN124"><span class='Ref_to_Member'>hasTargetSRFs</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN2198"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN197"><span class='Ref_to_Member'>p_hasTargetSRFs</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN2200"><span class='Ref_To_Local'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN125"><span class='Ref_to_Member'>hasSubLinks</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN2198"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN198"><span class='Ref_to_Member'>p_hasSubLinks</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../include/parser/parse_collate.h.html#LN18"><span class='Ref_to_Proto'>assign_query_collations</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2198"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2200"><span class='Ref_To_Local'>qry</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="analyze.c.html#LN2200"><span class='Ref_To_Local'>qry</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end transformUpdateStmt &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * transformUpdateTargetList - 
 *  handle SET clause in UPDATE/INSERT ... ON CONFLICT UPDATE 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN2264"></a><span class='Declare_Function'>transformUpdateTargetList</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>origTlist</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2266"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>tlist</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN2267"></a>    <a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>target_rte</span><span class='Delimiter'>; 
</span><a name="LN2268"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>orig_tl</span><span class='Delimiter'>; 
</span><a name="LN2269"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>tl</span><span class='Delimiter'>; 
</span> 
    <a href="analyze.c.html#LN2266"><span class='Ref_To_Local'>tlist</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_target.h.html#LN19"><span class='Ref_to_Proto'>transformTargetList</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2264"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2264"><span class='Ref_to_Parameter'>origTlist</span></a><span class='Delimiter'>, 
</span>                                <a href="../../include/parser/parse_node.h.html#LN49"><span class='Ref_to_EnumConst'>EXPR_KIND_UPDATE_SOURCE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Prepare to assign non-conflicting resnos to resjunk attributes */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN2264"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN183"><span class='Ref_to_Member'>p_next_resno</span></a> <span class='Operator'>&LT;= </span><a href="analyze.c.html#LN2264"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN178"><span class='Ref_to_Member'>p_target_relation</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relnatts<span class='Parentheses'>) 
</span>        <a href="analyze.c.html#LN2264"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN183"><span class='Ref_to_Member'>p_next_resno</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN2264"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN178"><span class='Ref_to_Member'>p_target_relation</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relnatts <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Prepare non-junk columns for assignment to target table */ 
</span>    <a href="analyze.c.html#LN2267"><span class='Ref_To_Local'>target_rte</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN2264"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN179"><span class='Ref_to_Member'>p_target_rangetblentry</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN2268"><span class='Ref_To_Local'>orig_tl</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2264"><span class='Ref_to_Parameter'>origTlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2269"><span class='Ref_To_Local'>tl</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2266"><span class='Ref_To_Local'>tlist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2284"></a>        <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2269"><span class='Ref_To_Local'>tl</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2285"></a>        <a href="../../include/nodes/parsenodes.h.html#LN436"><span class='Ref_to_Struct'>ResTarget</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>origTarget</span><span class='Delimiter'>; 
</span><a name="LN2286"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>attrno</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN2284"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1373"><span class='Ref_to_Member'>resjunk</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Resjunk nodes need no additional processing, but be sure they 
             * have resnos that do not match any target columns; else rewriter 
             * or planner might get confused.  They don't need a resname 
             * either. 
             */ 
</span>            <a href="analyze.c.html#LN2284"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1367"><span class='Ref_to_Member'>resno</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a><span class='Parentheses'>) </span><a href="analyze.c.html#LN2264"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN183"><span class='Ref_to_Member'>p_next_resno</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <a href="analyze.c.html#LN2284"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1368"><span class='Ref_to_Member'>resname</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN2268"><span class='Ref_To_Local'>orig_tl</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"UPDATE target count mismatch --- internal error"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN2285"><span class='Ref_To_Local'>origTarget</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN108"><span class='Ref_to_Macro'>lfirst_node</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN436"><span class='Ref_to_Struct'>ResTarget</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2268"><span class='Ref_To_Local'>orig_tl</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="analyze.c.html#LN2286"><span class='Ref_To_Local'>attrno</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_relation.h.html#LN125"><span class='Ref_to_Proto'>attnameAttNum</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2264"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN178"><span class='Ref_to_Member'>p_target_relation</span></a><span class='Delimiter'>, 
</span>                               <a href="analyze.c.html#LN2285"><span class='Ref_To_Local'>origTarget</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN439"><span class='Ref_to_Member'>name</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN2286"><span class='Ref_To_Local'>attrno</span></a> <span class='Operator'>== </span><a href="../../include/access/attnum.h.html#LN22"><span class='Ref_to_Const'>InvalidAttrNumber</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_UNDEFINED_COLUMN<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"column \"%s\" of relation \"%s\" does not exist"</span><span class='Delimiter'>, 
</span>                            <a href="analyze.c.html#LN2285"><span class='Ref_To_Local'>origTarget</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN439"><span class='Ref_to_Member'>name</span></a><span class='Delimiter'>, 
</span>                         <a href="../../include/utils/rel.h.html#LN436"><span class='Ref_to_Macro'>RelationGetRelationName</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2264"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN178"><span class='Ref_to_Member'>p_target_relation</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2264"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2285"><span class='Ref_To_Local'>origTarget</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN442"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/parser/parse_target.h.html#LN34"><span class='Ref_to_Proto'>updateTargetListEntry</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2264"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2284"><span class='Ref_To_Local'>tle</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2285"><span class='Ref_To_Local'>origTarget</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN439"><span class='Ref_to_Member'>name</span></a><span class='Delimiter'>, 
</span>                              <a href="analyze.c.html#LN2286"><span class='Ref_To_Local'>attrno</span></a><span class='Delimiter'>, 
</span>                              <a href="analyze.c.html#LN2285"><span class='Ref_To_Local'>origTarget</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN440"><span class='Ref_to_Member'>indirection</span></a><span class='Delimiter'>, 
</span>                              <a href="analyze.c.html#LN2285"><span class='Ref_To_Local'>origTarget</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN442"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Mark the target column as requiring update permissions */ 
</span>        <a href="analyze.c.html#LN2267"><span class='Ref_To_Local'>target_rte</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1031"><span class='Ref_to_Member'>updatedCols</span></a> <span class='Operator'>= </span><a href="../../include/nodes/bitmapset.h.html#LN89"><span class='Ref_to_Proto'>bms_add_member</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2267"><span class='Ref_To_Local'>target_rte</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1031"><span class='Ref_to_Member'>updatedCols</span></a><span class='Delimiter'>, 
</span>                                <a href="analyze.c.html#LN2286"><span class='Ref_To_Local'>attrno</span></a> <span class='Operator'>- </span><a href="../../include/access/sysattr.h.html#LN27"><span class='Ref_to_Const'>FirstLowInvalidHeapAttributeNumber</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="analyze.c.html#LN2268"><span class='Ref_To_Local'>orig_tl</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2268"><span class='Ref_To_Local'>orig_tl</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN2268"><span class='Ref_To_Local'>orig_tl</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"UPDATE target count mismatch --- internal error"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="analyze.c.html#LN2266"><span class='Ref_To_Local'>tlist</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end transformUpdateTargetList &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * transformReturningList - 
 *  handle a RETURNING clause in INSERT/UPDATE/DELETE 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN2336"></a><span class='Declare_Function'>transformReturningList</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>returningList</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2338"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>rlist</span><span class='Delimiter'>; 
</span><a name="LN2339"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>save_next_resno</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN2336"><span class='Ref_to_Parameter'>returningList</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* nothing to do */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We need to assign resnos starting at one in the RETURNING list. Save 
     * and restore the main tlist's value of p_next_resno, just in case 
     * someone looks at it later (probably won't happen). 
     */ 
</span>    <a href="analyze.c.html#LN2339"><span class='Ref_To_Local'>save_next_resno</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN2336"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN183"><span class='Ref_to_Member'>p_next_resno</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN2336"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN183"><span class='Ref_to_Member'>p_next_resno</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* transform RETURNING identically to a SELECT targetlist */ 
</span>    <a href="analyze.c.html#LN2338"><span class='Ref_To_Local'>rlist</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_target.h.html#LN19"><span class='Ref_to_Proto'>transformTargetList</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2336"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2336"><span class='Ref_to_Parameter'>returningList</span></a><span class='Delimiter'>, </span><a href="../../include/parser/parse_node.h.html#LN56"><span class='Ref_to_EnumConst'>EXPR_KIND_RETURNING</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Complain if the nonempty tlist expanded to nothing (which is possible 
     * if it contains only a star-expansion of a zero-column table).  If we 
     * allow this, the parsed Query will look like it didn't have RETURNING, 
     * with results that would probably surprise the user. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN2338"><span class='Ref_To_Local'>rlist</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_SYNTAX_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"RETURNING must have at least one column"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2336"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                    <a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2336"><span class='Ref_to_Parameter'>returningList</span></a><span class='Parentheses'>)))))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* mark column origins */ 
</span>    <a href="../../include/parser/parse_target.h.html#LN24"><span class='Ref_to_Proto'>markTargetListOrigins</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2336"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2338"><span class='Ref_To_Local'>rlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* resolve any still-unresolved output columns as being type text */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN2336"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN188"><span class='Ref_to_Member'>p_resolve_unknowns</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/parser/parse_target.h.html#LN23"><span class='Ref_to_Proto'>resolveTargetListUnknowns</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2336"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2338"><span class='Ref_To_Local'>rlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* restore state */ 
</span>    <a href="analyze.c.html#LN2336"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN183"><span class='Ref_to_Member'>p_next_resno</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN2339"><span class='Ref_To_Local'>save_next_resno</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="analyze.c.html#LN2338"><span class='Ref_To_Local'>rlist</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end transformReturningList &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * transformDeclareCursorStmt - 
 *  transform a DECLARE CURSOR Statement 
 * 
 * DECLARE CURSOR is like other utility statements in that we emit it as a 
 * CMD_UTILITY Query node; however, we must first transform the contained 
 * query.  We used to postpone that until execution, but it's really necessary 
 * to do it during the normal parse analysis phase to ensure that side effects 
 * of parser hooks happen at the expected time. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>* 
</span><a name="LN2393"></a><span class='Declare_Function'>transformDeclareCursorStmt</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN2612"><span class='Ref_to_Struct'>DeclareCursorStmt</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stmt</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2395"></a>    <a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span><a name="LN2396"></a>    <a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>query</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Don't allow both SCROLL and NO SCROLL to be specified 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="analyze.c.html#LN2393"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN2616"><span class='Ref_to_Member'>options</span></a> <span class='Operator'>& </span><a href="../../include/nodes/parsenodes.h.html#LN2602"><span class='Ref_to_Const'>CURSOR_OPT_SCROLL</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>        <span class='Parentheses'>(</span><a href="analyze.c.html#LN2393"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN2616"><span class='Ref_to_Member'>options</span></a> <span class='Operator'>& </span><a href="../../include/nodes/parsenodes.h.html#LN2603"><span class='Ref_to_Const'>CURSOR_OPT_NO_SCROLL</span></a><span class='Parentheses'>))</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_CURSOR_DEFINITION<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"cannot specify both SCROLL and NO SCROLL"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Transform contained query, not allowing SELECT INTO */ 
</span>    <a href="analyze.c.html#LN2396"><span class='Ref_To_Local'>query</span></a> <span class='Operator'>= </span><a href="../../include/parser/analyze.h.html#LN35"><span class='Ref_to_Proto'>transformStmt</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2393"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2393"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN2617"><span class='Ref_to_Member'>query</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN2393"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN2617"><span class='Ref_to_Member'>query</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN2396"><span class='Ref_To_Local'>query</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Grammar should not have allowed anything but SELECT */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2396"><span class='Ref_To_Local'>query</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <a href="analyze.c.html#LN2396"><span class='Ref_To_Local'>query</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN109"><span class='Ref_to_Member'>commandType</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/nodes.h.html#LN650"><span class='Ref_to_EnumConst'>CMD_SELECT</span></a><span class='Parentheses'>)</span> 
        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unexpected non-SELECT command in DECLARE CURSOR"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We also disallow data-modifying WITH in a cursor.  (This could be 
     * allowed, but the semantics of when the updates occur might be 
     * surprising.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN2396"><span class='Ref_To_Local'>query</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN128"><span class='Ref_to_Member'>hasModifyingCTE</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"DECLARE CURSOR must not contain data-modifying statements in WITH"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* FOR UPDATE and WITH HOLD are not compatible */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN2396"><span class='Ref_To_Local'>query</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN160"><span class='Ref_to_Member'>rowMarks</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>&& </span><span class='Parentheses'>(</span><a href="analyze.c.html#LN2393"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN2616"><span class='Ref_to_Member'>options</span></a> <span class='Operator'>& </span><a href="../../include/nodes/parsenodes.h.html#LN2605"><span class='Ref_to_Const'>CURSOR_OPT_HOLD</span></a><span class='Parentheses'>))</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>        <span class='Comment_Multi_Line'>/*------ 
          translator: %s is a SQL row locking clause such as FOR UPDATE */ 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"DECLARE CURSOR WITH HOLD ... %s is not supported"</span><span class='Delimiter'>, 
</span>                        <a href="../../include/parser/analyze.h.html#LN39"><span class='Ref_to_Proto'>LCS_asString</span></a><span class='Parentheses'>(((</span><a href="../../include/nodes/parsenodes.h.html#LN1278"><span class='Ref_to_Struct'>RowMarkClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                                      <a href="../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2396"><span class='Ref_To_Local'>query</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN160"><span class='Ref_to_Member'>rowMarks</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>strength<span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"Holdable cursors must be READ ONLY."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* FOR UPDATE and SCROLL are not compatible */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN2396"><span class='Ref_To_Local'>query</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN160"><span class='Ref_to_Member'>rowMarks</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>&& </span><span class='Parentheses'>(</span><a href="analyze.c.html#LN2393"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN2616"><span class='Ref_to_Member'>options</span></a> <span class='Operator'>& </span><a href="../../include/nodes/parsenodes.h.html#LN2602"><span class='Ref_to_Const'>CURSOR_OPT_SCROLL</span></a><span class='Parentheses'>))</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>        <span class='Comment_Multi_Line'>/*------ 
          translator: %s is a SQL row locking clause such as FOR UPDATE */ 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"DECLARE SCROLL CURSOR ... %s is not supported"</span><span class='Delimiter'>, 
</span>                        <a href="../../include/parser/analyze.h.html#LN39"><span class='Ref_to_Proto'>LCS_asString</span></a><span class='Parentheses'>(((</span><a href="../../include/nodes/parsenodes.h.html#LN1278"><span class='Ref_to_Struct'>RowMarkClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                                      <a href="../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2396"><span class='Ref_To_Local'>query</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN160"><span class='Ref_to_Member'>rowMarks</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>strength<span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"Scrollable cursors must be READ ONLY."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* FOR UPDATE and INSENSITIVE are not compatible */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN2396"><span class='Ref_To_Local'>query</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN160"><span class='Ref_to_Member'>rowMarks</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>&& </span><span class='Parentheses'>(</span><a href="analyze.c.html#LN2393"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN2616"><span class='Ref_to_Member'>options</span></a> <span class='Operator'>& </span><a href="../../include/nodes/parsenodes.h.html#LN2604"><span class='Ref_to_Const'>CURSOR_OPT_INSENSITIVE</span></a><span class='Parentheses'>))</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>        <span class='Comment_Multi_Line'>/*------ 
          translator: %s is a SQL row locking clause such as FOR UPDATE */ 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"DECLARE INSENSITIVE CURSOR ... %s is not supported"</span><span class='Delimiter'>, 
</span>                        <a href="../../include/parser/analyze.h.html#LN39"><span class='Ref_to_Proto'>LCS_asString</span></a><span class='Parentheses'>(((</span><a href="../../include/nodes/parsenodes.h.html#LN1278"><span class='Ref_to_Struct'>RowMarkClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                                      <a href="../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2396"><span class='Ref_To_Local'>query</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN160"><span class='Ref_to_Member'>rowMarks</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>strength<span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"Insensitive cursors must be READ ONLY."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* represent the command as a utility Query */ 
</span>    <a href="analyze.c.html#LN2395"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN2395"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN109"><span class='Ref_to_Member'>commandType</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN654"><span class='Ref_to_EnumConst'>CMD_UTILITY</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN2395"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN117"><span class='Ref_to_Member'>utilityStmt</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN2393"><span class='Ref_to_Parameter'>stmt</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="analyze.c.html#LN2395"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end transformDeclareCursorStmt &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * transformExplainStmt - 
 *  transform an EXPLAIN Statement 
 * 
 * EXPLAIN is like other utility statements in that we emit it as a 
 * CMD_UTILITY Query node; however, we must first transform the contained 
 * query.  We used to postpone that until execution, but it's really necessary 
 * to do it during the normal parse analysis phase to ensure that side effects 
 * of parser hooks happen at the expected time. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>* 
</span><a name="LN2479"></a><span class='Declare_Function'>transformExplainStmt</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN3088"><span class='Ref_to_Struct'>ExplainStmt</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stmt</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2481"></a>    <a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* transform contained query, allowing SELECT INTO */ 
</span>    <a href="analyze.c.html#LN2479"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3091"><span class='Ref_to_Member'>query</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN50"><span class='Ref_to_Proto'>transformOptionalSelectInto</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2479"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2479"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3091"><span class='Ref_to_Member'>query</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* represent the command as a utility Query */ 
</span>    <a href="analyze.c.html#LN2481"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN2481"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN109"><span class='Ref_to_Member'>commandType</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN654"><span class='Ref_to_EnumConst'>CMD_UTILITY</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN2481"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN117"><span class='Ref_to_Member'>utilityStmt</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN2479"><span class='Ref_to_Parameter'>stmt</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="analyze.c.html#LN2481"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * transformCreateTableAsStmt - 
 *  transform a CREATE TABLE AS, SELECT ... INTO, or CREATE MATERIALIZED VIEW 
 *  Statement 
 * 
 * As with DECLARE CURSOR and EXPLAIN, transform the contained statement now. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>* 
</span><a name="LN2503"></a><span class='Declare_Function'>transformCreateTableAsStmt</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN3108"><span class='Ref_to_Struct'>CreateTableAsStmt</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stmt</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2505"></a>    <a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span><a name="LN2506"></a>    <a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>query</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* transform contained query, not allowing SELECT INTO */ 
</span>    <a href="analyze.c.html#LN2506"><span class='Ref_To_Local'>query</span></a> <span class='Operator'>= </span><a href="../../include/parser/analyze.h.html#LN35"><span class='Ref_to_Proto'>transformStmt</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2503"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2503"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3111"><span class='Ref_to_Member'>query</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN2503"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3111"><span class='Ref_to_Member'>query</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN2506"><span class='Ref_To_Local'>query</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* additional work needed for CREATE MATERIALIZED VIEW */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN2503"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3113"><span class='Ref_to_Member'>relkind</span></a> <span class='Operator'>== </span><a href="../../include/nodes/parsenodes.h.html#LN1608"><span class='Ref_to_EnumConst'>OBJECT_MATVIEW</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Prohibit a data-modifying CTE in the query used to create a 
         * materialized view. It's not sufficiently clear what the user would 
         * want to happen if the MV is refreshed or incrementally maintained. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN2506"><span class='Ref_To_Local'>query</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN128"><span class='Ref_to_Member'>hasModifyingCTE</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"materialized views must not use data-modifying statements in WITH"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Check whether any temporary database objects are used in the 
         * creation query. It would be hard to refresh data or incrementally 
         * maintain it if a source disappeared. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/parser/parse_relation.h.html#LN129"><span class='Ref_to_Proto'>isQueryUsingTempRelation</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2506"><span class='Ref_To_Local'>query</span></a><span class='Parentheses'>))</span> 
            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"materialized views must not use temporary tables or views"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * A materialized view would either need to save parameters for use in 
         * maintaining/loading the data or prohibit them entirely.  The latter 
         * seems safer and more sane. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/parser/parse_param.h.html#LN22"><span class='Ref_to_Proto'>query_contains_extern_params</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2506"><span class='Ref_To_Local'>query</span></a><span class='Parentheses'>))</span> 
            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"materialized views may not be defined using bound parameters"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * For now, we disallow unlogged materialized views, because it seems 
         * like a bad idea for them to just go to empty after a crash. (If we 
         * could mark them as unpopulated, that would be better, but that 
         * requires catalog changes which crash recovery can't presently 
         * handle.) 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN2503"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3112"><span class='Ref_to_Member'>into</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN108"><span class='Ref_to_Member'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN70"><span class='Ref_to_Member'>relpersistence</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_class.h.html#LN170"><span class='Ref_to_Const'>RELPERSISTENCE_UNLOGGED</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"materialized views cannot be UNLOGGED"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * At runtime, we'll need a copy of the parsed-but-not-rewritten Query 
         * for purposes of creating the view's ON SELECT rule.  We stash that 
         * in the IntoClause because that's where intorel_startup() can 
         * conveniently get it from. 
         */ 
</span>        <a href="analyze.c.html#LN2503"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3112"><span class='Ref_to_Member'>into</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN113"><span class='Ref_to_Member'>viewQuery</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2506"><span class='Ref_To_Local'>query</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if stmt-&GT;relkind==OBJECT... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* represent the command as a utility Query */ 
</span>    <a href="analyze.c.html#LN2505"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN2505"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN109"><span class='Ref_to_Member'>commandType</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN654"><span class='Ref_to_EnumConst'>CMD_UTILITY</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN2505"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN117"><span class='Ref_to_Member'>utilityStmt</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN2503"><span class='Ref_to_Parameter'>stmt</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="analyze.c.html#LN2505"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end transformCreateTableAsStmt &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Produce a string representation of a LockClauseStrength value. 
 * This should only be applied to valid values (not LCS_NONE). 
 */ 
</span><span class='Keyword'>const char </span><span class='Operator'>* 
</span><a name="LN2580"></a><span class='Declare_Function'>LCS_asString</span><span class='Parentheses'>(</span><a href="../../include/nodes/lockoptions.h.html#LN20"><span class='Ref_to_Enum'>LockClauseStrength</span></a> <span class='Declare_Parameter'>strength</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN2580"><span class='Ref_to_Parameter'>strength</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/lockoptions.h.html#LN22"><span class='Ref_to_EnumConst'>LCS_NONE</span></a><span class='Operator'>: 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/lockoptions.h.html#LN23"><span class='Ref_to_EnumConst'>LCS_FORKEYSHARE</span></a><span class='Operator'>: 
</span>            <span class='Control'>return</span> <span class='String'>"FOR KEY SHARE"</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/lockoptions.h.html#LN24"><span class='Ref_to_EnumConst'>LCS_FORSHARE</span></a><span class='Operator'>: 
</span>            <span class='Control'>return</span> <span class='String'>"FOR SHARE"</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/lockoptions.h.html#LN25"><span class='Ref_to_EnumConst'>LCS_FORNOKEYUPDATE</span></a><span class='Operator'>: 
</span>            <span class='Control'>return</span> <span class='String'>"FOR NO KEY UPDATE"</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/lockoptions.h.html#LN26"><span class='Ref_to_EnumConst'>LCS_FORUPDATE</span></a><span class='Operator'>: 
</span>            <span class='Control'>return</span> <span class='String'>"FOR UPDATE"</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <span class='String'>"FOR some"</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* shouldn't happen */ 
</span><span class='Delimiter'>} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Check for features that are not supported with FOR [KEY] UPDATE/SHARE. 
 * 
 * exported so planner can check again after rewriting, query pullup, etc 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2605"></a><span class='Declare_Function'>CheckSelectLocking</span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>qry</span><span class='Delimiter'>, </span><a href="../../include/nodes/lockoptions.h.html#LN20"><span class='Ref_to_Enum'>LockClauseStrength</span></a> <span class='Declare_Parameter'>strength</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="analyze.c.html#LN2605"><span class='Ref_to_Parameter'>strength</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/lockoptions.h.html#LN22"><span class='Ref_to_EnumConst'>LCS_NONE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* else caller error */ 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN2605"><span class='Ref_to_Parameter'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN162"><span class='Ref_to_Member'>setOperations</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>        <span class='Comment_Multi_Line'>/*------ 
          translator: %s is a SQL row locking clause such as FOR UPDATE */ 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"%s is not allowed with UNION/INTERSECT/EXCEPT"</span><span class='Delimiter'>, 
</span>                        <a href="../../include/parser/analyze.h.html#LN39"><span class='Ref_to_Proto'>LCS_asString</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2605"><span class='Ref_to_Parameter'>strength</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN2605"><span class='Ref_to_Parameter'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN153"><span class='Ref_to_Member'>distinctClause</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>        <span class='Comment_Multi_Line'>/*------ 
          translator: %s is a SQL row locking clause such as FOR UPDATE */ 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"%s is not allowed with DISTINCT clause"</span><span class='Delimiter'>, 
</span>                        <a href="../../include/parser/analyze.h.html#LN39"><span class='Ref_to_Proto'>LCS_asString</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2605"><span class='Ref_to_Parameter'>strength</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN2605"><span class='Ref_to_Parameter'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>        <span class='Comment_Multi_Line'>/*------ 
          translator: %s is a SQL row locking clause such as FOR UPDATE */ 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"%s is not allowed with GROUP BY clause"</span><span class='Delimiter'>, 
</span>                        <a href="../../include/parser/analyze.h.html#LN39"><span class='Ref_to_Proto'>LCS_asString</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2605"><span class='Ref_to_Parameter'>strength</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN2605"><span class='Ref_to_Parameter'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>        <span class='Comment_Multi_Line'>/*------ 
          translator: %s is a SQL row locking clause such as FOR UPDATE */ 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"%s is not allowed with HAVING clause"</span><span class='Delimiter'>, 
</span>                        <a href="../../include/parser/analyze.h.html#LN39"><span class='Ref_to_Proto'>LCS_asString</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2605"><span class='Ref_to_Parameter'>strength</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN2605"><span class='Ref_to_Parameter'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN122"><span class='Ref_to_Member'>hasAggs</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>        <span class='Comment_Multi_Line'>/*------ 
          translator: %s is a SQL row locking clause such as FOR UPDATE */ 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"%s is not allowed with aggregate functions"</span><span class='Delimiter'>, 
</span>                        <a href="../../include/parser/analyze.h.html#LN39"><span class='Ref_to_Proto'>LCS_asString</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2605"><span class='Ref_to_Parameter'>strength</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN2605"><span class='Ref_to_Parameter'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN123"><span class='Ref_to_Member'>hasWindowFuncs</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>        <span class='Comment_Multi_Line'>/*------ 
          translator: %s is a SQL row locking clause such as FOR UPDATE */ 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"%s is not allowed with window functions"</span><span class='Delimiter'>, 
</span>                        <a href="../../include/parser/analyze.h.html#LN39"><span class='Ref_to_Proto'>LCS_asString</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2605"><span class='Ref_to_Parameter'>strength</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN2605"><span class='Ref_to_Parameter'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN124"><span class='Ref_to_Member'>hasTargetSRFs</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>        <span class='Comment_Multi_Line'>/*------ 
          translator: %s is a SQL row locking clause such as FOR UPDATE */ 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"%s is not allowed with set-returning functions in the target list"</span><span class='Delimiter'>, 
</span>                        <a href="../../include/parser/analyze.h.html#LN39"><span class='Ref_to_Proto'>LCS_asString</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2605"><span class='Ref_to_Parameter'>strength</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end CheckSelectLocking &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Transform a FOR [KEY] UPDATE/SHARE clause 
 * 
 * This basically involves replacing names by integer relids. 
 * 
 * NB: if you need to change this, see also markQueryForLocking() 
 * in rewriteHandler.c, and isLockedRefname() in parse_relation.c. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2669"></a><span class='Declare_Function'>transformLockingClause</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>qry</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN734"><span class='Ref_to_Struct'>LockingClause</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>lc</span><span class='Delimiter'>, 
</span><a name="LN2670"></a>                       <span class='Keyword'>bool </span><span class='Declare_Parameter'>pushedDown</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2672"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>lockedRels</span> <span class='Operator'>= </span><a href="analyze.c.html#LN2669"><span class='Ref_to_Parameter'>lc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN737"><span class='Ref_to_Member'>lockedRels</span></a><span class='Delimiter'>; 
</span><a name="LN2673"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span><a name="LN2674"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>rt</span><span class='Delimiter'>; 
</span><a name="LN2675"></a>    <a href="../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN2676"></a>    <a href="../../include/nodes/parsenodes.h.html#LN734"><span class='Ref_to_Struct'>LockingClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>allrels</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/parser/analyze.h.html#LN40"><span class='Ref_to_Proto'>CheckSelectLocking</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2669"><span class='Ref_to_Parameter'>qry</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2669"><span class='Ref_to_Parameter'>lc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN738"><span class='Ref_to_Member'>strength</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* make a clause we can pass down to subqueries to select all rels */ 
</span>    <a href="analyze.c.html#LN2676"><span class='Ref_To_Local'>allrels</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN734"><span class='Ref_to_Struct'>LockingClause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN2676"><span class='Ref_To_Local'>allrels</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN737"><span class='Ref_to_Member'>lockedRels</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* indicates all rels */ 
</span>    <a href="analyze.c.html#LN2676"><span class='Ref_To_Local'>allrels</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN738"><span class='Ref_to_Member'>strength</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN2669"><span class='Ref_to_Parameter'>lc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN738"><span class='Ref_to_Member'>strength</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN2676"><span class='Ref_To_Local'>allrels</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN739"><span class='Ref_to_Member'>waitPolicy</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN2669"><span class='Ref_to_Parameter'>lc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN739"><span class='Ref_to_Member'>waitPolicy</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN2672"><span class='Ref_To_Local'>lockedRels</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* all regular tables used in query */ 
</span>        <a href="analyze.c.html#LN2675"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2674"><span class='Ref_To_Local'>rt</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2669"><span class='Ref_to_Parameter'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN134"><span class='Ref_to_Member'>rtable</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN2692"></a>            <a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2674"><span class='Ref_To_Local'>rt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Operator'>++</span><a href="analyze.c.html#LN2675"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN2692"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>case</span> <a href="../../include/nodes/parsenodes.h.html#LN922"><span class='Ref_to_EnumConst'>RTE_RELATION</span></a><span class='Operator'>: 
</span>                    <a href="../../include/parser/analyze.h.html#LN41"><span class='Ref_to_Proto'>applyLockingClause</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2669"><span class='Ref_to_Parameter'>qry</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2675"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2669"><span class='Ref_to_Parameter'>lc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN738"><span class='Ref_to_Member'>strength</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2669"><span class='Ref_to_Parameter'>lc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN739"><span class='Ref_to_Member'>waitPolicy</span></a><span class='Delimiter'>, 
</span>                                       <a href="analyze.c.html#LN2670"><span class='Ref_to_Parameter'>pushedDown</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="analyze.c.html#LN2692"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1027"><span class='Ref_to_Member'>requiredPerms</span></a> <span class='Operator'>|= </span><a href="../../include/nodes/parsenodes.h.html#LN87"><span class='Ref_to_Const'>ACL_SELECT_FOR_UPDATE</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>case</span> <a href="../../include/nodes/parsenodes.h.html#LN923"><span class='Ref_to_EnumConst'>RTE_SUBQUERY</span></a><span class='Operator'>: 
</span>                    <a href="../../include/parser/analyze.h.html#LN41"><span class='Ref_to_Proto'>applyLockingClause</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2669"><span class='Ref_to_Parameter'>qry</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2675"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2669"><span class='Ref_to_Parameter'>lc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN738"><span class='Ref_to_Member'>strength</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2669"><span class='Ref_to_Parameter'>lc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN739"><span class='Ref_to_Member'>waitPolicy</span></a><span class='Delimiter'>, 
</span>                                       <a href="analyze.c.html#LN2670"><span class='Ref_to_Parameter'>pushedDown</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * FOR UPDATE/SHARE of subquery is propagated to all of 
                     * subquery's rels, too.  We could do this later (based on 
                     * the marking of the subquery RTE) but it is convenient 
                     * to have local knowledge in each query level about which 
                     * rels need to be opened with RowShareLock. 
                     */ 
</span>                    <a href="analyze.c.html#LN76"><span class='Ref_to_Proto'>transformLockingClause</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2669"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2692"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN954"><span class='Ref_to_Member'>subquery</span></a><span class='Delimiter'>, 
</span>                                           <a href="analyze.c.html#LN2676"><span class='Ref_To_Local'>allrels</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>default</span><span class='Operator'>: 
</span>                    <span class='Comment_Multi_Line'>/* ignore JOIN, SPECIAL, FUNCTION, VALUES, CTE RTEs */ 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch rte-&GT;rtekind &raquo; </span> 
        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if lockedRels==NIL &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* just the named tables */ 
</span>        <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2673"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2672"><span class='Ref_To_Local'>lockedRels</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN2727"></a>            <a href="../../include/nodes/primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>thisrel</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2673"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* For simplicity we insist on unqualified alias names here */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN2727"><span class='Ref_To_Local'>thisrel</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN65"><span class='Ref_to_Member'>catalogname</span></a> <span class='Operator'>|| </span><a href="analyze.c.html#LN2727"><span class='Ref_To_Local'>thisrel</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN66"><span class='Ref_to_Member'>schemaname</span></a><span class='Parentheses'>) 
</span>                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_SYNTAX_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                <span class='Comment_Multi_Line'>/*------ 
                  translator: %s is a SQL row locking clause such as FOR UPDATE */ 
</span>                         <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"%s must specify unqualified relation names"</span><span class='Delimiter'>, 
</span>                                <a href="../../include/parser/analyze.h.html#LN39"><span class='Ref_to_Proto'>LCS_asString</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2669"><span class='Ref_to_Parameter'>lc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN738"><span class='Ref_to_Member'>strength</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                         <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2669"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2727"><span class='Ref_To_Local'>thisrel</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN72"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
            <a href="analyze.c.html#LN2675"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2674"><span class='Ref_To_Local'>rt</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2669"><span class='Ref_to_Parameter'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN134"><span class='Ref_to_Member'>rtable</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN2742"></a>                <a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2674"><span class='Ref_To_Local'>rt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Operator'>++</span><a href="analyze.c.html#LN2675"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="analyze.c.html#LN2742"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1023"><span class='Ref_to_Member'>eref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN41"><span class='Ref_to_Member'>aliasname</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2727"><span class='Ref_To_Local'>thisrel</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN67"><span class='Ref_to_Member'>relname</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN2742"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Control'>case</span> <a href="../../include/nodes/parsenodes.h.html#LN922"><span class='Ref_to_EnumConst'>RTE_RELATION</span></a><span class='Operator'>: 
</span>                            <a href="../../include/parser/analyze.h.html#LN41"><span class='Ref_to_Proto'>applyLockingClause</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2669"><span class='Ref_to_Parameter'>qry</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2675"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2669"><span class='Ref_to_Parameter'>lc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN738"><span class='Ref_to_Member'>strength</span></a><span class='Delimiter'>, 
</span>                                               <a href="analyze.c.html#LN2669"><span class='Ref_to_Parameter'>lc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN739"><span class='Ref_to_Member'>waitPolicy</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2670"><span class='Ref_to_Parameter'>pushedDown</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                            <a href="analyze.c.html#LN2742"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1027"><span class='Ref_to_Member'>requiredPerms</span></a> <span class='Operator'>|= </span><a href="../../include/nodes/parsenodes.h.html#LN87"><span class='Ref_to_Const'>ACL_SELECT_FOR_UPDATE</span></a><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Control'>case</span> <a href="../../include/nodes/parsenodes.h.html#LN923"><span class='Ref_to_EnumConst'>RTE_SUBQUERY</span></a><span class='Operator'>: 
</span>                            <a href="../../include/parser/analyze.h.html#LN41"><span class='Ref_to_Proto'>applyLockingClause</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2669"><span class='Ref_to_Parameter'>qry</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2675"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2669"><span class='Ref_to_Parameter'>lc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN738"><span class='Ref_to_Member'>strength</span></a><span class='Delimiter'>, 
</span>                                               <a href="analyze.c.html#LN2669"><span class='Ref_to_Parameter'>lc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN739"><span class='Ref_to_Member'>waitPolicy</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2670"><span class='Ref_to_Parameter'>pushedDown</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                            <span class='Comment_Multi_Line'>/* see comment above */ 
</span>                            <a href="analyze.c.html#LN76"><span class='Ref_to_Proto'>transformLockingClause</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2669"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2742"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN954"><span class='Ref_to_Member'>subquery</span></a><span class='Delimiter'>, 
</span>                                                   <a href="analyze.c.html#LN2676"><span class='Ref_To_Local'>allrels</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Control'>case</span> <a href="../../include/nodes/parsenodes.h.html#LN924"><span class='Ref_to_EnumConst'>RTE_JOIN</span></a><span class='Operator'>: 
</span>                            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                            <span class='Comment_Multi_Line'>/*------ 
                              translator: %s is a SQL row locking clause such as FOR UPDATE */ 
</span>                                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"%s cannot be applied to a join"</span><span class='Delimiter'>, 
</span>                                            <a href="../../include/parser/analyze.h.html#LN39"><span class='Ref_to_Proto'>LCS_asString</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2669"><span class='Ref_to_Parameter'>lc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN738"><span class='Ref_to_Member'>strength</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                             <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2669"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2727"><span class='Ref_To_Local'>thisrel</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN72"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Control'>case</span> <a href="../../include/nodes/parsenodes.h.html#LN925"><span class='Ref_to_EnumConst'>RTE_FUNCTION</span></a><span class='Operator'>: 
</span>                            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                            <span class='Comment_Multi_Line'>/*------ 
                              translator: %s is a SQL row locking clause such as FOR UPDATE */ 
</span>                                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"%s cannot be applied to a function"</span><span class='Delimiter'>, 
</span>                                        <a href="../../include/parser/analyze.h.html#LN39"><span class='Ref_to_Proto'>LCS_asString</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2669"><span class='Ref_to_Parameter'>lc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN738"><span class='Ref_to_Member'>strength</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                             <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2669"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2727"><span class='Ref_To_Local'>thisrel</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN72"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Control'>case</span> <a href="../../include/nodes/parsenodes.h.html#LN926"><span class='Ref_to_EnumConst'>RTE_TABLEFUNC</span></a><span class='Operator'>: 
</span>                            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                            <span class='Comment_Multi_Line'>/*------ 
                              translator: %s is a SQL row locking clause such as FOR UPDATE */ 
</span>                            <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"%s cannot be applied to a table function"</span><span class='Delimiter'>, 
</span>                                   <a href="../../include/parser/analyze.h.html#LN39"><span class='Ref_to_Proto'>LCS_asString</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2669"><span class='Ref_to_Parameter'>lc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN738"><span class='Ref_to_Member'>strength</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                             <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2669"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2727"><span class='Ref_To_Local'>thisrel</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN72"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Control'>case</span> <a href="../../include/nodes/parsenodes.h.html#LN927"><span class='Ref_to_EnumConst'>RTE_VALUES</span></a><span class='Operator'>: 
</span>                            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                            <span class='Comment_Multi_Line'>/*------ 
                              translator: %s is a SQL row locking clause such as FOR UPDATE */ 
</span>                                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"%s cannot be applied to VALUES"</span><span class='Delimiter'>, 
</span>                                            <a href="../../include/parser/analyze.h.html#LN39"><span class='Ref_to_Proto'>LCS_asString</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2669"><span class='Ref_to_Parameter'>lc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN738"><span class='Ref_to_Member'>strength</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                             <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2669"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2727"><span class='Ref_To_Local'>thisrel</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN72"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Control'>case</span> <a href="../../include/nodes/parsenodes.h.html#LN928"><span class='Ref_to_EnumConst'>RTE_CTE</span></a><span class='Operator'>: 
</span>                            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                            <span class='Comment_Multi_Line'>/*------ 
                              translator: %s is a SQL row locking clause such as FOR UPDATE */ 
</span>                               <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"%s cannot be applied to a WITH query"</span><span class='Delimiter'>, 
</span>                                      <a href="../../include/parser/analyze.h.html#LN39"><span class='Ref_to_Proto'>LCS_asString</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2669"><span class='Ref_to_Parameter'>lc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN738"><span class='Ref_to_Member'>strength</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                             <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2669"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2727"><span class='Ref_To_Local'>thisrel</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN72"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Control'>case</span> <a href="../../include/nodes/parsenodes.h.html#LN929"><span class='Ref_to_EnumConst'>RTE_NAMEDTUPLESTORE</span></a><span class='Operator'>: 
</span>                            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                            <span class='Comment_Multi_Line'>/*------ 
                              translator: %s is a SQL row locking clause such as FOR UPDATE */ 
</span>                                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"%s cannot be applied to a named tuplestore"</span><span class='Delimiter'>, 
</span>                                            <a href="../../include/parser/analyze.h.html#LN39"><span class='Ref_to_Proto'>LCS_asString</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2669"><span class='Ref_to_Parameter'>lc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN738"><span class='Ref_to_Member'>strength</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                             <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2669"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2727"><span class='Ref_To_Local'>thisrel</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN72"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Control'>default</span><span class='Operator'>: 
</span>                            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized RTE type: %d"</span><span class='Delimiter'>, 
</span>                                 <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="analyze.c.html#LN2742"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch rte-&GT;rtekind &raquo; </span> 
                    <span class='Control'>break</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* out of foreach loop */ 
</span>                <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if strcmp(rte-&GT;eref-&GT;ali... &raquo; </span> 
            <span class='Delimiter'>} 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN2674"><span class='Ref_To_Local'>rt</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span><a href="../../bin/scripts/vacuumdb.c.html#LN25"><span class='Ref_to_Const'>ERRCODE_UNDEFINED_TABLE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                <span class='Comment_Multi_Line'>/*------ 
                  translator: %s is a SQL row locking clause such as FOR UPDATE */ 
</span>                         <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"relation \"%s\" in %s clause not found in FROM clause"</span><span class='Delimiter'>, 
</span>                                <a href="analyze.c.html#LN2727"><span class='Ref_To_Local'>thisrel</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN67"><span class='Ref_to_Member'>relname</span></a><span class='Delimiter'>, 
</span>                                <a href="../../include/parser/analyze.h.html#LN39"><span class='Ref_to_Proto'>LCS_asString</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2669"><span class='Ref_to_Parameter'>lc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN738"><span class='Ref_to_Member'>strength</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                         <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2669"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2727"><span class='Ref_To_Local'>thisrel</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN72"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end transformLockingClause &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Record locking info for a single rangetable item 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2840"></a><span class='Declare_Function'>applyLockingClause</span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>qry</span><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> <span class='Declare_Parameter'>rtindex</span><span class='Delimiter'>, 
</span><a name="LN2841"></a>                   <a href="../../include/nodes/lockoptions.h.html#LN20"><span class='Ref_to_Enum'>LockClauseStrength</span></a> <span class='Declare_Parameter'>strength</span><span class='Delimiter'>, </span><a href="../../include/nodes/lockoptions.h.html#LN35"><span class='Ref_to_Enum'>LockWaitPolicy</span></a> <span class='Declare_Parameter'>waitPolicy</span><span class='Delimiter'>, 
</span><a name="LN2842"></a>                   <span class='Keyword'>bool </span><span class='Declare_Parameter'>pushedDown</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2844"></a>    <a href="../../include/nodes/parsenodes.h.html#LN1278"><span class='Ref_to_Struct'>RowMarkClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rc</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="analyze.c.html#LN2841"><span class='Ref_to_Parameter'>strength</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/lockoptions.h.html#LN22"><span class='Ref_to_EnumConst'>LCS_NONE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* else caller error */ 
</span> 
    <span class='Comment_Multi_Line'>/* If it's an explicit clause, make sure hasForUpdate gets set */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="analyze.c.html#LN2842"><span class='Ref_to_Parameter'>pushedDown</span></a><span class='Parentheses'>) 
</span>        <a href="analyze.c.html#LN2840"><span class='Ref_to_Parameter'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN129"><span class='Ref_to_Member'>hasForUpdate</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Check for pre-existing entry for same rtindex */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="analyze.c.html#LN2844"><span class='Ref_To_Local'>rc</span></a> <span class='Operator'>= </span><a href="../../include/parser/parsetree.h.html#LN76"><span class='Ref_to_Proto'>get_parse_rowmark</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2840"><span class='Ref_to_Parameter'>qry</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2840"><span class='Ref_to_Parameter'>rtindex</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * If the same RTE is specified with more than one locking strength, 
         * use the strongest.  (Reasonable, since you can't take both a shared 
         * and exclusive lock at the same time; it'll end up being exclusive 
         * anyway.) 
         * 
         * Similarly, if the same RTE is specified with more than one lock 
         * wait policy, consider that NOWAIT wins over SKIP LOCKED, which in 
         * turn wins over waiting for the lock (the default).  This is a bit 
         * more debatable but raising an error doesn't seem helpful. (Consider 
         * for instance SELECT FOR UPDATE NOWAIT from a view that internally 
         * contains a plain FOR UPDATE spec.)  Having NOWAIT win over SKIP 
         * LOCKED is reasonable since the former throws an error in case of 
         * coming across a locked tuple, which may be undesirable in some 
         * cases but it seems better than silently returning inconsistent 
         * results. 
         * 
         * And of course pushedDown becomes false if any clause is explicit. 
         */ 
</span>        <a href="analyze.c.html#LN2844"><span class='Ref_To_Local'>rc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1282"><span class='Ref_to_Member'>strength</span></a> <span class='Operator'>= </span><a href="../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN10"><span class='Ref_to_Macro'>Max</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2844"><span class='Ref_To_Local'>rc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1282"><span class='Ref_to_Member'>strength</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2841"><span class='Ref_to_Parameter'>strength</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN2844"><span class='Ref_To_Local'>rc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1283"><span class='Ref_to_Member'>waitPolicy</span></a> <span class='Operator'>= </span><a href="../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN10"><span class='Ref_to_Macro'>Max</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2844"><span class='Ref_To_Local'>rc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1283"><span class='Ref_to_Member'>waitPolicy</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2841"><span class='Ref_to_Parameter'>waitPolicy</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyze.c.html#LN2844"><span class='Ref_To_Local'>rc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1284"><span class='Ref_to_Member'>pushedDown</span></a> <span class='Operator'>&= </span><a href="analyze.c.html#LN2842"><span class='Ref_to_Parameter'>pushedDown</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if (rc=get_parse_rowmark... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Make a new RowMarkClause */ 
</span>    <a href="analyze.c.html#LN2844"><span class='Ref_To_Local'>rc</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1278"><span class='Ref_to_Struct'>RowMarkClause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN2844"><span class='Ref_To_Local'>rc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1281"><span class='Ref_to_Member'>rti</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN2840"><span class='Ref_to_Parameter'>rtindex</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN2844"><span class='Ref_To_Local'>rc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1282"><span class='Ref_to_Member'>strength</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN2841"><span class='Ref_to_Parameter'>strength</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN2844"><span class='Ref_To_Local'>rc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1283"><span class='Ref_to_Member'>waitPolicy</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN2841"><span class='Ref_to_Parameter'>waitPolicy</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN2844"><span class='Ref_To_Local'>rc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1284"><span class='Ref_to_Member'>pushedDown</span></a> <span class='Operator'>= </span><a href="analyze.c.html#LN2842"><span class='Ref_to_Parameter'>pushedDown</span></a><span class='Delimiter'>; 
</span>    <a href="analyze.c.html#LN2840"><span class='Ref_to_Parameter'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN160"><span class='Ref_to_Member'>rowMarks</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2840"><span class='Ref_to_Parameter'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN160"><span class='Ref_to_Member'>rowMarks</span></a><span class='Delimiter'>, </span><a href="analyze.c.html#LN2844"><span class='Ref_To_Local'>rc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end applyLockingClause &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Coverage testing for raw_expression_tree_walker(). 
 * 
 * When enabled, we run raw_expression_tree_walker() over every DML statement 
 * submitted to parse analysis.  Without this provision, that function is only 
 * applied in limited cases involving CTEs, and we don't really want to have 
 * to test everything inside as well as outside a CTE. 
 */ 
</span><span class='Directive'>#ifdef</span> RAW_EXPRESSION_COVERAGE_TEST 
 
<span class='Keyword'>static bool 
</span><a name="LN2900"></a><span class='Declare_Function'>test_raw_expression_coverage</span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyze.c.html#LN2900"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="../../include/nodes/nodeFuncs.h.html#LN72"><span class='Ref_to_Proto'>raw_expression_tree_walker</span></a><span class='Parentheses'>(</span><a href="analyze.c.html#LN2900"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, 
</span>                                      <a href="analyze.c.html#LN79"><span class='Ref_to_Proto'>test_raw_expression_coverage</span></a><span class='Delimiter'>, 
</span>                                      <a href="analyze.c.html#LN2900"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Directive'>#endif</span>   <span class='Comment_Single_Line'>/* RAW_EXPRESSION_COVERAGE_TEST */ 
</span></pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>