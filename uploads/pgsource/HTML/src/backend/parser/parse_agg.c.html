<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\parser\parse_agg.c</title>
<LINK REL=StyleSheet HREF="../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\parser\parse_agg.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:44 2017
</td></tr>
<tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * parse_agg.c 
 *    handle aggregates and window functions in parser 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * 
 * IDENTIFICATION 
 *    src/backend/parser/parse_agg.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_aggregate.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_constraint_fn.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_type.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/makefuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/nodeFuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/tlist.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/var.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_agg.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_clause.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_coerce.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_expr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parsetree.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"rewrite/rewriteManip.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/builtins.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/lsyscache.h"</span> 
 
 
<span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN35"></a>    <a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Member'>pstate</span><span class='Delimiter'>; 
</span><a name="LN36"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>min_varlevel</span><span class='Delimiter'>; 
</span><a name="LN37"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>min_agglevel</span><span class='Delimiter'>; 
</span><a name="LN38"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>sublevels_up</span><span class='Delimiter'>; 
</span><a name="LN39"></a>} <span class='Declare_Typedef'>check_agg_arguments_context</span><span class='Delimiter'>; 
</span> 
<span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN43"></a>    <a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Member'>pstate</span><span class='Delimiter'>; 
</span><a name="LN44"></a>    <a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Member'>qry</span><span class='Delimiter'>; 
</span><a name="LN45"></a>    <a href="../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Member'>root</span><span class='Delimiter'>; 
</span><a name="LN46"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>groupClauses</span><span class='Delimiter'>; 
</span><a name="LN47"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>groupClauseCommonVars</span><span class='Delimiter'>; 
</span><a name="LN48"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>have_non_var_grouping</span><span class='Delimiter'>; 
</span><a name="LN49"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>      <span class='Operator'>**</span><span class='Declare_Member'>func_grouped_rels</span><span class='Delimiter'>; 
</span><a name="LN50"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>sublevels_up</span><span class='Delimiter'>; 
</span><a name="LN51"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>in_agg_direct_args</span><span class='Delimiter'>; 
</span><a name="LN52"></a>} <span class='Declare_Typedef'>check_ungrouped_columns_context</span><span class='Delimiter'>; 
</span> 
<a name="LN54"></a><span class='Keyword'>static int </span><span class='Declare_Prototype'>check_agg_arguments</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, 
</span><a name="LN55"></a>                    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>directargs</span><span class='Delimiter'>, 
</span><a name="LN56"></a>                    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>args</span><span class='Delimiter'>, 
</span><a name="LN57"></a>                    <a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>filter</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN58"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>check_agg_arguments_walker</span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, 
</span><a name="LN59"></a>                           <a href="parse_agg.c.html#LN33"><span class='Ref_to_Typedef'>check_agg_arguments_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN60"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>check_ungrouped_columns</span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>qry</span><span class='Delimiter'>, 
</span><a name="LN61"></a>                        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>groupClauses</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>groupClauseVars</span><span class='Delimiter'>, 
</span><a name="LN62"></a>                        <span class='Keyword'>bool </span><span class='Declare_Parameter'>have_non_var_grouping</span><span class='Delimiter'>, 
</span><a name="LN63"></a>                        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>func_grouped_rels</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN64"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>check_ungrouped_columns_walker</span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, 
</span><a name="LN65"></a>                               <a href="parse_agg.c.html#LN41"><span class='Ref_to_Typedef'>check_ungrouped_columns_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN66"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>finalize_grouping_exprs</span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>qry</span><span class='Delimiter'>, 
</span><a name="LN67"></a>                        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>groupClauses</span><span class='Delimiter'>, </span><a href="../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN68"></a>                        <span class='Keyword'>bool </span><span class='Declare_Parameter'>have_non_var_grouping</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN69"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>finalize_grouping_exprs_walker</span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, 
</span><a name="LN70"></a>                               <a href="parse_agg.c.html#LN41"><span class='Ref_to_Typedef'>check_ungrouped_columns_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN71"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>check_agglevels_and_constraints</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>expr</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN72"></a><span class='Keyword'>static </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>expand_groupingset_node</span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1230"><span class='Ref_to_Struct'>GroupingSet</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>gs</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN73"></a><span class='Keyword'>static </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>make_agg_arg</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>argtype</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>argcollation</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * transformAggregateCall - 
 *      Finish initial transformation of an aggregate call 
 * 
 * parse_func.c has recognized the function as an aggregate, and has set up 
 * all the fields of the Aggref except aggargtypes, aggdirectargs, args, 
 * aggorder, aggdistinct and agglevelsup.  The passed-in args list has been 
 * through standard expression transformation and type coercion to match the 
 * agg's declared arg types, while the passed-in aggorder list hasn't been 
 * transformed at all. 
 * 
 * Here we separate the args list into direct and aggregated args, storing the 
 * former in agg-&GT;aggdirectargs and the latter in agg-&GT;args.  The regular 
 * args, but not the direct args, are converted into a targetlist by inserting 
 * TargetEntry nodes.  We then transform the aggorder and agg_distinct 
 * specifications to produce lists of SortGroupClause nodes for agg-&GT;aggorder 
 * and agg-&GT;aggdistinct.  (For a regular aggregate, this might result in 
 * adding resjunk expressions to the targetlist; but for ordered-set 
 * aggregates the aggorder list will always be one-to-one with the aggregated 
 * args.) 
 * 
 * We must also determine which query level the aggregate actually belongs to, 
 * set agglevelsup accordingly, and mark p_hasAggs true in the corresponding 
 * pstate level. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN102"></a><span class='Declare_Function'>transformAggregateCall</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>agg</span><span class='Delimiter'>, 
</span><a name="LN103"></a>                       <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>args</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggorder</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>agg_distinct</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN105"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>argtypes</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN106"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>tlist</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN107"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>torder</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN108"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>tdistinct</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN109"></a>    <a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a>  <span class='Declare_Local'>attno</span> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span><a name="LN110"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>save_next_resno</span><span class='Delimiter'>; 
</span><a name="LN111"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Before separating the args into direct and aggregated args, make a list 
     * of their data type OIDs for use later. 
     */ 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN111"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN103"><span class='Ref_to_Parameter'>args</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN119"></a>        <a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>arg</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN111"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="parse_agg.c.html#LN105"><span class='Ref_To_Local'>argtypes</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN162"><span class='Ref_to_Func'>lappend_oid</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN105"><span class='Ref_To_Local'>argtypes</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN119"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="parse_agg.c.html#LN102"><span class='Ref_to_Parameter'>agg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN298"><span class='Ref_to_Member'>aggargtypes</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN105"><span class='Ref_To_Local'>argtypes</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/catalog/pg_aggregate.h.html#LN128"><span class='Ref_to_Macro'>AGGKIND_IS_ORDERED_SET</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN102"><span class='Ref_to_Parameter'>agg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN307"><span class='Ref_to_Member'>aggkind</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * For an ordered-set agg, the args list includes direct args and 
         * aggregated args; we must split them apart. 
         */ 
</span><a name="LN131"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>numDirectArgs</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN103"><span class='Ref_to_Parameter'>args</span></a><span class='Parentheses'>) </span><span class='Operator'>- </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN103"><span class='Ref_to_Parameter'>aggorder</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN132"></a>        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>aargs</span><span class='Delimiter'>; 
</span><a name="LN133"></a>        <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc2</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN131"><span class='Ref_To_Local'>numDirectArgs</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="parse_agg.c.html#LN132"><span class='Ref_To_Local'>aargs</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN269"><span class='Ref_to_Proto'>list_copy_tail</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN103"><span class='Ref_to_Parameter'>args</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN131"><span class='Ref_To_Local'>numDirectArgs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_agg.c.html#LN102"><span class='Ref_to_Parameter'>agg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN299"><span class='Ref_to_Member'>aggdirectargs</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN220"><span class='Ref_to_Proto'>list_truncate</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN103"><span class='Ref_to_Parameter'>args</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN131"><span class='Ref_To_Local'>numDirectArgs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Build a tlist from the aggregated args, and make a sortlist entry 
         * for each one.  Note that the expressions in the SortBy nodes are 
         * ignored (they are the raw versions of the transformed args); we are 
         * just looking at the sort information in the SortBy nodes. 
         */ 
</span>        <a href="../../include/nodes/pg_list.h.html#LN179"><span class='Ref_to_Macro'>forboth</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN111"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN132"><span class='Ref_To_Local'>aargs</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN133"><span class='Ref_To_Local'>lc2</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN103"><span class='Ref_to_Parameter'>aggorder</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN148"></a>            <a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>arg</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN111"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN149"></a>            <a href="../../include/nodes/parsenodes.h.html#LN465"><span class='Ref_to_Struct'>SortBy</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>sortby</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN465"><span class='Ref_to_Struct'>SortBy</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN133"><span class='Ref_To_Local'>lc2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN150"></a>            <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* We don't bother to assign column names to the entries */ 
</span>            <a href="parse_agg.c.html#LN150"><span class='Ref_To_Local'>tle</span></a> <span class='Operator'>= </span><a href="../../include/nodes/makefuncs.h.html#LN40"><span class='Ref_to_Proto'>makeTargetEntry</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN148"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN109"><span class='Ref_To_Local'>attno</span></a><span class='Operator'>++</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="parse_agg.c.html#LN106"><span class='Ref_To_Local'>tlist</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN106"><span class='Ref_To_Local'>tlist</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN150"><span class='Ref_To_Local'>tle</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="parse_agg.c.html#LN107"><span class='Ref_To_Local'>torder</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_clause.h.html#LN48"><span class='Ref_to_Proto'>addTargetToSortList</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN102"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN150"><span class='Ref_To_Local'>tle</span></a><span class='Delimiter'>, 
</span>                                         <a href="parse_agg.c.html#LN107"><span class='Ref_To_Local'>torder</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN106"><span class='Ref_To_Local'>tlist</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN149"><span class='Ref_To_Local'>sortby</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Never any DISTINCT in an ordered-set agg */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_agg.c.html#LN103"><span class='Ref_to_Parameter'>agg_distinct</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if AGGKIND_IS_ORDERED_SE... &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Regular aggregate, so it has no direct args */ 
</span>        <a href="parse_agg.c.html#LN102"><span class='Ref_to_Parameter'>agg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN299"><span class='Ref_to_Member'>aggdirectargs</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Transform the plain list of Exprs into a targetlist. 
         */ 
</span>        <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN111"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN103"><span class='Ref_to_Parameter'>args</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN173"></a>            <a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>arg</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN111"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN174"></a>            <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* We don't bother to assign column names to the entries */ 
</span>            <a href="parse_agg.c.html#LN174"><span class='Ref_To_Local'>tle</span></a> <span class='Operator'>= </span><a href="../../include/nodes/makefuncs.h.html#LN40"><span class='Ref_to_Proto'>makeTargetEntry</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN173"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN109"><span class='Ref_To_Local'>attno</span></a><span class='Operator'>++</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="parse_agg.c.html#LN106"><span class='Ref_To_Local'>tlist</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN106"><span class='Ref_To_Local'>tlist</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN174"><span class='Ref_To_Local'>tle</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If we have an ORDER BY, transform it.  This will add columns to the 
         * tlist if they appear in ORDER BY but weren't already in the arg 
         * list.  They will be marked resjunk = true so we can tell them apart 
         * from regular aggregate arguments later. 
         * 
         * We need to mess with p_next_resno since it will be used to number 
         * any new targetlist entries. 
         */ 
</span>        <a href="parse_agg.c.html#LN110"><span class='Ref_To_Local'>save_next_resno</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN102"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN183"><span class='Ref_to_Member'>p_next_resno</span></a><span class='Delimiter'>; 
</span>        <a href="parse_agg.c.html#LN102"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN183"><span class='Ref_to_Member'>p_next_resno</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN109"><span class='Ref_To_Local'>attno</span></a><span class='Delimiter'>; 
</span> 
        <a href="parse_agg.c.html#LN107"><span class='Ref_To_Local'>torder</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_clause.h.html#LN31"><span class='Ref_to_Proto'>transformSortClause</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN102"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                     <a href="parse_agg.c.html#LN103"><span class='Ref_to_Parameter'>aggorder</span></a><span class='Delimiter'>, 
</span>                                     <span class='Operator'>&</span><a href="parse_agg.c.html#LN106"><span class='Ref_To_Local'>tlist</span></a><span class='Delimiter'>, 
</span>                                     <a href="../../include/parser/parse_node.h.html#LN52"><span class='Ref_to_EnumConst'>EXPR_KIND_ORDER_BY</span></a><span class='Delimiter'>, 
</span>                                     <span class='Boolean'>true </span><span class='Comment_Multi_Line'>/* force SQL99 rules */ </span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If we have DISTINCT, transform that to produce a distinctList. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN103"><span class='Ref_to_Parameter'>agg_distinct</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="parse_agg.c.html#LN108"><span class='Ref_To_Local'>tdistinct</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_clause.h.html#LN39"><span class='Ref_to_Proto'>transformDistinctClause</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN102"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_agg.c.html#LN106"><span class='Ref_To_Local'>tlist</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN107"><span class='Ref_To_Local'>torder</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Remove this check if executor support for hashed distinct for 
             * aggregates is ever added. 
             */ 
</span>            <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN111"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN108"><span class='Ref_To_Local'>tdistinct</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN212"></a>                <a href="../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sortcl</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN111"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN212"><span class='Ref_To_Local'>sortcl</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1166"><span class='Ref_to_Member'>sortop</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span><a name="LN216"></a>                    <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><a href="../../include/optimizer/tlist.h.html#LN39"><span class='Ref_to_Proto'>get_sortgroupclause_expr</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN212"><span class='Ref_To_Local'>sortcl</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN106"><span class='Ref_To_Local'>tlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_UNDEFINED_FUNCTION<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not identify an ordering operator for type %s"</span><span class='Delimiter'>, 
</span>                                    <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN216"><span class='Ref_To_Local'>expr</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>, 
</span>                             <a href="../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"Aggregates with DISTINCT must be able to sort their inputs."</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN102"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN216"><span class='Ref_To_Local'>expr</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if agg_distinct &raquo; </span> 
 
        <a href="parse_agg.c.html#LN102"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN183"><span class='Ref_to_Member'>p_next_resno</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN110"><span class='Ref_To_Local'>save_next_resno</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Update the Aggref with the transformation results */ 
</span>    <a href="parse_agg.c.html#LN102"><span class='Ref_to_Parameter'>agg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN300"><span class='Ref_to_Member'>args</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN106"><span class='Ref_To_Local'>tlist</span></a><span class='Delimiter'>; 
</span>    <a href="parse_agg.c.html#LN102"><span class='Ref_to_Parameter'>agg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN301"><span class='Ref_to_Member'>aggorder</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN107"><span class='Ref_To_Local'>torder</span></a><span class='Delimiter'>; 
</span>    <a href="parse_agg.c.html#LN102"><span class='Ref_to_Parameter'>agg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN302"><span class='Ref_to_Member'>aggdistinct</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN108"><span class='Ref_To_Local'>tdistinct</span></a><span class='Delimiter'>; 
</span> 
    <a href="parse_agg.c.html#LN71"><span class='Ref_to_Proto'>check_agglevels_and_constraints</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN102"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN102"><span class='Ref_to_Parameter'>agg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end transformAggregateCall &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * transformGroupingFunc 
 *      Transform a GROUPING expression 
 * 
 * GROUPING() behaves very like an aggregate.  Processing of levels and nesting 
 * is done as for aggregates.  We set p_hasAggs for these expressions too. 
 */ 
</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN247"></a><span class='Declare_Function'>transformGroupingFunc</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN337"><span class='Ref_to_Struct'>GroupingFunc</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>p</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN249"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span><a name="LN250"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>args</span> <span class='Operator'>= </span><a href="parse_agg.c.html#LN247"><span class='Ref_to_Parameter'>p</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN340"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>; 
</span><a name="LN251"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result_list</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN252"></a>    <a href="../../include/nodes/primnodes.h.html#LN337"><span class='Ref_to_Struct'>GroupingFunc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>result</span> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN337"><span class='Ref_to_Struct'>GroupingFunc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN250"><span class='Ref_To_Local'>args</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT; </span><span class='Number'>31</span><span class='Parentheses'>)</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_TOO_MANY_ARGUMENTS<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"GROUPING must have fewer than 32 arguments"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN247"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN247"><span class='Ref_to_Parameter'>p</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN345"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN249"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN250"><span class='Ref_To_Local'>args</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN262"></a>        <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>current_result</span><span class='Delimiter'>; 
</span> 
        <a href="parse_agg.c.html#LN262"><span class='Ref_To_Local'>current_result</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_expr.h.html#LN21"><span class='Ref_to_Proto'>transformExpr</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN247"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN249"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN247"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN182"><span class='Ref_to_Member'>p_expr_kind</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* acceptability of expressions is checked later */ 
</span> 
        <a href="parse_agg.c.html#LN251"><span class='Ref_To_Local'>result_list</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN251"><span class='Ref_To_Local'>result_list</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN262"><span class='Ref_To_Local'>current_result</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="parse_agg.c.html#LN252"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN340"><span class='Ref_to_Member'>args</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN251"><span class='Ref_To_Local'>result_list</span></a><span class='Delimiter'>; 
</span>    <a href="parse_agg.c.html#LN252"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN345"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN247"><span class='Ref_to_Parameter'>p</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN345"><span class='Ref_to_Member'>location</span></a><span class='Delimiter'>; 
</span> 
    <a href="parse_agg.c.html#LN71"><span class='Ref_to_Proto'>check_agglevels_and_constraints</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN247"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN252"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN252"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end transformGroupingFunc &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Aggregate functions and grouping operations (which are combined in the spec 
 * as &LT;set function specification&GT;) are very similar with regard to level and 
 * nesting restrictions (though we allow a lot more things than the spec does). 
 * Centralise those restrictions here. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN286"></a><span class='Declare_Function'>check_agglevels_and_constraints</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>expr</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN288"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>directargs</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN289"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>args</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN290"></a>    <a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>filter</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN291"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>min_varlevel</span><span class='Delimiter'>; 
</span><a name="LN292"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>location</span> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span><a name="LN293"></a>    <a href="../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>p_levelsup</span><span class='Delimiter'>; 
</span><a name="LN294"></a>    <span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Local'>err</span><span class='Delimiter'>; 
</span><a name="LN295"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>errkind</span><span class='Delimiter'>; 
</span><a name="LN296"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isAgg</span> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN286"><span class='Ref_to_Parameter'>expr</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN296"><span class='Ref_To_Local'>isAgg</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN300"></a>        <a href="../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>agg</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN286"><span class='Ref_to_Parameter'>expr</span></a><span class='Delimiter'>; 
</span> 
        <a href="parse_agg.c.html#LN288"><span class='Ref_To_Local'>directargs</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN300"><span class='Ref_To_Local'>agg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN299"><span class='Ref_to_Member'>aggdirectargs</span></a><span class='Delimiter'>; 
</span>        <a href="parse_agg.c.html#LN289"><span class='Ref_To_Local'>args</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN300"><span class='Ref_To_Local'>agg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN300"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>; 
</span>        <a href="parse_agg.c.html#LN290"><span class='Ref_To_Local'>filter</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN300"><span class='Ref_To_Local'>agg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN303"><span class='Ref_to_Member'>aggfilter</span></a><span class='Delimiter'>; 
</span>        <a href="parse_agg.c.html#LN292"><span class='Ref_To_Local'>location</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN300"><span class='Ref_To_Local'>agg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN310"><span class='Ref_to_Member'>location</span></a><span class='Delimiter'>; 
</span>        <a href="parse_agg.c.html#LN293"><span class='Ref_To_Local'>p_levelsup</span></a> <span class='Operator'>= &</span><a href="parse_agg.c.html#LN300"><span class='Ref_To_Local'>agg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN308"><span class='Ref_to_Member'>agglevelsup</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span><a name="LN310"></a>        <a href="../../include/nodes/primnodes.h.html#LN337"><span class='Ref_to_Struct'>GroupingFunc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>grp</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN337"><span class='Ref_to_Struct'>GroupingFunc</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN286"><span class='Ref_to_Parameter'>expr</span></a><span class='Delimiter'>; 
</span> 
        <a href="parse_agg.c.html#LN289"><span class='Ref_To_Local'>args</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN310"><span class='Ref_To_Local'>grp</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN340"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>; 
</span>        <a href="parse_agg.c.html#LN292"><span class='Ref_To_Local'>location</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN310"><span class='Ref_To_Local'>grp</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN345"><span class='Ref_to_Member'>location</span></a><span class='Delimiter'>; 
</span>        <a href="parse_agg.c.html#LN293"><span class='Ref_To_Local'>p_levelsup</span></a> <span class='Operator'>= &</span><a href="parse_agg.c.html#LN310"><span class='Ref_To_Local'>grp</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN344"><span class='Ref_to_Member'>agglevelsup</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Check the arguments to compute the aggregate's level and detect 
     * improper nesting. 
     */ 
</span>    <a href="parse_agg.c.html#LN291"><span class='Ref_To_Local'>min_varlevel</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN54"><span class='Ref_to_Proto'>check_agg_arguments</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN286"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                       <a href="parse_agg.c.html#LN288"><span class='Ref_To_Local'>directargs</span></a><span class='Delimiter'>, 
</span>                                       <a href="parse_agg.c.html#LN289"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>, 
</span>                                       <a href="parse_agg.c.html#LN290"><span class='Ref_To_Local'>filter</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Operator'>*</span><a href="parse_agg.c.html#LN293"><span class='Ref_To_Local'>p_levelsup</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN291"><span class='Ref_To_Local'>min_varlevel</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Mark the correct pstate level as having aggregates */ 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN291"><span class='Ref_To_Local'>min_varlevel</span></a><span class='Operator'>-- &GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="parse_agg.c.html#LN286"><span class='Ref_to_Parameter'>pstate</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN286"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN166"><span class='Ref_to_Member'>parentParseState</span></a><span class='Delimiter'>; 
</span>    <a href="parse_agg.c.html#LN286"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN195"><span class='Ref_to_Member'>p_hasAggs</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Check to see if the aggregate function is in an invalid place within 
     * its aggregation query. 
     * 
     * For brevity we support two schemes for reporting an error here: set 
     * "err" to a custom message, or set "errkind" true if the error context 
     * is sufficiently identified by what ParseExprKindName will return, *and* 
     * what it will return is just a SQL keyword.  (Otherwise, use a custom 
     * message to avoid creating translation problems.) 
     */ 
</span>    <a href="parse_agg.c.html#LN294"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="parse_agg.c.html#LN295"><span class='Ref_To_Local'>errkind</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN286"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN182"><span class='Ref_to_Member'>p_expr_kind</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN34"><span class='Ref_to_EnumConst'>EXPR_KIND_NONE</span></a><span class='Operator'>: 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* can't happen */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN35"><span class='Ref_to_EnumConst'>EXPR_KIND_OTHER</span></a><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Accept aggregate/grouping here; caller must throw error if 
             * wanted 
             */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN36"><span class='Ref_to_EnumConst'>EXPR_KIND_JOIN_ON</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN37"><span class='Ref_to_EnumConst'>EXPR_KIND_JOIN_USING</span></a><span class='Operator'>: 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN296"><span class='Ref_To_Local'>isAgg</span></a><span class='Parentheses'>) 
</span>                <a href="parse_agg.c.html#LN294"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"aggregate functions are not allowed in JOIN conditions"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="parse_agg.c.html#LN294"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"grouping operations are not allowed in JOIN conditions"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN38"><span class='Ref_to_EnumConst'>EXPR_KIND_FROM_SUBSELECT</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* Should only be possible in a LATERAL subquery */ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN286"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN174"><span class='Ref_to_Member'>p_lateral_active</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Aggregate/grouping scope rules make it worth being explicit 
             * here 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN296"><span class='Ref_To_Local'>isAgg</span></a><span class='Parentheses'>) 
</span>                <a href="parse_agg.c.html#LN294"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"aggregate functions are not allowed in FROM clause of their own query level"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="parse_agg.c.html#LN294"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"grouping operations are not allowed in FROM clause of their own query level"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN39"><span class='Ref_to_EnumConst'>EXPR_KIND_FROM_FUNCTION</span></a><span class='Operator'>: 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN296"><span class='Ref_To_Local'>isAgg</span></a><span class='Parentheses'>) 
</span>                <a href="parse_agg.c.html#LN294"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"aggregate functions are not allowed in functions in FROM"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="parse_agg.c.html#LN294"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"grouping operations are not allowed in functions in FROM"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN40"><span class='Ref_to_EnumConst'>EXPR_KIND_WHERE</span></a><span class='Operator'>: 
</span>            <a href="parse_agg.c.html#LN295"><span class='Ref_To_Local'>errkind</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN68"><span class='Ref_to_EnumConst'>EXPR_KIND_POLICY</span></a><span class='Operator'>: 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN296"><span class='Ref_To_Local'>isAgg</span></a><span class='Parentheses'>) 
</span>                <a href="parse_agg.c.html#LN294"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"aggregate functions are not allowed in policy expressions"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="parse_agg.c.html#LN294"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"grouping operations are not allowed in policy expressions"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN41"><span class='Ref_to_EnumConst'>EXPR_KIND_HAVING</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* okay */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN42"><span class='Ref_to_EnumConst'>EXPR_KIND_FILTER</span></a><span class='Operator'>: 
</span>            <a href="parse_agg.c.html#LN295"><span class='Ref_To_Local'>errkind</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN43"><span class='Ref_to_EnumConst'>EXPR_KIND_WINDOW_PARTITION</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* okay */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN44"><span class='Ref_to_EnumConst'>EXPR_KIND_WINDOW_ORDER</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* okay */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN45"><span class='Ref_to_EnumConst'>EXPR_KIND_WINDOW_FRAME_RANGE</span></a><span class='Operator'>: 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN296"><span class='Ref_To_Local'>isAgg</span></a><span class='Parentheses'>) 
</span>                <a href="parse_agg.c.html#LN294"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"aggregate functions are not allowed in window RANGE"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="parse_agg.c.html#LN294"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"grouping operations are not allowed in window RANGE"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN46"><span class='Ref_to_EnumConst'>EXPR_KIND_WINDOW_FRAME_ROWS</span></a><span class='Operator'>: 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN296"><span class='Ref_To_Local'>isAgg</span></a><span class='Parentheses'>) 
</span>                <a href="parse_agg.c.html#LN294"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"aggregate functions are not allowed in window ROWS"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="parse_agg.c.html#LN294"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"grouping operations are not allowed in window ROWS"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN47"><span class='Ref_to_EnumConst'>EXPR_KIND_SELECT_TARGET</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* okay */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN48"><span class='Ref_to_EnumConst'>EXPR_KIND_INSERT_TARGET</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN49"><span class='Ref_to_EnumConst'>EXPR_KIND_UPDATE_SOURCE</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN50"><span class='Ref_to_EnumConst'>EXPR_KIND_UPDATE_TARGET</span></a><span class='Operator'>: 
</span>            <a href="parse_agg.c.html#LN295"><span class='Ref_To_Local'>errkind</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN51"><span class='Ref_to_EnumConst'>EXPR_KIND_GROUP_BY</span></a><span class='Operator'>: 
</span>            <a href="parse_agg.c.html#LN295"><span class='Ref_To_Local'>errkind</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN52"><span class='Ref_to_EnumConst'>EXPR_KIND_ORDER_BY</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* okay */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN53"><span class='Ref_to_EnumConst'>EXPR_KIND_DISTINCT_ON</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* okay */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN54"><span class='Ref_to_EnumConst'>EXPR_KIND_LIMIT</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN55"><span class='Ref_to_EnumConst'>EXPR_KIND_OFFSET</span></a><span class='Operator'>: 
</span>            <a href="parse_agg.c.html#LN295"><span class='Ref_To_Local'>errkind</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN56"><span class='Ref_to_EnumConst'>EXPR_KIND_RETURNING</span></a><span class='Operator'>: 
</span>            <a href="parse_agg.c.html#LN295"><span class='Ref_To_Local'>errkind</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN57"><span class='Ref_to_EnumConst'>EXPR_KIND_VALUES</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN58"><span class='Ref_to_EnumConst'>EXPR_KIND_VALUES_SINGLE</span></a><span class='Operator'>: 
</span>            <a href="parse_agg.c.html#LN295"><span class='Ref_To_Local'>errkind</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN59"><span class='Ref_to_EnumConst'>EXPR_KIND_CHECK_CONSTRAINT</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN60"><span class='Ref_to_EnumConst'>EXPR_KIND_DOMAIN_CHECK</span></a><span class='Operator'>: 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN296"><span class='Ref_To_Local'>isAgg</span></a><span class='Parentheses'>) 
</span>                <a href="parse_agg.c.html#LN294"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"aggregate functions are not allowed in check constraints"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="parse_agg.c.html#LN294"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"grouping operations are not allowed in check constraints"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN61"><span class='Ref_to_EnumConst'>EXPR_KIND_COLUMN_DEFAULT</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN62"><span class='Ref_to_EnumConst'>EXPR_KIND_FUNCTION_DEFAULT</span></a><span class='Operator'>: 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN296"><span class='Ref_To_Local'>isAgg</span></a><span class='Parentheses'>) 
</span>                <a href="parse_agg.c.html#LN294"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"aggregate functions are not allowed in DEFAULT expressions"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="parse_agg.c.html#LN294"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"grouping operations are not allowed in DEFAULT expressions"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN63"><span class='Ref_to_EnumConst'>EXPR_KIND_INDEX_EXPRESSION</span></a><span class='Operator'>: 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN296"><span class='Ref_To_Local'>isAgg</span></a><span class='Parentheses'>) 
</span>                <a href="parse_agg.c.html#LN294"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"aggregate functions are not allowed in index expressions"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="parse_agg.c.html#LN294"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"grouping operations are not allowed in index expressions"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN64"><span class='Ref_to_EnumConst'>EXPR_KIND_INDEX_PREDICATE</span></a><span class='Operator'>: 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN296"><span class='Ref_To_Local'>isAgg</span></a><span class='Parentheses'>) 
</span>                <a href="parse_agg.c.html#LN294"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"aggregate functions are not allowed in index predicates"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="parse_agg.c.html#LN294"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"grouping operations are not allowed in index predicates"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN65"><span class='Ref_to_EnumConst'>EXPR_KIND_ALTER_COL_TRANSFORM</span></a><span class='Operator'>: 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN296"><span class='Ref_To_Local'>isAgg</span></a><span class='Parentheses'>) 
</span>                <a href="parse_agg.c.html#LN294"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"aggregate functions are not allowed in transform expressions"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="parse_agg.c.html#LN294"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"grouping operations are not allowed in transform expressions"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN66"><span class='Ref_to_EnumConst'>EXPR_KIND_EXECUTE_PARAMETER</span></a><span class='Operator'>: 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN296"><span class='Ref_To_Local'>isAgg</span></a><span class='Parentheses'>) 
</span>                <a href="parse_agg.c.html#LN294"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"aggregate functions are not allowed in EXECUTE parameters"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="parse_agg.c.html#LN294"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"grouping operations are not allowed in EXECUTE parameters"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN67"><span class='Ref_to_EnumConst'>EXPR_KIND_TRIGGER_WHEN</span></a><span class='Operator'>: 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN296"><span class='Ref_To_Local'>isAgg</span></a><span class='Parentheses'>) 
</span>                <a href="parse_agg.c.html#LN294"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"aggregate functions are not allowed in trigger WHEN conditions"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="parse_agg.c.html#LN294"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"grouping operations are not allowed in trigger WHEN conditions"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN69"><span class='Ref_to_EnumConst'>EXPR_KIND_PARTITION_EXPRESSION</span></a><span class='Operator'>: 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN296"><span class='Ref_To_Local'>isAgg</span></a><span class='Parentheses'>) 
</span>                <a href="parse_agg.c.html#LN294"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"aggregate functions are not allowed in partition key expression"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="parse_agg.c.html#LN294"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"grouping operations are not allowed in partition key expression"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * There is intentionally no default: case here, so that the 
             * compiler will warn if we add a new ParseExprKind without 
             * extending this switch.  If we do see an unrecognized value at 
             * runtime, the behavior will be the same as for EXPR_KIND_OTHER, 
             * which is sane anyway. 
             */ 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch pstate-&GT;p_expr_kind &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN294"><span class='Ref_To_Local'>err</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_GROUPING_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN825"><span class='Ref_to_Func'>errmsg_internal</span></a><span class='Parentheses'>(</span><span class='String'>"%s"</span><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN294"><span class='Ref_To_Local'>err</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN286"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN292"><span class='Ref_To_Local'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN295"><span class='Ref_To_Local'>errkind</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN296"><span class='Ref_To_Local'>isAgg</span></a><span class='Parentheses'>) 
</span>            <span class='Comment_Multi_Line'>/* translator: %s is name of a SQL construct, eg GROUP BY */ 
</span>            <a href="parse_agg.c.html#LN294"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"aggregate functions are not allowed in %s"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <span class='Comment_Multi_Line'>/* translator: %s is name of a SQL construct, eg GROUP BY */ 
</span>            <a href="parse_agg.c.html#LN294"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"grouping operations are not allowed in %s"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_GROUPING_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN825"><span class='Ref_to_Func'>errmsg_internal</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN294"><span class='Ref_To_Local'>err</span></a><span class='Delimiter'>, 
</span>                                 <a href="../../include/parser/parse_expr.h.html#LN23"><span class='Ref_to_Proto'>ParseExprKindName</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN286"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN182"><span class='Ref_to_Member'>p_expr_kind</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                 <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN286"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN292"><span class='Ref_To_Local'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end check_agglevels_and_constraints &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * check_agg_arguments 
 *    Scan the arguments of an aggregate function to determine the 
 *    aggregate's semantic level (zero is the current select's level, 
 *    one is its parent, etc). 
 * 
 * The aggregate's level is the same as the level of the lowest-level variable 
 * or aggregate in its aggregated arguments (including any ORDER BY columns) 
 * or filter expression; or if it contains no variables at all, we presume it 
 * to be local. 
 * 
 * Vars/Aggs in direct arguments are *not* counted towards determining the 
 * agg's level, as those arguments aren't evaluated per-row but only 
 * per-group, and so in some sense aren't really agg arguments.  However, 
 * this can mean that we decide an agg is upper-level even when its direct 
 * args contain lower-level Vars/Aggs, and that case has to be disallowed. 
 * (This is a little strange, but the SQL standard seems pretty definite that 
 * direct args are not to be considered when setting the agg's level.) 
 * 
 * We also take this opportunity to detect any aggregates or window functions 
 * nested within the arguments.  We can throw error immediately if we find 
 * a window function.  Aggregates are a bit trickier because it's only an 
 * error if the inner aggregate is of the same semantic level as the outer, 
 * which we can't know until we finish scanning the arguments. 
 */ 
</span><span class='Keyword'>static int 
</span><a name="LN568"></a><span class='Declare_Function'>check_agg_arguments</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, 
</span><a name="LN569"></a>                    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>directargs</span><span class='Delimiter'>, 
</span><a name="LN570"></a>                    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>args</span><span class='Delimiter'>, 
</span><a name="LN571"></a>                    <a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>filter</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN573"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>agglevel</span><span class='Delimiter'>; 
</span><a name="LN574"></a>    <a href="parse_agg.c.html#LN33"><span class='Ref_to_Typedef'>check_agg_arguments_context</span></a> <span class='Declare_Local'>context</span><span class='Delimiter'>; 
</span> 
    <a href="parse_agg.c.html#LN574"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_agg.c.html#LN35"><span class='Ref_to_Member'>pstate</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN568"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>; 
</span>    <a href="parse_agg.c.html#LN574"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_agg.c.html#LN36"><span class='Ref_to_Member'>min_varlevel</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* signifies nothing found yet */ 
</span>    <a href="parse_agg.c.html#LN574"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_agg.c.html#LN37"><span class='Ref_to_Member'>min_agglevel</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <a href="parse_agg.c.html#LN574"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_agg.c.html#LN38"><span class='Ref_to_Member'>sublevels_up</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="../../include/nodes/nodeFuncs.h.html#LN52"><span class='Ref_to_Proto'>expression_tree_walker</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN570"><span class='Ref_to_Parameter'>args</span></a><span class='Delimiter'>, 
</span>                                  <a href="parse_agg.c.html#LN58"><span class='Ref_to_Proto'>check_agg_arguments_walker</span></a><span class='Delimiter'>, 
</span>                                  <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="parse_agg.c.html#LN574"><span class='Ref_To_Local'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="../../include/nodes/nodeFuncs.h.html#LN52"><span class='Ref_to_Proto'>expression_tree_walker</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN571"><span class='Ref_to_Parameter'>filter</span></a><span class='Delimiter'>, 
</span>                                  <a href="parse_agg.c.html#LN58"><span class='Ref_to_Proto'>check_agg_arguments_walker</span></a><span class='Delimiter'>, 
</span>                                  <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="parse_agg.c.html#LN574"><span class='Ref_To_Local'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we found no vars nor aggs at all, it's a level-zero aggregate; 
     * otherwise, its level is the minimum of vars or aggs. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN574"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_agg.c.html#LN36"><span class='Ref_to_Member'>min_varlevel</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN574"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_agg.c.html#LN37"><span class='Ref_to_Member'>min_agglevel</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <a href="parse_agg.c.html#LN573"><span class='Ref_To_Local'>agglevel</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="parse_agg.c.html#LN573"><span class='Ref_To_Local'>agglevel</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN574"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_agg.c.html#LN37"><span class='Ref_to_Member'>min_agglevel</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN574"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_agg.c.html#LN37"><span class='Ref_to_Member'>min_agglevel</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="parse_agg.c.html#LN573"><span class='Ref_To_Local'>agglevel</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN574"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_agg.c.html#LN36"><span class='Ref_to_Member'>min_varlevel</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="parse_agg.c.html#LN573"><span class='Ref_To_Local'>agglevel</span></a> <span class='Operator'>= </span><a href="../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN11"><span class='Ref_to_Macro'>Min</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN574"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_agg.c.html#LN36"><span class='Ref_to_Member'>min_varlevel</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN574"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_agg.c.html#LN37"><span class='Ref_to_Member'>min_agglevel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If there's a nested aggregate of the same semantic level, complain. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN573"><span class='Ref_To_Local'>agglevel</span></a> <span class='Operator'>== </span><a href="parse_agg.c.html#LN574"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_agg.c.html#LN37"><span class='Ref_to_Member'>min_agglevel</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN610"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>aggloc</span><span class='Delimiter'>; 
</span> 
        <a href="parse_agg.c.html#LN610"><span class='Ref_To_Local'>aggloc</span></a> <span class='Operator'>= </span><a href="../../include/rewrite/rewriteManip.h.html#LN58"><span class='Ref_to_Proto'>locate_agg_of_level</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN570"><span class='Ref_to_Parameter'>args</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN573"><span class='Ref_To_Local'>agglevel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN610"><span class='Ref_To_Local'>aggloc</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <a href="parse_agg.c.html#LN610"><span class='Ref_To_Local'>aggloc</span></a> <span class='Operator'>= </span><a href="../../include/rewrite/rewriteManip.h.html#LN58"><span class='Ref_to_Proto'>locate_agg_of_level</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN571"><span class='Ref_to_Parameter'>filter</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN573"><span class='Ref_To_Local'>agglevel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_GROUPING_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"aggregate function calls cannot be nested"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN568"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN610"><span class='Ref_To_Local'>aggloc</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now check for vars/aggs in the direct arguments, and throw error if 
     * needed.  Note that we allow a Var of the agg's semantic level, but not 
     * an Agg of that level.  In principle such Aggs could probably be 
     * supported, but it would create an ordering dependency among the 
     * aggregates at execution time.  Since the case appears neither to be 
     * required by spec nor particularly useful, we just treat it as a 
     * nested-aggregate situation. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN569"><span class='Ref_to_Parameter'>directargs</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="parse_agg.c.html#LN574"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_agg.c.html#LN36"><span class='Ref_to_Member'>min_varlevel</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <a href="parse_agg.c.html#LN574"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_agg.c.html#LN37"><span class='Ref_to_Member'>min_agglevel</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="../../include/nodes/nodeFuncs.h.html#LN52"><span class='Ref_to_Proto'>expression_tree_walker</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN569"><span class='Ref_to_Parameter'>directargs</span></a><span class='Delimiter'>, 
</span>                                      <a href="parse_agg.c.html#LN58"><span class='Ref_to_Proto'>check_agg_arguments_walker</span></a><span class='Delimiter'>, 
</span>                                      <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="parse_agg.c.html#LN574"><span class='Ref_To_Local'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN574"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_agg.c.html#LN36"><span class='Ref_to_Member'>min_varlevel</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="parse_agg.c.html#LN574"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_agg.c.html#LN36"><span class='Ref_to_Member'>min_varlevel</span></a> <span class='Operator'>&LT; </span><a href="parse_agg.c.html#LN573"><span class='Ref_To_Local'>agglevel</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_GROUPING_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"outer-level aggregate cannot contain a lower-level variable in its direct arguments"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN568"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                     <a href="../../include/optimizer/var.h.html#LN35"><span class='Ref_to_Proto'>locate_var_of_level</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN569"><span class='Ref_to_Parameter'>directargs</span></a><span class='Delimiter'>, 
</span>                                                    <a href="parse_agg.c.html#LN574"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_agg.c.html#LN36"><span class='Ref_to_Member'>min_varlevel</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN574"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_agg.c.html#LN37"><span class='Ref_to_Member'>min_agglevel</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="parse_agg.c.html#LN574"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_agg.c.html#LN37"><span class='Ref_to_Member'>min_agglevel</span></a> <span class='Operator'>&LT;= </span><a href="parse_agg.c.html#LN573"><span class='Ref_To_Local'>agglevel</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_GROUPING_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"aggregate function calls cannot be nested"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN568"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                     <a href="../../include/rewrite/rewriteManip.h.html#LN58"><span class='Ref_to_Proto'>locate_agg_of_level</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN569"><span class='Ref_to_Parameter'>directargs</span></a><span class='Delimiter'>, 
</span>                                                    <a href="parse_agg.c.html#LN574"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_agg.c.html#LN37"><span class='Ref_to_Member'>min_agglevel</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if directargs &raquo; </span> 
    <span class='Control'>return</span> <a href="parse_agg.c.html#LN573"><span class='Ref_To_Local'>agglevel</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end check_agg_arguments &raquo; </span> 
 
<span class='Keyword'>static bool 
</span><a name="LN656"></a><span class='Declare_Function'>check_agg_arguments_walker</span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, 
</span><a name="LN657"></a>                           <a href="parse_agg.c.html#LN33"><span class='Ref_to_Typedef'>check_agg_arguments_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN656"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN656"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN663"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>varlevelsup</span> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN656"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>varlevelsup<span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* convert levelsup to frame of reference of original query */ 
</span>        <a href="parse_agg.c.html#LN663"><span class='Ref_To_Local'>varlevelsup</span></a> <span class='Operator'>-= </span><a href="parse_agg.c.html#LN657"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN38"><span class='Ref_to_Member'>sublevels_up</span></a><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* ignore local vars of subqueries */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN663"><span class='Ref_To_Local'>varlevelsup</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN657"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN36"><span class='Ref_to_Member'>min_varlevel</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span> <span class='Operator'>|| 
</span>                <a href="parse_agg.c.html#LN657"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN36"><span class='Ref_to_Member'>min_varlevel</span></a> <span class='Operator'>&GT; </span><a href="parse_agg.c.html#LN663"><span class='Ref_To_Local'>varlevelsup</span></a><span class='Parentheses'>) 
</span>                <a href="parse_agg.c.html#LN657"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN36"><span class='Ref_to_Member'>min_varlevel</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN663"><span class='Ref_To_Local'>varlevelsup</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN656"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN678"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>agglevelsup</span> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN656"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>agglevelsup<span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* convert levelsup to frame of reference of original query */ 
</span>        <a href="parse_agg.c.html#LN678"><span class='Ref_To_Local'>agglevelsup</span></a> <span class='Operator'>-= </span><a href="parse_agg.c.html#LN657"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN38"><span class='Ref_to_Member'>sublevels_up</span></a><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* ignore local aggs of subqueries */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN678"><span class='Ref_To_Local'>agglevelsup</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN657"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN37"><span class='Ref_to_Member'>min_agglevel</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span> <span class='Operator'>|| 
</span>                <a href="parse_agg.c.html#LN657"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN37"><span class='Ref_to_Member'>min_agglevel</span></a> <span class='Operator'>&GT; </span><a href="parse_agg.c.html#LN678"><span class='Ref_To_Local'>agglevelsup</span></a><span class='Parentheses'>) 
</span>                <a href="parse_agg.c.html#LN657"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN37"><span class='Ref_to_Member'>min_agglevel</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN678"><span class='Ref_To_Local'>agglevelsup</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Comment_Multi_Line'>/* no need to examine args of the inner aggregate */ 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN656"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN337"><span class='Ref_to_Struct'>GroupingFunc</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN694"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>agglevelsup</span> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN337"><span class='Ref_to_Struct'>GroupingFunc</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN656"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>agglevelsup<span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* convert levelsup to frame of reference of original query */ 
</span>        <a href="parse_agg.c.html#LN694"><span class='Ref_To_Local'>agglevelsup</span></a> <span class='Operator'>-= </span><a href="parse_agg.c.html#LN657"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN38"><span class='Ref_to_Member'>sublevels_up</span></a><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* ignore local aggs of subqueries */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN694"><span class='Ref_To_Local'>agglevelsup</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN657"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN37"><span class='Ref_to_Member'>min_agglevel</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span> <span class='Operator'>|| 
</span>                <a href="parse_agg.c.html#LN657"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN37"><span class='Ref_to_Member'>min_agglevel</span></a> <span class='Operator'>&GT; </span><a href="parse_agg.c.html#LN694"><span class='Ref_To_Local'>agglevelsup</span></a><span class='Parentheses'>) 
</span>                <a href="parse_agg.c.html#LN657"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN37"><span class='Ref_to_Member'>min_agglevel</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN694"><span class='Ref_To_Local'>agglevelsup</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Comment_Multi_Line'>/* Continue and descend into subtree */ 
</span>    <span class='Delimiter'>} 
</span>    <span class='Comment_Multi_Line'>/* We can throw error on sight for a window function */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN656"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN351"><span class='Ref_to_Struct'>WindowFunc</span></a><span class='Parentheses'>))</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_GROUPING_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"aggregate function calls cannot contain window function calls"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN657"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN35"><span class='Ref_to_Member'>pstate</span></a><span class='Delimiter'>, 
</span>                                    <span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN351"><span class='Ref_to_Struct'>WindowFunc</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN656"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>location<span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN656"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Recurse into subselects */ 
</span><a name="LN717"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span> 
        <a href="parse_agg.c.html#LN657"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN38"><span class='Ref_to_Member'>sublevels_up</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <a href="parse_agg.c.html#LN717"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN57"><span class='Ref_to_Proto'>query_tree_walker</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN656"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, 
</span>                                   <a href="parse_agg.c.html#LN58"><span class='Ref_to_Proto'>check_agg_arguments_walker</span></a><span class='Delimiter'>, 
</span>                                   <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN657"><span class='Ref_to_Parameter'>context</span></a><span class='Delimiter'>, 
</span>                                   <span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_agg.c.html#LN657"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN38"><span class='Ref_to_Member'>sublevels_up</span></a><span class='Operator'>--</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <a href="parse_agg.c.html#LN717"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="../../include/nodes/nodeFuncs.h.html#LN52"><span class='Ref_to_Proto'>expression_tree_walker</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN656"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, 
</span>                                  <a href="parse_agg.c.html#LN58"><span class='Ref_to_Proto'>check_agg_arguments_walker</span></a><span class='Delimiter'>, 
</span>                                  <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN657"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end check_agg_arguments_walker &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * transformWindowFuncCall - 
 *      Finish initial transformation of a window function call 
 * 
 * parse_func.c has recognized the function as a window function, and has set 
 * up all the fields of the WindowFunc except winref.  Here we must (1) add 
 * the WindowDef to the pstate (if not a duplicate of one already present) and 
 * set winref to link to it; and (2) mark p_hasWindowFuncs true in the pstate. 
 * Unlike aggregates, only the most closely nested pstate level need be 
 * considered --- there are no "outer window functions" per SQL spec. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN745"></a><span class='Declare_Function'>transformWindowFuncCall</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN351"><span class='Ref_to_Struct'>WindowFunc</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>wfunc</span><span class='Delimiter'>, 
</span><a name="LN746"></a>                        <a href="../../include/nodes/parsenodes.h.html#LN483"><span class='Ref_to_Struct'>WindowDef</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>windef</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN748"></a>    <span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Local'>err</span><span class='Delimiter'>; 
</span><a name="LN749"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>errkind</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * A window function call can't contain another one (but aggs are OK). XXX 
     * is this required by spec, or just an unimplemented feature? 
     * 
     * Note: we don't need to check the filter expression here, because the 
     * context checks done below and in transformAggregateCall would have 
     * already rejected any window funcs or aggs within the filter. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN745"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN196"><span class='Ref_to_Member'>p_hasWindowFuncs</span></a> <span class='Operator'>&& 
</span>        <a href="../../include/rewrite/rewriteManip.h.html#LN59"><span class='Ref_to_Proto'>contain_windowfuncs</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN745"><span class='Ref_to_Parameter'>wfunc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN358"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>))</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_WINDOWING_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"window function calls cannot be nested"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN745"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                  <a href="../../include/rewrite/rewriteManip.h.html#LN60"><span class='Ref_to_Proto'>locate_windowfunc</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN745"><span class='Ref_to_Parameter'>wfunc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN358"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Check to see if the window function is in an invalid place within the 
     * query. 
     * 
     * For brevity we support two schemes for reporting an error here: set 
     * "err" to a custom message, or set "errkind" true if the error context 
     * is sufficiently identified by what ParseExprKindName will return, *and* 
     * what it will return is just a SQL keyword.  (Otherwise, use a custom 
     * message to avoid creating translation problems.) 
     */ 
</span>    <a href="parse_agg.c.html#LN748"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="parse_agg.c.html#LN749"><span class='Ref_To_Local'>errkind</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN745"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN182"><span class='Ref_to_Member'>p_expr_kind</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN34"><span class='Ref_to_EnumConst'>EXPR_KIND_NONE</span></a><span class='Operator'>: 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* can't happen */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN35"><span class='Ref_to_EnumConst'>EXPR_KIND_OTHER</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* Accept window func here; caller must throw error if wanted */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN36"><span class='Ref_to_EnumConst'>EXPR_KIND_JOIN_ON</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN37"><span class='Ref_to_EnumConst'>EXPR_KIND_JOIN_USING</span></a><span class='Operator'>: 
</span>            <a href="parse_agg.c.html#LN748"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"window functions are not allowed in JOIN conditions"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN38"><span class='Ref_to_EnumConst'>EXPR_KIND_FROM_SUBSELECT</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* can't get here, but just in case, throw an error */ 
</span>            <a href="parse_agg.c.html#LN749"><span class='Ref_To_Local'>errkind</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN39"><span class='Ref_to_EnumConst'>EXPR_KIND_FROM_FUNCTION</span></a><span class='Operator'>: 
</span>            <a href="parse_agg.c.html#LN748"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"window functions are not allowed in functions in FROM"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN40"><span class='Ref_to_EnumConst'>EXPR_KIND_WHERE</span></a><span class='Operator'>: 
</span>            <a href="parse_agg.c.html#LN749"><span class='Ref_To_Local'>errkind</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN68"><span class='Ref_to_EnumConst'>EXPR_KIND_POLICY</span></a><span class='Operator'>: 
</span>            <a href="parse_agg.c.html#LN748"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"window functions are not allowed in policy expressions"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN41"><span class='Ref_to_EnumConst'>EXPR_KIND_HAVING</span></a><span class='Operator'>: 
</span>            <a href="parse_agg.c.html#LN749"><span class='Ref_To_Local'>errkind</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN42"><span class='Ref_to_EnumConst'>EXPR_KIND_FILTER</span></a><span class='Operator'>: 
</span>            <a href="parse_agg.c.html#LN749"><span class='Ref_To_Local'>errkind</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN43"><span class='Ref_to_EnumConst'>EXPR_KIND_WINDOW_PARTITION</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN44"><span class='Ref_to_EnumConst'>EXPR_KIND_WINDOW_ORDER</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN45"><span class='Ref_to_EnumConst'>EXPR_KIND_WINDOW_FRAME_RANGE</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN46"><span class='Ref_to_EnumConst'>EXPR_KIND_WINDOW_FRAME_ROWS</span></a><span class='Operator'>: 
</span>            <a href="parse_agg.c.html#LN748"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"window functions are not allowed in window definitions"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN47"><span class='Ref_to_EnumConst'>EXPR_KIND_SELECT_TARGET</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* okay */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN48"><span class='Ref_to_EnumConst'>EXPR_KIND_INSERT_TARGET</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN49"><span class='Ref_to_EnumConst'>EXPR_KIND_UPDATE_SOURCE</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN50"><span class='Ref_to_EnumConst'>EXPR_KIND_UPDATE_TARGET</span></a><span class='Operator'>: 
</span>            <a href="parse_agg.c.html#LN749"><span class='Ref_To_Local'>errkind</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN51"><span class='Ref_to_EnumConst'>EXPR_KIND_GROUP_BY</span></a><span class='Operator'>: 
</span>            <a href="parse_agg.c.html#LN749"><span class='Ref_To_Local'>errkind</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN52"><span class='Ref_to_EnumConst'>EXPR_KIND_ORDER_BY</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* okay */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN53"><span class='Ref_to_EnumConst'>EXPR_KIND_DISTINCT_ON</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* okay */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN54"><span class='Ref_to_EnumConst'>EXPR_KIND_LIMIT</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN55"><span class='Ref_to_EnumConst'>EXPR_KIND_OFFSET</span></a><span class='Operator'>: 
</span>            <a href="parse_agg.c.html#LN749"><span class='Ref_To_Local'>errkind</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN56"><span class='Ref_to_EnumConst'>EXPR_KIND_RETURNING</span></a><span class='Operator'>: 
</span>            <a href="parse_agg.c.html#LN749"><span class='Ref_To_Local'>errkind</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN57"><span class='Ref_to_EnumConst'>EXPR_KIND_VALUES</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN58"><span class='Ref_to_EnumConst'>EXPR_KIND_VALUES_SINGLE</span></a><span class='Operator'>: 
</span>            <a href="parse_agg.c.html#LN749"><span class='Ref_To_Local'>errkind</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN59"><span class='Ref_to_EnumConst'>EXPR_KIND_CHECK_CONSTRAINT</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN60"><span class='Ref_to_EnumConst'>EXPR_KIND_DOMAIN_CHECK</span></a><span class='Operator'>: 
</span>            <a href="parse_agg.c.html#LN748"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"window functions are not allowed in check constraints"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN61"><span class='Ref_to_EnumConst'>EXPR_KIND_COLUMN_DEFAULT</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN62"><span class='Ref_to_EnumConst'>EXPR_KIND_FUNCTION_DEFAULT</span></a><span class='Operator'>: 
</span>            <a href="parse_agg.c.html#LN748"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"window functions are not allowed in DEFAULT expressions"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN63"><span class='Ref_to_EnumConst'>EXPR_KIND_INDEX_EXPRESSION</span></a><span class='Operator'>: 
</span>            <a href="parse_agg.c.html#LN748"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"window functions are not allowed in index expressions"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN64"><span class='Ref_to_EnumConst'>EXPR_KIND_INDEX_PREDICATE</span></a><span class='Operator'>: 
</span>            <a href="parse_agg.c.html#LN748"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"window functions are not allowed in index predicates"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN65"><span class='Ref_to_EnumConst'>EXPR_KIND_ALTER_COL_TRANSFORM</span></a><span class='Operator'>: 
</span>            <a href="parse_agg.c.html#LN748"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"window functions are not allowed in transform expressions"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN66"><span class='Ref_to_EnumConst'>EXPR_KIND_EXECUTE_PARAMETER</span></a><span class='Operator'>: 
</span>            <a href="parse_agg.c.html#LN748"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"window functions are not allowed in EXECUTE parameters"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN67"><span class='Ref_to_EnumConst'>EXPR_KIND_TRIGGER_WHEN</span></a><span class='Operator'>: 
</span>            <a href="parse_agg.c.html#LN748"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"window functions are not allowed in trigger WHEN conditions"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN69"><span class='Ref_to_EnumConst'>EXPR_KIND_PARTITION_EXPRESSION</span></a><span class='Operator'>: 
</span>            <a href="parse_agg.c.html#LN748"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"window functions are not allowed in partition key expression"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * There is intentionally no default: case here, so that the 
             * compiler will warn if we add a new ParseExprKind without 
             * extending this switch.  If we do see an unrecognized value at 
             * runtime, the behavior will be the same as for EXPR_KIND_OTHER, 
             * which is sane anyway. 
             */ 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch pstate-&GT;p_expr_kind &raquo; </span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN748"><span class='Ref_To_Local'>err</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_WINDOWING_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN825"><span class='Ref_to_Func'>errmsg_internal</span></a><span class='Parentheses'>(</span><span class='String'>"%s"</span><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN748"><span class='Ref_To_Local'>err</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN745"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN745"><span class='Ref_to_Parameter'>wfunc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN363"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN749"><span class='Ref_To_Local'>errkind</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_WINDOWING_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>        <span class='Comment_Multi_Line'>/* translator: %s is name of a SQL construct, eg GROUP BY */ 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"window functions are not allowed in %s"</span><span class='Delimiter'>, 
</span>                        <a href="../../include/parser/parse_expr.h.html#LN23"><span class='Ref_to_Proto'>ParseExprKindName</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN745"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN182"><span class='Ref_to_Member'>p_expr_kind</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                 <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN745"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN745"><span class='Ref_to_Parameter'>wfunc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN363"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the OVER clause just specifies a window name, find that WINDOW 
     * clause (which had better be present).  Otherwise, try to match all the 
     * properties of the OVER clause, and make a new entry in the p_windowdefs 
     * list if no luck. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN746"><span class='Ref_to_Parameter'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN486"><span class='Ref_to_Member'>name</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN900"></a>        <a href="../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Local'>winref</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN901"></a>        <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN746"><span class='Ref_to_Parameter'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN487"><span class='Ref_to_Member'>refname</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>&& 
</span>               <a href="parse_agg.c.html#LN746"><span class='Ref_to_Parameter'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN488"><span class='Ref_to_Member'>partitionClause</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>&& 
</span>               <a href="parse_agg.c.html#LN746"><span class='Ref_to_Parameter'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN489"><span class='Ref_to_Member'>orderClause</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>&& 
</span>               <a href="parse_agg.c.html#LN746"><span class='Ref_to_Parameter'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN490"><span class='Ref_to_Member'>frameOptions</span></a> <span class='Operator'>== </span><a href="../../include/nodes/parsenodes.h.html#LN524"><span class='Ref_to_Const'>FRAMEOPTION_DEFAULTS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN901"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN745"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN181"><span class='Ref_to_Member'>p_windowdefs</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN910"></a>            <a href="../../include/nodes/parsenodes.h.html#LN483"><span class='Ref_to_Struct'>WindowDef</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>refwin</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN483"><span class='Ref_to_Struct'>WindowDef</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN901"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="parse_agg.c.html#LN900"><span class='Ref_To_Local'>winref</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN910"><span class='Ref_To_Local'>refwin</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN486"><span class='Ref_to_Member'>name</span></a> <span class='Operator'>&& </span>strcmp<span class='Parentheses'>(</span><a href="parse_agg.c.html#LN910"><span class='Ref_To_Local'>refwin</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN486"><span class='Ref_to_Member'>name</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN746"><span class='Ref_to_Parameter'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN486"><span class='Ref_to_Member'>name</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <span class='Delimiter'>{ 
</span>                <a href="parse_agg.c.html#LN745"><span class='Ref_to_Parameter'>wfunc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN360"><span class='Ref_to_Member'>winref</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN900"><span class='Ref_To_Local'>winref</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN901"><span class='Ref_To_Local'>lc</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span>         <span class='Comment_Single_Line'>/* didn't find it? */ 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_UNDEFINED_OBJECT<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"window \"%s\" does not exist"</span><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN746"><span class='Ref_to_Parameter'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN486"><span class='Ref_to_Member'>name</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN745"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN746"><span class='Ref_to_Parameter'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN493"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if windef-&GT;name &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span><a name="LN927"></a>        <a href="../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Local'>winref</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN928"></a>        <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN928"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN745"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN181"><span class='Ref_to_Member'>p_windowdefs</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN932"></a>            <a href="../../include/nodes/parsenodes.h.html#LN483"><span class='Ref_to_Struct'>WindowDef</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>refwin</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN483"><span class='Ref_to_Struct'>WindowDef</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN928"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="parse_agg.c.html#LN927"><span class='Ref_To_Local'>winref</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN932"><span class='Ref_To_Local'>refwin</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN487"><span class='Ref_to_Member'>refname</span></a> <span class='Operator'>&& </span><a href="parse_agg.c.html#LN746"><span class='Ref_to_Parameter'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN487"><span class='Ref_to_Member'>refname</span></a> <span class='Operator'>&& 
</span>                strcmp<span class='Parentheses'>(</span><a href="parse_agg.c.html#LN932"><span class='Ref_To_Local'>refwin</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN487"><span class='Ref_to_Member'>refname</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN746"><span class='Ref_to_Parameter'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN487"><span class='Ref_to_Member'>refname</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                 <span class='Comment_Multi_Line'>/* matched on refname */ </span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_agg.c.html#LN932"><span class='Ref_To_Local'>refwin</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN487"><span class='Ref_to_Member'>refname</span></a> <span class='Operator'>&& !</span><a href="parse_agg.c.html#LN746"><span class='Ref_to_Parameter'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN487"><span class='Ref_to_Member'>refname</span></a><span class='Parentheses'>) 
</span>                 <span class='Comment_Multi_Line'>/* matched, no refname */ </span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN626"><span class='Ref_to_Proto'>equal</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN932"><span class='Ref_To_Local'>refwin</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN488"><span class='Ref_to_Member'>partitionClause</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN746"><span class='Ref_to_Parameter'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN488"><span class='Ref_to_Member'>partitionClause</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                <a href="../../include/nodes/nodes.h.html#LN626"><span class='Ref_to_Proto'>equal</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN932"><span class='Ref_To_Local'>refwin</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN489"><span class='Ref_to_Member'>orderClause</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN746"><span class='Ref_to_Parameter'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN489"><span class='Ref_to_Member'>orderClause</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                <a href="parse_agg.c.html#LN932"><span class='Ref_To_Local'>refwin</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN490"><span class='Ref_to_Member'>frameOptions</span></a> <span class='Operator'>== </span><a href="parse_agg.c.html#LN746"><span class='Ref_to_Parameter'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN490"><span class='Ref_to_Member'>frameOptions</span></a> <span class='Operator'>&& 
</span>                <a href="../../include/nodes/nodes.h.html#LN626"><span class='Ref_to_Proto'>equal</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN932"><span class='Ref_To_Local'>refwin</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN491"><span class='Ref_to_Member'>startOffset</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN746"><span class='Ref_to_Parameter'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN491"><span class='Ref_to_Member'>startOffset</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                <a href="../../include/nodes/nodes.h.html#LN626"><span class='Ref_to_Proto'>equal</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN932"><span class='Ref_To_Local'>refwin</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN492"><span class='Ref_to_Member'>endOffset</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN746"><span class='Ref_to_Parameter'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN492"><span class='Ref_to_Member'>endOffset</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* found a duplicate window specification */ 
</span>                <a href="parse_agg.c.html#LN745"><span class='Ref_to_Parameter'>wfunc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN360"><span class='Ref_to_Member'>winref</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN927"><span class='Ref_To_Local'>winref</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN928"><span class='Ref_To_Local'>lc</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span>         <span class='Comment_Single_Line'>/* didn't find it? */ 
</span>        <span class='Delimiter'>{ 
</span>            <a href="parse_agg.c.html#LN745"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN181"><span class='Ref_to_Member'>p_windowdefs</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN745"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN181"><span class='Ref_to_Member'>p_windowdefs</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN746"><span class='Ref_to_Parameter'>windef</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="parse_agg.c.html#LN745"><span class='Ref_to_Parameter'>wfunc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN360"><span class='Ref_to_Member'>winref</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN745"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN181"><span class='Ref_to_Member'>p_windowdefs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <a href="parse_agg.c.html#LN745"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN196"><span class='Ref_to_Member'>p_hasWindowFuncs</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end transformWindowFuncCall &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * parseCheckAggregates 
 *  Check for aggregates where they shouldn't be and improper grouping. 
 *  This function should be called after the target list and qualifications 
 *  are finalized. 
 * 
 *  Misplaced aggregates are now mostly detected in transformAggregateCall, 
 *  but it seems more robust to check for aggregates in recursive queries 
 *  only after everything is finalized.  In any case it's hard to detect 
 *  improper grouping on-the-fly, so we have to make another pass over the 
 *  query for that. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN976"></a><span class='Declare_Function'>parseCheckAggregates</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>qry</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN978"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>gset_common</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN979"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>groupClauses</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN980"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>groupClauseCommonVars</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN981"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>have_non_var_grouping</span><span class='Delimiter'>; 
</span><a name="LN982"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>func_grouped_rels</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN983"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span><a name="LN984"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>hasJoinRTEs</span><span class='Delimiter'>; 
</span><a name="LN985"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>hasSelfRefRTEs</span><span class='Delimiter'>; 
</span><a name="LN986"></a>    <a href="../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>root</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN987"></a>    <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>clause</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* This should only be called if we found aggregates or grouping */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN976"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN195"><span class='Ref_to_Member'>p_hasAggs</span></a> <span class='Operator'>|| </span><a href="parse_agg.c.html#LN976"><span class='Ref_to_Parameter'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a> <span class='Operator'>|| </span><a href="parse_agg.c.html#LN976"><span class='Ref_to_Parameter'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a> <span class='Operator'>|| </span><a href="parse_agg.c.html#LN976"><span class='Ref_to_Parameter'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN147"><span class='Ref_to_Member'>groupingSets</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we have grouping sets, expand them and find the intersection of all 
     * sets. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN976"><span class='Ref_to_Parameter'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN147"><span class='Ref_to_Member'>groupingSets</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * The limit of 4096 is arbitrary and exists simply to avoid resource 
         * issues from pathological constructs. 
         */ 
</span><a name="LN1002"></a>        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>gsets</span> <span class='Operator'>= </span><a href="../../include/parser/parse_agg.h.html#LN28"><span class='Ref_to_Proto'>expand_grouping_sets</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN976"><span class='Ref_to_Parameter'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN147"><span class='Ref_to_Member'>groupingSets</span></a><span class='Delimiter'>, </span><span class='Number'>4096</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_agg.c.html#LN1002"><span class='Ref_To_Local'>gsets</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_STATEMENT_TOO_COMPLEX<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"too many grouping sets present (maximum 4096)"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN976"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                        <a href="parse_agg.c.html#LN976"><span class='Ref_to_Parameter'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a> 
                                    <span class='Operator'>? </span><a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN976"><span class='Ref_to_Parameter'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Parentheses'>)</span> 
                               <span class='Operator'>: </span><a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN976"><span class='Ref_to_Parameter'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN147"><span class='Ref_to_Member'>groupingSets</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * The intersection will often be empty, so help things along by 
         * seeding the intersect with the smallest set. 
         */ 
</span>        <a href="parse_agg.c.html#LN978"><span class='Ref_To_Local'>gset_common</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1002"><span class='Ref_To_Local'>gsets</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN978"><span class='Ref_To_Local'>gset_common</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../include/nodes/pg_list.h.html#LN168"><span class='Ref_to_Macro'>for_each_cell</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN983"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1002"><span class='Ref_To_Local'>gsets</span></a><span class='Parentheses'>)))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="parse_agg.c.html#LN978"><span class='Ref_To_Local'>gset_common</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN246"><span class='Ref_to_Proto'>list_intersection_int</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN978"><span class='Ref_To_Local'>gset_common</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN983"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_agg.c.html#LN978"><span class='Ref_To_Local'>gset_common</span></a><span class='Parentheses'>) 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If there was only one grouping set in the expansion, AND if the 
         * groupClause is non-empty (meaning that the grouping set is not 
         * empty either), then we can ditch the grouping set and pretend we 
         * just had a normal GROUP BY. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1002"><span class='Ref_To_Local'>gsets</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>1</span> <span class='Operator'>&& </span><a href="parse_agg.c.html#LN976"><span class='Ref_to_Parameter'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Parentheses'>)</span> 
            <a href="parse_agg.c.html#LN976"><span class='Ref_to_Parameter'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN147"><span class='Ref_to_Member'>groupingSets</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if qry-&GT;groupingSets &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Scan the range table to see if there are JOIN or self-reference CTE 
     * entries.  We'll need this info below. 
     */ 
</span>    <a href="parse_agg.c.html#LN984"><span class='Ref_To_Local'>hasJoinRTEs</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN985"><span class='Ref_To_Local'>hasSelfRefRTEs</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN983"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN976"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1046"></a>        <a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN983"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1046"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../include/nodes/parsenodes.h.html#LN924"><span class='Ref_to_EnumConst'>RTE_JOIN</span></a><span class='Parentheses'>) 
</span>            <a href="parse_agg.c.html#LN984"><span class='Ref_To_Local'>hasJoinRTEs</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1046"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../include/nodes/parsenodes.h.html#LN928"><span class='Ref_to_EnumConst'>RTE_CTE</span></a> <span class='Operator'>&& </span><a href="parse_agg.c.html#LN1046"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1003"><span class='Ref_to_Member'>self_reference</span></a><span class='Parentheses'>) 
</span>            <a href="parse_agg.c.html#LN985"><span class='Ref_To_Local'>hasSelfRefRTEs</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Build a list of the acceptable GROUP BY expressions for use by 
     * check_ungrouped_columns(). 
     * 
     * We get the TLE, not just the expr, because GROUPING wants to know the 
     * sortgroupref. 
     */ 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN983"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN976"><span class='Ref_to_Parameter'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1063"></a>        <a href="../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>grpcl</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN983"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1064"></a>        <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>expr</span><span class='Delimiter'>; 
</span> 
        <a href="parse_agg.c.html#LN1064"><span class='Ref_To_Local'>expr</span></a> <span class='Operator'>= </span><a href="../../include/optimizer/tlist.h.html#LN37"><span class='Ref_to_Proto'>get_sortgroupclause_tle</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1063"><span class='Ref_To_Local'>grpcl</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN976"><span class='Ref_to_Parameter'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1064"><span class='Ref_To_Local'>expr</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* probably cannot happen */ 
</span> 
        <a href="parse_agg.c.html#LN979"><span class='Ref_To_Local'>groupClauses</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN215"><span class='Ref_to_Proto'>lcons</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1064"><span class='Ref_To_Local'>expr</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN979"><span class='Ref_To_Local'>groupClauses</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If there are join alias vars involved, we have to flatten them to the 
     * underlying vars, so that aliased and unaliased vars will be correctly 
     * taken as equal.  We can skip the expense of doing this if no rangetable 
     * entries are RTE_JOIN kind. We use the planner's flatten_join_alias_vars 
     * routine to do the flattening; it wants a PlannerInfo root node, which 
     * fortunately can be mostly dummy. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN984"><span class='Ref_To_Local'>hasJoinRTEs</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="parse_agg.c.html#LN986"><span class='Ref_To_Local'>root</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_agg.c.html#LN986"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN976"><span class='Ref_to_Parameter'>qry</span></a><span class='Delimiter'>; 
</span>        <a href="parse_agg.c.html#LN986"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/relation.h.html#LN286"><span class='Ref_to_Member'>planner_cxt</span></a> <span class='Operator'>= </span><a href="../utils/mmgr/mcxt.c.html#LN36"><span class='Ref_to_Global_Var'>CurrentMemoryContext</span></a><span class='Delimiter'>; 
</span>        <a href="parse_agg.c.html#LN986"><span class='Ref_To_Local'>root</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/relation.h.html#LN298"><span class='Ref_to_Member'>hasJoinRTEs</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
        <a href="parse_agg.c.html#LN979"><span class='Ref_To_Local'>groupClauses</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/optimizer/var.h.html#LN37"><span class='Ref_to_Proto'>flatten_join_alias_vars</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN986"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, 
</span>                                                      <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN979"><span class='Ref_To_Local'>groupClauses</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Detect whether any of the grouping expressions aren't simple Vars; if 
     * they're all Vars then we don't have to work so hard in the recursive 
     * scans.  (Note we have to flatten aliases before this.) 
     * 
     * Track Vars that are included in all grouping sets separately in 
     * groupClauseCommonVars, since these are the only ones we can use to 
     * check for functional dependencies. 
     */ 
</span>    <a href="parse_agg.c.html#LN981"><span class='Ref_To_Local'>have_non_var_grouping</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN983"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN979"><span class='Ref_To_Local'>groupClauses</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1104"></a>        <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN983"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1104"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="parse_agg.c.html#LN981"><span class='Ref_To_Local'>have_non_var_grouping</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_agg.c.html#LN976"><span class='Ref_to_Parameter'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN147"><span class='Ref_to_Member'>groupingSets</span></a> <span class='Operator'>|| 
</span>                 <a href="../../include/nodes/pg_list.h.html#LN230"><span class='Ref_to_Proto'>list_member_int</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN978"><span class='Ref_To_Local'>gset_common</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN1104"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1369"><span class='Ref_to_Member'>ressortgroupref</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="parse_agg.c.html#LN980"><span class='Ref_To_Local'>groupClauseCommonVars</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN980"><span class='Ref_To_Local'>groupClauseCommonVars</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN1104"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Check the targetlist and HAVING clause for ungrouped variables. 
     * 
     * Note: because we check resjunk tlist elements as well as regular ones, 
     * this will also find ungrouped variables that came from ORDER BY and 
     * WINDOW clauses.  For that matter, it's also going to examine the 
     * grouping expressions themselves --- but they'll all pass the test ... 
     * 
     * We also finalize GROUPING expressions, but for that we need to traverse 
     * the original (unflattened) clause in order to modify nodes. 
     */ 
</span>    <a href="parse_agg.c.html#LN987"><span class='Ref_To_Local'>clause</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN976"><span class='Ref_to_Parameter'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Delimiter'>; 
</span>    <a href="parse_agg.c.html#LN66"><span class='Ref_to_Proto'>finalize_grouping_exprs</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN987"><span class='Ref_To_Local'>clause</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN976"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN976"><span class='Ref_to_Parameter'>qry</span></a><span class='Delimiter'>, 
</span>                            <a href="parse_agg.c.html#LN979"><span class='Ref_To_Local'>groupClauses</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN986"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, 
</span>                            <a href="parse_agg.c.html#LN981"><span class='Ref_To_Local'>have_non_var_grouping</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN984"><span class='Ref_To_Local'>hasJoinRTEs</span></a><span class='Parentheses'>) 
</span>        <a href="parse_agg.c.html#LN987"><span class='Ref_To_Local'>clause</span></a> <span class='Operator'>= </span><a href="../../include/optimizer/var.h.html#LN37"><span class='Ref_to_Proto'>flatten_join_alias_vars</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN986"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN987"><span class='Ref_To_Local'>clause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="parse_agg.c.html#LN60"><span class='Ref_to_Proto'>check_ungrouped_columns</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN987"><span class='Ref_To_Local'>clause</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN976"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN976"><span class='Ref_to_Parameter'>qry</span></a><span class='Delimiter'>, 
</span>                            <a href="parse_agg.c.html#LN979"><span class='Ref_To_Local'>groupClauses</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN980"><span class='Ref_To_Local'>groupClauseCommonVars</span></a><span class='Delimiter'>, 
</span>                            <a href="parse_agg.c.html#LN981"><span class='Ref_To_Local'>have_non_var_grouping</span></a><span class='Delimiter'>, 
</span>                            <span class='Operator'>&</span><a href="parse_agg.c.html#LN982"><span class='Ref_To_Local'>func_grouped_rels</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="parse_agg.c.html#LN987"><span class='Ref_To_Local'>clause</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN976"><span class='Ref_to_Parameter'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a><span class='Delimiter'>; 
</span>    <a href="parse_agg.c.html#LN66"><span class='Ref_to_Proto'>finalize_grouping_exprs</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN987"><span class='Ref_To_Local'>clause</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN976"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN976"><span class='Ref_to_Parameter'>qry</span></a><span class='Delimiter'>, 
</span>                            <a href="parse_agg.c.html#LN979"><span class='Ref_To_Local'>groupClauses</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN986"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, 
</span>                            <a href="parse_agg.c.html#LN981"><span class='Ref_To_Local'>have_non_var_grouping</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN984"><span class='Ref_To_Local'>hasJoinRTEs</span></a><span class='Parentheses'>) 
</span>        <a href="parse_agg.c.html#LN987"><span class='Ref_To_Local'>clause</span></a> <span class='Operator'>= </span><a href="../../include/optimizer/var.h.html#LN37"><span class='Ref_to_Proto'>flatten_join_alias_vars</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN986"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN987"><span class='Ref_To_Local'>clause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="parse_agg.c.html#LN60"><span class='Ref_to_Proto'>check_ungrouped_columns</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN987"><span class='Ref_To_Local'>clause</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN976"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN976"><span class='Ref_to_Parameter'>qry</span></a><span class='Delimiter'>, 
</span>                            <a href="parse_agg.c.html#LN979"><span class='Ref_To_Local'>groupClauses</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN980"><span class='Ref_To_Local'>groupClauseCommonVars</span></a><span class='Delimiter'>, 
</span>                            <a href="parse_agg.c.html#LN981"><span class='Ref_To_Local'>have_non_var_grouping</span></a><span class='Delimiter'>, 
</span>                            <span class='Operator'>&</span><a href="parse_agg.c.html#LN982"><span class='Ref_To_Local'>func_grouped_rels</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Per spec, aggregates can't appear in a recursive term. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN976"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN195"><span class='Ref_to_Member'>p_hasAggs</span></a> <span class='Operator'>&& </span><a href="parse_agg.c.html#LN985"><span class='Ref_To_Local'>hasSelfRefRTEs</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_RECURSION<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"aggregate functions are not allowed in a recursive query's recursive term"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN976"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                    <a href="../../include/rewrite/rewriteManip.h.html#LN58"><span class='Ref_to_Proto'>locate_agg_of_level</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN976"><span class='Ref_to_Parameter'>qry</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>))))</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end parseCheckAggregates &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * check_ungrouped_columns - 
 *    Scan the given expression tree for ungrouped variables (variables 
 *    that are not listed in the groupClauses list and are not within 
 *    the arguments of aggregate functions).  Emit a suitable error message 
 *    if any are found. 
 * 
 * NOTE: we assume that the given clause has been transformed suitably for 
 * parser output.  This means we can use expression_tree_walker. 
 * 
 * NOTE: we recognize grouping expressions in the main query, but only 
 * grouping Vars in subqueries.  For example, this will be rejected, 
 * although it could be allowed: 
 *      SELECT 
 *          (SELECT x FROM bar where y = (foo.a + foo.b)) 
 *      FROM foo 
 *      GROUP BY a + b; 
 * The difficulty is the need to account for different sublevels_up. 
 * This appears to require a whole custom version of equal(), which is 
 * way more pain than the feature seems worth. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1183"></a><span class='Declare_Function'>check_ungrouped_columns</span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>qry</span><span class='Delimiter'>, 
</span><a name="LN1184"></a>                        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>groupClauses</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>groupClauseCommonVars</span><span class='Delimiter'>, 
</span><a name="LN1185"></a>                        <span class='Keyword'>bool </span><span class='Declare_Parameter'>have_non_var_grouping</span><span class='Delimiter'>, 
</span><a name="LN1186"></a>                        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>func_grouped_rels</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1188"></a>    <a href="parse_agg.c.html#LN41"><span class='Ref_to_Typedef'>check_ungrouped_columns_context</span></a> <span class='Declare_Local'>context</span><span class='Delimiter'>; 
</span> 
    <a href="parse_agg.c.html#LN1188"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_agg.c.html#LN43"><span class='Ref_to_Member'>pstate</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN1183"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>; 
</span>    <a href="parse_agg.c.html#LN1188"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_agg.c.html#LN44"><span class='Ref_to_Member'>qry</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN1183"><span class='Ref_to_Parameter'>qry</span></a><span class='Delimiter'>; 
</span>    <a href="parse_agg.c.html#LN1188"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_agg.c.html#LN45"><span class='Ref_to_Member'>root</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="parse_agg.c.html#LN1188"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_agg.c.html#LN46"><span class='Ref_to_Member'>groupClauses</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN1184"><span class='Ref_to_Parameter'>groupClauses</span></a><span class='Delimiter'>; 
</span>    <a href="parse_agg.c.html#LN1188"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_agg.c.html#LN47"><span class='Ref_to_Member'>groupClauseCommonVars</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN1184"><span class='Ref_to_Parameter'>groupClauseCommonVars</span></a><span class='Delimiter'>; 
</span>    <a href="parse_agg.c.html#LN1188"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_agg.c.html#LN48"><span class='Ref_to_Member'>have_non_var_grouping</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN1185"><span class='Ref_to_Parameter'>have_non_var_grouping</span></a><span class='Delimiter'>; 
</span>    <a href="parse_agg.c.html#LN1188"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_agg.c.html#LN49"><span class='Ref_to_Member'>func_grouped_rels</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN1186"><span class='Ref_to_Parameter'>func_grouped_rels</span></a><span class='Delimiter'>; 
</span>    <a href="parse_agg.c.html#LN1188"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_agg.c.html#LN50"><span class='Ref_to_Member'>sublevels_up</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="parse_agg.c.html#LN1188"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_agg.c.html#LN51"><span class='Ref_to_Member'>in_agg_direct_args</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="parse_agg.c.html#LN64"><span class='Ref_to_Proto'>check_ungrouped_columns_walker</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1183"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_agg.c.html#LN1188"><span class='Ref_To_Local'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static bool 
</span><a name="LN1203"></a><span class='Declare_Function'>check_ungrouped_columns_walker</span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, 
</span><a name="LN1204"></a>                               <a href="parse_agg.c.html#LN41"><span class='Ref_to_Typedef'>check_ungrouped_columns_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1206"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>gl</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1203"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1203"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1203"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN240"><span class='Ref_to_Struct'>Param</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* constants are always acceptable */ 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1203"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1216"></a>        <a href="../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>agg</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN1203"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>((</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN1216"><span class='Ref_To_Local'>agg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN308"><span class='Ref_to_Member'>agglevelsup</span></a> <span class='Operator'>== </span><a href="parse_agg.c.html#LN1204"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN50"><span class='Ref_to_Member'>sublevels_up</span></a><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * If we find an aggregate call of the original level, do not 
             * recurse into its normal arguments, ORDER BY arguments, or 
             * filter; ungrouped vars there are not an error.  But we should 
             * check direct arguments as though they weren't in an aggregate. 
             * We set a special flag in the context to help produce a useful 
             * error message for ungrouped vars in direct arguments. 
             */ 
</span><a name="LN1228"></a>            <span class='Keyword'>bool</span>        <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span> 
            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_agg.c.html#LN1204"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN51"><span class='Ref_to_Member'>in_agg_direct_args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="parse_agg.c.html#LN1204"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN51"><span class='Ref_to_Member'>in_agg_direct_args</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="parse_agg.c.html#LN1228"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN64"><span class='Ref_to_Proto'>check_ungrouped_columns_walker</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN1216"><span class='Ref_To_Local'>agg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN299"><span class='Ref_to_Member'>aggdirectargs</span></a><span class='Delimiter'>, 
</span>                                                    <a href="parse_agg.c.html#LN1204"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="parse_agg.c.html#LN1204"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN51"><span class='Ref_to_Member'>in_agg_direct_args</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <a href="parse_agg.c.html#LN1228"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We can skip recursing into aggregates of higher levels altogether, 
         * since they could not possibly contain Vars of concern to us (see 
         * transformAggregateCall).  We do need to look at aggregates of lower 
         * levels, however. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>((</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN1216"><span class='Ref_To_Local'>agg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN308"><span class='Ref_to_Member'>agglevelsup</span></a> <span class='Operator'>&GT; </span><a href="parse_agg.c.html#LN1204"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN50"><span class='Ref_to_Member'>sublevels_up</span></a><span class='Parentheses'>)</span> 
            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IsA(node,Aggref) &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1203"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN337"><span class='Ref_to_Struct'>GroupingFunc</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1250"></a>        <a href="../../include/nodes/primnodes.h.html#LN337"><span class='Ref_to_Struct'>GroupingFunc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>grp</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN337"><span class='Ref_to_Struct'>GroupingFunc</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN1203"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* handled GroupingFunc separately, no need to recheck at this level */ 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>((</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN1250"><span class='Ref_To_Local'>grp</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN344"><span class='Ref_to_Member'>agglevelsup</span></a> <span class='Operator'>&GT;= </span><a href="parse_agg.c.html#LN1204"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN50"><span class='Ref_to_Member'>sublevels_up</span></a><span class='Parentheses'>)</span> 
            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we have any GROUP BY items that are not simple Vars, check to see if 
     * subexpression as a whole matches any GROUP BY item. We need to do this 
     * at every recursion level so that we recognize GROUPed-BY expressions 
     * before reaching variables within them. But this only works at the outer 
     * query level, as noted above. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1204"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN48"><span class='Ref_to_Member'>have_non_var_grouping</span></a> <span class='Operator'>&& </span><a href="parse_agg.c.html#LN1204"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN50"><span class='Ref_to_Member'>sublevels_up</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1206"><span class='Ref_To_Local'>gl</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN1204"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN46"><span class='Ref_to_Member'>groupClauses</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1269"></a>            <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1206"><span class='Ref_To_Local'>gl</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN626"><span class='Ref_to_Proto'>equal</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1203"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN1269"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* acceptable, do not descend more */ 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we have an ungrouped Var of the original query level, we have a 
     * failure.  Vars below the original query level are not a problem, and 
     * neither are Vars from above it.  (If such Vars are ungrouped as far as 
     * their own query level is concerned, that's someone else's problem...) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1203"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1284"></a>        <a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>var</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN1203"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span><a name="LN1285"></a>        <a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span><span class='Delimiter'>; 
</span><a name="LN1286"></a>        <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>attname</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1284"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN172"><span class='Ref_to_Member'>varlevelsup</span></a> <span class='Operator'>!= </span><a href="parse_agg.c.html#LN1204"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN50"><span class='Ref_to_Member'>sublevels_up</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* it's not local to my query, ignore */ 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Check for a match, if we didn't do it above. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_agg.c.html#LN1204"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN48"><span class='Ref_to_Member'>have_non_var_grouping</span></a> <span class='Operator'>|| </span><a href="parse_agg.c.html#LN1204"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN50"><span class='Ref_to_Member'>sublevels_up</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1206"><span class='Ref_To_Local'>gl</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN1204"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN46"><span class='Ref_to_Member'>groupClauses</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN1298"></a>                <a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>gvar</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) ((</span><a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1206"><span class='Ref_To_Local'>gl</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>expr<span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1298"><span class='Ref_To_Local'>gvar</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                    <a href="parse_agg.c.html#LN1298"><span class='Ref_To_Local'>gvar</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN165"><span class='Ref_to_Member'>varno</span></a> <span class='Operator'>== </span><a href="parse_agg.c.html#LN1284"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN165"><span class='Ref_to_Member'>varno</span></a> <span class='Operator'>&& 
</span>                    <a href="parse_agg.c.html#LN1298"><span class='Ref_To_Local'>gvar</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a> <span class='Operator'>== </span><a href="parse_agg.c.html#LN1284"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a> <span class='Operator'>&& 
</span>                    <a href="parse_agg.c.html#LN1298"><span class='Ref_To_Local'>gvar</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN172"><span class='Ref_to_Member'>varlevelsup</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* acceptable, we're okay */ 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Check whether the Var is known functionally dependent on the GROUP 
         * BY columns.  If so, we can allow the Var to be used, because the 
         * grouping is really a no-op for this table.  However, this deduction 
         * depends on one or more constraints of the table, so we have to add 
         * those constraints to the query's constraintDeps list, because it's 
         * not semantically valid anymore if the constraint(s) get dropped. 
         * (Therefore, this check must be the last-ditch effort before raising 
         * error: we don't want to add dependencies unnecessarily.) 
         * 
         * Because this is a pretty expensive check, and will have the same 
         * outcome for all columns of a table, we remember which RTEs we've 
         * already proven functional dependency for in the func_grouped_rels 
         * list.  This test also prevents us from adding duplicate entries to 
         * the constraintDeps list. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN230"><span class='Ref_to_Proto'>list_member_int</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="parse_agg.c.html#LN1204"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN49"><span class='Ref_to_Member'>func_grouped_rels</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN1284"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN165"><span class='Ref_to_Member'>varno</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* previously proven acceptable */ 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1284"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN165"><span class='Ref_to_Member'>varno</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span> <span class='Operator'>&& 
</span>               <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN1284"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN165"><span class='Ref_to_Member'>varno</span></a> <span class='Operator'>&LT;= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1204"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN43"><span class='Ref_to_Member'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="parse_agg.c.html#LN1285"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="../../include/parser/parsetree.h.html#LN30"><span class='Ref_to_Macro'>rt_fetch</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1284"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN165"><span class='Ref_to_Member'>varno</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN1204"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN43"><span class='Ref_to_Member'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1285"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../include/nodes/parsenodes.h.html#LN922"><span class='Ref_to_EnumConst'>RTE_RELATION</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/catalog/pg_constraint_fn.h.html#LN76"><span class='Ref_to_Proto'>check_functional_grouping</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1285"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN947"><span class='Ref_to_Member'>relid</span></a><span class='Delimiter'>, 
</span>                                          <a href="parse_agg.c.html#LN1284"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN165"><span class='Ref_to_Member'>varno</span></a><span class='Delimiter'>, 
</span>                                          <span class='Number'>0</span><span class='Delimiter'>, 
</span>                                          <a href="parse_agg.c.html#LN1204"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN47"><span class='Ref_to_Member'>groupClauseCommonVars</span></a><span class='Delimiter'>, 
</span>                                          <span class='Operator'>&</span><a href="parse_agg.c.html#LN1204"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN44"><span class='Ref_to_Member'>qry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN165"><span class='Ref_to_Member'>constraintDeps</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Operator'>*</span><a href="parse_agg.c.html#LN1204"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN49"><span class='Ref_to_Member'>func_grouped_rels</span></a> <span class='Operator'>= 
</span>                    <a href="../nodes/list.c.html#LN144"><span class='Ref_to_Func'>lappend_int</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="parse_agg.c.html#LN1204"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN49"><span class='Ref_to_Member'>func_grouped_rels</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN1284"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN165"><span class='Ref_to_Member'>varno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* acceptable */ 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Found an ungrouped local variable; generate error message */ 
</span>        <a href="parse_agg.c.html#LN1286"><span class='Ref_To_Local'>attname</span></a> <span class='Operator'>= </span><a href="../../include/parser/parsetree.h.html#LN47"><span class='Ref_to_Proto'>get_rte_attribute_name</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1285"><span class='Ref_To_Local'>rte</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN1284"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1204"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN50"><span class='Ref_to_Member'>sublevels_up</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_GROUPING_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"column \"%s.%s\" must appear in the GROUP BY clause or be used in an aggregate function"</span><span class='Delimiter'>, 
</span>                            <a href="parse_agg.c.html#LN1285"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1023"><span class='Ref_to_Member'>eref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN41"><span class='Ref_to_Member'>aliasname</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN1286"><span class='Ref_To_Local'>attname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="parse_agg.c.html#LN1204"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN51"><span class='Ref_to_Member'>in_agg_direct_args</span></a> <span class='Operator'>? 
</span>                     <a href="../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"Direct arguments of an ordered-set aggregate must use only grouped columns."</span><span class='Parentheses'>) </span><span class='Operator'>: </span><span class='Number'>0</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1204"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN43"><span class='Ref_to_Member'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN1284"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN177"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_GROUPING_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"subquery uses ungrouped column \"%s.%s\" from outer query"</span><span class='Delimiter'>, 
</span>                            <a href="parse_agg.c.html#LN1285"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1023"><span class='Ref_to_Member'>eref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN41"><span class='Ref_to_Member'>aliasname</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN1286"><span class='Ref_To_Local'>attname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1204"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN43"><span class='Ref_to_Member'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN1284"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN177"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IsA(node,Var) &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1203"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Recurse into subselects */ 
</span><a name="LN1365"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span> 
        <a href="parse_agg.c.html#LN1204"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN50"><span class='Ref_to_Member'>sublevels_up</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <a href="parse_agg.c.html#LN1365"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN57"><span class='Ref_to_Proto'>query_tree_walker</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN1203"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, 
</span>                                   <a href="parse_agg.c.html#LN64"><span class='Ref_to_Proto'>check_ungrouped_columns_walker</span></a><span class='Delimiter'>, 
</span>                                   <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN1204"><span class='Ref_to_Parameter'>context</span></a><span class='Delimiter'>, 
</span>                                   <span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_agg.c.html#LN1204"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN50"><span class='Ref_to_Member'>sublevels_up</span></a><span class='Operator'>--</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <a href="parse_agg.c.html#LN1365"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <a href="../../include/nodes/nodeFuncs.h.html#LN52"><span class='Ref_to_Proto'>expression_tree_walker</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1203"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN64"><span class='Ref_to_Proto'>check_ungrouped_columns_walker</span></a><span class='Delimiter'>, 
</span>                                  <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN1204"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end check_ungrouped_columns_walker &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * finalize_grouping_exprs - 
 *    Scan the given expression tree for GROUPING() and related calls, 
 *    and validate and process their arguments. 
 * 
 * This is split out from check_ungrouped_columns above because it needs 
 * to modify the nodes (which it does in-place, not via a mutator) while 
 * check_ungrouped_columns may see only a copy of the original thanks to 
 * flattening of join alias vars. So here, we flatten each individual 
 * GROUPING argument as we see it before comparing it. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1391"></a><span class='Declare_Function'>finalize_grouping_exprs</span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>qry</span><span class='Delimiter'>, 
</span><a name="LN1392"></a>                        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>groupClauses</span><span class='Delimiter'>, </span><a href="../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN1393"></a>                        <span class='Keyword'>bool </span><span class='Declare_Parameter'>have_non_var_grouping</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1395"></a>    <a href="parse_agg.c.html#LN41"><span class='Ref_to_Typedef'>check_ungrouped_columns_context</span></a> <span class='Declare_Local'>context</span><span class='Delimiter'>; 
</span> 
    <a href="parse_agg.c.html#LN1395"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_agg.c.html#LN43"><span class='Ref_to_Member'>pstate</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN1391"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>; 
</span>    <a href="parse_agg.c.html#LN1395"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_agg.c.html#LN44"><span class='Ref_to_Member'>qry</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN1391"><span class='Ref_to_Parameter'>qry</span></a><span class='Delimiter'>; 
</span>    <a href="parse_agg.c.html#LN1395"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_agg.c.html#LN45"><span class='Ref_to_Member'>root</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN1392"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>; 
</span>    <a href="parse_agg.c.html#LN1395"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_agg.c.html#LN46"><span class='Ref_to_Member'>groupClauses</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN1392"><span class='Ref_to_Parameter'>groupClauses</span></a><span class='Delimiter'>; 
</span>    <a href="parse_agg.c.html#LN1395"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_agg.c.html#LN47"><span class='Ref_to_Member'>groupClauseCommonVars</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="parse_agg.c.html#LN1395"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_agg.c.html#LN48"><span class='Ref_to_Member'>have_non_var_grouping</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN1393"><span class='Ref_to_Parameter'>have_non_var_grouping</span></a><span class='Delimiter'>; 
</span>    <a href="parse_agg.c.html#LN1395"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_agg.c.html#LN49"><span class='Ref_to_Member'>func_grouped_rels</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="parse_agg.c.html#LN1395"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_agg.c.html#LN50"><span class='Ref_to_Member'>sublevels_up</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="parse_agg.c.html#LN1395"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_agg.c.html#LN51"><span class='Ref_to_Member'>in_agg_direct_args</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="parse_agg.c.html#LN69"><span class='Ref_to_Proto'>finalize_grouping_exprs_walker</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1391"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_agg.c.html#LN1395"><span class='Ref_To_Local'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static bool 
</span><a name="LN1410"></a><span class='Declare_Function'>finalize_grouping_exprs_walker</span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, 
</span><a name="LN1411"></a>                               <a href="parse_agg.c.html#LN41"><span class='Ref_to_Typedef'>check_ungrouped_columns_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1413"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>gl</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1410"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1410"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1410"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN240"><span class='Ref_to_Struct'>Param</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* constants are always acceptable */ 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1410"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1423"></a>        <a href="../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>agg</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN1410"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>((</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN1423"><span class='Ref_To_Local'>agg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN308"><span class='Ref_to_Member'>agglevelsup</span></a> <span class='Operator'>== </span><a href="parse_agg.c.html#LN1411"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN50"><span class='Ref_to_Member'>sublevels_up</span></a><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * If we find an aggregate call of the original level, do not 
             * recurse into its normal arguments, ORDER BY arguments, or 
             * filter; GROUPING exprs of this level are not allowed there. But 
             * check direct arguments as though they weren't in an aggregate. 
             */ 
</span><a name="LN1433"></a>            <span class='Keyword'>bool</span>        <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span> 
            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_agg.c.html#LN1411"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN51"><span class='Ref_to_Member'>in_agg_direct_args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="parse_agg.c.html#LN1411"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN51"><span class='Ref_to_Member'>in_agg_direct_args</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="parse_agg.c.html#LN1433"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN69"><span class='Ref_to_Proto'>finalize_grouping_exprs_walker</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN1423"><span class='Ref_To_Local'>agg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN299"><span class='Ref_to_Member'>aggdirectargs</span></a><span class='Delimiter'>, 
</span>                                                    <a href="parse_agg.c.html#LN1411"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="parse_agg.c.html#LN1411"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN51"><span class='Ref_to_Member'>in_agg_direct_args</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <a href="parse_agg.c.html#LN1433"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We can skip recursing into aggregates of higher levels altogether, 
         * since they could not possibly contain exprs of concern to us (see 
         * transformAggregateCall).  We do need to look at aggregates of lower 
         * levels, however. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>((</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN1423"><span class='Ref_To_Local'>agg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN308"><span class='Ref_to_Member'>agglevelsup</span></a> <span class='Operator'>&GT; </span><a href="parse_agg.c.html#LN1411"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN50"><span class='Ref_to_Member'>sublevels_up</span></a><span class='Parentheses'>)</span> 
            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IsA(node,Aggref) &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1410"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN337"><span class='Ref_to_Struct'>GroupingFunc</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1455"></a>        <a href="../../include/nodes/primnodes.h.html#LN337"><span class='Ref_to_Struct'>GroupingFunc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>grp</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN337"><span class='Ref_to_Struct'>GroupingFunc</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN1410"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We only need to check GroupingFunc nodes at the exact level to 
         * which they belong, since they cannot mix levels in arguments. 
         */ 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>((</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN1455"><span class='Ref_To_Local'>grp</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN344"><span class='Ref_to_Member'>agglevelsup</span></a> <span class='Operator'>== </span><a href="parse_agg.c.html#LN1411"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN50"><span class='Ref_to_Member'>sublevels_up</span></a><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span><a name="LN1464"></a>            <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span><a name="LN1465"></a>            <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>ref_list</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
            <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1464"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN1455"><span class='Ref_To_Local'>grp</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN340"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN1469"></a>                <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1464"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1470"></a>                <a href="../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Local'>ref</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1411"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN45"><span class='Ref_to_Member'>root</span></a><span class='Parentheses'>) 
</span>                    <a href="parse_agg.c.html#LN1469"><span class='Ref_To_Local'>expr</span></a> <span class='Operator'>= </span><a href="../../include/optimizer/var.h.html#LN37"><span class='Ref_to_Proto'>flatten_join_alias_vars</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1411"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN45"><span class='Ref_to_Member'>root</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN1469"><span class='Ref_To_Local'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Each expression must match a grouping entry at the current 
                 * query level. Unlike the general expression case, we don't 
                 * allow functional dependencies or outer references. 
                 */ 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1469"><span class='Ref_To_Local'>expr</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span><a name="LN1483"></a>                    <a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>var</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN1469"><span class='Ref_To_Local'>expr</span></a><span class='Delimiter'>; 
</span> 
                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1483"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN172"><span class='Ref_to_Member'>varlevelsup</span></a> <span class='Operator'>== </span><a href="parse_agg.c.html#LN1411"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN50"><span class='Ref_to_Member'>sublevels_up</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1413"><span class='Ref_To_Local'>gl</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN1411"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN46"><span class='Ref_to_Member'>groupClauses</span></a><span class='Parentheses'>) 
</span>                        <span class='Delimiter'>{ 
</span><a name="LN1489"></a>                            <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1413"><span class='Ref_To_Local'>gl</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1490"></a>                            <a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>gvar</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN1489"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Delimiter'>; 
</span> 
                            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1490"><span class='Ref_To_Local'>gvar</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                                <a href="parse_agg.c.html#LN1490"><span class='Ref_To_Local'>gvar</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN165"><span class='Ref_to_Member'>varno</span></a> <span class='Operator'>== </span><a href="parse_agg.c.html#LN1483"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN165"><span class='Ref_to_Member'>varno</span></a> <span class='Operator'>&& 
</span>                                <a href="parse_agg.c.html#LN1490"><span class='Ref_To_Local'>gvar</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a> <span class='Operator'>== </span><a href="parse_agg.c.html#LN1483"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a> <span class='Operator'>&& 
</span>                                <a href="parse_agg.c.html#LN1490"><span class='Ref_To_Local'>gvar</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN172"><span class='Ref_to_Member'>varlevelsup</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                            <span class='Delimiter'>{ 
</span>                                <span class='Keyword'>ref </span><span class='Operator'>= </span><a href="parse_agg.c.html#LN1489"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1369"><span class='Ref_to_Member'>ressortgroupref</span></a><span class='Delimiter'>; 
</span>                                <span class='Control'>break</span><span class='Delimiter'>; 
</span>                            <span class='Delimiter'>} 
</span>                        <span class='Delimiter'>} 
</span>                    <span class='Delimiter'>} 
</span>                <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IsA(expr,Var) &raquo; </span> 
                <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1411"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN48"><span class='Ref_to_Member'>have_non_var_grouping</span></a> <span class='Operator'>&& 
</span>                         <a href="parse_agg.c.html#LN1411"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN50"><span class='Ref_to_Member'>sublevels_up</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1413"><span class='Ref_To_Local'>gl</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN1411"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN46"><span class='Ref_to_Member'>groupClauses</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span><a name="LN1508"></a>                        <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1413"><span class='Ref_To_Local'>gl</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN626"><span class='Ref_to_Proto'>equal</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1469"><span class='Ref_To_Local'>expr</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN1508"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Parentheses'>))</span> 
                        <span class='Delimiter'>{ 
</span>                            <span class='Keyword'>ref </span><span class='Operator'>= </span><a href="parse_agg.c.html#LN1508"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1369"><span class='Ref_to_Member'>ressortgroupref</span></a><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                    <span class='Delimiter'>} 
</span>                <span class='Delimiter'>} 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Keyword'>ref </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                    <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_GROUPING_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"arguments to GROUPING must be grouping expressions of the associated query level"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1411"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN43"><span class='Ref_to_Member'>pstate</span></a><span class='Delimiter'>, 
</span>                                                <a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1469"><span class='Ref_To_Local'>expr</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span> 
                <a href="parse_agg.c.html#LN1465"><span class='Ref_To_Local'>ref_list</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN144"><span class='Ref_to_Func'>lappend_int</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1465"><span class='Ref_To_Local'>ref_list</span></a><span class='Delimiter'>, </span><span class='Keyword'>ref</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <a href="parse_agg.c.html#LN1455"><span class='Ref_To_Local'>grp</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN342"><span class='Ref_to_Member'>refs</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN1465"><span class='Ref_To_Local'>ref_list</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if (int)grp-&GT;agglevelsup... &raquo; </span> 
 
        <span class='Control'>if</span> <span class='Parentheses'>((</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN1455"><span class='Ref_To_Local'>grp</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN344"><span class='Ref_to_Member'>agglevelsup</span></a> <span class='Operator'>&GT; </span><a href="parse_agg.c.html#LN1411"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN50"><span class='Ref_to_Member'>sublevels_up</span></a><span class='Parentheses'>)</span> 
            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IsA(node,GroupingFunc... &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1410"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Recurse into subselects */ 
</span><a name="LN1538"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span> 
        <a href="parse_agg.c.html#LN1411"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN50"><span class='Ref_to_Member'>sublevels_up</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <a href="parse_agg.c.html#LN1538"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN57"><span class='Ref_to_Proto'>query_tree_walker</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN1410"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, 
</span>                                   <a href="parse_agg.c.html#LN69"><span class='Ref_to_Proto'>finalize_grouping_exprs_walker</span></a><span class='Delimiter'>, 
</span>                                   <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN1411"><span class='Ref_to_Parameter'>context</span></a><span class='Delimiter'>, 
</span>                                   <span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_agg.c.html#LN1411"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_agg.c.html#LN50"><span class='Ref_to_Member'>sublevels_up</span></a><span class='Operator'>--</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <a href="parse_agg.c.html#LN1538"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <a href="../../include/nodes/nodeFuncs.h.html#LN52"><span class='Ref_to_Proto'>expression_tree_walker</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1410"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN69"><span class='Ref_to_Proto'>finalize_grouping_exprs_walker</span></a><span class='Delimiter'>, 
</span>                                  <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN1411"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end finalize_grouping_exprs_walker &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Given a GroupingSet node, expand it and return a list of lists. 
 * 
 * For EMPTY nodes, return a list of one empty list. 
 * 
 * For SIMPLE nodes, return a list of one list, which is the node content. 
 * 
 * For CUBE and ROLLUP nodes, return a list of the expansions. 
 * 
 * For SET nodes, recursively expand contained CUBE and ROLLUP. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN1565"></a><span class='Declare_Function'>expand_groupingset_node</span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1230"><span class='Ref_to_Struct'>GroupingSet</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>gs</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1567"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1565"><span class='Ref_to_Parameter'>gs</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1233"><span class='Ref_to_Member'>kind</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/parsenodes.h.html#LN1223"><span class='Ref_to_EnumConst'>GROUPING_SET_EMPTY</span></a><span class='Operator'>: 
</span>            <a href="parse_agg.c.html#LN1567"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="../../include/nodes/parsenodes.h.html#LN1224"><span class='Ref_to_EnumConst'>GROUPING_SET_SIMPLE</span></a><span class='Operator'>: 
</span>            <a href="parse_agg.c.html#LN1567"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1565"><span class='Ref_to_Parameter'>gs</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1234"><span class='Ref_to_Member'>content</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="../../include/nodes/parsenodes.h.html#LN1225"><span class='Ref_to_EnumConst'>GROUPING_SET_ROLLUP</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span><a name="LN1581"></a>                <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>rollup_val</span> <span class='Operator'>= </span><a href="parse_agg.c.html#LN1565"><span class='Ref_to_Parameter'>gs</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1234"><span class='Ref_to_Member'>content</span></a><span class='Delimiter'>; 
</span><a name="LN1582"></a>                <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span><a name="LN1583"></a>                <span class='Keyword'>int</span>         <span class='Declare_Local'>curgroup_size</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1565"><span class='Ref_to_Parameter'>gs</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1234"><span class='Ref_to_Member'>content</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1583"><span class='Ref_To_Local'>curgroup_size</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN1587"></a>                    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>current_result</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN1588"></a>                    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span> <span class='Operator'>= </span><a href="parse_agg.c.html#LN1583"><span class='Ref_To_Local'>curgroup_size</span></a><span class='Delimiter'>; 
</span> 
                    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1582"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN1581"><span class='Ref_To_Local'>rollup_val</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span><a name="LN1592"></a>                        <a href="../../include/nodes/parsenodes.h.html#LN1230"><span class='Ref_to_Struct'>GroupingSet</span></a> <span class='Operator'>*</span><span class='Declare_Local'>gs_current</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1230"><span class='Ref_to_Struct'>GroupingSet</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1582"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1592"><span class='Ref_To_Local'>gs_current</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1233"><span class='Ref_to_Member'>kind</span></a> <span class='Operator'>== </span><a href="../../include/nodes/parsenodes.h.html#LN1224"><span class='Ref_to_EnumConst'>GROUPING_SET_SIMPLE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                        <a href="parse_agg.c.html#LN1587"><span class='Ref_To_Local'>current_result</span></a> 
                            <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1587"><span class='Ref_To_Local'>current_result</span></a><span class='Delimiter'>, 
</span>                                          <a href="../../include/nodes/pg_list.h.html#LN268"><span class='Ref_to_Proto'>list_copy</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1592"><span class='Ref_To_Local'>gs_current</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1234"><span class='Ref_to_Member'>content</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
                        <span class='Comment_Multi_Line'>/* If we are done with making the current group, break */ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>--</span><a href="parse_agg.c.html#LN1588"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span> 
                    <a href="parse_agg.c.html#LN1567"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1567"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN1587"><span class='Ref_To_Local'>current_result</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Operator'>--</span><a href="parse_agg.c.html#LN1583"><span class='Ref_To_Local'>curgroup_size</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while curgroup_size&GT;0 &raquo; </span> 
 
                <a href="parse_agg.c.html#LN1567"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1567"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="../../include/nodes/parsenodes.h.html#LN1226"><span class='Ref_to_EnumConst'>GROUPING_SET_CUBE</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span><a name="LN1615"></a>                <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>cube_list</span> <span class='Operator'>= </span><a href="parse_agg.c.html#LN1565"><span class='Ref_to_Parameter'>gs</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1234"><span class='Ref_to_Member'>content</span></a><span class='Delimiter'>; 
</span><a name="LN1616"></a>                <span class='Keyword'>int</span>         <span class='Declare_Local'>number_bits</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1615"><span class='Ref_To_Local'>cube_list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1617"></a>                <a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>num_sets</span><span class='Delimiter'>; 
</span><a name="LN1618"></a>                <a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* parser should cap this much lower */ 
</span>                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1616"><span class='Ref_To_Local'>number_bits</span></a> <span class='Operator'>&LT; </span><span class='Number'>31</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="parse_agg.c.html#LN1617"><span class='Ref_To_Local'>num_sets</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Number'>1U</span> <span class='Operator'>&LT;&LT; </span><a href="parse_agg.c.html#LN1616"><span class='Ref_To_Local'>number_bits</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1618"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="parse_agg.c.html#LN1618"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="parse_agg.c.html#LN1617"><span class='Ref_To_Local'>num_sets</span></a><span class='Delimiter'>; </span><a href="parse_agg.c.html#LN1618"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN1627"></a>                    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>current_result</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN1628"></a>                    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span><a name="LN1629"></a>                    <a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>mask</span> <span class='Operator'>= </span><span class='Number'>1U</span><span class='Delimiter'>; 
</span> 
                    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1628"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN1615"><span class='Ref_To_Local'>cube_list</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span><a name="LN1633"></a>                        <a href="../../include/nodes/parsenodes.h.html#LN1230"><span class='Ref_to_Struct'>GroupingSet</span></a> <span class='Operator'>*</span><span class='Declare_Local'>gs_current</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1230"><span class='Ref_to_Struct'>GroupingSet</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1628"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1633"><span class='Ref_To_Local'>gs_current</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1233"><span class='Ref_to_Member'>kind</span></a> <span class='Operator'>== </span><a href="../../include/nodes/parsenodes.h.html#LN1224"><span class='Ref_to_EnumConst'>GROUPING_SET_SIMPLE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1629"><span class='Ref_To_Local'>mask</span></a> <span class='Operator'>& </span><a href="parse_agg.c.html#LN1618"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>) 
</span>                        <span class='Delimiter'>{ 
</span>                            <a href="parse_agg.c.html#LN1627"><span class='Ref_To_Local'>current_result</span></a> 
                                <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1627"><span class='Ref_To_Local'>current_result</span></a><span class='Delimiter'>, 
</span>                                              <a href="../../include/nodes/pg_list.h.html#LN268"><span class='Ref_to_Proto'>list_copy</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1633"><span class='Ref_To_Local'>gs_current</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1234"><span class='Ref_to_Member'>content</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span> 
                        <a href="parse_agg.c.html#LN1629"><span class='Ref_To_Local'>mask</span></a> <span class='Operator'>&LT;&LT;= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span> 
                    <a href="parse_agg.c.html#LN1567"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1567"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN1627"><span class='Ref_To_Local'>current_result</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;num_sets;i++ &raquo; </span> 
            <span class='Delimiter'>} 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="../../include/nodes/parsenodes.h.html#LN1227"><span class='Ref_to_EnumConst'>GROUPING_SET_SETS</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span><a name="LN1654"></a>                <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
                <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1654"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN1565"><span class='Ref_to_Parameter'>gs</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1234"><span class='Ref_to_Member'>content</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN1658"></a>                    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>current_result</span> <span class='Operator'>= </span><a href="parse_agg.c.html#LN72"><span class='Ref_to_Proto'>expand_groupingset_node</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1654"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
                    <a href="parse_agg.c.html#LN1567"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1567"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN1658"><span class='Ref_To_Local'>current_result</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch gs-&GT;kind &raquo; </span> 
 
    <span class='Control'>return</span> <a href="parse_agg.c.html#LN1567"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end expand_groupingset_node &raquo; </span> 
 
<span class='Keyword'>static int 
</span><a name="LN1670"></a><span class='Declare_Function'>cmp_list_len_asc</span><span class='Parentheses'>(</span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>a</span><span class='Delimiter'>, </span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>b</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1672"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>la</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Keyword'>const </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN1670"><span class='Ref_to_Parameter'>a</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1673"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>lb</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Keyword'>const </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN1670"><span class='Ref_to_Parameter'>b</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1672"><span class='Ref_To_Local'>la</span></a> <span class='Operator'>&GT; </span><a href="parse_agg.c.html#LN1673"><span class='Ref_To_Local'>lb</span></a><span class='Parentheses'>) </span><span class='Operator'>? </span><span class='Number'>1</span> <span class='Operator'>: </span><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1672"><span class='Ref_To_Local'>la</span></a> <span class='Operator'>== </span><a href="parse_agg.c.html#LN1673"><span class='Ref_To_Local'>lb</span></a><span class='Parentheses'>) </span><span class='Operator'>? </span><span class='Number'>0</span> <span class='Operator'>: -</span><span class='Number'>1</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Expand a groupingSets clause to a flat list of grouping sets. 
 * The returned list is sorted by length, shortest sets first. 
 * 
 * This is mainly for the planner, but we use it here too to do 
 * some consistency checks. 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN1686"></a><span class='Declare_Function'>expand_grouping_sets</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>groupingSets</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>limit</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1688"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>expanded_groups</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN1689"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN1690"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>numsets</span> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span><a name="LN1691"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1686"><span class='Ref_to_Parameter'>groupingSets</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1691"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN1686"><span class='Ref_to_Parameter'>groupingSets</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1698"></a>        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>current_result</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN1699"></a>        <a href="../../include/nodes/parsenodes.h.html#LN1230"><span class='Ref_to_Struct'>GroupingSet</span></a> <span class='Operator'>*</span><span class='Declare_Local'>gs</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1691"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="parse_agg.c.html#LN1698"><span class='Ref_To_Local'>current_result</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN72"><span class='Ref_to_Proto'>expand_groupingset_node</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1699"><span class='Ref_To_Local'>gs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1698"><span class='Ref_To_Local'>current_result</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="parse_agg.c.html#LN1690"><span class='Ref_To_Local'>numsets</span></a> <span class='Operator'>*= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1698"><span class='Ref_To_Local'>current_result</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1686"><span class='Ref_to_Parameter'>limit</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="parse_agg.c.html#LN1690"><span class='Ref_To_Local'>numsets</span></a> <span class='Operator'>&GT; </span><a href="parse_agg.c.html#LN1686"><span class='Ref_to_Parameter'>limit</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
        <a href="parse_agg.c.html#LN1688"><span class='Ref_To_Local'>expanded_groups</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1688"><span class='Ref_To_Local'>expanded_groups</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN1698"><span class='Ref_To_Local'>current_result</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Do cartesian product between sublists of expanded_groups. While at it, 
     * remove any duplicate elements from individual grouping sets (we must 
     * NOT change the number of sets though) 
     */ 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1691"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1688"><span class='Ref_To_Local'>expanded_groups</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="parse_agg.c.html#LN1689"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1689"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN242"><span class='Ref_to_Proto'>list_union_int</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1691"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN168"><span class='Ref_to_Macro'>for_each_cell</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1691"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1688"><span class='Ref_To_Local'>expanded_groups</span></a><span class='Parentheses'>)))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1726"></a>        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>p</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1691"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1727"></a>        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>new_result</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN1728"></a>        <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc2</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1728"><span class='Ref_To_Local'>lc2</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN1689"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1732"></a>            <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>q</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1728"><span class='Ref_To_Local'>lc2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1733"></a>            <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc3</span><span class='Delimiter'>; 
</span> 
            <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1733"><span class='Ref_To_Local'>lc3</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN1726"><span class='Ref_To_Local'>p</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="parse_agg.c.html#LN1727"><span class='Ref_To_Local'>new_result</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1727"><span class='Ref_To_Local'>new_result</span></a><span class='Delimiter'>, 
</span>                                     <a href="../../include/nodes/pg_list.h.html#LN242"><span class='Ref_to_Proto'>list_union_int</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1732"><span class='Ref_To_Local'>q</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1733"><span class='Ref_To_Local'>lc3</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>        <a href="parse_agg.c.html#LN1689"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN1727"><span class='Ref_To_Local'>new_result</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1689"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1746"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>result_len</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1689"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1747"></a>        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>      <span class='Operator'>**</span><span class='Declare_Local'>buf</span> <span class='Operator'>= </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="parse_agg.c.html#LN1746"><span class='Ref_To_Local'>result_len</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1748"></a>        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>      <span class='Operator'>**</span><span class='Declare_Local'>ptr</span> <span class='Operator'>= </span><a href="parse_agg.c.html#LN1747"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>; 
</span> 
        <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1691"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN1689"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Operator'>*</span><a href="parse_agg.c.html#LN1748"><span class='Ref_To_Local'>ptr</span></a><span class='Operator'>++ = </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1691"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="../../include/port.h.html#LN439"><span class='Ref_to_Macro'>qsort</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1747"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN1746"><span class='Ref_To_Local'>result_len</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN1669"><span class='Ref_to_Func'>cmp_list_len_asc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="parse_agg.c.html#LN1689"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>        <a href="parse_agg.c.html#LN1748"><span class='Ref_To_Local'>ptr</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN1747"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1746"><span class='Ref_To_Local'>result_len</span></a><span class='Operator'>-- &GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <a href="parse_agg.c.html#LN1689"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1689"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><span class='Operator'>*</span><a href="parse_agg.c.html#LN1748"><span class='Ref_To_Local'>ptr</span></a><span class='Operator'>++</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1747"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if list_length(result)&GT;1 &raquo; </span> 
 
    <span class='Control'>return</span> <a href="parse_agg.c.html#LN1689"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end expand_grouping_sets &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * get_aggregate_argtypes 
 *  Identify the specific datatypes passed to an aggregate call. 
 * 
 * Given an Aggref, extract the actual datatypes of the input arguments. 
 * The input datatypes are reported in a way that matches up with the 
 * aggregate's declaration, ie, any ORDER BY columns attached to a plain 
 * aggregate are ignored, but we report both direct and aggregated args of 
 * an ordered-set aggregate. 
 * 
 * Datatypes are returned into inputTypes[], which must reference an array 
 * of length FUNC_MAX_ARGS. 
 * 
 * The function result is the number of actual arguments. 
 */ 
</span><span class='Keyword'>int 
</span><a name="LN1785"></a><span class='Declare_Function'>get_aggregate_argtypes</span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggref</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>inputTypes</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1787"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numArguments</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1788"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1785"><span class='Ref_to_Parameter'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN298"><span class='Ref_to_Member'>aggargtypes</span></a><span class='Parentheses'>) </span><span class='Operator'>&LT;= </span><a href="../../include/pg_config_manual.h.html#LN36"><span class='Ref_to_Const'>FUNC_MAX_ARGS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1788"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN1785"><span class='Ref_to_Parameter'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN298"><span class='Ref_to_Member'>aggargtypes</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="parse_agg.c.html#LN1785"><span class='Ref_to_Parameter'>inputTypes</span></a><span class='Delimiter'>[</span><a href="parse_agg.c.html#LN1787"><span class='Ref_To_Local'>numArguments</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN107"><span class='Ref_to_Macro'>lfirst_oid</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1788"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="parse_agg.c.html#LN1787"><span class='Ref_To_Local'>numArguments</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * resolve_aggregate_transtype 
 *  Identify the transition state value's datatype for an aggregate call. 
 * 
 * This function resolves a polymorphic aggregate's state datatype. 
 * It must be passed the aggtranstype from the aggregate's catalog entry, 
 * as well as the actual argument types extracted by get_aggregate_argtypes. 
 * (We could fetch pg_aggregate.aggtranstype internally, but all existing 
 * callers already have the value at hand, so we make them pass it.) 
 */ 
</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> 
<a name="LN1811"></a><span class='Declare_Function'>resolve_aggregate_transtype</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>aggfuncid</span><span class='Delimiter'>, 
</span><a name="LN1812"></a>                            <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>aggtranstype</span><span class='Delimiter'>, 
</span><a name="LN1813"></a>                            <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>inputTypes</span><span class='Delimiter'>, 
</span><a name="LN1814"></a>                            <span class='Keyword'>int </span><span class='Declare_Parameter'>numArguments</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* resolve actual type of transition state, if polymorphic */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/catalog/pg_type.h.html#LN744"><span class='Ref_to_Macro'>IsPolymorphicType</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1812"><span class='Ref_to_Parameter'>aggtranstype</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* have to fetch the agg's declared input types... */ 
</span><a name="LN1820"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>declaredArgTypes</span><span class='Delimiter'>; 
</span><a name="LN1821"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>agg_nargs</span><span class='Delimiter'>; 
</span> 
        <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="../../include/utils/lsyscache.h.html#LN114"><span class='Ref_to_Proto'>get_func_signature</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1811"><span class='Ref_to_Parameter'>aggfuncid</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_agg.c.html#LN1820"><span class='Ref_To_Local'>declaredArgTypes</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_agg.c.html#LN1821"><span class='Ref_To_Local'>agg_nargs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * VARIADIC ANY aggs could have more actual than declared args, but 
         * such extra args can't affect polymorphic type resolution. 
         */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1821"><span class='Ref_To_Local'>agg_nargs</span></a> <span class='Operator'>&LT;= </span><a href="parse_agg.c.html#LN1814"><span class='Ref_to_Parameter'>numArguments</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="parse_agg.c.html#LN1812"><span class='Ref_to_Parameter'>aggtranstype</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN77"><span class='Ref_to_Proto'>enforce_generic_type_consistency</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1813"><span class='Ref_to_Parameter'>inputTypes</span></a><span class='Delimiter'>, 
</span>                                                        <a href="parse_agg.c.html#LN1820"><span class='Ref_To_Local'>declaredArgTypes</span></a><span class='Delimiter'>, 
</span>                                                        <a href="parse_agg.c.html#LN1821"><span class='Ref_To_Local'>agg_nargs</span></a><span class='Delimiter'>, 
</span>                                                        <a href="parse_agg.c.html#LN1812"><span class='Ref_to_Parameter'>aggtranstype</span></a><span class='Delimiter'>, 
</span>                                                        <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1820"><span class='Ref_To_Local'>declaredArgTypes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IsPolymorphicType(agg... &raquo; </span> 
    <span class='Control'>return</span> <a href="parse_agg.c.html#LN1812"><span class='Ref_to_Parameter'>aggtranstype</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end resolve_aggregate_transtype &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Create an expression tree for the transition function of an aggregate. 
 * This is needed so that polymorphic functions can be used within an 
 * aggregate --- without the expression tree, such functions would not know 
 * the datatypes they are supposed to use.  (The trees will never actually 
 * be executed, however, so we can skimp a bit on correctness.) 
 * 
 * agg_input_types and agg_state_type identifies the input types of the 
 * aggregate.  These should be resolved to actual types (ie, none should 
 * ever be ANYELEMENT etc). 
 * agg_input_collation is the aggregate function's input collation. 
 * 
 * For an ordered-set aggregate, remember that agg_input_types describes 
 * the direct arguments followed by the aggregated arguments. 
 * 
 * transfn_oid and invtransfn_oid identify the funcs to be called; the 
 * latter may be InvalidOid, however if invtransfn_oid is set then 
 * transfn_oid must also be set. 
 * 
 * Pointers to the constructed trees are returned into *transfnexpr, 
 * *invtransfnexpr. If there is no invtransfn, the respective pointer is set 
 * to NULL.  Since use of the invtransfn is optional, NULL may be passed for 
 * invtransfnexpr. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1866"></a><span class='Declare_Function'>build_aggregate_transfn_expr</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>agg_input_types</span><span class='Delimiter'>, 
</span><a name="LN1867"></a>                             <span class='Keyword'>int </span><span class='Declare_Parameter'>agg_num_inputs</span><span class='Delimiter'>, 
</span><a name="LN1868"></a>                             <span class='Keyword'>int </span><span class='Declare_Parameter'>agg_num_direct_inputs</span><span class='Delimiter'>, 
</span><a name="LN1869"></a>                             <span class='Keyword'>bool </span><span class='Declare_Parameter'>agg_variadic</span><span class='Delimiter'>, 
</span><a name="LN1870"></a>                             <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>agg_state_type</span><span class='Delimiter'>, 
</span><a name="LN1871"></a>                             <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>agg_input_collation</span><span class='Delimiter'>, 
</span><a name="LN1872"></a>                             <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>transfn_oid</span><span class='Delimiter'>, 
</span><a name="LN1873"></a>                             <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>invtransfn_oid</span><span class='Delimiter'>, 
</span><a name="LN1874"></a>                             <a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>transfnexpr</span><span class='Delimiter'>, 
</span><a name="LN1875"></a>                             <a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>invtransfnexpr</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1877"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>args</span><span class='Delimiter'>; 
</span><a name="LN1878"></a>    <a href="../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>fexpr</span><span class='Delimiter'>; 
</span><a name="LN1879"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Build arg list to use in the transfn FuncExpr node. 
     */ 
</span>    <a href="parse_agg.c.html#LN1877"><span class='Ref_To_Local'>args</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN73"><span class='Ref_to_Proto'>make_agg_arg</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1870"><span class='Ref_to_Parameter'>agg_state_type</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN1871"><span class='Ref_to_Parameter'>agg_input_collation</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1879"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN1868"><span class='Ref_to_Parameter'>agg_num_direct_inputs</span></a><span class='Delimiter'>; </span><a href="parse_agg.c.html#LN1879"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="parse_agg.c.html#LN1867"><span class='Ref_to_Parameter'>agg_num_inputs</span></a><span class='Delimiter'>; </span><a href="parse_agg.c.html#LN1879"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="parse_agg.c.html#LN1877"><span class='Ref_To_Local'>args</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1877"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>, 
</span>                       <a href="parse_agg.c.html#LN73"><span class='Ref_to_Proto'>make_agg_arg</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1866"><span class='Ref_to_Parameter'>agg_input_types</span></a><span class='Delimiter'>[</span><a href="parse_agg.c.html#LN1879"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], </span><a href="parse_agg.c.html#LN1871"><span class='Ref_to_Parameter'>agg_input_collation</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="parse_agg.c.html#LN1878"><span class='Ref_To_Local'>fexpr</span></a> <span class='Operator'>= </span><a href="../../include/nodes/makefuncs.h.html#LN77"><span class='Ref_to_Proto'>makeFuncExpr</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1872"><span class='Ref_to_Parameter'>transfn_oid</span></a><span class='Delimiter'>, 
</span>                         <a href="parse_agg.c.html#LN1870"><span class='Ref_to_Parameter'>agg_state_type</span></a><span class='Delimiter'>, 
</span>                         <a href="parse_agg.c.html#LN1877"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>, 
</span>                         <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                         <a href="parse_agg.c.html#LN1871"><span class='Ref_to_Parameter'>agg_input_collation</span></a><span class='Delimiter'>, 
</span>                         <a href="../../include/nodes/primnodes.h.html#LN436"><span class='Ref_to_EnumConst'>COERCE_EXPLICIT_CALL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="parse_agg.c.html#LN1878"><span class='Ref_To_Local'>fexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN450"><span class='Ref_to_Member'>funcvariadic</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN1869"><span class='Ref_to_Parameter'>agg_variadic</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="parse_agg.c.html#LN1874"><span class='Ref_to_Parameter'>transfnexpr</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN1878"><span class='Ref_To_Local'>fexpr</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Build invtransfn expression if requested, with same args as transfn 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1875"><span class='Ref_to_Parameter'>invtransfnexpr</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1873"><span class='Ref_to_Parameter'>invtransfn_oid</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="parse_agg.c.html#LN1878"><span class='Ref_To_Local'>fexpr</span></a> <span class='Operator'>= </span><a href="../../include/nodes/makefuncs.h.html#LN77"><span class='Ref_to_Proto'>makeFuncExpr</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1873"><span class='Ref_to_Parameter'>invtransfn_oid</span></a><span class='Delimiter'>, 
</span>                                 <a href="parse_agg.c.html#LN1870"><span class='Ref_to_Parameter'>agg_state_type</span></a><span class='Delimiter'>, 
</span>                                 <a href="parse_agg.c.html#LN1877"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>, 
</span>                                 <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                                 <a href="parse_agg.c.html#LN1871"><span class='Ref_to_Parameter'>agg_input_collation</span></a><span class='Delimiter'>, 
</span>                                 <a href="../../include/nodes/primnodes.h.html#LN436"><span class='Ref_to_EnumConst'>COERCE_EXPLICIT_CALL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="parse_agg.c.html#LN1878"><span class='Ref_To_Local'>fexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN450"><span class='Ref_to_Member'>funcvariadic</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN1869"><span class='Ref_to_Parameter'>agg_variadic</span></a><span class='Delimiter'>; 
</span>            <span class='Operator'>*</span><a href="parse_agg.c.html#LN1875"><span class='Ref_to_Parameter'>invtransfnexpr</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN1878"><span class='Ref_To_Local'>fexpr</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <span class='Operator'>*</span><a href="parse_agg.c.html#LN1875"><span class='Ref_to_Parameter'>invtransfnexpr</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end build_aggregate_transfn_expr &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Like build_aggregate_transfn_expr, but creates an expression tree for the 
 * combine function of an aggregate, rather than the transition function. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1927"></a><span class='Declare_Function'>build_aggregate_combinefn_expr</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>agg_state_type</span><span class='Delimiter'>, 
</span><a name="LN1928"></a>                               <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>agg_input_collation</span><span class='Delimiter'>, 
</span><a name="LN1929"></a>                               <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>combinefn_oid</span><span class='Delimiter'>, 
</span><a name="LN1930"></a>                               <a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>combinefnexpr</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1932"></a>    <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>argp</span><span class='Delimiter'>; 
</span><a name="LN1933"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>args</span><span class='Delimiter'>; 
</span><a name="LN1934"></a>    <a href="../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>fexpr</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* combinefn takes two arguments of the aggregate state type */ 
</span>    <a href="parse_agg.c.html#LN1932"><span class='Ref_To_Local'>argp</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN73"><span class='Ref_to_Proto'>make_agg_arg</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1927"><span class='Ref_to_Parameter'>agg_state_type</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN1928"><span class='Ref_to_Parameter'>agg_input_collation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="parse_agg.c.html#LN1933"><span class='Ref_To_Local'>args</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN139"><span class='Ref_to_Macro'>list_make2</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1932"><span class='Ref_To_Local'>argp</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN1932"><span class='Ref_To_Local'>argp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="parse_agg.c.html#LN1934"><span class='Ref_To_Local'>fexpr</span></a> <span class='Operator'>= </span><a href="../../include/nodes/makefuncs.h.html#LN77"><span class='Ref_to_Proto'>makeFuncExpr</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1929"><span class='Ref_to_Parameter'>combinefn_oid</span></a><span class='Delimiter'>, 
</span>                         <a href="parse_agg.c.html#LN1927"><span class='Ref_to_Parameter'>agg_state_type</span></a><span class='Delimiter'>, 
</span>                         <a href="parse_agg.c.html#LN1933"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>, 
</span>                         <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                         <a href="parse_agg.c.html#LN1928"><span class='Ref_to_Parameter'>agg_input_collation</span></a><span class='Delimiter'>, 
</span>                         <a href="../../include/nodes/primnodes.h.html#LN436"><span class='Ref_to_EnumConst'>COERCE_EXPLICIT_CALL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* combinefn is currently never treated as variadic */ 
</span>    <span class='Operator'>*</span><a href="parse_agg.c.html#LN1930"><span class='Ref_to_Parameter'>combinefnexpr</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN1934"><span class='Ref_To_Local'>fexpr</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end build_aggregate_combinefn_expr &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Like build_aggregate_transfn_expr, but creates an expression tree for the 
 * serialization function of an aggregate. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1956"></a><span class='Declare_Function'>build_aggregate_serialfn_expr</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>serialfn_oid</span><span class='Delimiter'>, 
</span><a name="LN1957"></a>                              <a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>serialfnexpr</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1959"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>args</span><span class='Delimiter'>; 
</span><a name="LN1960"></a>    <a href="../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>fexpr</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* serialfn always takes INTERNAL and returns BYTEA */ 
</span>    <a href="parse_agg.c.html#LN1959"><span class='Ref_To_Local'>args</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN73"><span class='Ref_to_Proto'>make_agg_arg</span></a><span class='Parentheses'>(</span><a href="../../include/catalog/pg_type.h.html#LN697"><span class='Ref_to_Const'>INTERNALOID</span></a><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="parse_agg.c.html#LN1960"><span class='Ref_To_Local'>fexpr</span></a> <span class='Operator'>= </span><a href="../../include/nodes/makefuncs.h.html#LN77"><span class='Ref_to_Proto'>makeFuncExpr</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1956"><span class='Ref_to_Parameter'>serialfn_oid</span></a><span class='Delimiter'>, 
</span>                         <a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN18"><span class='Ref_to_Const'>BYTEAOID</span></a><span class='Delimiter'>, 
</span>                         <a href="parse_agg.c.html#LN1959"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>, 
</span>                         <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                         <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                         <a href="../../include/nodes/primnodes.h.html#LN436"><span class='Ref_to_EnumConst'>COERCE_EXPLICIT_CALL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="parse_agg.c.html#LN1957"><span class='Ref_to_Parameter'>serialfnexpr</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN1960"><span class='Ref_To_Local'>fexpr</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Like build_aggregate_transfn_expr, but creates an expression tree for the 
 * deserialization function of an aggregate. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1979"></a><span class='Declare_Function'>build_aggregate_deserialfn_expr</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>deserialfn_oid</span><span class='Delimiter'>, 
</span><a name="LN1980"></a>                                <a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>deserialfnexpr</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1982"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>args</span><span class='Delimiter'>; 
</span><a name="LN1983"></a>    <a href="../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>fexpr</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* deserialfn always takes BYTEA, INTERNAL and returns INTERNAL */ 
</span>    <a href="parse_agg.c.html#LN1982"><span class='Ref_To_Local'>args</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN139"><span class='Ref_to_Macro'>list_make2</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN73"><span class='Ref_to_Proto'>make_agg_arg</span></a><span class='Parentheses'>(</span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN18"><span class='Ref_to_Const'>BYTEAOID</span></a><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                      <a href="parse_agg.c.html#LN73"><span class='Ref_to_Proto'>make_agg_arg</span></a><span class='Parentheses'>(</span><a href="../../include/catalog/pg_type.h.html#LN697"><span class='Ref_to_Const'>INTERNALOID</span></a><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="parse_agg.c.html#LN1983"><span class='Ref_To_Local'>fexpr</span></a> <span class='Operator'>= </span><a href="../../include/nodes/makefuncs.h.html#LN77"><span class='Ref_to_Proto'>makeFuncExpr</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN1979"><span class='Ref_to_Parameter'>deserialfn_oid</span></a><span class='Delimiter'>, 
</span>                         <a href="../../include/catalog/pg_type.h.html#LN697"><span class='Ref_to_Const'>INTERNALOID</span></a><span class='Delimiter'>, 
</span>                         <a href="parse_agg.c.html#LN1982"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>, 
</span>                         <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                         <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                         <a href="../../include/nodes/primnodes.h.html#LN436"><span class='Ref_to_EnumConst'>COERCE_EXPLICIT_CALL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="parse_agg.c.html#LN1980"><span class='Ref_to_Parameter'>deserialfnexpr</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN1983"><span class='Ref_To_Local'>fexpr</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Like build_aggregate_transfn_expr, but creates an expression tree for the 
 * final function of an aggregate, rather than the transition function. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2003"></a><span class='Declare_Function'>build_aggregate_finalfn_expr</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>agg_input_types</span><span class='Delimiter'>, 
</span><a name="LN2004"></a>                             <span class='Keyword'>int </span><span class='Declare_Parameter'>num_finalfn_inputs</span><span class='Delimiter'>, 
</span><a name="LN2005"></a>                             <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>agg_state_type</span><span class='Delimiter'>, 
</span><a name="LN2006"></a>                             <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>agg_result_type</span><span class='Delimiter'>, 
</span><a name="LN2007"></a>                             <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>agg_input_collation</span><span class='Delimiter'>, 
</span><a name="LN2008"></a>                             <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>finalfn_oid</span><span class='Delimiter'>, 
</span><a name="LN2009"></a>                             <a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>finalfnexpr</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2011"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>args</span><span class='Delimiter'>; 
</span><a name="LN2012"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Build expr tree for final function 
     */ 
</span>    <a href="parse_agg.c.html#LN2011"><span class='Ref_To_Local'>args</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN73"><span class='Ref_to_Proto'>make_agg_arg</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN2005"><span class='Ref_to_Parameter'>agg_state_type</span></a><span class='Delimiter'>, </span><a href="parse_agg.c.html#LN2007"><span class='Ref_to_Parameter'>agg_input_collation</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* finalfn may take additional args, which match agg's input types */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="parse_agg.c.html#LN2012"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="parse_agg.c.html#LN2012"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="parse_agg.c.html#LN2004"><span class='Ref_to_Parameter'>num_finalfn_inputs</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="parse_agg.c.html#LN2012"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="parse_agg.c.html#LN2011"><span class='Ref_To_Local'>args</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN2011"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>, 
</span>                       <a href="parse_agg.c.html#LN73"><span class='Ref_to_Proto'>make_agg_arg</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN2003"><span class='Ref_to_Parameter'>agg_input_types</span></a><span class='Delimiter'>[</span><a href="parse_agg.c.html#LN2012"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], </span><a href="parse_agg.c.html#LN2007"><span class='Ref_to_Parameter'>agg_input_collation</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Operator'>*</span><a href="parse_agg.c.html#LN2009"><span class='Ref_to_Parameter'>finalfnexpr</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/makefuncs.h.html#LN77"><span class='Ref_to_Proto'>makeFuncExpr</span></a><span class='Parentheses'>(</span><a href="parse_agg.c.html#LN2008"><span class='Ref_to_Parameter'>finalfn_oid</span></a><span class='Delimiter'>, 
</span>                                         <a href="parse_agg.c.html#LN2006"><span class='Ref_to_Parameter'>agg_result_type</span></a><span class='Delimiter'>, 
</span>                                         <a href="parse_agg.c.html#LN2011"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>, 
</span>                                         <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                                         <a href="parse_agg.c.html#LN2007"><span class='Ref_to_Parameter'>agg_input_collation</span></a><span class='Delimiter'>, 
</span>                                         <a href="../../include/nodes/primnodes.h.html#LN436"><span class='Ref_to_EnumConst'>COERCE_EXPLICIT_CALL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* finalfn is currently never treated as variadic */ 
</span><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end build_aggregate_finalfn_expr &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Convenience function to build dummy argument expressions for aggregates. 
 * 
 * We really only care that an aggregate support function can discover its 
 * actual argument types at runtime using get_fn_expr_argtype(), so it's okay 
 * to use Param nodes that don't correspond to any real Param. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN2043"></a><span class='Declare_Function'>make_agg_arg</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>argtype</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>argcollation</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2045"></a>    <a href="../../include/nodes/primnodes.h.html#LN240"><span class='Ref_to_Struct'>Param</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>argp</span> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN240"><span class='Ref_to_Struct'>Param</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="parse_agg.c.html#LN2045"><span class='Ref_To_Local'>argp</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN243"><span class='Ref_to_Member'>paramkind</span></a> <span class='Operator'>= </span><a href="../../include/nodes/primnodes.h.html#LN235"><span class='Ref_to_EnumConst'>PARAM_EXEC</span></a><span class='Delimiter'>; 
</span>    <a href="parse_agg.c.html#LN2045"><span class='Ref_To_Local'>argp</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN244"><span class='Ref_to_Member'>paramid</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <a href="parse_agg.c.html#LN2045"><span class='Ref_To_Local'>argp</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN245"><span class='Ref_to_Member'>paramtype</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN2043"><span class='Ref_to_Parameter'>argtype</span></a><span class='Delimiter'>; 
</span>    <a href="parse_agg.c.html#LN2045"><span class='Ref_To_Local'>argp</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN246"><span class='Ref_to_Member'>paramtypmod</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <a href="parse_agg.c.html#LN2045"><span class='Ref_To_Local'>argp</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN247"><span class='Ref_to_Member'>paramcollid</span></a> <span class='Operator'>= </span><a href="parse_agg.c.html#LN2043"><span class='Ref_to_Parameter'>argcollation</span></a><span class='Delimiter'>; 
</span>    <a href="parse_agg.c.html#LN2045"><span class='Ref_To_Local'>argp</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN248"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_agg.c.html#LN2045"><span class='Ref_To_Local'>argp</span></a><span class='Delimiter'>; 
} 
</span></pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>