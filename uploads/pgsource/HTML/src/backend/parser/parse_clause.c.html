<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\parser\parse_clause.c</title>
<LINK REL=StyleSheet HREF="../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\parser\parse_clause.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:44 2017
</td></tr>
<tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
</span><span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * parse_clause.c 
 *    handle clauses in parser 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * 
 * IDENTIFICATION 
 *    src/backend/parser/parse_clause.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span> 
<span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"miscadmin.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/heapam.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/tsmapi.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/catalog.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/heap.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_am.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_collation.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_constraint_fn.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_type.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"commands/defrem.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/makefuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/nodeFuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/tlist.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/var.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/analyze.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parsetree.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parser.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_clause.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_coerce.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_collate.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_expr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_func.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_oper.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_relation.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_target.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_type.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"rewrite/rewriteManip.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/guc.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/lsyscache.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/rel.h"</span> 
 
 
<span class='Comment_Multi_Line'>/* Convenience macro for the most common makeNamespaceItem() case */ 
</span><a name="LN51"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>makeDefaultNSItem</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>rte</span><span class='Parentheses'>)</span>  <a href="parse_clause.c.html#LN80"><span class='Ref_to_Proto'>makeNamespaceItem</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN51"><span class='Ref_to_Parameter'>rte</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>) 
</span> 
<a name="LN53"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>extractRemainingColumns</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>common_colnames</span><span class='Delimiter'>, 
</span><a name="LN54"></a>                        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>src_colnames</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>src_colvars</span><span class='Delimiter'>, 
</span><a name="LN55"></a>                        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>res_colnames</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>res_colvars</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN56"></a><span class='Keyword'>static </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>transformJoinUsingClause</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, 
</span><a name="LN57"></a>                         <a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>leftRTE</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rightRTE</span><span class='Delimiter'>, 
</span><a name="LN58"></a>                         <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>leftVars</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rightVars</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN59"></a><span class='Keyword'>static </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>transformJoinOnClause</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN1444"><span class='Ref_to_Struct'>JoinExpr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>j</span><span class='Delimiter'>, 
</span><a name="LN60"></a>                      <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>namespace</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN61"></a><span class='Keyword'>static </span><a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>getRTEForSpecialRelationTypes</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, 
</span><a name="LN62"></a>                              <a href="../../include/nodes/primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rv</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN63"></a><span class='Keyword'>static </span><a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>transformTableEntry</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>r</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN64"></a><span class='Keyword'>static </span><a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>transformCTEReference</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>r</span><span class='Delimiter'>, 
</span><a name="LN65"></a>                      <a href="../../include/nodes/parsenodes.h.html#LN1339"><span class='Ref_to_Struct'>CommonTableExpr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>cte</span><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> <span class='Declare_Parameter'>levelsup</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN66"></a><span class='Keyword'>static </span><a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>transformENRReference</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>r</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN67"></a><span class='Keyword'>static </span><a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>transformRangeSubselect</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, 
</span><a name="LN68"></a>                        <a href="../../include/nodes/parsenodes.h.html#LN531"><span class='Ref_to_Struct'>RangeSubselect</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>r</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN69"></a><span class='Keyword'>static </span><a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>transformRangeFunction</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, 
</span><a name="LN70"></a>                       <a href="../../include/nodes/parsenodes.h.html#LN553"><span class='Ref_to_Struct'>RangeFunction</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>r</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN71"></a><span class='Keyword'>static </span><a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>transformRangeTableFunc</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, 
</span><a name="LN72"></a>                        <a href="../../include/nodes/parsenodes.h.html#LN568"><span class='Ref_to_Struct'>RangeTableFunc</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>t</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN73"></a><span class='Keyword'>static </span><a href="../../include/nodes/parsenodes.h.html#LN1071"><span class='Ref_to_Struct'>TableSampleClause</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>transformRangeTableSample</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, 
</span><a name="LN74"></a>                          <a href="../../include/nodes/parsenodes.h.html#LN608"><span class='Ref_to_Struct'>RangeTableSample</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rts</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN75"></a><span class='Keyword'>static </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>transformFromClauseItem</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>n</span><span class='Delimiter'>, 
</span><a name="LN76"></a>                        <a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>top_rte</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Operator'>*</span><span class='Declare_Parameter'>top_rti</span><span class='Delimiter'>, 
</span><a name="LN77"></a>                        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>namespace</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN78"></a><span class='Keyword'>static </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>buildMergedJoinVar</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/nodes.h.html#LN671"><span class='Ref_to_Enum'>JoinType</span></a> <span class='Declare_Parameter'>jointype</span><span class='Delimiter'>, 
</span><a name="LN79"></a>                   <a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>l_colvar</span><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>r_colvar</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN80"></a><span class='Keyword'>static </span><a href="../../include/parser/parse_node.h.html#LN239"><span class='Ref_to_Struct'>ParseNamespaceItem</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>makeNamespaceItem</span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Delimiter'>, 
</span><a name="LN81"></a>                  <span class='Keyword'>bool </span><span class='Declare_Parameter'>rel_visible</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>cols_visible</span><span class='Delimiter'>, 
</span><a name="LN82"></a>                  <span class='Keyword'>bool </span><span class='Declare_Parameter'>lateral_only</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>lateral_ok</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN83"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>setNamespaceColumnVisibility</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>namespace</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>cols_visible</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN84"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>setNamespaceLateralState</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>namespace</span><span class='Delimiter'>, 
</span><a name="LN85"></a>                         <span class='Keyword'>bool </span><span class='Declare_Parameter'>lateral_only</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>lateral_ok</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN86"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>checkExprIsVarFree</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>n</span><span class='Delimiter'>, 
</span><a name="LN87"></a>                   <span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>constructName</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN88"></a><span class='Keyword'>static </span><a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>findTargetlistEntrySQL92</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, 
</span><a name="LN89"></a>                         <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>tlist</span><span class='Delimiter'>, </span><a href="../../include/parser/parse_node.h.html#LN32"><span class='Ref_to_Enum'>ParseExprKind</span></a> <span class='Declare_Parameter'>exprKind</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN90"></a><span class='Keyword'>static </span><a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>findTargetlistEntrySQL99</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, 
</span><a name="LN91"></a>                         <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>tlist</span><span class='Delimiter'>, </span><a href="../../include/parser/parse_node.h.html#LN32"><span class='Ref_to_Enum'>ParseExprKind</span></a> <span class='Declare_Parameter'>exprKind</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN92"></a><span class='Keyword'>static int </span><span class='Declare_Prototype'>get_matching_location</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>sortgroupref</span><span class='Delimiter'>, 
</span><a name="LN93"></a>                      <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sortgrouprefs</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>exprs</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN94"></a><span class='Keyword'>static </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>resolve_unique_index_expr</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN1308"><span class='Ref_to_Struct'>InferClause</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>infer</span><span class='Delimiter'>, 
</span><a name="LN95"></a>                          <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>heapRel</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN96"></a><span class='Keyword'>static </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>addTargetToGroupList</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tle</span><span class='Delimiter'>, 
</span><a name="LN97"></a>                     <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>grouplist</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>targetlist</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>location</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN98"></a><span class='Keyword'>static </span><a href="../../include/nodes/parsenodes.h.html#LN1252"><span class='Ref_to_Struct'>WindowClause</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>findWindowClause</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>wclist</span><span class='Delimiter'>, </span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>name</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN99"></a><span class='Keyword'>static </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>transformFrameOffset</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>frameOptions</span><span class='Delimiter'>, 
</span><a name="LN100"></a>                     <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * transformFromClause - 
 *    Process the FROM clause and add items to the query's range table, 
 *    joinlist, and namespace. 
 * 
 * Note: we assume that the pstate's p_rtable, p_joinlist, and p_namespace 
 * lists were initialized to NIL when the pstate was created. 
 * We will add onto any entries already present --- this is needed for rule 
 * processing, as well as for UPDATE and DELETE. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN114"></a><span class='Declare_Function'>transformFromClause</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>frmList</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN116"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>fl</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The grammar will have produced a list of RangeVars, RangeSubselects, 
     * RangeFunctions, and/or JoinExprs. Transform each one (possibly adding 
     * entries to the rtable), check for duplicate refnames, and then add it 
     * to the joinlist and namespace. 
     * 
     * Note we must process the items left-to-right for proper handling of 
     * LATERAL references. 
     */ 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN116"><span class='Ref_To_Local'>fl</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN114"><span class='Ref_to_Parameter'>frmList</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN129"></a>        <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>n</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN116"><span class='Ref_To_Local'>fl</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN130"></a>        <a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span><span class='Delimiter'>; 
</span><a name="LN131"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>rtindex</span><span class='Delimiter'>; 
</span><a name="LN132"></a>        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>namespace</span><span class='Delimiter'>; 
</span> 
        <a href="parse_clause.c.html#LN129"><span class='Ref_To_Local'>n</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN75"><span class='Ref_to_Proto'>transformFromClauseItem</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN114"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN129"><span class='Ref_To_Local'>n</span></a><span class='Delimiter'>, 
</span>                                    <span class='Operator'>&</span><a href="parse_clause.c.html#LN130"><span class='Ref_To_Local'>rte</span></a><span class='Delimiter'>, 
</span>                                    <span class='Operator'>&</span><a href="parse_clause.c.html#LN131"><span class='Ref_To_Local'>rtindex</span></a><span class='Delimiter'>, 
</span>                                    <span class='Operator'>&</span><span class='Control'>namespace</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/parser/parse_relation.h.html#LN45"><span class='Ref_to_Proto'>checkNameSpaceConflicts</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN114"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN114"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN172"><span class='Ref_to_Member'>p_namespace</span></a><span class='Delimiter'>, </span><span class='Control'>namespace</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Mark the new namespace items as visible only to LATERAL */ 
</span>        <a href="parse_clause.c.html#LN84"><span class='Ref_to_Proto'>setNamespaceLateralState</span></a><span class='Parentheses'>(</span><span class='Control'>namespace</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="parse_clause.c.html#LN114"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN170"><span class='Ref_to_Member'>p_joinlist</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN114"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN170"><span class='Ref_to_Member'>p_joinlist</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN129"><span class='Ref_To_Local'>n</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN114"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN172"><span class='Ref_to_Member'>p_namespace</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN114"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN172"><span class='Ref_to_Member'>p_namespace</span></a><span class='Delimiter'>, </span><span class='Control'>namespace</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We're done parsing the FROM list, so make all namespace items 
     * unconditionally visible.  Note that this will also reset lateral_only 
     * for any namespace items that were already present when we were called; 
     * but those should have been that way already. 
     */ 
</span>    <a href="parse_clause.c.html#LN84"><span class='Ref_to_Proto'>setNamespaceLateralState</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN114"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN172"><span class='Ref_to_Member'>p_namespace</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end transformFromClause &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * setTargetTable 
 *    Add the target relation of INSERT/UPDATE/DELETE to the range table, 
 *    and make the special links to it in the ParseState. 
 * 
 *    We also open the target relation and acquire a write lock on it. 
 *    This must be done before processing the FROM list, in case the target 
 *    is also mentioned as a source relation --- we want to be sure to grab 
 *    the write lock before any read lock. 
 * 
 *    If alsoSource is true, add the target to the query's joinlist and 
 *    namespace.  For INSERT, we don't want the target to be joined to; 
 *    it's a destination of tuples, not a source.   For UPDATE/DELETE, 
 *    we do need to scan or join the target.  (NOTE: we do not bother 
 *    to check for namespace conflict; we assume that the namespace was 
 *    initially empty in these cases.) 
 * 
 *    Finally, we mark the relation as requiring the permissions specified 
 *    by requiredPerms. 
 * 
 *    Returns the rangetable index of the target relation. 
 */ 
</span><span class='Keyword'>int 
</span><a name="LN180"></a><span class='Declare_Function'>setTargetTable</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>relation</span><span class='Delimiter'>, 
</span><a name="LN181"></a>               <span class='Keyword'>bool </span><span class='Declare_Parameter'>inh</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>alsoSource</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN69"><span class='Ref_to_Typedef'>AclMode</span></a> <span class='Declare_Parameter'>requiredPerms</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN183"></a>    <a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span><span class='Delimiter'>; 
</span><a name="LN184"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>rtindex</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* So far special relations are immutable; so they cannot be targets. */ 
</span>    <a href="parse_clause.c.html#LN183"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN61"><span class='Ref_to_Proto'>getRTEForSpecialRelationTypes</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN180"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN180"><span class='Ref_to_Parameter'>relation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN183"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"relation \"%s\" cannot be the target of a modifying statement"</span><span class='Delimiter'>, 
</span>                        <a href="parse_clause.c.html#LN180"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN67"><span class='Ref_to_Member'>relname</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Close old target; this could only happen for multi-action rules */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN180"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN178"><span class='Ref_to_Member'>p_target_relation</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../include/access/heapam.h.html#LN96"><span class='Ref_to_Macro'>heap_close</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN180"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN178"><span class='Ref_to_Member'>p_target_relation</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN33"><span class='Ref_to_Const'>NoLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Open target rel and grab suitable lock (which we will hold till end of 
     * transaction). 
     * 
     * free_parsestate() will eventually do the corresponding heap_close(), 
     * but *not* release the lock. 
     */ 
</span>    <a href="parse_clause.c.html#LN180"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN178"><span class='Ref_to_Member'>p_target_relation</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_relation.h.html#LN62"><span class='Ref_to_Proto'>parserOpenTable</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN180"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN180"><span class='Ref_to_Parameter'>relation</span></a><span class='Delimiter'>, 
</span>                                                <a href="../../include/storage/lockdefs.h.html#LN37"><span class='Ref_to_Const'>RowExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now build an RTE. 
     */ 
</span>    <a href="parse_clause.c.html#LN183"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_relation.h.html#LN69"><span class='Ref_to_Proto'>addRangeTableEntryForRelation</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN180"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN180"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN178"><span class='Ref_to_Member'>p_target_relation</span></a><span class='Delimiter'>, 
</span>                                        <a href="parse_clause.c.html#LN180"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN71"><span class='Ref_to_Member'>alias</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN181"><span class='Ref_to_Parameter'>inh</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="parse_clause.c.html#LN180"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN179"><span class='Ref_to_Member'>p_target_rangetblentry</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN183"><span class='Ref_To_Local'>rte</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* assume new rte is at end */ 
</span>    <a href="parse_clause.c.html#LN184"><span class='Ref_To_Local'>rtindex</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN180"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN183"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>== </span><a href="../../include/parser/parsetree.h.html#LN30"><span class='Ref_to_Macro'>rt_fetch</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN184"><span class='Ref_To_Local'>rtindex</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN180"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Override addRangeTableEntry's default ACL_SELECT permissions check, and 
     * instead mark target table as requiring exactly the specified 
     * permissions. 
     * 
     * If we find an explicit reference to the rel later during parse 
     * analysis, we will add the ACL_SELECT bit back again; see 
     * markVarForSelectPriv and its callers. 
     */ 
</span>    <a href="parse_clause.c.html#LN183"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1027"><span class='Ref_to_Member'>requiredPerms</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN181"><span class='Ref_to_Parameter'>requiredPerms</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If UPDATE/DELETE, add table to joinlist and namespace. 
     * 
     * Note: some callers know that they can find the new ParseNamespaceItem 
     * at the end of the pstate-&GT;p_namespace list.  This is a bit ugly but not 
     * worth complicating this function's signature for. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN181"><span class='Ref_to_Parameter'>alsoSource</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/parser/parse_relation.h.html#LN114"><span class='Ref_to_Proto'>addRTEtoQuery</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN180"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN183"><span class='Ref_To_Local'>rte</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="parse_clause.c.html#LN184"><span class='Ref_To_Local'>rtindex</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end setTargetTable &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Given a relation-options list (of DefElems), return true iff the specified 
 * table/result set should be created with OIDs. This needs to be done after 
 * parsing the query string because the return value can depend upon the 
 * default_with_oids GUC var. 
 * 
 * In some situations, we want to reject an OIDS option even if it's present. 
 * That's (rather messily) handled here rather than reloptions.c, because that 
 * code explicitly punts checking for oids to here. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN254"></a><span class='Declare_Function'>interpretOidsOption</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>defList</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>allowOids</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN256"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>cell</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Scan list to see if OIDS was included */ 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN256"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN254"><span class='Ref_to_Parameter'>defList</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN261"></a>        <a href="../../include/nodes/parsenodes.h.html#LN715"><span class='Ref_to_Struct'>DefElem</span></a>    <span class='Operator'>*</span><span class='Declare_Local'>def</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN715"><span class='Ref_to_Struct'>DefElem</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN256"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN261"><span class='Ref_To_Local'>def</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN718"><span class='Ref_to_Member'>defnamespace</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>&& 
</span>            <a href="../../port/pgstrcasecmp.c.html#LN34"><span class='Ref_to_Func'>pg_strcasecmp</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN261"><span class='Ref_To_Local'>def</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN719"><span class='Ref_to_Member'>defname</span></a><span class='Delimiter'>, </span><span class='String'>"oids"</span><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_clause.c.html#LN254"><span class='Ref_to_Parameter'>allowOids</span></a><span class='Parentheses'>) 
</span>                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_PARAMETER_VALUE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"unrecognized parameter \"%s\""</span><span class='Delimiter'>, 
</span>                                <a href="parse_clause.c.html#LN261"><span class='Ref_To_Local'>def</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN719"><span class='Ref_to_Member'>defname</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <a href="../commands/define.c.html#LN109"><span class='Ref_to_Func'>defGetBoolean</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN261"><span class='Ref_To_Local'>def</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Force no-OIDS result if caller disallows OIDS. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_clause.c.html#LN254"><span class='Ref_to_Parameter'>allowOids</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* OIDS option was not specified, so use default. */ 
</span>    <span class='Control'>return</span> <a href="../utils/misc/guc.c.html#LN447"><span class='Ref_to_Global_Var'>default_with_oids</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end interpretOidsOption &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Extract all not-in-common columns from column lists of a source table 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN287"></a><span class='Declare_Function'>extractRemainingColumns</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>common_colnames</span><span class='Delimiter'>, 
</span><a name="LN288"></a>                        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>src_colnames</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>src_colvars</span><span class='Delimiter'>, 
</span><a name="LN289"></a>                        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>res_colnames</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>res_colvars</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN291"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>new_colnames</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN292"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>new_colvars</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN293"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lnames</span><span class='Delimiter'>, 
</span><a name="LN294"></a>               <span class='Operator'>*</span><span class='Declare_Local'>lvars</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN288"><span class='Ref_to_Parameter'>src_colnames</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN288"><span class='Ref_to_Parameter'>src_colvars</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN179"><span class='Ref_to_Macro'>forboth</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN293"><span class='Ref_To_Local'>lnames</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN288"><span class='Ref_to_Parameter'>src_colnames</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN294"><span class='Ref_To_Local'>lvars</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN288"><span class='Ref_to_Parameter'>src_colvars</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN300"></a>        <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>colname</span> <span class='Operator'>= </span><a href="../../include/nodes/value.h.html#LN53"><span class='Ref_to_Macro'>strVal</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN293"><span class='Ref_To_Local'>lnames</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span><a name="LN301"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>match</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN302"></a>        <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>cnames</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN302"><span class='Ref_To_Local'>cnames</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN287"><span class='Ref_to_Parameter'>common_colnames</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN306"></a>            <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>ccolname</span> <span class='Operator'>= </span><a href="../../include/nodes/value.h.html#LN53"><span class='Ref_to_Macro'>strVal</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN302"><span class='Ref_To_Local'>cnames</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="parse_clause.c.html#LN300"><span class='Ref_To_Local'>colname</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN306"><span class='Ref_To_Local'>ccolname</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <span class='Delimiter'>{ 
</span>                <a href="parse_clause.c.html#LN301"><span class='Ref_To_Local'>match</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_clause.c.html#LN301"><span class='Ref_To_Local'>match</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="parse_clause.c.html#LN291"><span class='Ref_To_Local'>new_colnames</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN291"><span class='Ref_To_Local'>new_colnames</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN293"><span class='Ref_To_Local'>lnames</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="parse_clause.c.html#LN292"><span class='Ref_To_Local'>new_colvars</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN292"><span class='Ref_To_Local'>new_colvars</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN294"><span class='Ref_To_Local'>lvars</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Operator'>*</span><a href="parse_clause.c.html#LN289"><span class='Ref_to_Parameter'>res_colnames</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN291"><span class='Ref_To_Local'>new_colnames</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="parse_clause.c.html#LN289"><span class='Ref_to_Parameter'>res_colvars</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN292"><span class='Ref_To_Local'>new_colvars</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end extractRemainingColumns &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* transformJoinUsingClause() 
 *    Build a complete ON clause from a partially-transformed USING list. 
 *    We are given lists of nodes representing left and right match columns. 
 *    Result is a transformed qualification expression. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN332"></a><span class='Declare_Function'>transformJoinUsingClause</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, 
</span><a name="LN333"></a>                         <a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>leftRTE</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rightRTE</span><span class='Delimiter'>, 
</span><a name="LN334"></a>                         <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>leftVars</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rightVars</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN336"></a>    <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span><a name="LN337"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>andargs</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN338"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lvars</span><span class='Delimiter'>, 
</span><a name="LN339"></a>               <span class='Operator'>*</span><span class='Declare_Local'>rvars</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We cheat a little bit here by building an untransformed operator tree 
     * whose leaves are the already-transformed Vars.  This requires collusion 
     * from transformExpr(), which normally could be expected to complain 
     * about already-transformed subnodes.  However, this does mean that we 
     * have to mark the columns as requiring SELECT privilege for ourselves; 
     * transformExpr() won't do it. 
     */ 
</span>    <a href="../../include/nodes/pg_list.h.html#LN179"><span class='Ref_to_Macro'>forboth</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN338"><span class='Ref_To_Local'>lvars</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN334"><span class='Ref_to_Parameter'>leftVars</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN339"><span class='Ref_To_Local'>rvars</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN334"><span class='Ref_to_Parameter'>rightVars</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN351"></a>        <a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>lvar</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN338"><span class='Ref_To_Local'>lvars</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN352"></a>        <a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>rvar</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN339"><span class='Ref_To_Local'>rvars</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN353"></a>        <a href="../../include/nodes/parsenodes.h.html#LN271"><span class='Ref_to_Struct'>A_Expr</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>e</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Require read access to the join variables */ 
</span>        <a href="../../include/parser/parse_relation.h.html#LN60"><span class='Ref_to_Proto'>markVarForSelectPriv</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN332"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN351"><span class='Ref_To_Local'>lvar</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN333"><span class='Ref_to_Parameter'>leftRTE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/parser/parse_relation.h.html#LN60"><span class='Ref_to_Proto'>markVarForSelectPriv</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN332"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN352"><span class='Ref_To_Local'>rvar</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN333"><span class='Ref_to_Parameter'>rightRTE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Now create the lvar = rvar join condition */ 
</span>        <a href="parse_clause.c.html#LN353"><span class='Ref_To_Local'>e</span></a> <span class='Operator'>= </span><a href="../../include/nodes/makefuncs.h.html#LN22"><span class='Ref_to_Proto'>makeSimpleA_Expr</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN253"><span class='Ref_to_EnumConst'>AEXPR_OP</span></a><span class='Delimiter'>, </span><span class='String'>"="</span><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN351"><span class='Ref_To_Local'>lvar</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN352"><span class='Ref_To_Local'>rvar</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <span class='Operator'>-</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Prepare to combine into an AND clause, if multiple join columns */ 
</span>        <a href="parse_clause.c.html#LN337"><span class='Ref_To_Local'>andargs</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN337"><span class='Ref_To_Local'>andargs</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN353"><span class='Ref_To_Local'>e</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Only need an AND if there's more than one join column */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN337"><span class='Ref_To_Local'>andargs</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
        <a href="parse_clause.c.html#LN336"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN337"><span class='Ref_To_Local'>andargs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="parse_clause.c.html#LN336"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/makefuncs.h.html#LN61"><span class='Ref_to_Proto'>makeBoolExpr</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN554"><span class='Ref_to_EnumConst'>AND_EXPR</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN337"><span class='Ref_To_Local'>andargs</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Since the references are already Vars, and are certainly from the input 
     * relations, we don't have to go through the same pushups that 
     * transformJoinOnClause() does.  Just invoke transformExpr() to fix up 
     * the operators, and we're done. 
     */ 
</span>    <a href="parse_clause.c.html#LN336"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_expr.h.html#LN21"><span class='Ref_to_Proto'>transformExpr</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN332"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN336"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="../../include/parser/parse_node.h.html#LN37"><span class='Ref_to_EnumConst'>EXPR_KIND_JOIN_USING</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="parse_clause.c.html#LN336"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN54"><span class='Ref_to_Proto'>coerce_to_boolean</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN332"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN336"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><span class='String'>"JOIN/USING"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="parse_clause.c.html#LN336"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end transformJoinUsingClause &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* transformJoinOnClause() 
 *    Transform the qual conditions for JOIN/ON. 
 *    Result is a transformed qualification expression. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN392"></a><span class='Declare_Function'>transformJoinOnClause</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN1444"><span class='Ref_to_Struct'>JoinExpr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>j</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>namespace</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN394"></a>    <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span><a name="LN395"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>save_namespace</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The namespace that the join expression should see is just the two 
     * subtrees of the JOIN plus any outer references from upper pstate 
     * levels.  Temporarily set this pstate's namespace accordingly.  (We need 
     * not check for refname conflicts, because transformFromClauseItem() 
     * already did.)  All namespace items are marked visible regardless of 
     * LATERAL state. 
     */ 
</span>    <a href="parse_clause.c.html#LN84"><span class='Ref_to_Proto'>setNamespaceLateralState</span></a><span class='Parentheses'>(</span><span class='Control'>namespace</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="parse_clause.c.html#LN395"><span class='Ref_To_Local'>save_namespace</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN392"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN172"><span class='Ref_to_Member'>p_namespace</span></a><span class='Delimiter'>; 
</span>    <a href="parse_clause.c.html#LN392"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN172"><span class='Ref_to_Member'>p_namespace</span></a> <span class='Operator'>= </span><span class='Control'>namespace</span><span class='Delimiter'>; 
</span> 
    <a href="parse_clause.c.html#LN394"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_clause.h.html#LN23"><span class='Ref_to_Proto'>transformWhereClause</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN392"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN392"><span class='Ref_to_Parameter'>j</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1452"><span class='Ref_to_Member'>quals</span></a><span class='Delimiter'>, 
</span>                                  <a href="../../include/parser/parse_node.h.html#LN36"><span class='Ref_to_EnumConst'>EXPR_KIND_JOIN_ON</span></a><span class='Delimiter'>, </span><span class='String'>"JOIN/ON"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="parse_clause.c.html#LN392"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN172"><span class='Ref_to_Member'>p_namespace</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN395"><span class='Ref_To_Local'>save_namespace</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="parse_clause.c.html#LN394"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end transformJoinOnClause &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * transformTableEntry --- transform a RangeVar (simple relation reference) 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>* 
</span><a name="LN422"></a><span class='Declare_Function'>transformTableEntry</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>r</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN424"></a>    <a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* We need only build a range table entry */ 
</span>    <a href="parse_clause.c.html#LN424"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_relation.h.html#LN64"><span class='Ref_to_Proto'>addRangeTableEntry</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN422"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN422"><span class='Ref_to_Parameter'>r</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN422"><span class='Ref_to_Parameter'>r</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN71"><span class='Ref_to_Member'>alias</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN422"><span class='Ref_to_Parameter'>r</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN68"><span class='Ref_to_Member'>inh</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="parse_clause.c.html#LN424"><span class='Ref_To_Local'>rte</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * transformCTEReference --- transform a RangeVar that references a common 
 * table expression (ie, a sub-SELECT defined in a WITH clause) 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>* 
</span><a name="LN437"></a><span class='Declare_Function'>transformCTEReference</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>r</span><span class='Delimiter'>, 
</span><a name="LN438"></a>                      <a href="../../include/nodes/parsenodes.h.html#LN1339"><span class='Ref_to_Struct'>CommonTableExpr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>cte</span><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> <span class='Declare_Parameter'>levelsup</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN440"></a>    <a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span><span class='Delimiter'>; 
</span> 
    <a href="parse_clause.c.html#LN440"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_relation.h.html#LN105"><span class='Ref_to_Proto'>addRangeTableEntryForCTE</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN437"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN438"><span class='Ref_to_Parameter'>cte</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN438"><span class='Ref_to_Parameter'>levelsup</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN437"><span class='Ref_to_Parameter'>r</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="parse_clause.c.html#LN440"><span class='Ref_To_Local'>rte</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * transformENRReference --- transform a RangeVar that references an ephemeral 
 * named relation 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>* 
</span><a name="LN452"></a><span class='Declare_Function'>transformENRReference</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>r</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN454"></a>    <a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span><span class='Delimiter'>; 
</span> 
    <a href="parse_clause.c.html#LN454"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_relation.h.html#LN110"><span class='Ref_to_Proto'>addRangeTableEntryForENR</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN452"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN452"><span class='Ref_to_Parameter'>r</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="parse_clause.c.html#LN454"><span class='Ref_To_Local'>rte</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * transformRangeSubselect --- transform a sub-SELECT appearing in FROM 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>* 
</span><a name="LN465"></a><span class='Declare_Function'>transformRangeSubselect</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN531"><span class='Ref_to_Struct'>RangeSubselect</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>r</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN467"></a>    <a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>query</span><span class='Delimiter'>; 
</span><a name="LN468"></a>    <a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We require user to supply an alias for a subselect, per SQL92. To relax 
     * this, we'd have to be prepared to gin up a unique alias for an 
     * unlabeled subselect.  (This is just elog, not ereport, because the 
     * grammar should have enforced it already.  It'd probably be better to 
     * report the error here, but we don't have a good error location here.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN465"><span class='Ref_to_Parameter'>r</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN536"><span class='Ref_to_Member'>alias</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"subquery in FROM must have an alias"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Set p_expr_kind to show this parse level is recursing to a subselect. 
     * We can't be nested within any expression, so don't need save-restore 
     * logic here. 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN465"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN182"><span class='Ref_to_Member'>p_expr_kind</span></a> <span class='Operator'>== </span><a href="../../include/parser/parse_node.h.html#LN34"><span class='Ref_to_EnumConst'>EXPR_KIND_NONE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="parse_clause.c.html#LN465"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN182"><span class='Ref_to_Member'>p_expr_kind</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_node.h.html#LN38"><span class='Ref_to_EnumConst'>EXPR_KIND_FROM_SUBSELECT</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the subselect is LATERAL, make lateral_only names of this level 
     * visible to it.  (LATERAL can't nest within a single pstate level, so we 
     * don't need save/restore logic here.) 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_clause.c.html#LN465"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN174"><span class='Ref_to_Member'>p_lateral_active</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="parse_clause.c.html#LN465"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN174"><span class='Ref_to_Member'>p_lateral_active</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN465"><span class='Ref_to_Parameter'>r</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN534"><span class='Ref_to_Member'>lateral</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Analyze and transform the subquery. 
     */ 
</span>    <a href="parse_clause.c.html#LN467"><span class='Ref_To_Local'>query</span></a> <span class='Operator'>= </span><a href="../../include/parser/analyze.h.html#LN29"><span class='Ref_to_Proto'>parse_sub_analyze</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN465"><span class='Ref_to_Parameter'>r</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN535"><span class='Ref_to_Member'>subquery</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN465"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                              <a href="../../include/parser/parse_relation.h.html#LN113"><span class='Ref_to_Proto'>isLockedRefname</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN465"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN465"><span class='Ref_to_Parameter'>r</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN536"><span class='Ref_to_Member'>alias</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN41"><span class='Ref_to_Member'>aliasname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                              <span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Restore state */ 
</span>    <a href="parse_clause.c.html#LN465"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN174"><span class='Ref_to_Member'>p_lateral_active</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="parse_clause.c.html#LN465"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN182"><span class='Ref_to_Member'>p_expr_kind</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_node.h.html#LN34"><span class='Ref_to_EnumConst'>EXPR_KIND_NONE</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Check that we got a SELECT.  Anything else should be impossible given 
     * restrictions of the grammar, but check anyway. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN467"><span class='Ref_To_Local'>query</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <a href="parse_clause.c.html#LN467"><span class='Ref_To_Local'>query</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN109"><span class='Ref_to_Member'>commandType</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/nodes.h.html#LN650"><span class='Ref_to_EnumConst'>CMD_SELECT</span></a><span class='Parentheses'>)</span> 
        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unexpected non-SELECT command in subquery in FROM"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * OK, build an RTE for the subquery. 
     */ 
</span>    <a href="parse_clause.c.html#LN468"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_relation.h.html#LN74"><span class='Ref_to_Proto'>addRangeTableEntryForSubquery</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN465"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                        <a href="parse_clause.c.html#LN467"><span class='Ref_To_Local'>query</span></a><span class='Delimiter'>, 
</span>                                        <a href="parse_clause.c.html#LN465"><span class='Ref_to_Parameter'>r</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN536"><span class='Ref_to_Member'>alias</span></a><span class='Delimiter'>, 
</span>                                        <a href="parse_clause.c.html#LN465"><span class='Ref_to_Parameter'>r</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN534"><span class='Ref_to_Member'>lateral</span></a><span class='Delimiter'>, 
</span>                                        <span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="parse_clause.c.html#LN468"><span class='Ref_To_Local'>rte</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end transformRangeSubselect &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * transformRangeFunction --- transform a function call appearing in FROM 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>* 
</span><a name="LN532"></a><span class='Declare_Function'>transformRangeFunction</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN553"><span class='Ref_to_Struct'>RangeFunction</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>r</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN534"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>funcexprs</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN535"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>funcnames</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN536"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>coldeflists</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN537"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>is_lateral</span><span class='Delimiter'>; 
</span><a name="LN538"></a>    <a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span><span class='Delimiter'>; 
</span><a name="LN539"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We make lateral_only names of this level visible, whether or not the 
     * RangeFunction is explicitly marked LATERAL.  This is needed for SQL 
     * spec compliance in the case of UNNEST(), and seems useful on 
     * convenience grounds for all functions in FROM. 
     * 
     * (LATERAL can't nest within a single pstate level, so we don't need 
     * save/restore logic here.) 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_clause.c.html#LN532"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN174"><span class='Ref_to_Member'>p_lateral_active</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="parse_clause.c.html#LN532"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN174"><span class='Ref_to_Member'>p_lateral_active</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Transform the raw expressions. 
     * 
     * While transforming, also save function names for possible use as alias 
     * and column names.  We use the same transformation rules as for a SELECT 
     * output expression.  For a FuncCall node, the result will be the 
     * function name, but it is possible for the grammar to hand back other 
     * node types. 
     * 
     * We have to get this info now, because FigureColname only works on raw 
     * parsetrees.  Actually deciding what to do with the names is left up to 
     * addRangeTableEntryForFunction. 
     * 
     * Likewise, collect column definition lists if there were any.  But 
     * complain if we find one here and the RangeFunction has one too. 
     */ 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN539"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN532"><span class='Ref_to_Parameter'>r</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN559"><span class='Ref_to_Member'>functions</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN571"></a>        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>pair</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN539"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN572"></a>        <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>fexpr</span><span class='Delimiter'>; 
</span><a name="LN573"></a>        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>coldeflist</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Disassemble the function-call/column-def-list pairs */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN571"><span class='Ref_To_Local'>pair</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN572"><span class='Ref_To_Local'>fexpr</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN571"><span class='Ref_To_Local'>pair</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN573"><span class='Ref_To_Local'>coldeflist</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN115"><span class='Ref_to_Macro'>lsecond</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN571"><span class='Ref_To_Local'>pair</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If we find a function call unnest() with more than one argument and 
         * no special decoration, transform it into separate unnest() calls on 
         * each argument.  This is a kluge, for sure, but it's less nasty than 
         * other ways of implementing the SQL-standard UNNEST() syntax. 
         * 
         * If there is any decoration (including a coldeflist), we don't 
         * transform, which probably means a no-such-function error later.  We 
         * could alternatively throw an error right now, but that doesn't seem 
         * tremendously helpful.  If someone is using any such decoration, 
         * then they're not using the SQL-standard syntax, and they're more 
         * likely expecting an un-tweaked function call. 
         * 
         * Note: the transformation changes a non-schema-qualified unnest() 
         * function name into schema-qualified pg_catalog.unnest().  This 
         * choice is also a bit debatable, but it seems reasonable to force 
         * use of built-in unnest() when we make this transformation. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN572"><span class='Ref_To_Local'>fexpr</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN346"><span class='Ref_to_Struct'>FuncCall</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN600"></a>            <a href="../../include/nodes/parsenodes.h.html#LN346"><span class='Ref_to_Struct'>FuncCall</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>fc</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN346"><span class='Ref_to_Struct'>FuncCall</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN572"><span class='Ref_To_Local'>fexpr</span></a><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN600"><span class='Ref_To_Local'>fc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN349"><span class='Ref_to_Member'>funcname</span></a><span class='Parentheses'>)</span> <span class='Operator'>== </span><span class='Number'>1</span> <span class='Operator'>&& 
</span>                strcmp<span class='Parentheses'>(</span><a href="../../include/nodes/value.h.html#LN53"><span class='Ref_to_Macro'>strVal</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN600"><span class='Ref_To_Local'>fc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN349"><span class='Ref_to_Member'>funcname</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, </span><span class='String'>"unnest"</span><span class='Parentheses'>)</span> <span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>&& 
</span>                <a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN600"><span class='Ref_To_Local'>fc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN350"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span> <span class='Operator'>&GT; </span><span class='Number'>1</span> <span class='Operator'>&& 
</span>                <a href="parse_clause.c.html#LN600"><span class='Ref_To_Local'>fc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN351"><span class='Ref_to_Member'>agg_order</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>&& 
</span>                <a href="parse_clause.c.html#LN600"><span class='Ref_To_Local'>fc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN352"><span class='Ref_to_Member'>agg_filter</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>&& 
</span>                <span class='Operator'>!</span><a href="parse_clause.c.html#LN600"><span class='Ref_To_Local'>fc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN354"><span class='Ref_to_Member'>agg_star</span></a> <span class='Operator'>&& 
</span>                <span class='Operator'>!</span><a href="parse_clause.c.html#LN600"><span class='Ref_To_Local'>fc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN355"><span class='Ref_to_Member'>agg_distinct</span></a> <span class='Operator'>&& 
</span>                <span class='Operator'>!</span><a href="parse_clause.c.html#LN600"><span class='Ref_To_Local'>fc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN356"><span class='Ref_to_Member'>func_variadic</span></a> <span class='Operator'>&& 
</span>                <a href="parse_clause.c.html#LN600"><span class='Ref_To_Local'>fc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN357"><span class='Ref_to_Member'>over</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>&& 
</span>                <a href="parse_clause.c.html#LN573"><span class='Ref_To_Local'>coldeflist</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span> 
            <span class='Delimiter'>{ 
</span><a name="LN613"></a>                <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
                <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN613"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN600"><span class='Ref_To_Local'>fc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN350"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN617"></a>                    <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>arg</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN613"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN618"></a>                    <a href="../../include/nodes/parsenodes.h.html#LN346"><span class='Ref_to_Struct'>FuncCall</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>newfc</span><span class='Delimiter'>; 
</span> 
                    <a href="parse_clause.c.html#LN618"><span class='Ref_To_Local'>newfc</span></a> <span class='Operator'>= </span><a href="../../include/nodes/makefuncs.h.html#LN80"><span class='Ref_to_Proto'>makeFuncCall</span></a><span class='Parentheses'>(</span><a href="../../include/parser/parser.h.html#LN37"><span class='Ref_to_Proto'>SystemFuncName</span></a><span class='Parentheses'>(</span><span class='String'>"unnest"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                         <a href="../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN617"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                         <a href="parse_clause.c.html#LN600"><span class='Ref_To_Local'>fc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN358"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <a href="parse_clause.c.html#LN534"><span class='Ref_To_Local'>funcexprs</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN534"><span class='Ref_To_Local'>funcexprs</span></a><span class='Delimiter'>, 
</span>                                        <a href="../../include/parser/parse_expr.h.html#LN21"><span class='Ref_to_Proto'>transformExpr</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN532"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN618"><span class='Ref_To_Local'>newfc</span></a><span class='Delimiter'>, 
</span>                                                   <a href="../../include/parser/parse_node.h.html#LN39"><span class='Ref_to_EnumConst'>EXPR_KIND_FROM_FUNCTION</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
                    <a href="parse_clause.c.html#LN535"><span class='Ref_To_Local'>funcnames</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN535"><span class='Ref_To_Local'>funcnames</span></a><span class='Delimiter'>, 
</span>                                        <a href="../../include/parser/parse_target.h.html#LN42"><span class='Ref_to_Proto'>FigureColname</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN618"><span class='Ref_To_Local'>newfc</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
                    <span class='Comment_Multi_Line'>/* coldeflist is empty, so no error is possible */ 
</span> 
                    <a href="parse_clause.c.html#LN536"><span class='Ref_To_Local'>coldeflists</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN536"><span class='Ref_To_Local'>coldeflists</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN573"><span class='Ref_To_Local'>coldeflist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>continue</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* done with this function item */ 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if list_length(fc-&GT;funcn... &raquo; </span> 
        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IsA(fexpr,FuncCall) &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* normal case ... */ 
</span>        <a href="parse_clause.c.html#LN534"><span class='Ref_To_Local'>funcexprs</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN534"><span class='Ref_To_Local'>funcexprs</span></a><span class='Delimiter'>, 
</span>                            <a href="../../include/parser/parse_expr.h.html#LN21"><span class='Ref_to_Proto'>transformExpr</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN532"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN572"><span class='Ref_To_Local'>fexpr</span></a><span class='Delimiter'>, 
</span>                                          <a href="../../include/parser/parse_node.h.html#LN39"><span class='Ref_to_EnumConst'>EXPR_KIND_FROM_FUNCTION</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <a href="parse_clause.c.html#LN535"><span class='Ref_To_Local'>funcnames</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN535"><span class='Ref_To_Local'>funcnames</span></a><span class='Delimiter'>, 
</span>                            <a href="../../include/parser/parse_target.h.html#LN42"><span class='Ref_to_Proto'>FigureColname</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN572"><span class='Ref_To_Local'>fexpr</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN573"><span class='Ref_To_Local'>coldeflist</span></a> <span class='Operator'>&& </span><a href="parse_clause.c.html#LN532"><span class='Ref_to_Parameter'>r</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN561"><span class='Ref_to_Member'>coldeflist</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_SYNTAX_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"multiple column definition lists are not allowed for the same function"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN532"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                     <a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN532"><span class='Ref_to_Parameter'>r</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN561"><span class='Ref_to_Member'>coldeflist</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span> 
        <a href="parse_clause.c.html#LN536"><span class='Ref_To_Local'>coldeflists</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN536"><span class='Ref_To_Local'>coldeflists</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN573"><span class='Ref_To_Local'>coldeflist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="parse_clause.c.html#LN532"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN174"><span class='Ref_to_Member'>p_lateral_active</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We must assign collations now so that the RTE exposes correct collation 
     * info for Vars created from it. 
     */ 
</span>    <a href="../../include/parser/parse_collate.h.html#LN20"><span class='Ref_to_Proto'>assign_list_collations</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN532"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN534"><span class='Ref_To_Local'>funcexprs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Install the top-level coldeflist if there was one (we already checked 
     * that there was no conflicting per-function coldeflist). 
     * 
     * We only allow this when there's a single function (even after UNNEST 
     * expansion) and no WITH ORDINALITY.  The reason for the latter 
     * restriction is that it's not real clear whether the ordinality column 
     * should be in the coldeflist, and users are too likely to make mistakes 
     * in one direction or the other.  Putting the coldeflist inside ROWS 
     * FROM() is much clearer in this case. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN532"><span class='Ref_to_Parameter'>r</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN561"><span class='Ref_to_Member'>coldeflist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN534"><span class='Ref_To_Local'>funcexprs</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN532"><span class='Ref_to_Parameter'>r</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN558"><span class='Ref_to_Member'>is_rowsfrom</span></a><span class='Parentheses'>) 
</span>                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_SYNTAX_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"ROWS FROM() with multiple functions cannot have a column definition list"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"Put a separate column definition list for each function inside ROWS FROM()."</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN532"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                     <a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN532"><span class='Ref_to_Parameter'>r</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN561"><span class='Ref_to_Member'>coldeflist</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_SYNTAX_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"UNNEST() with multiple arguments cannot have a column definition list"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"Use separate UNNEST() calls inside ROWS FROM(), and attach a column definition list to each one."</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN532"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                     <a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN532"><span class='Ref_to_Parameter'>r</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN561"><span class='Ref_to_Member'>coldeflist</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN532"><span class='Ref_to_Parameter'>r</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN557"><span class='Ref_to_Member'>ordinality</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_SYNTAX_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"WITH ORDINALITY cannot be used with a column definition list"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>               <a href="../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"Put the column definition list inside ROWS FROM()."</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN532"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                     <a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN532"><span class='Ref_to_Parameter'>r</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN561"><span class='Ref_to_Member'>coldeflist</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span> 
        <a href="parse_clause.c.html#LN536"><span class='Ref_To_Local'>coldeflists</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN532"><span class='Ref_to_Parameter'>r</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN561"><span class='Ref_to_Member'>coldeflist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if r-&GT;coldeflist &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Mark the RTE as LATERAL if the user said LATERAL explicitly, or if 
     * there are any lateral cross-references in it. 
     */ 
</span>    <a href="parse_clause.c.html#LN537"><span class='Ref_To_Local'>is_lateral</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN532"><span class='Ref_to_Parameter'>r</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN556"><span class='Ref_to_Member'>lateral</span></a> <span class='Operator'>|| </span><a href="../../include/optimizer/var.h.html#LN34"><span class='Ref_to_Proto'>contain_vars_of_level</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN534"><span class='Ref_To_Local'>funcexprs</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * OK, build an RTE for the function. 
     */ 
</span>    <a href="parse_clause.c.html#LN538"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_relation.h.html#LN79"><span class='Ref_to_Proto'>addRangeTableEntryForFunction</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN532"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                        <a href="parse_clause.c.html#LN535"><span class='Ref_To_Local'>funcnames</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN534"><span class='Ref_To_Local'>funcexprs</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN536"><span class='Ref_To_Local'>coldeflists</span></a><span class='Delimiter'>, 
</span>                                        <a href="parse_clause.c.html#LN532"><span class='Ref_to_Parameter'>r</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN537"><span class='Ref_To_Local'>is_lateral</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="parse_clause.c.html#LN538"><span class='Ref_To_Local'>rte</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end transformRangeFunction &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * transformRangeTableFunc - 
 *          Transform a raw RangeTableFunc into TableFunc. 
 * 
 * Transform the namespace clauses, the document-generating expression, the 
 * row-generating expression, the column-generating expressions, and the 
 * default value expressions. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>* 
</span><a name="LN731"></a><span class='Declare_Function'>transformRangeTableFunc</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN568"><span class='Ref_to_Struct'>RangeTableFunc</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rtf</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN733"></a>    <a href="../../include/nodes/primnodes.h.html#LN78"><span class='Ref_to_Struct'>TableFunc</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>tf</span> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN78"><span class='Ref_to_Struct'>TableFunc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN734"></a>    <span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Local'>constructName</span><span class='Delimiter'>; 
</span><a name="LN735"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>docType</span><span class='Delimiter'>; 
</span><a name="LN736"></a>    <a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span><span class='Delimiter'>; 
</span><a name="LN737"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>is_lateral</span><span class='Delimiter'>; 
</span><a name="LN738"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>col</span><span class='Delimiter'>; 
</span><a name="LN739"></a>    <span class='Keyword'>char</span>      <span class='Operator'>**</span><span class='Declare_Local'>names</span><span class='Delimiter'>; 
</span><a name="LN740"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>colno</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Currently only XMLTABLE is supported */ 
</span>    <a href="parse_clause.c.html#LN734"><span class='Ref_To_Local'>constructName</span></a> <span class='Operator'>= </span><span class='String'>"XMLTABLE"</span><span class='Delimiter'>; 
</span>    <a href="parse_clause.c.html#LN735"><span class='Ref_To_Local'>docType</span></a> <span class='Operator'>= </span><a href="../../include/catalog/pg_type.h.html#LN358"><span class='Ref_to_Const'>XMLOID</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We make lateral_only names of this level visible, whether or not the 
     * RangeTableFunc is explicitly marked LATERAL.  This is needed for SQL 
     * spec compliance and seems useful on convenience grounds for all 
     * functions in FROM. 
     * 
     * (LATERAL can't nest within a single pstate level, so we don't need 
     * save/restore logic here.) 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_clause.c.html#LN731"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN174"><span class='Ref_to_Member'>p_lateral_active</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="parse_clause.c.html#LN731"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN174"><span class='Ref_to_Member'>p_lateral_active</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Transform and apply typecast to the row-generating expression ... */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN731"><span class='Ref_to_Parameter'>rtf</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN573"><span class='Ref_to_Member'>rowexpr</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="parse_clause.c.html#LN733"><span class='Ref_To_Local'>tf</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN84"><span class='Ref_to_Member'>rowexpr</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN56"><span class='Ref_to_Proto'>coerce_to_specific_type</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN731"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                <a href="../../include/parser/parse_expr.h.html#LN21"><span class='Ref_to_Proto'>transformExpr</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN731"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN731"><span class='Ref_to_Parameter'>rtf</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN573"><span class='Ref_to_Member'>rowexpr</span></a><span class='Delimiter'>, </span><a href="../../include/parser/parse_node.h.html#LN39"><span class='Ref_to_EnumConst'>EXPR_KIND_FROM_FUNCTION</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                          <a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN26"><span class='Ref_to_Const'>TEXTOID</span></a><span class='Delimiter'>, 
</span>                                          <a href="parse_clause.c.html#LN734"><span class='Ref_To_Local'>constructName</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/parser/parse_collate.h.html#LN22"><span class='Ref_to_Proto'>assign_expr_collations</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN731"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN733"><span class='Ref_To_Local'>tf</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN84"><span class='Ref_to_Member'>rowexpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* ... and to the document itself */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN731"><span class='Ref_to_Parameter'>rtf</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN572"><span class='Ref_to_Member'>docexpr</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="parse_clause.c.html#LN733"><span class='Ref_To_Local'>tf</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN83"><span class='Ref_to_Member'>docexpr</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN56"><span class='Ref_to_Proto'>coerce_to_specific_type</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN731"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                <a href="../../include/parser/parse_expr.h.html#LN21"><span class='Ref_to_Proto'>transformExpr</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN731"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN731"><span class='Ref_to_Parameter'>rtf</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN572"><span class='Ref_to_Member'>docexpr</span></a><span class='Delimiter'>, </span><a href="../../include/parser/parse_node.h.html#LN39"><span class='Ref_to_EnumConst'>EXPR_KIND_FROM_FUNCTION</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                          <a href="parse_clause.c.html#LN735"><span class='Ref_To_Local'>docType</span></a><span class='Delimiter'>, 
</span>                                          <a href="parse_clause.c.html#LN734"><span class='Ref_To_Local'>constructName</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/parser/parse_collate.h.html#LN22"><span class='Ref_to_Proto'>assign_expr_collations</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN731"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN733"><span class='Ref_To_Local'>tf</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN83"><span class='Ref_to_Member'>docexpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* undef ordinality column number */ 
</span>    <a href="parse_clause.c.html#LN733"><span class='Ref_To_Local'>tf</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN92"><span class='Ref_to_Member'>ordinalitycol</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
 
    <a href="parse_clause.c.html#LN739"><span class='Ref_To_Local'>names</span></a> <span class='Operator'>= </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN731"><span class='Ref_to_Parameter'>rtf</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN575"><span class='Ref_to_Member'>columns</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="parse_clause.c.html#LN740"><span class='Ref_To_Local'>colno</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN738"><span class='Ref_To_Local'>col</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN731"><span class='Ref_to_Parameter'>rtf</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN575"><span class='Ref_to_Member'>columns</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN783"></a>        <a href="../../include/nodes/parsenodes.h.html#LN586"><span class='Ref_to_Struct'>RangeTableFuncCol</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rawc</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN586"><span class='Ref_to_Struct'>RangeTableFuncCol</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN738"><span class='Ref_To_Local'>col</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN784"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>typid</span><span class='Delimiter'>; 
</span><a name="LN785"></a>        <a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>typmod</span><span class='Delimiter'>; 
</span><a name="LN786"></a>        <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>colexpr</span><span class='Delimiter'>; 
</span><a name="LN787"></a>        <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>coldefexpr</span><span class='Delimiter'>; 
</span><a name="LN788"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>j</span><span class='Delimiter'>; 
</span> 
        <a href="parse_clause.c.html#LN733"><span class='Ref_To_Local'>tf</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN85"><span class='Ref_to_Member'>colnames</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN733"><span class='Ref_To_Local'>tf</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN85"><span class='Ref_to_Member'>colnames</span></a><span class='Delimiter'>, 
</span>                               <a href="../nodes/value.c.html#LN51"><span class='Ref_to_Func'>makeString</span></a><span class='Parentheses'>(</span><a href="../../include/common/fe_memutils.h.html#LN32"><span class='Ref_to_Proto'>pstrdup</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN783"><span class='Ref_To_Local'>rawc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN589"><span class='Ref_to_Member'>colname</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Determine the type and typmod for the new column. FOR ORDINALITY 
         * columns are INTEGER per spec; the others are user-specified. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN783"><span class='Ref_To_Local'>rawc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN591"><span class='Ref_to_Member'>for_ordinality</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN733"><span class='Ref_To_Local'>tf</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN92"><span class='Ref_to_Member'>ordinalitycol</span></a> <span class='Operator'>!= -</span><span class='Number'>1</span><span class='Parentheses'>) 
</span>                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_SYNTAX_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"only one FOR ORDINALITY column is allowed"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN731"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN783"><span class='Ref_To_Local'>rawc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN595"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
            <a href="parse_clause.c.html#LN784"><span class='Ref_To_Local'>typid</span></a> <span class='Operator'>= </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN24"><span class='Ref_to_Const'>INT4OID</span></a><span class='Delimiter'>; 
</span>            <a href="parse_clause.c.html#LN785"><span class='Ref_To_Local'>typmod</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>            <a href="parse_clause.c.html#LN733"><span class='Ref_To_Local'>tf</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN92"><span class='Ref_to_Member'>ordinalitycol</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN740"><span class='Ref_To_Local'>colno</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN783"><span class='Ref_To_Local'>rawc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN590"><span class='Ref_to_Member'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN210"><span class='Ref_to_Member'>setof</span></a><span class='Parentheses'>) 
</span>                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_TABLE_DEFINITION<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"column \"%s\" cannot be declared SETOF"</span><span class='Delimiter'>, 
</span>                                <a href="parse_clause.c.html#LN783"><span class='Ref_To_Local'>rawc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN589"><span class='Ref_to_Member'>colname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN731"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN783"><span class='Ref_To_Local'>rawc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN595"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
            <a href="../../include/parser/parse_type.h.html#LN28"><span class='Ref_to_Proto'>typenameTypeIdAndMod</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN731"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN783"><span class='Ref_To_Local'>rawc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN590"><span class='Ref_to_Member'>typeName</span></a><span class='Delimiter'>, 
</span>                                 <span class='Operator'>&</span><a href="parse_clause.c.html#LN784"><span class='Ref_To_Local'>typid</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_clause.c.html#LN785"><span class='Ref_To_Local'>typmod</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="parse_clause.c.html#LN733"><span class='Ref_To_Local'>tf</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN86"><span class='Ref_to_Member'>coltypes</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN162"><span class='Ref_to_Func'>lappend_oid</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN733"><span class='Ref_To_Local'>tf</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN86"><span class='Ref_to_Member'>coltypes</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN784"><span class='Ref_To_Local'>typid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN733"><span class='Ref_To_Local'>tf</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN87"><span class='Ref_to_Member'>coltypmods</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN144"><span class='Ref_to_Func'>lappend_int</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN733"><span class='Ref_To_Local'>tf</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN87"><span class='Ref_to_Member'>coltypmods</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN785"><span class='Ref_To_Local'>typmod</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN733"><span class='Ref_To_Local'>tf</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN88"><span class='Ref_to_Member'>colcollations</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN162"><span class='Ref_to_Func'>lappend_oid</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN733"><span class='Ref_To_Local'>tf</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN88"><span class='Ref_to_Member'>colcollations</span></a><span class='Delimiter'>, 
</span>             <a href="../../include/utils/lsyscache.h.html#LN167"><span class='Ref_to_Proto'>type_is_collatable</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN784"><span class='Ref_To_Local'>typid</span></a><span class='Parentheses'>) </span><span class='Operator'>? </span><a href="../../include/catalog/pg_collation.h.html#LN74"><span class='Ref_to_Const'>DEFAULT_COLLATION_OID</span></a> <span class='Operator'>: </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Transform the PATH and DEFAULT expressions */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN783"><span class='Ref_To_Local'>rawc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN593"><span class='Ref_to_Member'>colexpr</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="parse_clause.c.html#LN786"><span class='Ref_To_Local'>colexpr</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN56"><span class='Ref_to_Proto'>coerce_to_specific_type</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN731"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                         <a href="../../include/parser/parse_expr.h.html#LN21"><span class='Ref_to_Proto'>transformExpr</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN731"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN783"><span class='Ref_To_Local'>rawc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN593"><span class='Ref_to_Member'>colexpr</span></a><span class='Delimiter'>, 
</span>                                                    <a href="../../include/parser/parse_node.h.html#LN39"><span class='Ref_to_EnumConst'>EXPR_KIND_FROM_FUNCTION</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                              <a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN26"><span class='Ref_to_Const'>TEXTOID</span></a><span class='Delimiter'>, 
</span>                                              <a href="parse_clause.c.html#LN734"><span class='Ref_To_Local'>constructName</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../include/parser/parse_collate.h.html#LN22"><span class='Ref_to_Proto'>assign_expr_collations</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN731"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN786"><span class='Ref_To_Local'>colexpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <a href="parse_clause.c.html#LN786"><span class='Ref_To_Local'>colexpr</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN783"><span class='Ref_To_Local'>rawc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN594"><span class='Ref_to_Member'>coldefexpr</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="parse_clause.c.html#LN787"><span class='Ref_To_Local'>coldefexpr</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN60"><span class='Ref_to_Proto'>coerce_to_specific_type_typmod</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN731"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                      <a href="../../include/parser/parse_expr.h.html#LN21"><span class='Ref_to_Proto'>transformExpr</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN731"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN783"><span class='Ref_To_Local'>rawc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN594"><span class='Ref_to_Member'>coldefexpr</span></a><span class='Delimiter'>, 
</span>                                                    <a href="../../include/parser/parse_node.h.html#LN39"><span class='Ref_to_EnumConst'>EXPR_KIND_FROM_FUNCTION</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                        <a href="parse_clause.c.html#LN784"><span class='Ref_To_Local'>typid</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN785"><span class='Ref_To_Local'>typmod</span></a><span class='Delimiter'>, 
</span>                                                        <a href="parse_clause.c.html#LN734"><span class='Ref_To_Local'>constructName</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../include/parser/parse_collate.h.html#LN22"><span class='Ref_to_Proto'>assign_expr_collations</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN731"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN787"><span class='Ref_To_Local'>coldefexpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <a href="parse_clause.c.html#LN787"><span class='Ref_To_Local'>coldefexpr</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
        <a href="parse_clause.c.html#LN733"><span class='Ref_To_Local'>tf</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN89"><span class='Ref_to_Member'>colexprs</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN733"><span class='Ref_To_Local'>tf</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN89"><span class='Ref_to_Member'>colexprs</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN786"><span class='Ref_To_Local'>colexpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN733"><span class='Ref_To_Local'>tf</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN90"><span class='Ref_to_Member'>coldefexprs</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN733"><span class='Ref_To_Local'>tf</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN90"><span class='Ref_to_Member'>coldefexprs</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN787"><span class='Ref_To_Local'>coldefexpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN783"><span class='Ref_To_Local'>rawc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN592"><span class='Ref_to_Member'>is_not_null</span></a><span class='Parentheses'>) 
</span>            <a href="parse_clause.c.html#LN733"><span class='Ref_To_Local'>tf</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN91"><span class='Ref_to_Member'>notnulls</span></a> <span class='Operator'>= </span><a href="../../include/nodes/bitmapset.h.html#LN89"><span class='Ref_to_Proto'>bms_add_member</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN733"><span class='Ref_To_Local'>tf</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN91"><span class='Ref_to_Member'>notnulls</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN740"><span class='Ref_To_Local'>colno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* make sure column names are unique */ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN788"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="parse_clause.c.html#LN788"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>&LT; </span><a href="parse_clause.c.html#LN740"><span class='Ref_To_Local'>colno</span></a><span class='Delimiter'>; </span><a href="parse_clause.c.html#LN788"><span class='Ref_To_Local'>j</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="parse_clause.c.html#LN739"><span class='Ref_To_Local'>names</span></a><span class='Delimiter'>[</span><a href="parse_clause.c.html#LN788"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>], </span><a href="parse_clause.c.html#LN783"><span class='Ref_To_Local'>rawc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN589"><span class='Ref_to_Member'>colname</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_SYNTAX_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"column name \"%s\" is not unique"</span><span class='Delimiter'>, 
</span>                                <a href="parse_clause.c.html#LN783"><span class='Ref_To_Local'>rawc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN589"><span class='Ref_to_Member'>colname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN731"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN783"><span class='Ref_To_Local'>rawc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN595"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN739"><span class='Ref_To_Local'>names</span></a><span class='Delimiter'>[</span><a href="parse_clause.c.html#LN740"><span class='Ref_To_Local'>colno</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="parse_clause.c.html#LN783"><span class='Ref_To_Local'>rawc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN589"><span class='Ref_to_Member'>colname</span></a><span class='Delimiter'>; 
</span> 
        <a href="parse_clause.c.html#LN740"><span class='Ref_To_Local'>colno</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN739"><span class='Ref_To_Local'>names</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Namespaces, if any, also need to be transformed */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN731"><span class='Ref_to_Parameter'>rtf</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN574"><span class='Ref_to_Member'>namespaces</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN875"></a>        <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>ns</span><span class='Delimiter'>; 
</span><a name="LN876"></a>        <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc2</span><span class='Delimiter'>; 
</span><a name="LN877"></a>        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>ns_uris</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN878"></a>        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>ns_names</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN879"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>default_ns_seen</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN875"><span class='Ref_To_Local'>ns</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN731"><span class='Ref_to_Parameter'>rtf</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN574"><span class='Ref_to_Member'>namespaces</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN883"></a>            <a href="../../include/nodes/parsenodes.h.html#LN436"><span class='Ref_to_Struct'>ResTarget</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>r</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN436"><span class='Ref_to_Struct'>ResTarget</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN875"><span class='Ref_To_Local'>ns</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN884"></a>            <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>ns_uri</span><span class='Delimiter'>; 
</span> 
            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN883"><span class='Ref_To_Local'>r</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN436"><span class='Ref_to_Struct'>ResTarget</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="parse_clause.c.html#LN884"><span class='Ref_To_Local'>ns_uri</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_expr.h.html#LN21"><span class='Ref_to_Proto'>transformExpr</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN731"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN883"><span class='Ref_To_Local'>r</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN441"><span class='Ref_to_Member'>val</span></a><span class='Delimiter'>, </span><a href="../../include/parser/parse_node.h.html#LN39"><span class='Ref_to_EnumConst'>EXPR_KIND_FROM_FUNCTION</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="parse_clause.c.html#LN884"><span class='Ref_To_Local'>ns_uri</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN56"><span class='Ref_to_Proto'>coerce_to_specific_type</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN731"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN884"><span class='Ref_To_Local'>ns_uri</span></a><span class='Delimiter'>, 
</span>                                             <a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN26"><span class='Ref_to_Const'>TEXTOID</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN734"><span class='Ref_To_Local'>constructName</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../include/parser/parse_collate.h.html#LN22"><span class='Ref_to_Proto'>assign_expr_collations</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN731"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN884"><span class='Ref_To_Local'>ns_uri</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="parse_clause.c.html#LN877"><span class='Ref_To_Local'>ns_uris</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN877"><span class='Ref_To_Local'>ns_uris</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN884"><span class='Ref_To_Local'>ns_uri</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Verify consistency of name list: no dupes, only one DEFAULT */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN883"><span class='Ref_To_Local'>r</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN439"><span class='Ref_to_Member'>name</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN876"><span class='Ref_To_Local'>lc2</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN878"><span class='Ref_To_Local'>ns_names</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN898"></a>                    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>name</span> <span class='Operator'>= </span><a href="../../include/nodes/value.h.html#LN53"><span class='Ref_to_Macro'>strVal</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN876"><span class='Ref_To_Local'>lc2</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN898"><span class='Ref_To_Local'>name</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>                        <span class='Control'>continue</span><span class='Delimiter'>; 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="parse_clause.c.html#LN898"><span class='Ref_To_Local'>name</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN883"><span class='Ref_To_Local'>r</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN439"><span class='Ref_to_Member'>name</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_SYNTAX_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"namespace name \"%s\" is not unique"</span><span class='Delimiter'>, 
</span>                                        <a href="parse_clause.c.html#LN898"><span class='Ref_To_Local'>name</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                 <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN731"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN883"><span class='Ref_To_Local'>r</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN442"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN879"><span class='Ref_To_Local'>default_ns_seen</span></a><span class='Parentheses'>) 
</span>                    <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_SYNTAX_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"only one default namespace is allowed"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN731"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN883"><span class='Ref_To_Local'>r</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN442"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <a href="parse_clause.c.html#LN879"><span class='Ref_To_Local'>default_ns_seen</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* Note the string may be NULL */ 
</span>            <a href="parse_clause.c.html#LN878"><span class='Ref_To_Local'>ns_names</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN878"><span class='Ref_To_Local'>ns_names</span></a><span class='Delimiter'>, </span><a href="../nodes/value.c.html#LN51"><span class='Ref_to_Func'>makeString</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN883"><span class='Ref_To_Local'>r</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN439"><span class='Ref_to_Member'>name</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="parse_clause.c.html#LN733"><span class='Ref_To_Local'>tf</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN81"><span class='Ref_to_Member'>ns_uris</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN877"><span class='Ref_To_Local'>ns_uris</span></a><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN733"><span class='Ref_To_Local'>tf</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN82"><span class='Ref_to_Member'>ns_names</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN878"><span class='Ref_To_Local'>ns_names</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if rtf-&GT;namespaces!=NIL &raquo; </span> 
 
    <a href="parse_clause.c.html#LN733"><span class='Ref_To_Local'>tf</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN93"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN731"><span class='Ref_to_Parameter'>rtf</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN577"><span class='Ref_to_Member'>location</span></a><span class='Delimiter'>; 
</span> 
    <a href="parse_clause.c.html#LN731"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN174"><span class='Ref_to_Member'>p_lateral_active</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Mark the RTE as LATERAL if the user said LATERAL explicitly, or if 
     * there are any lateral cross-references in it. 
     */ 
</span>    <a href="parse_clause.c.html#LN737"><span class='Ref_To_Local'>is_lateral</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN731"><span class='Ref_to_Parameter'>rtf</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN571"><span class='Ref_to_Member'>lateral</span></a> <span class='Operator'>|| </span><a href="../../include/optimizer/var.h.html#LN34"><span class='Ref_to_Proto'>contain_vars_of_level</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN733"><span class='Ref_To_Local'>tf</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="parse_clause.c.html#LN736"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_relation.h.html#LN94"><span class='Ref_to_Proto'>addRangeTableEntryForTableFunc</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN731"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                         <a href="parse_clause.c.html#LN733"><span class='Ref_To_Local'>tf</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN731"><span class='Ref_to_Parameter'>rtf</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN576"><span class='Ref_to_Member'>alias</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN737"><span class='Ref_To_Local'>is_lateral</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="parse_clause.c.html#LN736"><span class='Ref_To_Local'>rte</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end transformRangeTableFunc &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * transformRangeTableSample --- transform a TABLESAMPLE clause 
 * 
 * Caller has already transformed rts-&GT;relation, we just have to validate 
 * the remaining fields and create a TableSampleClause node. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/parsenodes.h.html#LN1071"><span class='Ref_to_Struct'>TableSampleClause</span></a> <span class='Operator'>* 
</span><a name="LN951"></a><span class='Declare_Function'>transformRangeTableSample</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN608"><span class='Ref_to_Struct'>RangeTableSample</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rts</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN953"></a>    <a href="../../include/nodes/parsenodes.h.html#LN1071"><span class='Ref_to_Struct'>TableSampleClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tablesample</span><span class='Delimiter'>; 
</span><a name="LN954"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>handlerOid</span><span class='Delimiter'>; 
</span><a name="LN955"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>funcargtypes</span><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>]; 
</span><a name="LN956"></a>    <a href="../../include/access/tsmapi.h.html#LN54"><span class='Ref_to_Struct'>TsmRoutine</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tsm</span><span class='Delimiter'>; 
</span><a name="LN957"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>fargs</span><span class='Delimiter'>; 
</span><a name="LN958"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>larg</span><span class='Delimiter'>, 
</span><a name="LN959"></a>               <span class='Operator'>*</span><span class='Declare_Local'>ltyp</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * To validate the sample method name, look up the handler function, which 
     * has the same name, one dummy INTERNAL argument, and a result type of 
     * tsm_handler.  (Note: tablesample method names are not schema-qualified 
     * in the SQL standard; but since they are just functions to us, we allow 
     * schema qualification to resolve any potential ambiguity.) 
     */ 
</span>    <a href="parse_clause.c.html#LN955"><span class='Ref_To_Local'>funcargtypes</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/catalog/pg_type.h.html#LN697"><span class='Ref_to_Const'>INTERNALOID</span></a><span class='Delimiter'>; 
</span> 
    <a href="parse_clause.c.html#LN954"><span class='Ref_To_Local'>handlerOid</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_func.h.html#LN62"><span class='Ref_to_Proto'>LookupFuncName</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN951"><span class='Ref_to_Parameter'>rts</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN612"><span class='Ref_to_Member'>method</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN955"><span class='Ref_To_Local'>funcargtypes</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* we want error to complain about no-such-method, not no-such-function */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN954"><span class='Ref_To_Local'>handlerOid</span></a><span class='Parentheses'>))</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_UNDEFINED_OBJECT<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"tablesample method %s does not exist"</span><span class='Delimiter'>, 
</span>                        <a href="../../include/catalog/namespace.h.html#LN120"><span class='Ref_to_Proto'>NameListToString</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN951"><span class='Ref_to_Parameter'>rts</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN612"><span class='Ref_to_Member'>method</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                 <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN951"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN951"><span class='Ref_to_Parameter'>rts</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN615"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* check that handler has correct return type */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/utils/lsyscache.h.html#LN112"><span class='Ref_to_Proto'>get_func_rettype</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN954"><span class='Ref_To_Local'>handlerOid</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="../../include/catalog/pg_type.h.html#LN711"><span class='Ref_to_Const'>TSM_HANDLEROID</span></a><span class='Parentheses'>)</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_WRONG_OBJECT_TYPE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"function %s must return type %s"</span><span class='Delimiter'>, 
</span>                        <a href="../../include/catalog/namespace.h.html#LN120"><span class='Ref_to_Proto'>NameListToString</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN951"><span class='Ref_to_Parameter'>rts</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN612"><span class='Ref_to_Member'>method</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='String'>"tsm_handler"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN951"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN951"><span class='Ref_to_Parameter'>rts</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN615"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* OK, run the handler to get TsmRoutine, for argument type info */ 
</span>    <a href="parse_clause.c.html#LN956"><span class='Ref_To_Local'>tsm</span></a> <span class='Operator'>= </span><a href="../access/tablesample/tablesample.c.html#LN25"><span class='Ref_to_Func'>GetTsmRoutine</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN954"><span class='Ref_To_Local'>handlerOid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="parse_clause.c.html#LN953"><span class='Ref_To_Local'>tablesample</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1071"><span class='Ref_to_Struct'>TableSampleClause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="parse_clause.c.html#LN953"><span class='Ref_To_Local'>tablesample</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1074"><span class='Ref_to_Member'>tsmhandler</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN954"><span class='Ref_To_Local'>handlerOid</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* check user provided the expected number of arguments */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN951"><span class='Ref_to_Parameter'>rts</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN613"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN956"><span class='Ref_To_Local'>tsm</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tsmapi.h.html#LN59"><span class='Ref_to_Member'>parameterTypes</span></a><span class='Parentheses'>))</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_TABLESAMPLE_ARGUMENT<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>          <a href="../utils/error/elog.c.html#LN848"><span class='Ref_to_Func'>errmsg_plural</span></a><span class='Parentheses'>(</span><span class='String'>"tablesample method %s requires %d argument, not %d"</span><span class='Delimiter'>, 
</span>                        <span class='String'>"tablesample method %s requires %d arguments, not %d"</span><span class='Delimiter'>, 
</span>                        <a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN956"><span class='Ref_To_Local'>tsm</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tsmapi.h.html#LN59"><span class='Ref_to_Member'>parameterTypes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                        <a href="../../include/catalog/namespace.h.html#LN120"><span class='Ref_to_Proto'>NameListToString</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN951"><span class='Ref_to_Parameter'>rts</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN612"><span class='Ref_to_Member'>method</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                        <a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN956"><span class='Ref_To_Local'>tsm</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tsmapi.h.html#LN59"><span class='Ref_to_Member'>parameterTypes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                        <a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN951"><span class='Ref_to_Parameter'>rts</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN613"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                 <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN951"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN951"><span class='Ref_to_Parameter'>rts</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN615"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Transform the arguments, typecasting them as needed.  Note we must also 
     * assign collations now, because assign_query_collations() doesn't 
     * examine any substructure of RTEs. 
     */ 
</span>    <a href="parse_clause.c.html#LN957"><span class='Ref_To_Local'>fargs</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN179"><span class='Ref_to_Macro'>forboth</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN958"><span class='Ref_To_Local'>larg</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN951"><span class='Ref_to_Parameter'>rts</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN613"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN959"><span class='Ref_To_Local'>ltyp</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN956"><span class='Ref_To_Local'>tsm</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tsmapi.h.html#LN59"><span class='Ref_to_Member'>parameterTypes</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1014"></a>        <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>arg</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN958"><span class='Ref_To_Local'>larg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1015"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>argtype</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN107"><span class='Ref_to_Macro'>lfirst_oid</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN959"><span class='Ref_To_Local'>ltyp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="parse_clause.c.html#LN1014"><span class='Ref_To_Local'>arg</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_expr.h.html#LN21"><span class='Ref_to_Proto'>transformExpr</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN951"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1014"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>, </span><a href="../../include/parser/parse_node.h.html#LN39"><span class='Ref_to_EnumConst'>EXPR_KIND_FROM_FUNCTION</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN1014"><span class='Ref_To_Local'>arg</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN56"><span class='Ref_to_Proto'>coerce_to_specific_type</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN951"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1014"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1015"><span class='Ref_To_Local'>argtype</span></a><span class='Delimiter'>, </span><span class='String'>"TABLESAMPLE"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/parser/parse_collate.h.html#LN22"><span class='Ref_to_Proto'>assign_expr_collations</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN951"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1014"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN957"><span class='Ref_To_Local'>fargs</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN957"><span class='Ref_To_Local'>fargs</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1014"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="parse_clause.c.html#LN953"><span class='Ref_To_Local'>tablesample</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1075"><span class='Ref_to_Member'>args</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN957"><span class='Ref_To_Local'>fargs</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Process REPEATABLE (seed) */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN951"><span class='Ref_to_Parameter'>rts</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN614"><span class='Ref_to_Member'>repeatable</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1027"></a>        <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>arg</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_clause.c.html#LN956"><span class='Ref_To_Local'>tsm</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tsmapi.h.html#LN62"><span class='Ref_to_Member'>repeatable_across_queries</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                  <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"tablesample method %s does not support REPEATABLE"</span><span class='Delimiter'>, 
</span>                         <a href="../../include/catalog/namespace.h.html#LN120"><span class='Ref_to_Proto'>NameListToString</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN951"><span class='Ref_to_Parameter'>rts</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN612"><span class='Ref_to_Member'>method</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN951"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN951"><span class='Ref_to_Parameter'>rts</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN615"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <a href="parse_clause.c.html#LN1027"><span class='Ref_To_Local'>arg</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_expr.h.html#LN21"><span class='Ref_to_Proto'>transformExpr</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN951"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN951"><span class='Ref_to_Parameter'>rts</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN614"><span class='Ref_to_Member'>repeatable</span></a><span class='Delimiter'>, </span><a href="../../include/parser/parse_node.h.html#LN39"><span class='Ref_to_EnumConst'>EXPR_KIND_FROM_FUNCTION</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN1027"><span class='Ref_To_Local'>arg</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN56"><span class='Ref_to_Proto'>coerce_to_specific_type</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN951"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1027"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>, </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN39"><span class='Ref_to_Const'>FLOAT8OID</span></a><span class='Delimiter'>, </span><span class='String'>"REPEATABLE"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/parser/parse_collate.h.html#LN22"><span class='Ref_to_Proto'>assign_expr_collations</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN951"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1027"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN953"><span class='Ref_To_Local'>tablesample</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1076"><span class='Ref_to_Member'>repeatable</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN1027"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
        <a href="parse_clause.c.html#LN953"><span class='Ref_To_Local'>tablesample</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1076"><span class='Ref_to_Member'>repeatable</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="parse_clause.c.html#LN953"><span class='Ref_To_Local'>tablesample</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end transformRangeTableSample &raquo; </span> 
 
 
<span class='Keyword'>static </span><a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>* 
</span><a name="LN1049"></a><span class='Declare_Function'>getRTEForSpecialRelationTypes</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rv</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1051"></a>    <a href="../../include/nodes/parsenodes.h.html#LN1339"><span class='Ref_to_Struct'>CommonTableExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>cte</span><span class='Delimiter'>; 
</span><a name="LN1052"></a>    <a href="../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Local'>levelsup</span><span class='Delimiter'>; 
</span><a name="LN1053"></a>    <a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <a href="parse_clause.c.html#LN1051"><span class='Ref_To_Local'>cte</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_relation.h.html#LN41"><span class='Ref_to_Proto'>scanNameSpaceForCTE</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1049"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1049"><span class='Ref_to_Parameter'>rv</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN67"><span class='Ref_to_Member'>relname</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_clause.c.html#LN1052"><span class='Ref_To_Local'>levelsup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1051"><span class='Ref_To_Local'>cte</span></a><span class='Parentheses'>) 
</span>        <a href="parse_clause.c.html#LN1053"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN64"><span class='Ref_to_Proto'>transformCTEReference</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1049"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1049"><span class='Ref_to_Parameter'>rv</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1051"><span class='Ref_To_Local'>cte</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1052"><span class='Ref_To_Local'>levelsup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_clause.c.html#LN1053"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>&& </span><a href="../../include/parser/parse_relation.h.html#LN44"><span class='Ref_to_Proto'>scanNameSpaceForENR</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1049"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1049"><span class='Ref_to_Parameter'>rv</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN67"><span class='Ref_to_Member'>relname</span></a><span class='Parentheses'>))</span> 
        <a href="parse_clause.c.html#LN1053"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN66"><span class='Ref_to_Proto'>transformENRReference</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1049"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1049"><span class='Ref_to_Parameter'>rv</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="parse_clause.c.html#LN1053"><span class='Ref_To_Local'>rte</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * transformFromClauseItem - 
 *    Transform a FROM-clause item, adding any required entries to the 
 *    range table list being built in the ParseState, and return the 
 *    transformed item ready to include in the joinlist.  Also build a 
 *    ParseNamespaceItem list describing the names exposed by this item. 
 *    This routine can recurse to handle SQL92 JOIN expressions. 
 * 
 * The function return value is the node to add to the jointree (a 
 * RangeTblRef or JoinExpr).  Additional output parameters are: 
 * 
 * *top_rte: receives the RTE corresponding to the jointree item. 
 * (We could extract this from the function return node, but it saves cycles 
 * to pass it back separately.) 
 * 
 * *top_rti: receives the rangetable index of top_rte.  (Ditto.) 
 * 
 * *namespace: receives a List of ParseNamespaceItems for the RTEs exposed 
 * as table/column names by this item.  (The lateral_only flags in these items 
 * are indeterminate and should be explicitly set by the caller before use.) 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN1086"></a><span class='Declare_Function'>transformFromClauseItem</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>n</span><span class='Delimiter'>, 
</span><a name="LN1087"></a>                        <a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>top_rte</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Operator'>*</span><span class='Declare_Parameter'>top_rti</span><span class='Delimiter'>, 
</span><a name="LN1088"></a>                        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>namespace</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>n</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Plain relation reference, or perhaps a CTE reference */ 
</span><a name="LN1093"></a>        <a href="../../include/nodes/primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>rv</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>n</span></a><span class='Delimiter'>; 
</span><a name="LN1094"></a>        <a href="../../include/nodes/primnodes.h.html#LN1415"><span class='Ref_to_Struct'>RangeTblRef</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rtr</span><span class='Delimiter'>; 
</span><a name="LN1095"></a>        <a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN1096"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>rtindex</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * if it is an unqualified name, it might be a CTE or tuplestore 
         * reference 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_clause.c.html#LN1093"><span class='Ref_To_Local'>rv</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN66"><span class='Ref_to_Member'>schemaname</span></a><span class='Parentheses'>) 
</span>            <a href="parse_clause.c.html#LN1095"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN61"><span class='Ref_to_Proto'>getRTEForSpecialRelationTypes</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1093"><span class='Ref_To_Local'>rv</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* if not found above, must be a table reference */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_clause.c.html#LN1095"><span class='Ref_To_Local'>rte</span></a><span class='Parentheses'>) 
</span>            <a href="parse_clause.c.html#LN1095"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN63"><span class='Ref_to_Proto'>transformTableEntry</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1093"><span class='Ref_To_Local'>rv</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* assume new rte is at end */ 
</span>        <a href="parse_clause.c.html#LN1096"><span class='Ref_To_Local'>rtindex</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1095"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>== </span><a href="../../include/parser/parsetree.h.html#LN30"><span class='Ref_to_Macro'>rt_fetch</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1096"><span class='Ref_To_Local'>rtindex</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="parse_clause.c.html#LN1087"><span class='Ref_to_Parameter'>top_rte</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN1095"><span class='Ref_To_Local'>rte</span></a><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="parse_clause.c.html#LN1087"><span class='Ref_to_Parameter'>top_rti</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN1096"><span class='Ref_To_Local'>rtindex</span></a><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><span class='Control'>namespace</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN51"><span class='Ref_to_Macro'>makeDefaultNSItem</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1095"><span class='Ref_To_Local'>rte</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN1094"><span class='Ref_To_Local'>rtr</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN1415"><span class='Ref_to_Struct'>RangeTblRef</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN1094"><span class='Ref_To_Local'>rtr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1418"><span class='Ref_to_Member'>rtindex</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN1096"><span class='Ref_To_Local'>rtindex</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN1094"><span class='Ref_To_Local'>rtr</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IsA(n,RangeVar) &raquo; </span> 
    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>n</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN531"><span class='Ref_to_Struct'>RangeSubselect</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* sub-SELECT is like a plain relation */ 
</span><a name="LN1122"></a>        <a href="../../include/nodes/primnodes.h.html#LN1415"><span class='Ref_to_Struct'>RangeTblRef</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rtr</span><span class='Delimiter'>; 
</span><a name="LN1123"></a>        <a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span><span class='Delimiter'>; 
</span><a name="LN1124"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>rtindex</span><span class='Delimiter'>; 
</span> 
        <a href="parse_clause.c.html#LN1123"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN67"><span class='Ref_to_Proto'>transformRangeSubselect</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN531"><span class='Ref_to_Struct'>RangeSubselect</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>n</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* assume new rte is at end */ 
</span>        <a href="parse_clause.c.html#LN1124"><span class='Ref_To_Local'>rtindex</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1123"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>== </span><a href="../../include/parser/parsetree.h.html#LN30"><span class='Ref_to_Macro'>rt_fetch</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1124"><span class='Ref_To_Local'>rtindex</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="parse_clause.c.html#LN1087"><span class='Ref_to_Parameter'>top_rte</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN1123"><span class='Ref_To_Local'>rte</span></a><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="parse_clause.c.html#LN1087"><span class='Ref_to_Parameter'>top_rti</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN1124"><span class='Ref_To_Local'>rtindex</span></a><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><span class='Control'>namespace</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN51"><span class='Ref_to_Macro'>makeDefaultNSItem</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1123"><span class='Ref_To_Local'>rte</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN1122"><span class='Ref_To_Local'>rtr</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN1415"><span class='Ref_to_Struct'>RangeTblRef</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN1122"><span class='Ref_To_Local'>rtr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1418"><span class='Ref_to_Member'>rtindex</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN1124"><span class='Ref_To_Local'>rtindex</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN1122"><span class='Ref_To_Local'>rtr</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>n</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN553"><span class='Ref_to_Struct'>RangeFunction</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* function is like a plain relation */ 
</span><a name="LN1140"></a>        <a href="../../include/nodes/primnodes.h.html#LN1415"><span class='Ref_to_Struct'>RangeTblRef</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rtr</span><span class='Delimiter'>; 
</span><a name="LN1141"></a>        <a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span><span class='Delimiter'>; 
</span><a name="LN1142"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>rtindex</span><span class='Delimiter'>; 
</span> 
        <a href="parse_clause.c.html#LN1141"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN69"><span class='Ref_to_Proto'>transformRangeFunction</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN553"><span class='Ref_to_Struct'>RangeFunction</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>n</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* assume new rte is at end */ 
</span>        <a href="parse_clause.c.html#LN1142"><span class='Ref_To_Local'>rtindex</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1141"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>== </span><a href="../../include/parser/parsetree.h.html#LN30"><span class='Ref_to_Macro'>rt_fetch</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1142"><span class='Ref_To_Local'>rtindex</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="parse_clause.c.html#LN1087"><span class='Ref_to_Parameter'>top_rte</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN1141"><span class='Ref_To_Local'>rte</span></a><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="parse_clause.c.html#LN1087"><span class='Ref_to_Parameter'>top_rti</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN1142"><span class='Ref_To_Local'>rtindex</span></a><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><span class='Control'>namespace</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN51"><span class='Ref_to_Macro'>makeDefaultNSItem</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1141"><span class='Ref_To_Local'>rte</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN1140"><span class='Ref_To_Local'>rtr</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN1415"><span class='Ref_to_Struct'>RangeTblRef</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN1140"><span class='Ref_To_Local'>rtr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1418"><span class='Ref_to_Member'>rtindex</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN1142"><span class='Ref_To_Local'>rtindex</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN1140"><span class='Ref_To_Local'>rtr</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>n</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN568"><span class='Ref_to_Struct'>RangeTableFunc</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* table function is like a plain relation */ 
</span><a name="LN1158"></a>        <a href="../../include/nodes/primnodes.h.html#LN1415"><span class='Ref_to_Struct'>RangeTblRef</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rtr</span><span class='Delimiter'>; 
</span><a name="LN1159"></a>        <a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span><span class='Delimiter'>; 
</span><a name="LN1160"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>rtindex</span><span class='Delimiter'>; 
</span> 
        <a href="parse_clause.c.html#LN1159"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN71"><span class='Ref_to_Proto'>transformRangeTableFunc</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN568"><span class='Ref_to_Struct'>RangeTableFunc</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>n</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* assume new rte is at end */ 
</span>        <a href="parse_clause.c.html#LN1160"><span class='Ref_To_Local'>rtindex</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1159"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>== </span><a href="../../include/parser/parsetree.h.html#LN30"><span class='Ref_to_Macro'>rt_fetch</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1160"><span class='Ref_To_Local'>rtindex</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="parse_clause.c.html#LN1087"><span class='Ref_to_Parameter'>top_rte</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN1159"><span class='Ref_To_Local'>rte</span></a><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="parse_clause.c.html#LN1087"><span class='Ref_to_Parameter'>top_rti</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN1160"><span class='Ref_To_Local'>rtindex</span></a><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><span class='Control'>namespace</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN51"><span class='Ref_to_Macro'>makeDefaultNSItem</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1159"><span class='Ref_To_Local'>rte</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN1158"><span class='Ref_To_Local'>rtr</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN1415"><span class='Ref_to_Struct'>RangeTblRef</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN1158"><span class='Ref_To_Local'>rtr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1418"><span class='Ref_to_Member'>rtindex</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN1160"><span class='Ref_To_Local'>rtindex</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN1158"><span class='Ref_To_Local'>rtr</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>n</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN608"><span class='Ref_to_Struct'>RangeTableSample</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* TABLESAMPLE clause (wrapping some other valid FROM node) */ 
</span><a name="LN1176"></a>        <a href="../../include/nodes/parsenodes.h.html#LN608"><span class='Ref_to_Struct'>RangeTableSample</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rts</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN608"><span class='Ref_to_Struct'>RangeTableSample</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>n</span></a><span class='Delimiter'>; 
</span><a name="LN1177"></a>        <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>rel</span><span class='Delimiter'>; 
</span><a name="LN1178"></a>        <a href="../../include/nodes/primnodes.h.html#LN1415"><span class='Ref_to_Struct'>RangeTblRef</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rtr</span><span class='Delimiter'>; 
</span><a name="LN1179"></a>        <a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Recursively transform the contained relation */ 
</span>        <a href="parse_clause.c.html#LN1177"><span class='Ref_To_Local'>rel</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN75"><span class='Ref_to_Proto'>transformFromClauseItem</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1176"><span class='Ref_To_Local'>rts</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN611"><span class='Ref_to_Member'>relation</span></a><span class='Delimiter'>, 
</span>                                      <a href="parse_clause.c.html#LN1087"><span class='Ref_to_Parameter'>top_rte</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1087"><span class='Ref_to_Parameter'>top_rti</span></a><span class='Delimiter'>, </span><span class='Control'>namespace</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Currently, grammar could only return a RangeVar as contained rel */ 
</span>        <a href="parse_clause.c.html#LN1178"><span class='Ref_To_Local'>rtr</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN575"><span class='Ref_to_Macro'>castNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN1415"><span class='Ref_to_Struct'>RangeTblRef</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1177"><span class='Ref_To_Local'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN1179"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="../../include/parser/parsetree.h.html#LN30"><span class='Ref_to_Macro'>rt_fetch</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1178"><span class='Ref_To_Local'>rtr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1418"><span class='Ref_to_Member'>rtindex</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* We only support this on plain relations and matviews */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1179"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN948"><span class='Ref_to_Member'>relkind</span></a> <span class='Operator'>!= </span><a href="../../include/catalog/pg_class.h.html#LN159"><span class='Ref_to_Const'>RELKIND_RELATION</span></a> <span class='Operator'>&& 
</span>            <a href="parse_clause.c.html#LN1179"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN948"><span class='Ref_to_Member'>relkind</span></a> <span class='Operator'>!= </span><a href="../../include/catalog/pg_class.h.html#LN164"><span class='Ref_to_Const'>RELKIND_MATVIEW</span></a> <span class='Operator'>&& 
</span>            <a href="parse_clause.c.html#LN1179"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN948"><span class='Ref_to_Member'>relkind</span></a> <span class='Operator'>!= </span><a href="../../include/catalog/pg_class.h.html#LN167"><span class='Ref_to_Const'>RELKIND_PARTITIONED_TABLE</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"TABLESAMPLE clause can only be applied to tables and materialized views"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                   <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1176"><span class='Ref_To_Local'>rts</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN611"><span class='Ref_to_Member'>relation</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Transform TABLESAMPLE details and attach to the RTE */ 
</span>        <a href="parse_clause.c.html#LN1179"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN949"><span class='Ref_to_Member'>tablesample</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN73"><span class='Ref_to_Proto'>transformRangeTableSample</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1176"><span class='Ref_To_Local'>rts</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN1178"><span class='Ref_To_Local'>rtr</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IsA(n,RangeTableSampl... &raquo; </span> 
    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>n</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN1444"><span class='Ref_to_Struct'>JoinExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* A newfangled join expression */ 
</span><a name="LN1203"></a>        <a href="../../include/nodes/primnodes.h.html#LN1444"><span class='Ref_to_Struct'>JoinExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>j</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN1444"><span class='Ref_to_Struct'>JoinExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>n</span></a><span class='Delimiter'>; 
</span><a name="LN1204"></a>        <a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>l_rte</span><span class='Delimiter'>; 
</span><a name="LN1205"></a>        <a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>r_rte</span><span class='Delimiter'>; 
</span><a name="LN1206"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>l_rtindex</span><span class='Delimiter'>; 
</span><a name="LN1207"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>r_rtindex</span><span class='Delimiter'>; 
</span><a name="LN1208"></a>        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>l_namespace</span><span class='Delimiter'>, 
</span><a name="LN1209"></a>                   <span class='Operator'>*</span><span class='Declare_Local'>r_namespace</span><span class='Delimiter'>, 
</span><a name="LN1210"></a>                   <span class='Operator'>*</span><span class='Declare_Local'>my_namespace</span><span class='Delimiter'>, 
</span><a name="LN1211"></a>                   <span class='Operator'>*</span><span class='Declare_Local'>l_colnames</span><span class='Delimiter'>, 
</span><a name="LN1212"></a>                   <span class='Operator'>*</span><span class='Declare_Local'>r_colnames</span><span class='Delimiter'>, 
</span><a name="LN1213"></a>                   <span class='Operator'>*</span><span class='Declare_Local'>res_colnames</span><span class='Delimiter'>, 
</span><a name="LN1214"></a>                   <span class='Operator'>*</span><span class='Declare_Local'>l_colvars</span><span class='Delimiter'>, 
</span><a name="LN1215"></a>                   <span class='Operator'>*</span><span class='Declare_Local'>r_colvars</span><span class='Delimiter'>, 
</span><a name="LN1216"></a>                   <span class='Operator'>*</span><span class='Declare_Local'>res_colvars</span><span class='Delimiter'>; 
</span><a name="LN1217"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>lateral_ok</span><span class='Delimiter'>; 
</span><a name="LN1218"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>sv_namespace_length</span><span class='Delimiter'>; 
</span><a name="LN1219"></a>        <a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span><span class='Delimiter'>; 
</span><a name="LN1220"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>k</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Recursively process the left subtree, then the right.  We must do 
         * it in this order for correct visibility of LATERAL references. 
         */ 
</span>        <a href="parse_clause.c.html#LN1203"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1449"><span class='Ref_to_Member'>larg</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN75"><span class='Ref_to_Proto'>transformFromClauseItem</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1203"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1449"><span class='Ref_to_Member'>larg</span></a><span class='Delimiter'>, 
</span>                                          <span class='Operator'>&</span><a href="parse_clause.c.html#LN1204"><span class='Ref_To_Local'>l_rte</span></a><span class='Delimiter'>, 
</span>                                          <span class='Operator'>&</span><a href="parse_clause.c.html#LN1206"><span class='Ref_To_Local'>l_rtindex</span></a><span class='Delimiter'>, 
</span>                                          <span class='Operator'>&</span><a href="parse_clause.c.html#LN1208"><span class='Ref_To_Local'>l_namespace</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Make the left-side RTEs available for LATERAL access within the 
         * right side, by temporarily adding them to the pstate's namespace 
         * list.  Per SQL:2008, if the join type is not INNER or LEFT then the 
         * left-side names must still be exposed, but it's an error to 
         * reference them.  (Stupid design, but that's what it says.)  Hence, 
         * we always push them into the namespace, but mark them as not 
         * lateral_ok if the jointype is wrong. 
         * 
         * Notice that we don't require the merged namespace list to be 
         * conflict-free.  See the comments for scanNameSpaceForRefname(). 
         * 
         * NB: this coding relies on the fact that list_concat is not 
         * destructive to its second argument. 
         */ 
</span>        <a href="parse_clause.c.html#LN1217"><span class='Ref_To_Local'>lateral_ok</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1203"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1447"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>== </span><a href="../../include/nodes/nodes.h.html#LN677"><span class='Ref_to_EnumConst'>JOIN_INNER</span></a> <span class='Operator'>|| </span><a href="parse_clause.c.html#LN1203"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1447"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>== </span><a href="../../include/nodes/nodes.h.html#LN678"><span class='Ref_to_EnumConst'>JOIN_LEFT</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN84"><span class='Ref_to_Proto'>setNamespaceLateralState</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1208"><span class='Ref_To_Local'>l_namespace</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1217"><span class='Ref_To_Local'>lateral_ok</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="parse_clause.c.html#LN1218"><span class='Ref_To_Local'>sv_namespace_length</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN172"><span class='Ref_to_Member'>p_namespace</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN172"><span class='Ref_to_Member'>p_namespace</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN172"><span class='Ref_to_Member'>p_namespace</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1208"><span class='Ref_To_Local'>l_namespace</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* And now we can process the RHS */ 
</span>        <a href="parse_clause.c.html#LN1203"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1450"><span class='Ref_to_Member'>rarg</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN75"><span class='Ref_to_Proto'>transformFromClauseItem</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1203"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1450"><span class='Ref_to_Member'>rarg</span></a><span class='Delimiter'>, 
</span>                                          <span class='Operator'>&</span><a href="parse_clause.c.html#LN1205"><span class='Ref_To_Local'>r_rte</span></a><span class='Delimiter'>, 
</span>                                          <span class='Operator'>&</span><a href="parse_clause.c.html#LN1207"><span class='Ref_To_Local'>r_rtindex</span></a><span class='Delimiter'>, 
</span>                                          <span class='Operator'>&</span><a href="parse_clause.c.html#LN1209"><span class='Ref_To_Local'>r_namespace</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Remove the left-side RTEs from the namespace list again */ 
</span>        <a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN172"><span class='Ref_to_Member'>p_namespace</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN220"><span class='Ref_to_Proto'>list_truncate</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN172"><span class='Ref_to_Member'>p_namespace</span></a><span class='Delimiter'>, 
</span>                                            <a href="parse_clause.c.html#LN1218"><span class='Ref_To_Local'>sv_namespace_length</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Check for conflicting refnames in left and right subtrees. Must do 
         * this because higher levels will assume I hand back a self- 
         * consistent namespace list. 
         */ 
</span>        <a href="../../include/parser/parse_relation.h.html#LN45"><span class='Ref_to_Proto'>checkNameSpaceConflicts</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1208"><span class='Ref_To_Local'>l_namespace</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1209"><span class='Ref_To_Local'>r_namespace</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Generate combined namespace info for possible use below. 
         */ 
</span>        <a href="parse_clause.c.html#LN1210"><span class='Ref_To_Local'>my_namespace</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1208"><span class='Ref_To_Local'>l_namespace</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1209"><span class='Ref_To_Local'>r_namespace</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Extract column name and var lists from both subtrees 
         * 
         * Note: expandRTE returns new lists, safe for me to modify 
         */ 
</span>        <a href="../../include/parser/parse_relation.h.html#LN120"><span class='Ref_to_Proto'>expandRTE</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1204"><span class='Ref_To_Local'>l_rte</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1206"><span class='Ref_To_Local'>l_rtindex</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                  <span class='Operator'>&</span><a href="parse_clause.c.html#LN1211"><span class='Ref_To_Local'>l_colnames</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_clause.c.html#LN1214"><span class='Ref_To_Local'>l_colvars</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/parser/parse_relation.h.html#LN120"><span class='Ref_to_Proto'>expandRTE</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1205"><span class='Ref_To_Local'>r_rte</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1207"><span class='Ref_To_Local'>r_rtindex</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                  <span class='Operator'>&</span><a href="parse_clause.c.html#LN1212"><span class='Ref_To_Local'>r_colnames</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_clause.c.html#LN1215"><span class='Ref_To_Local'>r_colvars</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Natural join does not explicitly specify columns; must generate 
         * columns to join. Need to run through the list of columns from each 
         * table or join result and match up the column names. Use the first 
         * table, and check every column in the second table for a match. 
         * (We'll check that the matches were unique later on.) The result of 
         * this step is a list of column names just like an explicitly-written 
         * USING list. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1203"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1448"><span class='Ref_to_Member'>isNatural</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1295"></a>            <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>rlist</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN1296"></a>            <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lx</span><span class='Delimiter'>, 
</span><a name="LN1297"></a>                       <span class='Operator'>*</span><span class='Declare_Local'>rx</span><span class='Delimiter'>; 
</span> 
            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1203"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1451"><span class='Ref_to_Member'>usingClause</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* shouldn't have USING() too */ 
</span> 
            <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1296"><span class='Ref_To_Local'>lx</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1211"><span class='Ref_To_Local'>l_colnames</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN1303"></a>                <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>l_colname</span> <span class='Operator'>= </span><a href="../../include/nodes/value.h.html#LN53"><span class='Ref_to_Macro'>strVal</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1296"><span class='Ref_To_Local'>lx</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span><a name="LN1304"></a>                <a href="../../include/nodes/value.h.html#LN41"><span class='Ref_to_Struct'>Value</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>m_name</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
                <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1297"><span class='Ref_To_Local'>rx</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1212"><span class='Ref_To_Local'>r_colnames</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN1308"></a>                    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>r_colname</span> <span class='Operator'>= </span><a href="../../include/nodes/value.h.html#LN53"><span class='Ref_to_Macro'>strVal</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1297"><span class='Ref_To_Local'>rx</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
                    <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1303"><span class='Ref_To_Local'>l_colname</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1308"><span class='Ref_To_Local'>r_colname</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                    <span class='Delimiter'>{ 
</span>                        <a href="parse_clause.c.html#LN1304"><span class='Ref_To_Local'>m_name</span></a> <span class='Operator'>= </span><a href="../nodes/value.c.html#LN51"><span class='Ref_to_Func'>makeString</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1303"><span class='Ref_To_Local'>l_colname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <span class='Control'>break</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                <span class='Delimiter'>} 
</span> 
                <span class='Comment_Multi_Line'>/* matched a right column? then keep as join column... */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1304"><span class='Ref_To_Local'>m_name</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>                    <a href="parse_clause.c.html#LN1295"><span class='Ref_To_Local'>rlist</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1295"><span class='Ref_To_Local'>rlist</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1304"><span class='Ref_To_Local'>m_name</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <a href="parse_clause.c.html#LN1203"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1451"><span class='Ref_to_Member'>usingClause</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN1295"><span class='Ref_To_Local'>rlist</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if j-&GT;isNatural &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* 
         * Now transform the join qualifications, if any. 
         */ 
</span>        <a href="parse_clause.c.html#LN1213"><span class='Ref_To_Local'>res_colnames</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN1216"><span class='Ref_To_Local'>res_colvars</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1203"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1451"><span class='Ref_to_Member'>usingClause</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * JOIN/USING (or NATURAL JOIN, as transformed above). Transform 
             * the list into an explicit ON-condition, and generate a list of 
             * merged result columns. 
             */ 
</span><a name="LN1338"></a>            <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>ucols</span> <span class='Operator'>= </span><a href="parse_clause.c.html#LN1203"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1451"><span class='Ref_to_Member'>usingClause</span></a><span class='Delimiter'>; 
</span><a name="LN1339"></a>            <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>l_usingvars</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN1340"></a>            <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>r_usingvars</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN1341"></a>            <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>ucol</span><span class='Delimiter'>; 
</span> 
            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1203"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1452"><span class='Ref_to_Member'>quals</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* shouldn't have ON() too */ 
</span> 
            <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1341"><span class='Ref_To_Local'>ucol</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1338"><span class='Ref_To_Local'>ucols</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN1347"></a>                <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>u_colname</span> <span class='Operator'>= </span><a href="../../include/nodes/value.h.html#LN53"><span class='Ref_to_Macro'>strVal</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1341"><span class='Ref_To_Local'>ucol</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span><a name="LN1348"></a>                <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>col</span><span class='Delimiter'>; 
</span><a name="LN1349"></a>                <span class='Keyword'>int</span>         <span class='Declare_Local'>ndx</span><span class='Delimiter'>; 
</span><a name="LN1350"></a>                <span class='Keyword'>int</span>         <span class='Declare_Local'>l_index</span> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span><a name="LN1351"></a>                <span class='Keyword'>int</span>         <span class='Declare_Local'>r_index</span> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span><a name="LN1352"></a>                <a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>l_colvar</span><span class='Delimiter'>, 
</span><a name="LN1353"></a>                           <span class='Operator'>*</span><span class='Declare_Local'>r_colvar</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* Check for USING(foo,foo) */ 
</span>                <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1348"><span class='Ref_To_Local'>col</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1213"><span class='Ref_To_Local'>res_colnames</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN1358"></a>                    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>res_colname</span> <span class='Operator'>= </span><a href="../../include/nodes/value.h.html#LN53"><span class='Ref_to_Macro'>strVal</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1348"><span class='Ref_To_Local'>col</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
                    <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1358"><span class='Ref_To_Local'>res_colname</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1347"><span class='Ref_To_Local'>u_colname</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_DUPLICATE_COLUMN<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"column name \"%s\" appears more than once in USING clause"</span><span class='Delimiter'>, 
</span>                                        <a href="parse_clause.c.html#LN1347"><span class='Ref_To_Local'>u_colname</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
                <span class='Comment_Multi_Line'>/* Find it in left input */ 
</span>                <a href="parse_clause.c.html#LN1349"><span class='Ref_To_Local'>ndx</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>                <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1348"><span class='Ref_To_Local'>col</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1211"><span class='Ref_To_Local'>l_colnames</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN1371"></a>                    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>l_colname</span> <span class='Operator'>= </span><a href="../../include/nodes/value.h.html#LN53"><span class='Ref_to_Macro'>strVal</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1348"><span class='Ref_To_Local'>col</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
                    <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1371"><span class='Ref_To_Local'>l_colname</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1347"><span class='Ref_To_Local'>u_colname</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                    <span class='Delimiter'>{ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1350"><span class='Ref_To_Local'>l_index</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_AMBIGUOUS_COLUMN<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"common column name \"%s\" appears more than once in left table"</span><span class='Delimiter'>, 
</span>                                            <a href="parse_clause.c.html#LN1347"><span class='Ref_To_Local'>u_colname</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                        <a href="parse_clause.c.html#LN1350"><span class='Ref_To_Local'>l_index</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN1349"><span class='Ref_To_Local'>ndx</span></a><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <a href="parse_clause.c.html#LN1349"><span class='Ref_To_Local'>ndx</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1350"><span class='Ref_To_Local'>l_index</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                    <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_UNDEFINED_COLUMN<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"column \"%s\" specified in USING clause does not exist in left table"</span><span class='Delimiter'>, 
</span>                                    <a href="parse_clause.c.html#LN1347"><span class='Ref_To_Local'>u_colname</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* Find it in right input */ 
</span>                <a href="parse_clause.c.html#LN1349"><span class='Ref_To_Local'>ndx</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>                <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1348"><span class='Ref_To_Local'>col</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1212"><span class='Ref_To_Local'>r_colnames</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN1394"></a>                    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>r_colname</span> <span class='Operator'>= </span><a href="../../include/nodes/value.h.html#LN53"><span class='Ref_to_Macro'>strVal</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1348"><span class='Ref_To_Local'>col</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
                    <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1394"><span class='Ref_To_Local'>r_colname</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1347"><span class='Ref_To_Local'>u_colname</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                    <span class='Delimiter'>{ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1351"><span class='Ref_To_Local'>r_index</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_AMBIGUOUS_COLUMN<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"common column name \"%s\" appears more than once in right table"</span><span class='Delimiter'>, 
</span>                                            <a href="parse_clause.c.html#LN1347"><span class='Ref_To_Local'>u_colname</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                        <a href="parse_clause.c.html#LN1351"><span class='Ref_To_Local'>r_index</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN1349"><span class='Ref_To_Local'>ndx</span></a><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <a href="parse_clause.c.html#LN1349"><span class='Ref_To_Local'>ndx</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1351"><span class='Ref_To_Local'>r_index</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                    <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_UNDEFINED_COLUMN<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"column \"%s\" specified in USING clause does not exist in right table"</span><span class='Delimiter'>, 
</span>                                    <a href="parse_clause.c.html#LN1347"><span class='Ref_To_Local'>u_colname</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
                <a href="parse_clause.c.html#LN1352"><span class='Ref_To_Local'>l_colvar</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN223"><span class='Ref_to_Proto'>list_nth</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1214"><span class='Ref_To_Local'>l_colvars</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1350"><span class='Ref_To_Local'>l_index</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="parse_clause.c.html#LN1339"><span class='Ref_To_Local'>l_usingvars</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1339"><span class='Ref_To_Local'>l_usingvars</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1352"><span class='Ref_To_Local'>l_colvar</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="parse_clause.c.html#LN1353"><span class='Ref_To_Local'>r_colvar</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN223"><span class='Ref_to_Proto'>list_nth</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1215"><span class='Ref_To_Local'>r_colvars</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1351"><span class='Ref_To_Local'>r_index</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="parse_clause.c.html#LN1340"><span class='Ref_To_Local'>r_usingvars</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1340"><span class='Ref_To_Local'>r_usingvars</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1353"><span class='Ref_To_Local'>r_colvar</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="parse_clause.c.html#LN1213"><span class='Ref_To_Local'>res_colnames</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1213"><span class='Ref_To_Local'>res_colnames</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1341"><span class='Ref_To_Local'>ucol</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <a href="parse_clause.c.html#LN1216"><span class='Ref_To_Local'>res_colvars</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1216"><span class='Ref_To_Local'>res_colvars</span></a><span class='Delimiter'>, 
</span>                                      <a href="parse_clause.c.html#LN78"><span class='Ref_to_Proto'>buildMergedJoinVar</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                                         <a href="parse_clause.c.html#LN1203"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1447"><span class='Ref_to_Member'>jointype</span></a><span class='Delimiter'>, 
</span>                                                         <a href="parse_clause.c.html#LN1352"><span class='Ref_To_Local'>l_colvar</span></a><span class='Delimiter'>, 
</span>                                                         <a href="parse_clause.c.html#LN1353"><span class='Ref_To_Local'>r_colvar</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <a href="parse_clause.c.html#LN1203"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1452"><span class='Ref_to_Member'>quals</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN56"><span class='Ref_to_Proto'>transformJoinUsingClause</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                                <a href="parse_clause.c.html#LN1204"><span class='Ref_To_Local'>l_rte</span></a><span class='Delimiter'>, 
</span>                                                <a href="parse_clause.c.html#LN1205"><span class='Ref_To_Local'>r_rte</span></a><span class='Delimiter'>, 
</span>                                                <a href="parse_clause.c.html#LN1339"><span class='Ref_To_Local'>l_usingvars</span></a><span class='Delimiter'>, 
</span>                                                <a href="parse_clause.c.html#LN1340"><span class='Ref_To_Local'>r_usingvars</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if j-&GT;usingClause &raquo; </span> 
        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1203"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1452"><span class='Ref_to_Member'>quals</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* User-written ON-condition; transform it */ 
</span>            <a href="parse_clause.c.html#LN1203"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1452"><span class='Ref_to_Member'>quals</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN59"><span class='Ref_to_Proto'>transformJoinOnClause</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1203"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1210"><span class='Ref_To_Local'>my_namespace</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* CROSS JOIN: no quals */ 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Add remaining columns from each side to the output columns */ 
</span>        <a href="parse_clause.c.html#LN53"><span class='Ref_to_Proto'>extractRemainingColumns</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1213"><span class='Ref_To_Local'>res_colnames</span></a><span class='Delimiter'>, 
</span>                                <a href="parse_clause.c.html#LN1211"><span class='Ref_To_Local'>l_colnames</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1214"><span class='Ref_To_Local'>l_colvars</span></a><span class='Delimiter'>, 
</span>                                <span class='Operator'>&</span><a href="parse_clause.c.html#LN1211"><span class='Ref_To_Local'>l_colnames</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_clause.c.html#LN1214"><span class='Ref_To_Local'>l_colvars</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN53"><span class='Ref_to_Proto'>extractRemainingColumns</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1213"><span class='Ref_To_Local'>res_colnames</span></a><span class='Delimiter'>, 
</span>                                <a href="parse_clause.c.html#LN1212"><span class='Ref_To_Local'>r_colnames</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1215"><span class='Ref_To_Local'>r_colvars</span></a><span class='Delimiter'>, 
</span>                                <span class='Operator'>&</span><a href="parse_clause.c.html#LN1212"><span class='Ref_To_Local'>r_colnames</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_clause.c.html#LN1215"><span class='Ref_To_Local'>r_colvars</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN1213"><span class='Ref_To_Local'>res_colnames</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1213"><span class='Ref_To_Local'>res_colnames</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1211"><span class='Ref_To_Local'>l_colnames</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN1216"><span class='Ref_To_Local'>res_colvars</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1216"><span class='Ref_To_Local'>res_colvars</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1214"><span class='Ref_To_Local'>l_colvars</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN1213"><span class='Ref_To_Local'>res_colnames</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1213"><span class='Ref_To_Local'>res_colnames</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1212"><span class='Ref_To_Local'>r_colnames</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN1216"><span class='Ref_To_Local'>res_colvars</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1216"><span class='Ref_To_Local'>res_colvars</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1215"><span class='Ref_To_Local'>r_colvars</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Check alias (AS clause), if any. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1203"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1453"><span class='Ref_to_Member'>alias</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1203"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1453"><span class='Ref_to_Member'>alias</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN42"><span class='Ref_to_Member'>colnames</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1203"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1453"><span class='Ref_to_Member'>alias</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN42"><span class='Ref_to_Member'>colnames</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT; </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1213"><span class='Ref_To_Local'>res_colnames</span></a><span class='Parentheses'>))</span> 
                    <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_SYNTAX_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"column alias list for \"%s\" has too many entries"</span><span class='Delimiter'>, 
</span>                                    <a href="parse_clause.c.html#LN1203"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1453"><span class='Ref_to_Member'>alias</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN41"><span class='Ref_to_Member'>aliasname</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Now build an RTE for the result of the join 
         */ 
</span>        <a href="parse_clause.c.html#LN1219"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_relation.h.html#LN99"><span class='Ref_to_Proto'>addRangeTableEntryForJoin</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                        <a href="parse_clause.c.html#LN1213"><span class='Ref_To_Local'>res_colnames</span></a><span class='Delimiter'>, 
</span>                                        <a href="parse_clause.c.html#LN1203"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1447"><span class='Ref_to_Member'>jointype</span></a><span class='Delimiter'>, 
</span>                                        <a href="parse_clause.c.html#LN1216"><span class='Ref_To_Local'>res_colvars</span></a><span class='Delimiter'>, 
</span>                                        <a href="parse_clause.c.html#LN1203"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1453"><span class='Ref_to_Member'>alias</span></a><span class='Delimiter'>, 
</span>                                        <span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* assume new rte is at end */ 
</span>        <a href="parse_clause.c.html#LN1203"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1454"><span class='Ref_to_Member'>rtindex</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1219"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>== </span><a href="../../include/parser/parsetree.h.html#LN30"><span class='Ref_to_Macro'>rt_fetch</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1203"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1454"><span class='Ref_to_Member'>rtindex</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN168"><span class='Ref_to_Member'>p_rtable</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Operator'>*</span><a href="parse_clause.c.html#LN1087"><span class='Ref_to_Parameter'>top_rte</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN1219"><span class='Ref_To_Local'>rte</span></a><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="parse_clause.c.html#LN1087"><span class='Ref_to_Parameter'>top_rti</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN1203"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1454"><span class='Ref_to_Member'>rtindex</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* make a matching link to the JoinExpr for later use */ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1220"><span class='Ref_To_Local'>k</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN169"><span class='Ref_to_Member'>p_joinexprs</span></a><span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="parse_clause.c.html#LN1220"><span class='Ref_To_Local'>k</span></a> <span class='Operator'>&LT; </span><a href="parse_clause.c.html#LN1203"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1454"><span class='Ref_to_Member'>rtindex</span></a><span class='Delimiter'>; </span><a href="parse_clause.c.html#LN1220"><span class='Ref_To_Local'>k</span></a><span class='Operator'>++</span><span class='Parentheses'>)</span> 
            <a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN169"><span class='Ref_to_Member'>p_joinexprs</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN169"><span class='Ref_to_Member'>p_joinexprs</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN169"><span class='Ref_to_Member'>p_joinexprs</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN169"><span class='Ref_to_Member'>p_joinexprs</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1203"><span class='Ref_To_Local'>j</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN169"><span class='Ref_to_Member'>p_joinexprs</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="parse_clause.c.html#LN1203"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1454"><span class='Ref_to_Member'>rtindex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Prepare returned namespace list.  If the JOIN has an alias then it 
         * hides the contained RTEs completely; otherwise, the contained RTEs 
         * are still visible as table names, but are not visible for 
         * unqualified column-name access. 
         * 
         * Note: if there are nested alias-less JOINs, the lower-level ones 
         * will remain in the list although they have neither p_rel_visible 
         * nor p_cols_visible set.  We could delete such list items, but it's 
         * unclear that it's worth expending cycles to do so. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1203"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1453"><span class='Ref_to_Member'>alias</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <a href="parse_clause.c.html#LN1210"><span class='Ref_To_Local'>my_namespace</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="parse_clause.c.html#LN83"><span class='Ref_to_Proto'>setNamespaceColumnVisibility</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1210"><span class='Ref_To_Local'>my_namespace</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * The join RTE itself is always made visible for unqualified column 
         * names.  It's visible as a relation name only if it has an alias. 
         */ 
</span>        <span class='Operator'>*</span><span class='Control'>namespace</span> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1210"><span class='Ref_To_Local'>my_namespace</span></a><span class='Delimiter'>, 
</span>                             <a href="parse_clause.c.html#LN80"><span class='Ref_to_Proto'>makeNamespaceItem</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1219"><span class='Ref_To_Local'>rte</span></a><span class='Delimiter'>, 
</span>                                               <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1203"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1453"><span class='Ref_to_Member'>alias</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                               <span class='Boolean'>true</span><span class='Delimiter'>, 
</span>                                               <span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                                               <span class='Boolean'>true</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN1203"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IsA(n,JoinExpr) &raquo; </span> 
    <span class='Control'>else</span> 
        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized node type: %d"</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="../../include/nodes/nodes.h.html#LN513"><span class='Ref_to_Macro'>nodeTag</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1086"><span class='Ref_to_Parameter'>n</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>;</span>                <span class='Comment_Single_Line'>/* can't get here, keep compiler quiet */ 
</span><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end transformFromClauseItem &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * buildMergedJoinVar - 
 *    generate a suitable replacement expression for a merged join column 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN1531"></a><span class='Declare_Function'>buildMergedJoinVar</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/nodes.h.html#LN671"><span class='Ref_to_Enum'>JoinType</span></a> <span class='Declare_Parameter'>jointype</span><span class='Delimiter'>, 
</span><a name="LN1532"></a>                   <a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>l_colvar</span><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>r_colvar</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1534"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>outcoltype</span><span class='Delimiter'>; 
</span><a name="LN1535"></a>    <a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>outcoltypmod</span><span class='Delimiter'>; 
</span><a name="LN1536"></a>    <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>l_node</span><span class='Delimiter'>, 
</span><a name="LN1537"></a>               <span class='Operator'>*</span><span class='Declare_Local'>r_node</span><span class='Delimiter'>, 
</span><a name="LN1538"></a>               <span class='Operator'>*</span><span class='Declare_Local'>res_node</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Choose output type if input types are dissimilar. 
     */ 
</span>    <a href="parse_clause.c.html#LN1534"><span class='Ref_To_Local'>outcoltype</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN1532"><span class='Ref_to_Parameter'>l_colvar</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN169"><span class='Ref_to_Member'>vartype</span></a><span class='Delimiter'>; 
</span>    <a href="parse_clause.c.html#LN1535"><span class='Ref_To_Local'>outcoltypmod</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN1532"><span class='Ref_to_Parameter'>l_colvar</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN170"><span class='Ref_to_Member'>vartypmod</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1534"><span class='Ref_To_Local'>outcoltype</span></a> <span class='Operator'>!= </span><a href="parse_clause.c.html#LN1532"><span class='Ref_to_Parameter'>r_colvar</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN169"><span class='Ref_to_Member'>vartype</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="parse_clause.c.html#LN1534"><span class='Ref_To_Local'>outcoltype</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN68"><span class='Ref_to_Proto'>select_common_type</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1531"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                        <a href="../../include/nodes/pg_list.h.html#LN139"><span class='Ref_to_Macro'>list_make2</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1532"><span class='Ref_to_Parameter'>l_colvar</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1532"><span class='Ref_to_Parameter'>r_colvar</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                        <span class='String'>"JOIN/USING"</span><span class='Delimiter'>, 
</span>                                        <span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN1535"><span class='Ref_To_Local'>outcoltypmod</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* ie, unknown */ 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1535"><span class='Ref_To_Local'>outcoltypmod</span></a> <span class='Operator'>!= </span><a href="parse_clause.c.html#LN1532"><span class='Ref_to_Parameter'>r_colvar</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN170"><span class='Ref_to_Member'>vartypmod</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* same type, but not same typmod */ 
</span>        <a href="parse_clause.c.html#LN1535"><span class='Ref_To_Local'>outcoltypmod</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* ie, unknown */ 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Insert coercion functions if needed.  Note that a difference in typmod 
     * can only happen if input has typmod but outcoltypmod is -1. In that 
     * case we insert a RelabelType to clearly mark that result's typmod is 
     * not same as input.  We never need coerce_type_typmod. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1532"><span class='Ref_to_Parameter'>l_colvar</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN169"><span class='Ref_to_Member'>vartype</span></a> <span class='Operator'>!= </span><a href="parse_clause.c.html#LN1534"><span class='Ref_To_Local'>outcoltype</span></a><span class='Parentheses'>) 
</span>        <a href="parse_clause.c.html#LN1536"><span class='Ref_To_Local'>l_node</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN45"><span class='Ref_to_Proto'>coerce_type</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1531"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN1532"><span class='Ref_to_Parameter'>l_colvar</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1532"><span class='Ref_to_Parameter'>l_colvar</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN169"><span class='Ref_to_Member'>vartype</span></a><span class='Delimiter'>, 
</span>                             <a href="parse_clause.c.html#LN1534"><span class='Ref_To_Local'>outcoltype</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1535"><span class='Ref_To_Local'>outcoltypmod</span></a><span class='Delimiter'>, 
</span>                             <a href="../../include/nodes/primnodes.h.html#LN420"><span class='Ref_to_EnumConst'>COERCION_IMPLICIT</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN438"><span class='Ref_to_EnumConst'>COERCE_IMPLICIT_CAST</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1532"><span class='Ref_to_Parameter'>l_colvar</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN170"><span class='Ref_to_Member'>vartypmod</span></a> <span class='Operator'>!= </span><a href="parse_clause.c.html#LN1535"><span class='Ref_To_Local'>outcoltypmod</span></a><span class='Parentheses'>) 
</span>        <a href="parse_clause.c.html#LN1536"><span class='Ref_To_Local'>l_node</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/makefuncs.h.html#LN65"><span class='Ref_to_Proto'>makeRelabelType</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN1532"><span class='Ref_to_Parameter'>l_colvar</span></a><span class='Delimiter'>, 
</span>                                          <a href="parse_clause.c.html#LN1534"><span class='Ref_To_Local'>outcoltype</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1535"><span class='Ref_To_Local'>outcoltypmod</span></a><span class='Delimiter'>, 
</span>                                          <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>,</span>   <span class='Comment_Single_Line'>/* fixed below */ 
</span>                                          <a href="../../include/nodes/primnodes.h.html#LN438"><span class='Ref_to_EnumConst'>COERCE_IMPLICIT_CAST</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="parse_clause.c.html#LN1536"><span class='Ref_To_Local'>l_node</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN1532"><span class='Ref_to_Parameter'>l_colvar</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1532"><span class='Ref_to_Parameter'>r_colvar</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN169"><span class='Ref_to_Member'>vartype</span></a> <span class='Operator'>!= </span><a href="parse_clause.c.html#LN1534"><span class='Ref_To_Local'>outcoltype</span></a><span class='Parentheses'>) 
</span>        <a href="parse_clause.c.html#LN1537"><span class='Ref_To_Local'>r_node</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN45"><span class='Ref_to_Proto'>coerce_type</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1531"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN1532"><span class='Ref_to_Parameter'>r_colvar</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1532"><span class='Ref_to_Parameter'>r_colvar</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN169"><span class='Ref_to_Member'>vartype</span></a><span class='Delimiter'>, 
</span>                             <a href="parse_clause.c.html#LN1534"><span class='Ref_To_Local'>outcoltype</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1535"><span class='Ref_To_Local'>outcoltypmod</span></a><span class='Delimiter'>, 
</span>                             <a href="../../include/nodes/primnodes.h.html#LN420"><span class='Ref_to_EnumConst'>COERCION_IMPLICIT</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN438"><span class='Ref_to_EnumConst'>COERCE_IMPLICIT_CAST</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1532"><span class='Ref_to_Parameter'>r_colvar</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN170"><span class='Ref_to_Member'>vartypmod</span></a> <span class='Operator'>!= </span><a href="parse_clause.c.html#LN1535"><span class='Ref_To_Local'>outcoltypmod</span></a><span class='Parentheses'>) 
</span>        <a href="parse_clause.c.html#LN1537"><span class='Ref_To_Local'>r_node</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/makefuncs.h.html#LN65"><span class='Ref_to_Proto'>makeRelabelType</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN1532"><span class='Ref_to_Parameter'>r_colvar</span></a><span class='Delimiter'>, 
</span>                                          <a href="parse_clause.c.html#LN1534"><span class='Ref_To_Local'>outcoltype</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1535"><span class='Ref_To_Local'>outcoltypmod</span></a><span class='Delimiter'>, 
</span>                                          <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>,</span>   <span class='Comment_Single_Line'>/* fixed below */ 
</span>                                          <a href="../../include/nodes/primnodes.h.html#LN438"><span class='Ref_to_EnumConst'>COERCE_IMPLICIT_CAST</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="parse_clause.c.html#LN1537"><span class='Ref_To_Local'>r_node</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN1532"><span class='Ref_to_Parameter'>r_colvar</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Choose what to emit 
     */ 
</span>    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1531"><span class='Ref_to_Parameter'>jointype</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN677"><span class='Ref_to_EnumConst'>JOIN_INNER</span></a><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * We can use either var; prefer non-coerced one if available. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1536"><span class='Ref_To_Local'>l_node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>))</span> 
                <a href="parse_clause.c.html#LN1538"><span class='Ref_To_Local'>res_node</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN1536"><span class='Ref_To_Local'>l_node</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1537"><span class='Ref_To_Local'>r_node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>))</span> 
                <a href="parse_clause.c.html#LN1538"><span class='Ref_To_Local'>res_node</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN1537"><span class='Ref_To_Local'>r_node</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="parse_clause.c.html#LN1538"><span class='Ref_To_Local'>res_node</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN1536"><span class='Ref_To_Local'>l_node</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN678"><span class='Ref_to_EnumConst'>JOIN_LEFT</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* Always use left var */ 
</span>            <a href="parse_clause.c.html#LN1538"><span class='Ref_To_Local'>res_node</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN1536"><span class='Ref_To_Local'>l_node</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN680"><span class='Ref_to_EnumConst'>JOIN_RIGHT</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* Always use right var */ 
</span>            <a href="parse_clause.c.html#LN1538"><span class='Ref_To_Local'>res_node</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN1537"><span class='Ref_To_Local'>r_node</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN679"><span class='Ref_to_EnumConst'>JOIN_FULL</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * Here we must build a COALESCE expression to ensure that the 
                 * join output is non-null if either input is. 
                 */ 
</span><a name="LN1620"></a>                <a href="../../include/nodes/primnodes.h.html#LN1040"><span class='Ref_to_Struct'>CoalesceExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>c</span> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN1040"><span class='Ref_to_Struct'>CoalesceExpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="parse_clause.c.html#LN1620"><span class='Ref_To_Local'>c</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1043"><span class='Ref_to_Member'>coalescetype</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN1534"><span class='Ref_To_Local'>outcoltype</span></a><span class='Delimiter'>; 
</span>                <span class='Comment_Multi_Line'>/* coalescecollid will get set below */ 
</span>                <a href="parse_clause.c.html#LN1620"><span class='Ref_To_Local'>c</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1045"><span class='Ref_to_Member'>args</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN139"><span class='Ref_to_Macro'>list_make2</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1536"><span class='Ref_To_Local'>l_node</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1537"><span class='Ref_To_Local'>r_node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="parse_clause.c.html#LN1620"><span class='Ref_To_Local'>c</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1046"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>                <a href="parse_clause.c.html#LN1538"><span class='Ref_To_Local'>res_node</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN1620"><span class='Ref_To_Local'>c</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Control'>default</span><span class='Operator'>: 
</span>            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized join type: %d"</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN1531"><span class='Ref_to_Parameter'>jointype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="parse_clause.c.html#LN1538"><span class='Ref_To_Local'>res_node</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch jointype &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Apply assign_expr_collations to fix up the collation info in the 
     * coercion and CoalesceExpr nodes, if we made any.  This must be done now 
     * so that the join node's alias vars show correct collation info. 
     */ 
</span>    <a href="../../include/parser/parse_collate.h.html#LN22"><span class='Ref_to_Proto'>assign_expr_collations</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1531"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1538"><span class='Ref_To_Local'>res_node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="parse_clause.c.html#LN1538"><span class='Ref_To_Local'>res_node</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end buildMergedJoinVar &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * makeNamespaceItem - 
 *    Convenience subroutine to construct a ParseNamespaceItem. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/parser/parse_node.h.html#LN239"><span class='Ref_to_Struct'>ParseNamespaceItem</span></a> <span class='Operator'>* 
</span><a name="LN1650"></a><span class='Declare_Function'>makeNamespaceItem</span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>rel_visible</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>cols_visible</span><span class='Delimiter'>, 
</span><a name="LN1651"></a>                  <span class='Keyword'>bool </span><span class='Declare_Parameter'>lateral_only</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>lateral_ok</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1653"></a>    <a href="../../include/parser/parse_node.h.html#LN239"><span class='Ref_to_Struct'>ParseNamespaceItem</span></a> <span class='Operator'>*</span><span class='Declare_Local'>nsitem</span><span class='Delimiter'>; 
</span> 
    <a href="parse_clause.c.html#LN1653"><span class='Ref_To_Local'>nsitem</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN239"><span class='Ref_to_Struct'>ParseNamespaceItem</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN239"><span class='Ref_to_Struct'>ParseNamespaceItem</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="parse_clause.c.html#LN1653"><span class='Ref_To_Local'>nsitem</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN241"><span class='Ref_to_Member'>p_rte</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN1650"><span class='Ref_to_Parameter'>rte</span></a><span class='Delimiter'>; 
</span>    <a href="parse_clause.c.html#LN1653"><span class='Ref_To_Local'>nsitem</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN242"><span class='Ref_to_Member'>p_rel_visible</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN1650"><span class='Ref_to_Parameter'>rel_visible</span></a><span class='Delimiter'>; 
</span>    <a href="parse_clause.c.html#LN1653"><span class='Ref_To_Local'>nsitem</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN243"><span class='Ref_to_Member'>p_cols_visible</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN1650"><span class='Ref_to_Parameter'>cols_visible</span></a><span class='Delimiter'>; 
</span>    <a href="parse_clause.c.html#LN1653"><span class='Ref_To_Local'>nsitem</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN244"><span class='Ref_to_Member'>p_lateral_only</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN1651"><span class='Ref_to_Parameter'>lateral_only</span></a><span class='Delimiter'>; 
</span>    <a href="parse_clause.c.html#LN1653"><span class='Ref_To_Local'>nsitem</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN245"><span class='Ref_to_Member'>p_lateral_ok</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN1651"><span class='Ref_to_Parameter'>lateral_ok</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="parse_clause.c.html#LN1653"><span class='Ref_To_Local'>nsitem</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * setNamespaceColumnVisibility - 
 *    Convenience subroutine to update cols_visible flags in a namespace list. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1669"></a><span class='Declare_Function'>setNamespaceColumnVisibility</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>namespace</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>cols_visible</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1671"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1671"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><span class='Control'>namespace</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1675"></a>        <a href="../../include/parser/parse_node.h.html#LN239"><span class='Ref_to_Struct'>ParseNamespaceItem</span></a> <span class='Operator'>*</span><span class='Declare_Local'>nsitem</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN239"><span class='Ref_to_Struct'>ParseNamespaceItem</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1671"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="parse_clause.c.html#LN1675"><span class='Ref_To_Local'>nsitem</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN243"><span class='Ref_to_Member'>p_cols_visible</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN1669"><span class='Ref_to_Parameter'>cols_visible</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * setNamespaceLateralState - 
 *    Convenience subroutine to update LATERAL flags in a namespace list. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1686"></a><span class='Declare_Function'>setNamespaceLateralState</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>namespace</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>lateral_only</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>lateral_ok</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1688"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1688"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><span class='Control'>namespace</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1692"></a>        <a href="../../include/parser/parse_node.h.html#LN239"><span class='Ref_to_Struct'>ParseNamespaceItem</span></a> <span class='Operator'>*</span><span class='Declare_Local'>nsitem</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN239"><span class='Ref_to_Struct'>ParseNamespaceItem</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1688"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="parse_clause.c.html#LN1692"><span class='Ref_To_Local'>nsitem</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN244"><span class='Ref_to_Member'>p_lateral_only</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN1686"><span class='Ref_to_Parameter'>lateral_only</span></a><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN1692"><span class='Ref_To_Local'>nsitem</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN245"><span class='Ref_to_Member'>p_lateral_ok</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN1686"><span class='Ref_to_Parameter'>lateral_ok</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * transformWhereClause - 
 *    Transform the qualification and make sure it is of type boolean. 
 *    Used for WHERE and allied clauses. 
 * 
 * constructName does not affect the semantics, but is used in error messages 
 */ 
</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN1708"></a><span class='Declare_Function'>transformWhereClause</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Delimiter'>, 
</span><a name="LN1709"></a>                     <a href="../../include/parser/parse_node.h.html#LN32"><span class='Ref_to_Enum'>ParseExprKind</span></a> <span class='Declare_Parameter'>exprKind</span><span class='Delimiter'>, </span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>constructName</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1711"></a>    <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>qual</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1708"><span class='Ref_to_Parameter'>clause</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <a href="parse_clause.c.html#LN1711"><span class='Ref_To_Local'>qual</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_expr.h.html#LN21"><span class='Ref_to_Proto'>transformExpr</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1708"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1708"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1709"><span class='Ref_to_Parameter'>exprKind</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="parse_clause.c.html#LN1711"><span class='Ref_To_Local'>qual</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN54"><span class='Ref_to_Proto'>coerce_to_boolean</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1708"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1711"><span class='Ref_To_Local'>qual</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1709"><span class='Ref_to_Parameter'>constructName</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="parse_clause.c.html#LN1711"><span class='Ref_To_Local'>qual</span></a><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * transformLimitClause - 
 *    Transform the expression and make sure it is of type bigint. 
 *    Used for LIMIT and allied clauses. 
 * 
 * Note: as of Postgres 8.2, LIMIT expressions are expected to yield int8, 
 * rather than int4 as before. 
 * 
 * constructName does not affect the semantics, but is used in error messages 
 */ 
</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN1735"></a><span class='Declare_Function'>transformLimitClause</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Delimiter'>, 
</span><a name="LN1736"></a>                     <a href="../../include/parser/parse_node.h.html#LN32"><span class='Ref_to_Enum'>ParseExprKind</span></a> <span class='Declare_Parameter'>exprKind</span><span class='Delimiter'>, </span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>constructName</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1738"></a>    <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>qual</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1735"><span class='Ref_to_Parameter'>clause</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <a href="parse_clause.c.html#LN1738"><span class='Ref_To_Local'>qual</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_expr.h.html#LN21"><span class='Ref_to_Proto'>transformExpr</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1735"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1735"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1736"><span class='Ref_to_Parameter'>exprKind</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="parse_clause.c.html#LN1738"><span class='Ref_To_Local'>qual</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN56"><span class='Ref_to_Proto'>coerce_to_specific_type</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1735"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1738"><span class='Ref_To_Local'>qual</span></a><span class='Delimiter'>, </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN21"><span class='Ref_to_Const'>INT8OID</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1736"><span class='Ref_to_Parameter'>constructName</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* LIMIT can't refer to any variables of the current query */ 
</span>    <a href="parse_clause.c.html#LN86"><span class='Ref_to_Proto'>checkExprIsVarFree</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1735"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1738"><span class='Ref_To_Local'>qual</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1736"><span class='Ref_to_Parameter'>constructName</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="parse_clause.c.html#LN1738"><span class='Ref_To_Local'>qual</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * checkExprIsVarFree 
 *      Check that given expr has no Vars of the current query level 
 *      (aggregates and window functions should have been rejected already). 
 * 
 * This is used to check expressions that have to have a consistent value 
 * across all rows of the query, such as a LIMIT.  Arguably it should reject 
 * volatile functions, too, but we don't do that --- whatever value the 
 * function gives on first execution is what you get. 
 * 
 * constructName does not affect the semantics, but is used in error messages 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1766"></a><span class='Declare_Function'>checkExprIsVarFree</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>n</span><span class='Delimiter'>, </span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>constructName</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/optimizer/var.h.html#LN34"><span class='Ref_to_Proto'>contain_vars_of_level</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1766"><span class='Ref_to_Parameter'>n</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_COLUMN_REFERENCE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>        <span class='Comment_Multi_Line'>/* translator: %s is name of a SQL construct, eg LIMIT */ 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"argument of %s must not contain variables"</span><span class='Delimiter'>, 
</span>                        <a href="parse_clause.c.html#LN1766"><span class='Ref_to_Parameter'>constructName</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1766"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                    <a href="../../include/optimizer/var.h.html#LN35"><span class='Ref_to_Proto'>locate_var_of_level</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1766"><span class='Ref_to_Parameter'>n</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * checkTargetlistEntrySQL92 - 
 *    Validate a targetlist entry found by findTargetlistEntrySQL92 
 * 
 * When we select a pre-existing tlist entry as a result of syntax such 
 * as "GROUP BY 1", we have to make sure it is acceptable for use in the 
 * indicated clause type; transformExpr() will have treated it as a regular 
 * targetlist item. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1791"></a><span class='Declare_Function'>checkTargetlistEntrySQL92</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tle</span><span class='Delimiter'>, 
</span><a name="LN1792"></a>                          <a href="../../include/parser/parse_node.h.html#LN32"><span class='Ref_to_Enum'>ParseExprKind</span></a> <span class='Declare_Parameter'>exprKind</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1792"><span class='Ref_to_Parameter'>exprKind</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN51"><span class='Ref_to_EnumConst'>EXPR_KIND_GROUP_BY</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* reject aggregates and window functions */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1791"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN195"><span class='Ref_to_Member'>p_hasAggs</span></a> <span class='Operator'>&& 
</span>                <a href="../../include/rewrite/rewriteManip.h.html#LN57"><span class='Ref_to_Proto'>contain_aggs_of_level</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN1791"><span class='Ref_to_Parameter'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>))</span> 
                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_GROUPING_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                <span class='Comment_Multi_Line'>/* translator: %s is name of a SQL construct, eg GROUP BY */ 
</span>                         <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"aggregate functions are not allowed in %s"</span><span class='Delimiter'>, 
</span>                                <a href="../../include/parser/parse_expr.h.html#LN23"><span class='Ref_to_Proto'>ParseExprKindName</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1792"><span class='Ref_to_Parameter'>exprKind</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                         <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1791"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                               <a href="../../include/rewrite/rewriteManip.h.html#LN58"><span class='Ref_to_Proto'>locate_agg_of_level</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN1791"><span class='Ref_to_Parameter'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1791"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN196"><span class='Ref_to_Member'>p_hasWindowFuncs</span></a> <span class='Operator'>&& 
</span>                <a href="../../include/rewrite/rewriteManip.h.html#LN59"><span class='Ref_to_Proto'>contain_windowfuncs</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN1791"><span class='Ref_to_Parameter'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Parentheses'>))</span> 
                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_WINDOWING_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                <span class='Comment_Multi_Line'>/* translator: %s is name of a SQL construct, eg GROUP BY */ 
</span>                         <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"window functions are not allowed in %s"</span><span class='Delimiter'>, 
</span>                                <a href="../../include/parser/parse_expr.h.html#LN23"><span class='Ref_to_Proto'>ParseExprKindName</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1792"><span class='Ref_to_Parameter'>exprKind</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                         <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1791"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                    <a href="../../include/rewrite/rewriteManip.h.html#LN60"><span class='Ref_to_Proto'>locate_windowfunc</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN1791"><span class='Ref_to_Parameter'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN52"><span class='Ref_to_EnumConst'>EXPR_KIND_ORDER_BY</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* no extra checks needed */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN53"><span class='Ref_to_EnumConst'>EXPR_KIND_DISTINCT_ON</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* no extra checks needed */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>default</span><span class='Operator'>: 
</span>            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unexpected exprKind in checkTargetlistEntrySQL92"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch exprKind &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end checkTargetlistEntrySQL92 &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *  findTargetlistEntrySQL92 - 
 *    Returns the targetlist entry matching the given (untransformed) node. 
 *    If no matching entry exists, one is created and appended to the target 
 *    list as a "resjunk" node. 
 * 
 * This function supports the old SQL92 ORDER BY interpretation, where the 
 * expression is an output column name or number.  If we fail to find a 
 * match of that sort, we fall through to the SQL99 rules.  For historical 
 * reasons, Postgres also allows this interpretation for GROUP BY, though 
 * the standard never did.  However, for GROUP BY we prefer a SQL99 match. 
 * This function is *not* used for WINDOW definitions. 
 * 
 * node     the ORDER BY, GROUP BY, or DISTINCT ON expression to be matched 
 * tlist    the target list (passed by reference so we can append to it) 
 * exprKind identifies clause type being processed 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>* 
</span><a name="LN1847"></a><span class='Declare_Function'>findTargetlistEntrySQL92</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>tlist</span><span class='Delimiter'>, 
</span><a name="LN1848"></a>                         <a href="../../include/parser/parse_node.h.html#LN32"><span class='Ref_to_Enum'>ParseExprKind</span></a> <span class='Declare_Parameter'>exprKind</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1850"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>tl</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/*---------- 
     * Handle two special cases as mandated by the SQL92 spec: 
     * 
     * 1. Bare ColumnName (no qualifier or subscripts) 
     *    For a bare identifier, we search for a matching column name 
     *    in the existing target list.  Multiple matches are an error 
     *    unless they refer to identical values; for example, 
     *    we allow  SELECT a, a FROM table ORDER BY a 
     *    but not   SELECT a AS b, b FROM table ORDER BY b 
     *    If no match is found, we fall through and treat the identifier 
     *    as an expression. 
     *    For GROUP BY, it is incorrect to match the grouping item against 
     *    targetlist entries: according to SQL92, an identifier in GROUP BY 
     *    is a reference to a column name exposed by FROM, not to a target 
     *    list column.  However, many implementations (including pre-7.0 
     *    PostgreSQL) accept this anyway.  So for GROUP BY, we look first 
     *    to see if the identifier matches any FROM column name, and only 
     *    try for a targetlist name if it doesn't.  This ensures that we 
     *    adhere to the spec in the case where the name could be both. 
     *    DISTINCT ON isn't in the standard, so we can do what we like there; 
     *    we choose to make it work like ORDER BY, on the rather flimsy 
     *    grounds that ordinary DISTINCT works on targetlist entries. 
     * 
     * 2. IntegerConstant 
     *    This means to use the n'th item in the existing target list. 
     *    Note that it would make no sense to order/group/distinct by an 
     *    actual constant, so this does not create a conflict with SQL99. 
     *    GROUP BY column-number is not allowed by SQL92, but since 
     *    the standard has no other behavior defined for this syntax, 
     *    we may as well accept this common extension. 
     * 
     * Note that pre-existing resjunk targets must not be used in either case, 
     * since the user didn't write them in his SELECT list. 
     * 
     * If neither special case applies, fall through to treat the item as 
     * an expression per SQL99. 
     *---------- 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1847"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN231"><span class='Ref_to_Struct'>ColumnRef</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>        <a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(((</span><a href="../../include/nodes/parsenodes.h.html#LN231"><span class='Ref_to_Struct'>ColumnRef</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> <a href="parse_clause.c.html#LN1847"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>fields<span class='Parentheses'>)</span> <span class='Operator'>== </span><span class='Number'>1</span> <span class='Operator'>&& 
</span>        <a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(((</span><a href="../../include/nodes/parsenodes.h.html#LN231"><span class='Ref_to_Struct'>ColumnRef</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN1847"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>fields<span class='Parentheses'>)</span><span class='Delimiter'>, </span>String<span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1894"></a>        <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>name</span> <span class='Operator'>= </span><a href="../../include/nodes/value.h.html#LN53"><span class='Ref_to_Macro'>strVal</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(((</span><a href="../../include/nodes/parsenodes.h.html#LN231"><span class='Ref_to_Struct'>ColumnRef</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN1847"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>fields<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span><a name="LN1895"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>location</span> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/nodes/parsenodes.h.html#LN231"><span class='Ref_to_Struct'>ColumnRef</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN1847"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>location<span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1848"><span class='Ref_to_Parameter'>exprKind</span></a> <span class='Operator'>== </span><a href="../../include/parser/parse_node.h.html#LN51"><span class='Ref_to_EnumConst'>EXPR_KIND_GROUP_BY</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * In GROUP BY, we must prefer a match against a FROM-clause 
             * column to one against the targetlist.  Look to see if there is 
             * a matching column.  If so, fall through to use SQL99 rules. 
             * NOTE: if name could refer ambiguously to more than one column 
             * name exposed by FROM, colNameToVar will ereport(ERROR). That's 
             * just what we want here. 
             * 
             * Small tweak for 7.4.3: ignore matches in upper query levels. 
             * This effectively changes the search order for bare names to (1) 
             * local FROM variables, (2) local targetlist aliases, (3) outer 
             * FROM variables, whereas before it was (1) (3) (2). SQL92 and 
             * SQL99 do not allow GROUPing BY an outer reference, so this 
             * breaks no cases that are legal per spec, and it seems a more 
             * self-consistent behavior. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/parser/parse_relation.h.html#LN58"><span class='Ref_to_Proto'>colNameToVar</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1847"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1894"><span class='Ref_To_Local'>name</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1895"><span class='Ref_To_Local'>location</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
                <a href="parse_clause.c.html#LN1894"><span class='Ref_To_Local'>name</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if exprKind==EXPR_KIND_G... &raquo; </span> 
 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1894"><span class='Ref_To_Local'>name</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1921"></a>            <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>target_result</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
            <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1850"><span class='Ref_To_Local'>tl</span></a><span class='Delimiter'>, </span><span class='Operator'>*</span><a href="parse_clause.c.html#LN1847"><span class='Ref_to_Parameter'>tlist</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN1925"></a>                <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1850"><span class='Ref_To_Local'>tl</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_clause.c.html#LN1925"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1373"><span class='Ref_to_Member'>resjunk</span></a> <span class='Operator'>&& 
</span>                    strcmp<span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1925"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1368"><span class='Ref_to_Member'>resname</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1894"><span class='Ref_To_Local'>name</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1921"><span class='Ref_To_Local'>target_result</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/nodes/nodes.h.html#LN626"><span class='Ref_to_Proto'>equal</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1921"><span class='Ref_To_Local'>target_result</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1925"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Parentheses'>))</span> 
                            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_AMBIGUOUS_COLUMN<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span> 
                            <span class='Comment_Multi_Line'>/*------ 
                              translator: first %s is name of a SQL construct, eg ORDER BY */ 
</span>                                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"%s \"%s\" is ambiguous"</span><span class='Delimiter'>, 
</span>                                            <a href="../../include/parser/parse_expr.h.html#LN23"><span class='Ref_to_Proto'>ParseExprKindName</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1848"><span class='Ref_to_Parameter'>exprKind</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                            <a href="parse_clause.c.html#LN1894"><span class='Ref_To_Local'>name</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1847"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1895"><span class='Ref_To_Local'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <span class='Control'>else</span> 
                        <a href="parse_clause.c.html#LN1921"><span class='Ref_To_Local'>target_result</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN1925"><span class='Ref_To_Local'>tle</span></a><span class='Delimiter'>; 
</span>                    <span class='Comment_Multi_Line'>/* Stay in loop to check for ambiguity */ 
</span>                <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !tle-&GT;resjunk&&strcmp... &raquo; </span> 
            <span class='Delimiter'>} 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1921"><span class='Ref_To_Local'>target_result</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* return the first match, after suitable validation */ 
</span>                <a href="parse_clause.c.html#LN1790"><span class='Ref_to_Func'>checkTargetlistEntrySQL92</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1847"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1921"><span class='Ref_To_Local'>target_result</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1848"><span class='Ref_to_Parameter'>exprKind</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <a href="parse_clause.c.html#LN1921"><span class='Ref_To_Local'>target_result</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if name!=NULL &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IsA(node,ColumnRef)&&... &raquo; </span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1847"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN284"><span class='Ref_to_Struct'>A_Const</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1958"></a>        <a href="../../include/nodes/value.h.html#LN41"><span class='Ref_to_Struct'>Value</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>val</span> <span class='Operator'>= &</span><span class='Parentheses'>((</span><a href="../../include/nodes/parsenodes.h.html#LN284"><span class='Ref_to_Struct'>A_Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN1847"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span><a href="../../../contrib/ltree/ltxtquery_io.c.html#LN29"><span class='Ref_to_Member'>val</span></a><span class='Delimiter'>; 
</span><a name="LN1959"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>location</span> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/nodes/parsenodes.h.html#LN284"><span class='Ref_to_Struct'>A_Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN1847"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>location<span class='Delimiter'>; 
</span><a name="LN1960"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>targetlist_pos</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1961"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>target_pos</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1958"><span class='Ref_To_Local'>val</span></a><span class='Delimiter'>, </span>Integer<span class='Parentheses'>))</span> 
            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_SYNTAX_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>            <span class='Comment_Multi_Line'>/* translator: %s is name of a SQL construct, eg ORDER BY */ 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"non-integer constant in %s"</span><span class='Delimiter'>, 
</span>                            <a href="../../include/parser/parse_expr.h.html#LN23"><span class='Ref_to_Proto'>ParseExprKindName</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1848"><span class='Ref_to_Parameter'>exprKind</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1847"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1959"><span class='Ref_To_Local'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <a href="parse_clause.c.html#LN1961"><span class='Ref_To_Local'>target_pos</span></a> <span class='Operator'>= </span><a href="../../include/nodes/value.h.html#LN51"><span class='Ref_to_Macro'>intVal</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1958"><span class='Ref_To_Local'>val</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1850"><span class='Ref_To_Local'>tl</span></a><span class='Delimiter'>, </span><span class='Operator'>*</span><a href="parse_clause.c.html#LN1847"><span class='Ref_to_Parameter'>tlist</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1974"></a>            <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1850"><span class='Ref_To_Local'>tl</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_clause.c.html#LN1974"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1373"><span class='Ref_to_Member'>resjunk</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>++</span><a href="parse_clause.c.html#LN1960"><span class='Ref_To_Local'>targetlist_pos</span></a> <span class='Operator'>== </span><a href="parse_clause.c.html#LN1961"><span class='Ref_To_Local'>target_pos</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* return the unique match, after suitable validation */ 
</span>                    <a href="parse_clause.c.html#LN1790"><span class='Ref_to_Func'>checkTargetlistEntrySQL92</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1847"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1974"><span class='Ref_To_Local'>tle</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1848"><span class='Ref_to_Parameter'>exprKind</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>return</span> <a href="parse_clause.c.html#LN1974"><span class='Ref_To_Local'>tle</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_COLUMN_REFERENCE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>        <span class='Comment_Multi_Line'>/* translator: %s is name of a SQL construct, eg ORDER BY */ 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"%s position %d is not in select list"</span><span class='Delimiter'>, 
</span>                        <a href="../../include/parser/parse_expr.h.html#LN23"><span class='Ref_to_Proto'>ParseExprKindName</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1848"><span class='Ref_to_Parameter'>exprKind</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1961"><span class='Ref_To_Local'>target_pos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1847"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1959"><span class='Ref_To_Local'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IsA(node,A_Const) &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Otherwise, we have an expression, so process it per SQL99 rules. 
     */ 
</span>    <span class='Control'>return</span> <a href="parse_clause.c.html#LN90"><span class='Ref_to_Proto'>findTargetlistEntrySQL99</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN1847"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1847"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1847"><span class='Ref_to_Parameter'>tlist</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN1848"><span class='Ref_to_Parameter'>exprKind</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end findTargetlistEntrySQL92 &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *  findTargetlistEntrySQL99 - 
 *    Returns the targetlist entry matching the given (untransformed) node. 
 *    If no matching entry exists, one is created and appended to the target 
 *    list as a "resjunk" node. 
 * 
 * This function supports the SQL99 interpretation, wherein the expression 
 * is just an ordinary expression referencing input column names. 
 * 
 * node     the ORDER BY, GROUP BY, etc expression to be matched 
 * tlist    the target list (passed by reference so we can append to it) 
 * exprKind identifies clause type being processed 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>* 
</span><a name="LN2014"></a><span class='Declare_Function'>findTargetlistEntrySQL99</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>tlist</span><span class='Delimiter'>, 
</span><a name="LN2015"></a>                         <a href="../../include/parser/parse_node.h.html#LN32"><span class='Ref_to_Enum'>ParseExprKind</span></a> <span class='Declare_Parameter'>exprKind</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2017"></a>    <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>target_result</span><span class='Delimiter'>; 
</span><a name="LN2018"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>tl</span><span class='Delimiter'>; 
</span><a name="LN2019"></a>    <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>expr</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Convert the untransformed node to a transformed expression, and search 
     * for a match in the tlist.  NOTE: it doesn't really matter whether there 
     * is more than one match.  Also, we are willing to match an existing 
     * resjunk target here, though the SQL92 cases above must ignore resjunk 
     * targets. 
     */ 
</span>    <a href="parse_clause.c.html#LN2019"><span class='Ref_To_Local'>expr</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_expr.h.html#LN21"><span class='Ref_to_Proto'>transformExpr</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2014"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2014"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2015"><span class='Ref_to_Parameter'>exprKind</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2018"><span class='Ref_To_Local'>tl</span></a><span class='Delimiter'>, </span><span class='Operator'>*</span><a href="parse_clause.c.html#LN2014"><span class='Ref_to_Parameter'>tlist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2032"></a>        <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2018"><span class='Ref_To_Local'>tl</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2033"></a>        <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>texpr</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Ignore any implicit cast on the existing tlist expression. 
         * 
         * This essentially allows the ORDER/GROUP/etc item to adopt the same 
         * datatype previously selected for a textually-equivalent tlist item. 
         * There can't be any implicit cast at top level in an ordinary SELECT 
         * tlist at this stage, but the case does arise with ORDER BY in an 
         * aggregate function. 
         */ 
</span>        <a href="parse_clause.c.html#LN2033"><span class='Ref_To_Local'>texpr</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN35"><span class='Ref_to_Proto'>strip_implicit_coercions</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN2032"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN626"><span class='Ref_to_Proto'>equal</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2019"><span class='Ref_To_Local'>expr</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2033"><span class='Ref_To_Local'>texpr</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <a href="parse_clause.c.html#LN2032"><span class='Ref_To_Local'>tle</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If no matches, construct a new target entry which is appended to the 
     * end of the target list.  This target is given resjunk = TRUE so that it 
     * will not be projected into the final tuple. 
     */ 
</span>    <a href="parse_clause.c.html#LN2017"><span class='Ref_To_Local'>target_result</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_target.h.html#LN25"><span class='Ref_to_Proto'>transformTargetEntry</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2014"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2014"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2019"><span class='Ref_To_Local'>expr</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2015"><span class='Ref_to_Parameter'>exprKind</span></a><span class='Delimiter'>, 
</span>                                         <span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Operator'>*</span><a href="parse_clause.c.html#LN2014"><span class='Ref_to_Parameter'>tlist</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="parse_clause.c.html#LN2014"><span class='Ref_to_Parameter'>tlist</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2017"><span class='Ref_To_Local'>target_result</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="parse_clause.c.html#LN2017"><span class='Ref_To_Local'>target_result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end findTargetlistEntrySQL99 &raquo; </span> 
 
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * Flatten out parenthesized sublists in grouping lists, and some cases 
 * of nested grouping sets. 
 * 
 * Inside a grouping set (ROLLUP, CUBE, or GROUPING SETS), we expect the 
 * content to be nested no more than 2 deep: i.e. ROLLUP((a,b),(c,d)) is 
 * ok, but ROLLUP((a,(b,c)),d) is flattened to ((a,b,c),d), which we then 
 * (later) normalize to ((a,b,c),(d)). 
 * 
 * CUBE or ROLLUP can be nested inside GROUPING SETS (but not the reverse), 
 * and we leave that alone if we find it. But if we see GROUPING SETS inside 
 * GROUPING SETS, we can flatten and normalize as follows: 
 *   GROUPING SETS (a, (b,c), GROUPING SETS ((c,d),(e)), (f,g)) 
 * becomes 
 *   GROUPING SETS ((a), (b,c), (c,d), (e), (f,g)) 
 * 
 * This is per the spec's syntax transformations, but these are the only such 
 * transformations we do in parse analysis, so that queries retain the 
 * originally specified grouping set syntax for CUBE and ROLLUP as much as 
 * possible when deparsed. (Full expansion of the result into a list of 
 * grouping sets is left to the planner.) 
 * 
 * When we're done, the resulting list should contain only these possible 
 * elements: 
 *   - an expression 
 *   - a CUBE or ROLLUP with a list of expressions nested 2 deep 
 *   - a GROUPING SET containing any of: 
 *      - expression lists 
 *      - empty grouping sets 
 *      - CUBE or ROLLUP nodes with lists nested 2 deep 
 * The return is a new list, but doesn't deep-copy the old nodes except for 
 * GroupingSet nodes. 
 * 
 * As a side effect, flag whether the list has any GroupingSet nodes. 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN2100"></a><span class='Declare_Function'>flatten_grouping_sets</span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>expr</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>toplevel</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>hasGroupingSets</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* just in case of pathological input */ 
</span>    <a href="../../include/miscadmin.h.html#LN275"><span class='Ref_to_Proto'>check_stack_depth</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2100"><span class='Ref_to_Parameter'>expr</span></a> <span class='Operator'>== </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span> 
        <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2100"><span class='Ref_to_Parameter'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../../contrib/ltree/ltxtquery_io.c.html#LN28"><span class='Ref_to_Member'>type</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN173"><span class='Ref_to_EnumConst'>T_RowExpr</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span><a name="LN2112"></a>                <a href="../../include/nodes/primnodes.h.html#LN981"><span class='Ref_to_Struct'>RowExpr</span></a>    <span class='Operator'>*</span><span class='Declare_Local'>r</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN981"><span class='Ref_to_Struct'>RowExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN2100"><span class='Ref_to_Parameter'>expr</span></a><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2112"><span class='Ref_To_Local'>r</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN996"><span class='Ref_to_Member'>row_format</span></a> <span class='Operator'>== </span><a href="../../include/nodes/primnodes.h.html#LN438"><span class='Ref_to_EnumConst'>COERCE_IMPLICIT_CAST</span></a><span class='Parentheses'>) 
</span>                    <span class='Control'>return</span> <a href="parse_clause.c.html#LN2099"><span class='Ref_to_Func'>flatten_grouping_sets</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN2112"><span class='Ref_To_Local'>r</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN984"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>, 
</span>                                                 <span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN449"><span class='Ref_to_EnumConst'>T_GroupingSet</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span><a name="LN2121"></a>                <a href="../../include/nodes/parsenodes.h.html#LN1230"><span class='Ref_to_Struct'>GroupingSet</span></a> <span class='Operator'>*</span><span class='Declare_Local'>gset</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1230"><span class='Ref_to_Struct'>GroupingSet</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN2100"><span class='Ref_to_Parameter'>expr</span></a><span class='Delimiter'>; 
</span><a name="LN2122"></a>                <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l2</span><span class='Delimiter'>; 
</span><a name="LN2123"></a>                <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result_set</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2100"><span class='Ref_to_Parameter'>hasGroupingSets</span></a><span class='Parentheses'>) 
</span>                    <span class='Operator'>*</span><a href="parse_clause.c.html#LN2100"><span class='Ref_to_Parameter'>hasGroupingSets</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * at the top level, we skip over all empty grouping sets; the 
                 * caller can supply the canonical GROUP BY () if nothing is 
                 * left. 
                 */ 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2100"><span class='Ref_to_Parameter'>toplevel</span></a> <span class='Operator'>&& </span><a href="parse_clause.c.html#LN2121"><span class='Ref_To_Local'>gset</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1233"><span class='Ref_to_Member'>kind</span></a> <span class='Operator'>== </span><a href="../../include/nodes/parsenodes.h.html#LN1223"><span class='Ref_to_EnumConst'>GROUPING_SET_EMPTY</span></a><span class='Parentheses'>) 
</span>                    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
                <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2122"><span class='Ref_To_Local'>l2</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2121"><span class='Ref_To_Local'>gset</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1234"><span class='Ref_to_Member'>content</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN2139"></a>                    <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>n1</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2122"><span class='Ref_To_Local'>l2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2140"></a>                    <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>n2</span> <span class='Operator'>= </span><a href="parse_clause.c.html#LN2099"><span class='Ref_to_Func'>flatten_grouping_sets</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2139"><span class='Ref_To_Local'>n1</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2139"><span class='Ref_To_Local'>n1</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN1230"><span class='Ref_to_Struct'>GroupingSet</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>                        <span class='Parentheses'>((</span><a href="../../include/nodes/parsenodes.h.html#LN1230"><span class='Ref_to_Struct'>GroupingSet</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN2139"><span class='Ref_To_Local'>n1</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>kind <span class='Operator'>== </span><a href="../../include/nodes/parsenodes.h.html#LN1227"><span class='Ref_to_EnumConst'>GROUPING_SET_SETS</span></a><span class='Parentheses'>)</span> 
                    <span class='Delimiter'>{ 
</span>                        <a href="parse_clause.c.html#LN2123"><span class='Ref_To_Local'>result_set</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2123"><span class='Ref_To_Local'>result_set</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN2140"><span class='Ref_To_Local'>n2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <span class='Control'>else</span> 
                        <a href="parse_clause.c.html#LN2123"><span class='Ref_To_Local'>result_set</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2123"><span class='Ref_To_Local'>result_set</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2140"><span class='Ref_To_Local'>n2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * At top level, keep the grouping set node; but if we're in a 
                 * nested grouping set, then we need to concat the flattened 
                 * result into the outer list if it's simply nested. 
                 */ 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2100"><span class='Ref_to_Parameter'>toplevel</span></a> <span class='Operator'>|| </span><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2121"><span class='Ref_To_Local'>gset</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1233"><span class='Ref_to_Member'>kind</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/parsenodes.h.html#LN1227"><span class='Ref_to_EnumConst'>GROUPING_SET_SETS</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/makefuncs.h.html#LN86"><span class='Ref_to_Proto'>makeGroupingSet</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2121"><span class='Ref_To_Local'>gset</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1233"><span class='Ref_to_Member'>kind</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2123"><span class='Ref_To_Local'>result_set</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2121"><span class='Ref_To_Local'>gset</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1235"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>else</span> 
                    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN2123"><span class='Ref_To_Local'>result_set</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN290"><span class='Ref_to_EnumConst'>T_List</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span><a name="LN2166"></a>                <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN2167"></a>                <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
                <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2167"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN2100"><span class='Ref_to_Parameter'>expr</span></a><span class='Parentheses'>)</span> 
                <span class='Delimiter'>{ 
</span><a name="LN2171"></a>                    <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>n</span> <span class='Operator'>= </span><a href="parse_clause.c.html#LN2099"><span class='Ref_to_Func'>flatten_grouping_sets</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2167"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2100"><span class='Ref_to_Parameter'>toplevel</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2100"><span class='Ref_to_Parameter'>hasGroupingSets</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2171"><span class='Ref_To_Local'>n</span></a> <span class='Operator'>!= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span> 
                    <span class='Delimiter'>{ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2171"><span class='Ref_To_Local'>n</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a><span class='Parentheses'>))</span> 
                            <a href="parse_clause.c.html#LN2166"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2166"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN2171"><span class='Ref_To_Local'>n</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <span class='Control'>else</span> 
                            <a href="parse_clause.c.html#LN2166"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2166"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2171"><span class='Ref_To_Local'>n</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                <span class='Delimiter'>} 
</span> 
                <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN2166"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Control'>default</span><span class='Operator'>: 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch expr-&GT;type &raquo; </span> 
 
    <span class='Control'>return</span> <a href="parse_clause.c.html#LN2100"><span class='Ref_to_Parameter'>expr</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end flatten_grouping_sets &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Transform a single expression within a GROUP BY clause or grouping set. 
 * 
 * The expression is added to the targetlist if not already present, and to the 
 * flatresult list (which will become the groupClause) if not already present 
 * there.  The sortClause is consulted for operator and sort order hints. 
 * 
 * Returns the ressortgroupref of the expression. 
 * 
 * flatresult   reference to flat list of SortGroupClause nodes 
 * seen_local   bitmapset of sortgrouprefs already seen at the local level 
 * pstate       ParseState 
 * gexpr        node to transform 
 * targetlist   reference to TargetEntry list 
 * sortClause   ORDER BY clause (SortGroupClause nodes) 
 * exprKind     expression kind 
 * useSQL99     SQL99 rather than SQL92 syntax 
 * toplevel     false if within any grouping set 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> 
<a name="LN2211"></a><span class='Declare_Function'>transformGroupClauseExpr</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>flatresult</span><span class='Delimiter'>, </span><a href="../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>seen_local</span><span class='Delimiter'>, 
</span><a name="LN2212"></a>                         <a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>gexpr</span><span class='Delimiter'>, 
</span><a name="LN2213"></a>                         <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>targetlist</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sortClause</span><span class='Delimiter'>, 
</span><a name="LN2214"></a>                         <a href="../../include/parser/parse_node.h.html#LN32"><span class='Ref_to_Enum'>ParseExprKind</span></a> <span class='Declare_Parameter'>exprKind</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>useSQL99</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>toplevel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2216"></a>    <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span><span class='Delimiter'>; 
</span><a name="LN2217"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2214"><span class='Ref_to_Parameter'>useSQL99</span></a><span class='Parentheses'>) 
</span>        <a href="parse_clause.c.html#LN2216"><span class='Ref_To_Local'>tle</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN90"><span class='Ref_to_Proto'>findTargetlistEntrySQL99</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2212"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2212"><span class='Ref_to_Parameter'>gexpr</span></a><span class='Delimiter'>, 
</span>                                       <a href="parse_clause.c.html#LN2213"><span class='Ref_to_Parameter'>targetlist</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2214"><span class='Ref_to_Parameter'>exprKind</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="parse_clause.c.html#LN2216"><span class='Ref_To_Local'>tle</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN88"><span class='Ref_to_Proto'>findTargetlistEntrySQL92</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2212"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2212"><span class='Ref_to_Parameter'>gexpr</span></a><span class='Delimiter'>, 
</span>                                       <a href="parse_clause.c.html#LN2213"><span class='Ref_to_Parameter'>targetlist</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2214"><span class='Ref_to_Parameter'>exprKind</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2216"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1369"><span class='Ref_to_Member'>ressortgroupref</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2228"></a>        <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>sl</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Eliminate duplicates (GROUP BY x, x) but only at local level. 
         * (Duplicates in grouping sets can affect the number of returned 
         * rows, so can't be dropped indiscriminately.) 
         * 
         * Since we don't care about anything except the sortgroupref, we can 
         * use a bitmapset rather than scanning lists. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/bitmapset.h.html#LN75"><span class='Ref_to_Proto'>bms_is_member</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2216"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1369"><span class='Ref_to_Member'>ressortgroupref</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2211"><span class='Ref_to_Parameter'>seen_local</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Number'>0</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If we're already in the flat clause list, we don't need to consider 
         * adding ourselves again. 
         */ 
</span>        <a href="parse_clause.c.html#LN2217"><span class='Ref_To_Local'>found</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_clause.h.html#LN51"><span class='Ref_to_Proto'>targetIsInSortList</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2216"><span class='Ref_To_Local'>tle</span></a><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, </span><span class='Operator'>*</span><a href="parse_clause.c.html#LN2211"><span class='Ref_to_Parameter'>flatresult</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2217"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <a href="parse_clause.c.html#LN2216"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1369"><span class='Ref_to_Member'>ressortgroupref</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If the GROUP BY tlist entry also appears in ORDER BY, copy operator 
         * info from the (first) matching ORDER BY item.  This means that if 
         * you write something like "GROUP BY foo ORDER BY foo USING &LT;&LT;&LT;", the 
         * GROUP BY operation silently takes on the equality semantics implied 
         * by the ORDER BY.  There are two reasons to do this: it improves the 
         * odds that we can implement both GROUP BY and ORDER BY with a single 
         * sort step, and it allows the user to choose the equality semantics 
         * used by GROUP BY, should she be working with a datatype that has 
         * more than one equality operator. 
         * 
         * If we're in a grouping set, though, we force our requested ordering 
         * to be NULLS LAST, because if we have any hope of using a sorted agg 
         * for the job, we're going to be tacking on generated NULL values 
         * after the corresponding groups. If the user demands nulls first, 
         * another sort step is going to be inevitable, but that's the 
         * planner's problem. 
         */ 
</span> 
        <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2228"><span class='Ref_To_Local'>sl</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2213"><span class='Ref_to_Parameter'>sortClause</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN2270"></a>            <a href="../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sc</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2228"><span class='Ref_To_Local'>sl</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2270"><span class='Ref_To_Local'>sc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1164"><span class='Ref_to_Member'>tleSortGroupRef</span></a> <span class='Operator'>== </span><a href="parse_clause.c.html#LN2216"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1369"><span class='Ref_to_Member'>ressortgroupref</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN2274"></a>                <a href="../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>grpc</span> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2270"><span class='Ref_To_Local'>sc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_clause.c.html#LN2214"><span class='Ref_to_Parameter'>toplevel</span></a><span class='Parentheses'>) 
</span>                    <a href="parse_clause.c.html#LN2274"><span class='Ref_To_Local'>grpc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1167"><span class='Ref_to_Member'>nulls_first</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                <span class='Operator'>*</span><a href="parse_clause.c.html#LN2211"><span class='Ref_to_Parameter'>flatresult</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="parse_clause.c.html#LN2211"><span class='Ref_to_Parameter'>flatresult</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2274"><span class='Ref_To_Local'>grpc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="parse_clause.c.html#LN2217"><span class='Ref_To_Local'>found</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if tle-&GT;ressortgroupref&GT;... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * If no match in ORDER BY, just add it to the result using default 
     * sort/group semantics. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_clause.c.html#LN2217"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>*</span><a href="parse_clause.c.html#LN2211"><span class='Ref_to_Parameter'>flatresult</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN96"><span class='Ref_to_Proto'>addTargetToGroupList</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2212"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2216"><span class='Ref_To_Local'>tle</span></a><span class='Delimiter'>, 
</span>                                           <span class='Operator'>*</span><a href="parse_clause.c.html#LN2211"><span class='Ref_to_Parameter'>flatresult</span></a><span class='Delimiter'>, </span><span class='Operator'>*</span><a href="parse_clause.c.html#LN2213"><span class='Ref_to_Parameter'>targetlist</span></a><span class='Delimiter'>, 
</span>                                           <a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2212"><span class='Ref_to_Parameter'>gexpr</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * _something_ must have assigned us a sortgroupref by now... 
     */ 
</span> 
    <span class='Control'>return</span> <a href="parse_clause.c.html#LN2216"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1369"><span class='Ref_to_Member'>ressortgroupref</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end transformGroupClauseExpr &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Transform a list of expressions within a GROUP BY clause or grouping set. 
 * 
 * The list of expressions belongs to a single clause within which duplicates 
 * can be safely eliminated. 
 * 
 * Returns an integer list of ressortgroupref values. 
 * 
 * flatresult   reference to flat list of SortGroupClause nodes 
 * pstate       ParseState 
 * list         nodes to transform 
 * targetlist   reference to TargetEntry list 
 * sortClause   ORDER BY clause (SortGroupClause nodes) 
 * exprKind     expression kind 
 * useSQL99     SQL99 rather than SQL92 syntax 
 * toplevel     false if within any grouping set 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN2319"></a><span class='Declare_Function'>transformGroupClauseList</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>flatresult</span><span class='Delimiter'>, 
</span><a name="LN2320"></a>                         <a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Delimiter'>, 
</span><a name="LN2321"></a>                         <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>targetlist</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sortClause</span><span class='Delimiter'>, 
</span><a name="LN2322"></a>                         <a href="../../include/parser/parse_node.h.html#LN32"><span class='Ref_to_Enum'>ParseExprKind</span></a> <span class='Declare_Parameter'>exprKind</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>useSQL99</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>toplevel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2324"></a>    <a href="../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>seen_local</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN2325"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN2326"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>gl</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2326"><span class='Ref_To_Local'>gl</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2320"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2330"></a>        <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>gexpr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2326"><span class='Ref_To_Local'>gl</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<a name="LN2332"></a>        <a href="../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Local'>ref</span> <span class='Operator'>= </span><a href="parse_clause.c.html#LN2210"><span class='Ref_to_Func'>transformGroupClauseExpr</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2319"><span class='Ref_to_Parameter'>flatresult</span></a><span class='Delimiter'>, 
</span>                                                   <a href="parse_clause.c.html#LN2324"><span class='Ref_To_Local'>seen_local</span></a><span class='Delimiter'>, 
</span>                                                   <a href="parse_clause.c.html#LN2320"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                                   <a href="parse_clause.c.html#LN2330"><span class='Ref_To_Local'>gexpr</span></a><span class='Delimiter'>, 
</span>                                                   <a href="parse_clause.c.html#LN2321"><span class='Ref_to_Parameter'>targetlist</span></a><span class='Delimiter'>, 
</span>                                                   <a href="parse_clause.c.html#LN2321"><span class='Ref_to_Parameter'>sortClause</span></a><span class='Delimiter'>, 
</span>                                                   <a href="parse_clause.c.html#LN2322"><span class='Ref_to_Parameter'>exprKind</span></a><span class='Delimiter'>, 
</span>                                                   <a href="parse_clause.c.html#LN2322"><span class='Ref_to_Parameter'>useSQL99</span></a><span class='Delimiter'>, 
</span>                                                   <a href="parse_clause.c.html#LN2322"><span class='Ref_to_Parameter'>toplevel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Keyword'>ref </span><span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="parse_clause.c.html#LN2324"><span class='Ref_To_Local'>seen_local</span></a> <span class='Operator'>= </span><a href="../../include/nodes/bitmapset.h.html#LN89"><span class='Ref_to_Proto'>bms_add_member</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2324"><span class='Ref_To_Local'>seen_local</span></a><span class='Delimiter'>, </span><span class='Keyword'>ref</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="parse_clause.c.html#LN2325"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN144"><span class='Ref_to_Func'>lappend_int</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2325"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><span class='Keyword'>ref</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="parse_clause.c.html#LN2325"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end transformGroupClauseList &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Transform a grouping set and (recursively) its content. 
 * 
 * The grouping set might be a GROUPING SETS node with other grouping sets 
 * inside it, but SETS within SETS have already been flattened out before 
 * reaching here. 
 * 
 * Returns the transformed node, which now contains SIMPLE nodes with lists 
 * of ressortgrouprefs rather than expressions. 
 * 
 * flatresult   reference to flat list of SortGroupClause nodes 
 * pstate       ParseState 
 * gset         grouping set to transform 
 * targetlist   reference to TargetEntry list 
 * sortClause   ORDER BY clause (SortGroupClause nodes) 
 * exprKind     expression kind 
 * useSQL99     SQL99 rather than SQL92 syntax 
 * toplevel     false if within any grouping set 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN2372"></a><span class='Declare_Function'>transformGroupingSet</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>flatresult</span><span class='Delimiter'>, 
</span><a name="LN2373"></a>                     <a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN1230"><span class='Ref_to_Struct'>GroupingSet</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>gset</span><span class='Delimiter'>, 
</span><a name="LN2374"></a>                     <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>targetlist</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sortClause</span><span class='Delimiter'>, 
</span><a name="LN2375"></a>                     <a href="../../include/parser/parse_node.h.html#LN32"><span class='Ref_to_Enum'>ParseExprKind</span></a> <span class='Declare_Parameter'>exprKind</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>useSQL99</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>toplevel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2377"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>gl</span><span class='Delimiter'>; 
</span><a name="LN2378"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>content</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2375"><span class='Ref_to_Parameter'>toplevel</span></a> <span class='Operator'>|| </span><a href="parse_clause.c.html#LN2373"><span class='Ref_to_Parameter'>gset</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1233"><span class='Ref_to_Member'>kind</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/parsenodes.h.html#LN1227"><span class='Ref_to_EnumConst'>GROUPING_SET_SETS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2377"><span class='Ref_To_Local'>gl</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2373"><span class='Ref_to_Parameter'>gset</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1234"><span class='Ref_to_Member'>content</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2384"></a>        <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>n</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2377"><span class='Ref_To_Local'>gl</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2384"><span class='Ref_To_Local'>n</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN2388"></a>            <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>l</span> <span class='Operator'>= </span><a href="parse_clause.c.html#LN2318"><span class='Ref_to_Func'>transformGroupClauseList</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2372"><span class='Ref_to_Parameter'>flatresult</span></a><span class='Delimiter'>, 
</span>                                                     <a href="parse_clause.c.html#LN2373"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN2384"><span class='Ref_To_Local'>n</span></a><span class='Delimiter'>, 
</span>                                                     <a href="parse_clause.c.html#LN2374"><span class='Ref_to_Parameter'>targetlist</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2374"><span class='Ref_to_Parameter'>sortClause</span></a><span class='Delimiter'>, 
</span>                                                  <a href="parse_clause.c.html#LN2375"><span class='Ref_to_Parameter'>exprKind</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2375"><span class='Ref_to_Parameter'>useSQL99</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="parse_clause.c.html#LN2378"><span class='Ref_To_Local'>content</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2378"><span class='Ref_To_Local'>content</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/makefuncs.h.html#LN86"><span class='Ref_to_Proto'>makeGroupingSet</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1224"><span class='Ref_to_EnumConst'>GROUPING_SET_SIMPLE</span></a><span class='Delimiter'>, 
</span>                                                       <a href="parse_clause.c.html#LN2388"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, 
</span>                                                       <a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2384"><span class='Ref_To_Local'>n</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2384"><span class='Ref_To_Local'>n</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN1230"><span class='Ref_to_Struct'>GroupingSet</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN2399"></a>            <a href="../../include/nodes/parsenodes.h.html#LN1230"><span class='Ref_to_Struct'>GroupingSet</span></a> <span class='Operator'>*</span><span class='Declare_Local'>gset2</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1230"><span class='Ref_to_Struct'>GroupingSet</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2377"><span class='Ref_To_Local'>gl</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="parse_clause.c.html#LN2378"><span class='Ref_To_Local'>content</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2378"><span class='Ref_To_Local'>content</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2371"><span class='Ref_to_Func'>transformGroupingSet</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2372"><span class='Ref_to_Parameter'>flatresult</span></a><span class='Delimiter'>, 
</span>                                                            <a href="parse_clause.c.html#LN2373"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2399"><span class='Ref_To_Local'>gset2</span></a><span class='Delimiter'>, 
</span>                                                      <a href="parse_clause.c.html#LN2374"><span class='Ref_to_Parameter'>targetlist</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2374"><span class='Ref_to_Parameter'>sortClause</span></a><span class='Delimiter'>, 
</span>                                                 <a href="parse_clause.c.html#LN2375"><span class='Ref_to_Parameter'>exprKind</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2375"><span class='Ref_to_Parameter'>useSQL99</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span><a name="LN2408"></a>            <a href="../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Local'>ref</span> <span class='Operator'>= </span><a href="parse_clause.c.html#LN2210"><span class='Ref_to_Func'>transformGroupClauseExpr</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2372"><span class='Ref_to_Parameter'>flatresult</span></a><span class='Delimiter'>, 
</span>                                                       <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                                       <a href="parse_clause.c.html#LN2373"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                                       <a href="parse_clause.c.html#LN2384"><span class='Ref_To_Local'>n</span></a><span class='Delimiter'>, 
</span>                                                       <a href="parse_clause.c.html#LN2374"><span class='Ref_to_Parameter'>targetlist</span></a><span class='Delimiter'>, 
</span>                                                       <a href="parse_clause.c.html#LN2374"><span class='Ref_to_Parameter'>sortClause</span></a><span class='Delimiter'>, 
</span>                                                       <a href="parse_clause.c.html#LN2375"><span class='Ref_to_Parameter'>exprKind</span></a><span class='Delimiter'>, 
</span>                                                       <a href="parse_clause.c.html#LN2375"><span class='Ref_to_Parameter'>useSQL99</span></a><span class='Delimiter'>, 
</span>                                                       <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="parse_clause.c.html#LN2378"><span class='Ref_To_Local'>content</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2378"><span class='Ref_To_Local'>content</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/makefuncs.h.html#LN86"><span class='Ref_to_Proto'>makeGroupingSet</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1224"><span class='Ref_to_EnumConst'>GROUPING_SET_SIMPLE</span></a><span class='Delimiter'>, 
</span>                                                       <a href="../../include/nodes/pg_list.h.html#LN144"><span class='Ref_to_Macro'>list_make1_int</span></a><span class='Parentheses'>(</span><span class='Keyword'>ref</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                       <a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2384"><span class='Ref_To_Local'>n</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Arbitrarily cap the size of CUBE, which has exponential growth */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2373"><span class='Ref_to_Parameter'>gset</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1233"><span class='Ref_to_Member'>kind</span></a> <span class='Operator'>== </span><a href="../../include/nodes/parsenodes.h.html#LN1226"><span class='Ref_to_EnumConst'>GROUPING_SET_CUBE</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2378"><span class='Ref_To_Local'>content</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT; </span><span class='Number'>12</span><span class='Parentheses'>)</span> 
            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_TOO_MANY_COLUMNS<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"CUBE is limited to 12 elements"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2373"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2373"><span class='Ref_to_Parameter'>gset</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1235"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/makefuncs.h.html#LN86"><span class='Ref_to_Proto'>makeGroupingSet</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2373"><span class='Ref_to_Parameter'>gset</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1233"><span class='Ref_to_Member'>kind</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2378"><span class='Ref_To_Local'>content</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2373"><span class='Ref_to_Parameter'>gset</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1235"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end transformGroupingSet &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * transformGroupClause - 
 *    transform a GROUP BY clause 
 * 
 * GROUP BY items will be added to the targetlist (as resjunk columns) 
 * if not already present, so the targetlist must be passed by reference. 
 * 
 * This is also used for window PARTITION BY clauses (which act almost the 
 * same, but are always interpreted per SQL99 rules). 
 * 
 * Grouping sets make this a lot more complex than it was. Our goal here is 
 * twofold: we make a flat list of SortGroupClause nodes referencing each 
 * distinct expression used for grouping, with those expressions added to the 
 * targetlist if needed. At the same time, we build the groupingSets tree, 
 * which stores only ressortgrouprefs as integer lists inside GroupingSet nodes 
 * (possibly nested, but limited in depth: a GROUPING_SET_SETS node can contain 
 * nested SIMPLE, CUBE or ROLLUP nodes, but not more sets - we flatten that 
 * out; while CUBE and ROLLUP can contain only SIMPLE nodes). 
 * 
 * We skip much of the hard work if there are no grouping sets. 
 * 
 * One subtlety is that the groupClause list can end up empty while the 
 * groupingSets list is not; this happens if there are only empty grouping 
 * sets, or an explicit GROUP BY (). This has the same effect as specifying 
 * aggregates or a HAVING clause with no GROUP BY; the output is one row per 
 * grouping set even if the input is empty. 
 * 
 * Returns the transformed (flat) groupClause. 
 * 
 * pstate       ParseState 
 * grouplist    clause to transform 
 * groupingSets reference to list to contain the grouping set tree 
 * targetlist   reference to TargetEntry list 
 * sortClause   ORDER BY clause (SortGroupClause nodes) 
 * exprKind     expression kind 
 * useSQL99     SQL99 rather than SQL92 syntax 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN2476"></a><span class='Declare_Function'>transformGroupClause</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>grouplist</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>groupingSets</span><span class='Delimiter'>, 
</span><a name="LN2477"></a>                     <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>targetlist</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sortClause</span><span class='Delimiter'>, 
</span><a name="LN2478"></a>                     <a href="../../include/parser/parse_node.h.html#LN32"><span class='Ref_to_Enum'>ParseExprKind</span></a> <span class='Declare_Parameter'>exprKind</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>useSQL99</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2480"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN2481"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>flat_grouplist</span><span class='Delimiter'>; 
</span><a name="LN2482"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>gsets</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN2483"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>gl</span><span class='Delimiter'>; 
</span><a name="LN2484"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>hasGroupingSets</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN2485"></a>    <a href="../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>seen_local</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Recursively flatten implicit RowExprs. (Technically this is only needed 
     * for GROUP BY, per the syntax rules for grouping sets, but we do it 
     * anyway.) 
     */ 
</span>    <a href="parse_clause.c.html#LN2481"><span class='Ref_To_Local'>flat_grouplist</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN2099"><span class='Ref_to_Func'>flatten_grouping_sets</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN2476"><span class='Ref_to_Parameter'>grouplist</span></a><span class='Delimiter'>, 
</span>                                                    <span class='Boolean'>true</span><span class='Delimiter'>, 
</span>                                                    <span class='Operator'>&</span><a href="parse_clause.c.html#LN2484"><span class='Ref_To_Local'>hasGroupingSets</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the list is now empty, but hasGroupingSets is true, it's because we 
     * elided redundant empty grouping sets. Restore a single empty grouping 
     * set to leave a canonical form: GROUP BY () 
     */ 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2481"><span class='Ref_To_Local'>flat_grouplist</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>&& </span><a href="parse_clause.c.html#LN2484"><span class='Ref_To_Local'>hasGroupingSets</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="parse_clause.c.html#LN2481"><span class='Ref_To_Local'>flat_grouplist</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/makefuncs.h.html#LN86"><span class='Ref_to_Proto'>makeGroupingSet</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1223"><span class='Ref_to_EnumConst'>GROUPING_SET_EMPTY</span></a><span class='Delimiter'>, 
</span>                                                    <a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>, 
</span>                                          <a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN2476"><span class='Ref_to_Parameter'>grouplist</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2483"><span class='Ref_To_Local'>gl</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2481"><span class='Ref_To_Local'>flat_grouplist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2511"></a>        <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>gexpr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2483"><span class='Ref_To_Local'>gl</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2511"><span class='Ref_To_Local'>gexpr</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN1230"><span class='Ref_to_Struct'>GroupingSet</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN2515"></a>            <a href="../../include/nodes/parsenodes.h.html#LN1230"><span class='Ref_to_Struct'>GroupingSet</span></a> <span class='Operator'>*</span><span class='Declare_Local'>gset</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1230"><span class='Ref_to_Struct'>GroupingSet</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN2511"><span class='Ref_To_Local'>gexpr</span></a><span class='Delimiter'>; 
</span> 
            <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2515"><span class='Ref_To_Local'>gset</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1233"><span class='Ref_to_Member'>kind</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>case</span> <a href="../../include/nodes/parsenodes.h.html#LN1223"><span class='Ref_to_EnumConst'>GROUPING_SET_EMPTY</span></a><span class='Operator'>: 
</span>                    <a href="parse_clause.c.html#LN2482"><span class='Ref_To_Local'>gsets</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2482"><span class='Ref_To_Local'>gsets</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2515"><span class='Ref_To_Local'>gset</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>case</span> <a href="../../include/nodes/parsenodes.h.html#LN1224"><span class='Ref_to_EnumConst'>GROUPING_SET_SIMPLE</span></a><span class='Operator'>: 
</span>                    <span class='Comment_Multi_Line'>/* can't happen */ 
</span>                    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>case</span> <a href="../../include/nodes/parsenodes.h.html#LN1227"><span class='Ref_to_EnumConst'>GROUPING_SET_SETS</span></a><span class='Operator'>: 
</span>                <span class='Control'>case</span> <a href="../../include/nodes/parsenodes.h.html#LN1226"><span class='Ref_to_EnumConst'>GROUPING_SET_CUBE</span></a><span class='Operator'>: 
</span>                <span class='Control'>case</span> <a href="../../include/nodes/parsenodes.h.html#LN1225"><span class='Ref_to_EnumConst'>GROUPING_SET_ROLLUP</span></a><span class='Operator'>: 
</span>                    <a href="parse_clause.c.html#LN2482"><span class='Ref_To_Local'>gsets</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2482"><span class='Ref_To_Local'>gsets</span></a><span class='Delimiter'>, 
</span>                                    <a href="parse_clause.c.html#LN2371"><span class='Ref_to_Func'>transformGroupingSet</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="parse_clause.c.html#LN2480"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, 
</span>                                                         <a href="parse_clause.c.html#LN2476"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2515"><span class='Ref_To_Local'>gset</span></a><span class='Delimiter'>, 
</span>                                                      <a href="parse_clause.c.html#LN2477"><span class='Ref_to_Parameter'>targetlist</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2477"><span class='Ref_to_Parameter'>sortClause</span></a><span class='Delimiter'>, 
</span>                                                  <a href="parse_clause.c.html#LN2478"><span class='Ref_to_Parameter'>exprKind</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2478"><span class='Ref_to_Parameter'>useSQL99</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IsA(gexpr,GroupingSet... &raquo; </span> 
        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span><a name="LN2539"></a>            <a href="../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Local'>ref</span> <span class='Operator'>= </span><a href="parse_clause.c.html#LN2210"><span class='Ref_to_Func'>transformGroupClauseExpr</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="parse_clause.c.html#LN2480"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2485"><span class='Ref_To_Local'>seen_local</span></a><span class='Delimiter'>, 
</span>                                                       <a href="parse_clause.c.html#LN2476"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2511"><span class='Ref_To_Local'>gexpr</span></a><span class='Delimiter'>, 
</span>                                                       <a href="parse_clause.c.html#LN2477"><span class='Ref_to_Parameter'>targetlist</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2477"><span class='Ref_to_Parameter'>sortClause</span></a><span class='Delimiter'>, 
</span>                                                   <a href="parse_clause.c.html#LN2478"><span class='Ref_to_Parameter'>exprKind</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2478"><span class='Ref_to_Parameter'>useSQL99</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Keyword'>ref </span><span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="parse_clause.c.html#LN2485"><span class='Ref_To_Local'>seen_local</span></a> <span class='Operator'>= </span><a href="../../include/nodes/bitmapset.h.html#LN89"><span class='Ref_to_Proto'>bms_add_member</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2485"><span class='Ref_To_Local'>seen_local</span></a><span class='Delimiter'>, </span><span class='Keyword'>ref</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2484"><span class='Ref_To_Local'>hasGroupingSets</span></a><span class='Parentheses'>) 
</span>                    <a href="parse_clause.c.html#LN2482"><span class='Ref_To_Local'>gsets</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2482"><span class='Ref_To_Local'>gsets</span></a><span class='Delimiter'>, 
</span>                                    <a href="../../include/nodes/makefuncs.h.html#LN86"><span class='Ref_to_Proto'>makeGroupingSet</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1224"><span class='Ref_to_EnumConst'>GROUPING_SET_SIMPLE</span></a><span class='Delimiter'>, 
</span>                                                    <a href="../../include/nodes/pg_list.h.html#LN144"><span class='Ref_to_Macro'>list_make1_int</span></a><span class='Parentheses'>(</span><span class='Keyword'>ref</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                    <a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2511"><span class='Ref_To_Local'>gexpr</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* parser should prevent this */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2482"><span class='Ref_To_Local'>gsets</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>|| </span><a href="parse_clause.c.html#LN2476"><span class='Ref_to_Parameter'>groupingSets</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2476"><span class='Ref_to_Parameter'>groupingSets</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>*</span><a href="parse_clause.c.html#LN2476"><span class='Ref_to_Parameter'>groupingSets</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN2482"><span class='Ref_To_Local'>gsets</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="parse_clause.c.html#LN2480"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end transformGroupClause &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * transformSortClause - 
 *    transform an ORDER BY clause 
 * 
 * ORDER BY items will be added to the targetlist (as resjunk columns) 
 * if not already present, so the targetlist must be passed by reference. 
 * 
 * This is also used for window and aggregate ORDER BY clauses (which act 
 * almost the same, but are always interpreted per SQL99 rules). 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN2576"></a><span class='Declare_Function'>transformSortClause</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, 
</span><a name="LN2577"></a>                    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>orderlist</span><span class='Delimiter'>, 
</span><a name="LN2578"></a>                    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>targetlist</span><span class='Delimiter'>, 
</span><a name="LN2579"></a>                    <a href="../../include/parser/parse_node.h.html#LN32"><span class='Ref_to_Enum'>ParseExprKind</span></a> <span class='Declare_Parameter'>exprKind</span><span class='Delimiter'>, 
</span><a name="LN2580"></a>                    <span class='Keyword'>bool </span><span class='Declare_Parameter'>useSQL99</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2582"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>sortlist</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN2583"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>olitem</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2583"><span class='Ref_To_Local'>olitem</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2577"><span class='Ref_to_Parameter'>orderlist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2587"></a>        <a href="../../include/nodes/parsenodes.h.html#LN465"><span class='Ref_to_Struct'>SortBy</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>sortby</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN465"><span class='Ref_to_Struct'>SortBy</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2583"><span class='Ref_To_Local'>olitem</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2588"></a>        <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2580"><span class='Ref_to_Parameter'>useSQL99</span></a><span class='Parentheses'>) 
</span>            <a href="parse_clause.c.html#LN2588"><span class='Ref_To_Local'>tle</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN90"><span class='Ref_to_Proto'>findTargetlistEntrySQL99</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2576"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2587"><span class='Ref_To_Local'>sortby</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN468"><span class='Ref_to_Member'>node</span></a><span class='Delimiter'>, 
</span>                                           <a href="parse_clause.c.html#LN2578"><span class='Ref_to_Parameter'>targetlist</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2579"><span class='Ref_to_Parameter'>exprKind</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="parse_clause.c.html#LN2588"><span class='Ref_To_Local'>tle</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN88"><span class='Ref_to_Proto'>findTargetlistEntrySQL92</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2576"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2587"><span class='Ref_To_Local'>sortby</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN468"><span class='Ref_to_Member'>node</span></a><span class='Delimiter'>, 
</span>                                           <a href="parse_clause.c.html#LN2578"><span class='Ref_to_Parameter'>targetlist</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2579"><span class='Ref_to_Parameter'>exprKind</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="parse_clause.c.html#LN2582"><span class='Ref_To_Local'>sortlist</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_clause.h.html#LN48"><span class='Ref_to_Proto'>addTargetToSortList</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2576"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2588"><span class='Ref_To_Local'>tle</span></a><span class='Delimiter'>, 
</span>                                       <a href="parse_clause.c.html#LN2582"><span class='Ref_To_Local'>sortlist</span></a><span class='Delimiter'>, </span><span class='Operator'>*</span><a href="parse_clause.c.html#LN2578"><span class='Ref_to_Parameter'>targetlist</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2587"><span class='Ref_To_Local'>sortby</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="parse_clause.c.html#LN2582"><span class='Ref_To_Local'>sortlist</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end transformSortClause &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * transformWindowDefinitions - 
 *      transform window definitions (WindowDef to WindowClause) 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN2609"></a><span class='Declare_Function'>transformWindowDefinitions</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, 
</span><a name="LN2610"></a>                           <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>windowdefs</span><span class='Delimiter'>, 
</span><a name="LN2611"></a>                           <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>targetlist</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2613"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN2614"></a>    <a href="../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Local'>winref</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN2615"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2615"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2610"><span class='Ref_to_Parameter'>windowdefs</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2619"></a>        <a href="../../include/nodes/parsenodes.h.html#LN483"><span class='Ref_to_Struct'>WindowDef</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>windef</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN483"><span class='Ref_to_Struct'>WindowDef</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2615"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2620"></a>        <a href="../../include/nodes/parsenodes.h.html#LN1252"><span class='Ref_to_Struct'>WindowClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>refwc</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN2621"></a>        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>partitionClause</span><span class='Delimiter'>; 
</span><a name="LN2622"></a>        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>orderClause</span><span class='Delimiter'>; 
</span><a name="LN2623"></a>        <a href="../../include/nodes/parsenodes.h.html#LN1252"><span class='Ref_to_Struct'>WindowClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>wc</span><span class='Delimiter'>; 
</span> 
        <a href="parse_clause.c.html#LN2614"><span class='Ref_To_Local'>winref</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Check for duplicate window names. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2619"><span class='Ref_To_Local'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN486"><span class='Ref_to_Member'>name</span></a> <span class='Operator'>&& 
</span>            <a href="parse_clause.c.html#LN98"><span class='Ref_to_Proto'>findWindowClause</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2613"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2619"><span class='Ref_To_Local'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN486"><span class='Ref_to_Member'>name</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_WINDOWING_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"window \"%s\" is already defined"</span><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2619"><span class='Ref_To_Local'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN486"><span class='Ref_to_Member'>name</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2609"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2619"><span class='Ref_To_Local'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN493"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If it references a previous window, look that up. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2619"><span class='Ref_To_Local'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN487"><span class='Ref_to_Member'>refname</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="parse_clause.c.html#LN2620"><span class='Ref_To_Local'>refwc</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN98"><span class='Ref_to_Proto'>findWindowClause</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2613"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2619"><span class='Ref_To_Local'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN487"><span class='Ref_to_Member'>refname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2620"><span class='Ref_To_Local'>refwc</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_UNDEFINED_OBJECT<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"window \"%s\" does not exist"</span><span class='Delimiter'>, 
</span>                                <a href="parse_clause.c.html#LN2619"><span class='Ref_To_Local'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN487"><span class='Ref_to_Member'>refname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2609"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2619"><span class='Ref_To_Local'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN493"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Transform PARTITION and ORDER specs, if any.  These are treated 
         * almost exactly like top-level GROUP BY and ORDER BY clauses, 
         * including the special handling of nondefault operator semantics. 
         */ 
</span>        <a href="parse_clause.c.html#LN2622"><span class='Ref_To_Local'>orderClause</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_clause.h.html#LN31"><span class='Ref_to_Proto'>transformSortClause</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2609"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                          <a href="parse_clause.c.html#LN2619"><span class='Ref_To_Local'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN489"><span class='Ref_to_Member'>orderClause</span></a><span class='Delimiter'>, 
</span>                                          <a href="parse_clause.c.html#LN2611"><span class='Ref_to_Parameter'>targetlist</span></a><span class='Delimiter'>, 
</span>                                          <a href="../../include/parser/parse_node.h.html#LN44"><span class='Ref_to_EnumConst'>EXPR_KIND_WINDOW_ORDER</span></a><span class='Delimiter'>, 
</span>                                          <span class='Boolean'>true </span><span class='Comment_Multi_Line'>/* force SQL99 rules */ </span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN2621"><span class='Ref_To_Local'>partitionClause</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_clause.h.html#LN27"><span class='Ref_to_Proto'>transformGroupClause</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2609"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                               <a href="parse_clause.c.html#LN2619"><span class='Ref_To_Local'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN488"><span class='Ref_to_Member'>partitionClause</span></a><span class='Delimiter'>, 
</span>                                               <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                               <a href="parse_clause.c.html#LN2611"><span class='Ref_to_Parameter'>targetlist</span></a><span class='Delimiter'>, 
</span>                                               <a href="parse_clause.c.html#LN2622"><span class='Ref_To_Local'>orderClause</span></a><span class='Delimiter'>, 
</span>                                               <a href="../../include/parser/parse_node.h.html#LN43"><span class='Ref_to_EnumConst'>EXPR_KIND_WINDOW_PARTITION</span></a><span class='Delimiter'>, 
</span>                                               <span class='Boolean'>true </span><span class='Comment_Multi_Line'>/* force SQL99 rules */ </span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * And prepare the new WindowClause. 
         */ 
</span>        <a href="parse_clause.c.html#LN2623"><span class='Ref_To_Local'>wc</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1252"><span class='Ref_to_Struct'>WindowClause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN2623"><span class='Ref_To_Local'>wc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1255"><span class='Ref_to_Member'>name</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN2619"><span class='Ref_To_Local'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN486"><span class='Ref_to_Member'>name</span></a><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN2623"><span class='Ref_To_Local'>wc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1256"><span class='Ref_to_Member'>refname</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN2619"><span class='Ref_To_Local'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN487"><span class='Ref_to_Member'>refname</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Per spec, a windowdef that references a previous one copies the 
         * previous partition clause (and mustn't specify its own).  It can 
         * specify its own ordering clause, but only if the previous one had 
         * none.  It always specifies its own frame clause, and the previous 
         * one must not have a frame clause.  Yeah, it's bizarre that each of 
         * these cases works differently, but SQL:2008 says so; see 7.11 
         * &LT;window clause&GT; syntax rule 10 and general rule 1.  The frame 
         * clause rule is especially bizarre because it makes "OVER foo" 
         * different from "OVER (foo)", and requires the latter to throw an 
         * error if foo has a nondefault frame clause.  Well, ours not to 
         * reason why, but we do go out of our way to throw a useful error 
         * message for such cases. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2620"><span class='Ref_To_Local'>refwc</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2621"><span class='Ref_To_Local'>partitionClause</span></a><span class='Parentheses'>) 
</span>                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_WINDOWING_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"cannot override PARTITION BY clause of window \"%s\""</span><span class='Delimiter'>, 
</span>                       <a href="parse_clause.c.html#LN2619"><span class='Ref_To_Local'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN487"><span class='Ref_to_Member'>refname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2609"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2619"><span class='Ref_To_Local'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN493"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <a href="parse_clause.c.html#LN2623"><span class='Ref_To_Local'>wc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1257"><span class='Ref_to_Member'>partitionClause</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2620"><span class='Ref_To_Local'>refwc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1257"><span class='Ref_to_Member'>partitionClause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <a href="parse_clause.c.html#LN2623"><span class='Ref_To_Local'>wc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1257"><span class='Ref_to_Member'>partitionClause</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN2621"><span class='Ref_To_Local'>partitionClause</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2620"><span class='Ref_To_Local'>refwc</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2622"><span class='Ref_To_Local'>orderClause</span></a> <span class='Operator'>&& </span><a href="parse_clause.c.html#LN2620"><span class='Ref_To_Local'>refwc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1258"><span class='Ref_to_Member'>orderClause</span></a><span class='Parentheses'>) 
</span>                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_WINDOWING_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                   <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"cannot override ORDER BY clause of window \"%s\""</span><span class='Delimiter'>, 
</span>                          <a href="parse_clause.c.html#LN2619"><span class='Ref_To_Local'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN487"><span class='Ref_to_Member'>refname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2609"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2619"><span class='Ref_To_Local'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN493"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2622"><span class='Ref_To_Local'>orderClause</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="parse_clause.c.html#LN2623"><span class='Ref_To_Local'>wc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1258"><span class='Ref_to_Member'>orderClause</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN2622"><span class='Ref_To_Local'>orderClause</span></a><span class='Delimiter'>; 
</span>                <a href="parse_clause.c.html#LN2623"><span class='Ref_To_Local'>wc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1263"><span class='Ref_to_Member'>copiedOrder</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <a href="parse_clause.c.html#LN2623"><span class='Ref_To_Local'>wc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1258"><span class='Ref_to_Member'>orderClause</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2620"><span class='Ref_To_Local'>refwc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1258"><span class='Ref_to_Member'>orderClause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="parse_clause.c.html#LN2623"><span class='Ref_To_Local'>wc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1263"><span class='Ref_to_Member'>copiedOrder</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="parse_clause.c.html#LN2623"><span class='Ref_To_Local'>wc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1258"><span class='Ref_to_Member'>orderClause</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN2622"><span class='Ref_To_Local'>orderClause</span></a><span class='Delimiter'>; 
</span>            <a href="parse_clause.c.html#LN2623"><span class='Ref_To_Local'>wc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1263"><span class='Ref_to_Member'>copiedOrder</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2620"><span class='Ref_To_Local'>refwc</span></a> <span class='Operator'>&& </span><a href="parse_clause.c.html#LN2620"><span class='Ref_To_Local'>refwc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1259"><span class='Ref_to_Member'>frameOptions</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/parsenodes.h.html#LN524"><span class='Ref_to_Const'>FRAMEOPTION_DEFAULTS</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Use this message if this is a WINDOW clause, or if it's an OVER 
             * clause that includes ORDER BY or framing clauses.  (We already 
             * rejected PARTITION BY above, so no need to check that.) 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2619"><span class='Ref_To_Local'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN486"><span class='Ref_to_Member'>name</span></a> <span class='Operator'>|| 
</span>                <a href="parse_clause.c.html#LN2622"><span class='Ref_To_Local'>orderClause</span></a> <span class='Operator'>|| </span><a href="parse_clause.c.html#LN2619"><span class='Ref_To_Local'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN490"><span class='Ref_to_Member'>frameOptions</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/parsenodes.h.html#LN524"><span class='Ref_to_Const'>FRAMEOPTION_DEFAULTS</span></a><span class='Parentheses'>) 
</span>                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_WINDOWING_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"cannot copy window \"%s\" because it has a frame clause"</span><span class='Delimiter'>, 
</span>                                <a href="parse_clause.c.html#LN2619"><span class='Ref_To_Local'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN487"><span class='Ref_to_Member'>refname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2609"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2619"><span class='Ref_To_Local'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN493"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* Else this clause is just OVER (foo), so say this: */ 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_WINDOWING_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>            <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"cannot copy window \"%s\" because it has a frame clause"</span><span class='Delimiter'>, 
</span>                   <a href="parse_clause.c.html#LN2619"><span class='Ref_To_Local'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN487"><span class='Ref_to_Member'>refname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"Omit the parentheses in this OVER clause."</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2609"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2619"><span class='Ref_To_Local'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN493"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if refwc&&refwc-&GT;frameOp... &raquo; </span> 
        <a href="parse_clause.c.html#LN2623"><span class='Ref_To_Local'>wc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1259"><span class='Ref_to_Member'>frameOptions</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN2619"><span class='Ref_To_Local'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN490"><span class='Ref_to_Member'>frameOptions</span></a><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Process frame offset expressions */ 
</span>        <a href="parse_clause.c.html#LN2623"><span class='Ref_To_Local'>wc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1260"><span class='Ref_to_Member'>startOffset</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN99"><span class='Ref_to_Proto'>transformFrameOffset</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2609"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2623"><span class='Ref_To_Local'>wc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1259"><span class='Ref_to_Member'>frameOptions</span></a><span class='Delimiter'>, 
</span>                                               <a href="parse_clause.c.html#LN2619"><span class='Ref_To_Local'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN491"><span class='Ref_to_Member'>startOffset</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN2623"><span class='Ref_To_Local'>wc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1261"><span class='Ref_to_Member'>endOffset</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN99"><span class='Ref_to_Proto'>transformFrameOffset</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2609"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2623"><span class='Ref_To_Local'>wc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1259"><span class='Ref_to_Member'>frameOptions</span></a><span class='Delimiter'>, 
</span>                                             <a href="parse_clause.c.html#LN2619"><span class='Ref_To_Local'>windef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN492"><span class='Ref_to_Member'>endOffset</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN2623"><span class='Ref_To_Local'>wc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1262"><span class='Ref_to_Member'>winref</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN2614"><span class='Ref_To_Local'>winref</span></a><span class='Delimiter'>; 
</span> 
        <a href="parse_clause.c.html#LN2613"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2613"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2623"><span class='Ref_To_Local'>wc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="parse_clause.c.html#LN2613"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end transformWindowDefinitions &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * transformDistinctClause - 
 *    transform a DISTINCT clause 
 * 
 * Since we may need to add items to the query's targetlist, that list 
 * is passed by reference. 
 * 
 * As with GROUP BY, we absorb the sorting semantics of ORDER BY as much as 
 * possible into the distinctClause.  This avoids a possible need to re-sort, 
 * and allows the user to choose the equality semantics used by DISTINCT, 
 * should she be working with a datatype that has more than one equality 
 * operator. 
 * 
 * is_agg is true if we are transforming an aggregate(DISTINCT ...) 
 * function call.  This does not affect any behavior, only the phrasing 
 * of error messages. 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN2780"></a><span class='Declare_Function'>transformDistinctClause</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, 
</span><a name="LN2781"></a>                        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>targetlist</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sortClause</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>is_agg</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2783"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN2784"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>slitem</span><span class='Delimiter'>; 
</span><a name="LN2785"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>tlitem</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The distinctClause should consist of all ORDER BY items followed by all 
     * other non-resjunk targetlist items.  There must not be any resjunk 
     * ORDER BY items --- that would imply that we are sorting by a value that 
     * isn't necessarily unique within a DISTINCT group, so the results 
     * wouldn't be well-defined.  This construction ensures we follow the rule 
     * that sortClause and distinctClause match; in fact the sortClause will 
     * always be a prefix of distinctClause. 
     * 
     * Note a corner case: the same TLE could be in the ORDER BY list multiple 
     * times with different sortops.  We have to include it in the 
     * distinctClause the same way to preserve the prefix property. The net 
     * effect will be that the TLE value will be made unique according to both 
     * sortops. 
     */ 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2784"><span class='Ref_To_Local'>slitem</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2781"><span class='Ref_to_Parameter'>sortClause</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2804"></a>        <a href="../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>scl</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2784"><span class='Ref_To_Local'>slitem</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2805"></a>        <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span> <span class='Operator'>= </span><a href="../../include/optimizer/tlist.h.html#LN37"><span class='Ref_to_Proto'>get_sortgroupclause_tle</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2804"><span class='Ref_To_Local'>scl</span></a><span class='Delimiter'>, </span><span class='Operator'>*</span><a href="parse_clause.c.html#LN2781"><span class='Ref_to_Parameter'>targetlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2805"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1373"><span class='Ref_to_Member'>resjunk</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_COLUMN_REFERENCE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="parse_clause.c.html#LN2781"><span class='Ref_to_Parameter'>is_agg</span></a> <span class='Operator'>? 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list"</span><span class='Parentheses'>)</span> <span class='Operator'>: 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"for SELECT DISTINCT, ORDER BY expressions must appear in select list"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2780"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                        <a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN2805"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN2783"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2783"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2804"><span class='Ref_To_Local'>scl</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now add any remaining non-resjunk tlist items, using default sort/group 
     * semantics for their data types. 
     */ 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2785"><span class='Ref_To_Local'>tlitem</span></a><span class='Delimiter'>, </span><span class='Operator'>*</span><a href="parse_clause.c.html#LN2781"><span class='Ref_to_Parameter'>targetlist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2824"></a>        <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2785"><span class='Ref_To_Local'>tlitem</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2824"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1373"><span class='Ref_to_Member'>resjunk</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* ignore junk */ 
</span>        <a href="parse_clause.c.html#LN2783"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN96"><span class='Ref_to_Proto'>addTargetToGroupList</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2780"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2824"><span class='Ref_To_Local'>tle</span></a><span class='Delimiter'>, 
</span>                                      <a href="parse_clause.c.html#LN2783"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><span class='Operator'>*</span><a href="parse_clause.c.html#LN2781"><span class='Ref_to_Parameter'>targetlist</span></a><span class='Delimiter'>, 
</span>                                      <a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN2824"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Complain if we found nothing to make DISTINCT.  Returning an empty list 
     * would cause the parsed Query to look like it didn't have DISTINCT, with 
     * results that would probably surprise the user.  Note: this case is 
     * presently impossible for aggregates because of grammar restrictions, 
     * but we check anyway. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2783"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_SYNTAX_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="parse_clause.c.html#LN2781"><span class='Ref_to_Parameter'>is_agg</span></a> <span class='Operator'>? 
</span>        <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"an aggregate with DISTINCT must have at least one argument"</span><span class='Parentheses'>) </span><span class='Operator'>: 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"SELECT DISTINCT must have at least one column"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="parse_clause.c.html#LN2783"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end transformDistinctClause &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * transformDistinctOnClause - 
 *    transform a DISTINCT ON clause 
 * 
 * Since we may need to add items to the query's targetlist, that list 
 * is passed by reference. 
 * 
 * As with GROUP BY, we absorb the sorting semantics of ORDER BY as much as 
 * possible into the distinctClause.  This avoids a possible need to re-sort, 
 * and allows the user to choose the equality semantics used by DISTINCT, 
 * should she be working with a datatype that has more than one equality 
 * operator. 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN2864"></a><span class='Declare_Function'>transformDistinctOnClause</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>distinctlist</span><span class='Delimiter'>, 
</span><a name="LN2865"></a>                          <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>targetlist</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sortClause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2867"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN2868"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>sortgrouprefs</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN2869"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>skipped_sortitem</span><span class='Delimiter'>; 
</span><a name="LN2870"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span><a name="LN2871"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc2</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Add all the DISTINCT ON expressions to the tlist (if not already 
     * present, they are added as resjunk items).  Assign sortgroupref numbers 
     * to them, and make a list of these numbers.  (NB: we rely below on the 
     * sortgrouprefs list being one-for-one with the original distinctlist. 
     * Also notice that we could have duplicate DISTINCT ON expressions and 
     * hence duplicate entries in sortgrouprefs.) 
     */ 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2870"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2864"><span class='Ref_to_Parameter'>distinctlist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2883"></a>        <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>dexpr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2870"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2884"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>sortgroupref</span><span class='Delimiter'>; 
</span><a name="LN2885"></a>        <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span><span class='Delimiter'>; 
</span> 
        <a href="parse_clause.c.html#LN2885"><span class='Ref_To_Local'>tle</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN88"><span class='Ref_to_Proto'>findTargetlistEntrySQL92</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2864"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2883"><span class='Ref_To_Local'>dexpr</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2865"><span class='Ref_to_Parameter'>targetlist</span></a><span class='Delimiter'>, 
</span>                                       <a href="../../include/parser/parse_node.h.html#LN53"><span class='Ref_to_EnumConst'>EXPR_KIND_DISTINCT_ON</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN2884"><span class='Ref_To_Local'>sortgroupref</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_clause.h.html#LN50"><span class='Ref_to_Proto'>assignSortGroupRef</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2885"><span class='Ref_To_Local'>tle</span></a><span class='Delimiter'>, </span><span class='Operator'>*</span><a href="parse_clause.c.html#LN2865"><span class='Ref_to_Parameter'>targetlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN2868"><span class='Ref_To_Local'>sortgrouprefs</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN144"><span class='Ref_to_Func'>lappend_int</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2868"><span class='Ref_To_Local'>sortgrouprefs</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2884"><span class='Ref_To_Local'>sortgroupref</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the user writes both DISTINCT ON and ORDER BY, adopt the sorting 
     * semantics from ORDER BY items that match DISTINCT ON items, and also 
     * adopt their column sort order.  We insist that the distinctClause and 
     * sortClause match, so throw error if we find the need to add any more 
     * distinctClause items after we've skipped an ORDER BY item that wasn't 
     * in DISTINCT ON. 
     */ 
</span>    <a href="parse_clause.c.html#LN2869"><span class='Ref_To_Local'>skipped_sortitem</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2870"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2865"><span class='Ref_to_Parameter'>sortClause</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2904"></a>        <a href="../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>scl</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2870"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN230"><span class='Ref_to_Proto'>list_member_int</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2868"><span class='Ref_To_Local'>sortgrouprefs</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2904"><span class='Ref_To_Local'>scl</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1164"><span class='Ref_to_Member'>tleSortGroupRef</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2869"><span class='Ref_To_Local'>skipped_sortitem</span></a><span class='Parentheses'>) 
</span>                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_COLUMN_REFERENCE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"SELECT DISTINCT ON expressions must match initial ORDER BY expressions"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2864"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                  <a href="parse_clause.c.html#LN92"><span class='Ref_to_Proto'>get_matching_location</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2904"><span class='Ref_To_Local'>scl</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1164"><span class='Ref_to_Member'>tleSortGroupRef</span></a><span class='Delimiter'>, 
</span>                                                        <a href="parse_clause.c.html#LN2868"><span class='Ref_To_Local'>sortgrouprefs</span></a><span class='Delimiter'>, 
</span>                                                        <a href="parse_clause.c.html#LN2864"><span class='Ref_to_Parameter'>distinctlist</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="parse_clause.c.html#LN2867"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2867"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2904"><span class='Ref_To_Local'>scl</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <a href="parse_clause.c.html#LN2869"><span class='Ref_To_Local'>skipped_sortitem</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now add any remaining DISTINCT ON items, using default sort/group 
     * semantics for their data types.  (Note: this is pretty questionable; if 
     * the ORDER BY list doesn't include all the DISTINCT ON items and more 
     * besides, you certainly aren't using DISTINCT ON in the intended way, 
     * and you probably aren't going to get consistent results.  It might be 
     * better to throw an error or warning here.  But historically we've 
     * allowed it, so keep doing so.) 
     */ 
</span>    <a href="../../include/nodes/pg_list.h.html#LN179"><span class='Ref_to_Macro'>forboth</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2870"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2864"><span class='Ref_to_Parameter'>distinctlist</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2871"><span class='Ref_To_Local'>lc2</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2868"><span class='Ref_To_Local'>sortgrouprefs</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2934"></a>        <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>dexpr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2870"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2935"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>sortgroupref</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN106"><span class='Ref_to_Macro'>lfirst_int</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2871"><span class='Ref_To_Local'>lc2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2936"></a>        <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span> <span class='Operator'>= </span><a href="../../include/optimizer/tlist.h.html#LN35"><span class='Ref_to_Proto'>get_sortgroupref_tle</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2935"><span class='Ref_To_Local'>sortgroupref</span></a><span class='Delimiter'>, </span><span class='Operator'>*</span><a href="parse_clause.c.html#LN2865"><span class='Ref_to_Parameter'>targetlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/parser/parse_clause.h.html#LN51"><span class='Ref_to_Proto'>targetIsInSortList</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2936"><span class='Ref_To_Local'>tle</span></a><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2867"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* already in list (with some semantics) */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2869"><span class='Ref_To_Local'>skipped_sortitem</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_COLUMN_REFERENCE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"SELECT DISTINCT ON expressions must match initial ORDER BY expressions"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2864"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2934"><span class='Ref_To_Local'>dexpr</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN2867"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN96"><span class='Ref_to_Proto'>addTargetToGroupList</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2864"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2936"><span class='Ref_To_Local'>tle</span></a><span class='Delimiter'>, 
</span>                                      <a href="parse_clause.c.html#LN2867"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><span class='Operator'>*</span><a href="parse_clause.c.html#LN2865"><span class='Ref_to_Parameter'>targetlist</span></a><span class='Delimiter'>, 
</span>                                      <a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2934"><span class='Ref_To_Local'>dexpr</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * An empty result list is impossible here because of grammar 
     * restrictions. 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2867"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="parse_clause.c.html#LN2867"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end transformDistinctOnClause &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * get_matching_location 
 *      Get the exprLocation of the exprs member corresponding to the 
 *      (first) member of sortgrouprefs that equals sortgroupref. 
 * 
 * This is used so that we can point at a troublesome DISTINCT ON entry. 
 * (Note that we need to use the original untransformed DISTINCT ON list 
 * item, as whatever TLE it corresponds to will very possibly have a 
 * parse location pointing to some matching entry in the SELECT list 
 * or ORDER BY list.) 
 */ 
</span><span class='Keyword'>static int 
</span><a name="LN2971"></a><span class='Declare_Function'>get_matching_location</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>sortgroupref</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sortgrouprefs</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>exprs</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2973"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lcs</span><span class='Delimiter'>; 
</span><a name="LN2974"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lce</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN179"><span class='Ref_to_Macro'>forboth</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2973"><span class='Ref_To_Local'>lcs</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2971"><span class='Ref_to_Parameter'>sortgrouprefs</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2974"><span class='Ref_To_Local'>lce</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2971"><span class='Ref_to_Parameter'>exprs</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN106"><span class='Ref_to_Macro'>lfirst_int</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2973"><span class='Ref_To_Local'>lcs</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="parse_clause.c.html#LN2971"><span class='Ref_to_Parameter'>sortgroupref</span></a><span class='Parentheses'>)</span> 
            <span class='Control'>return</span> <a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2974"><span class='Ref_To_Local'>lce</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Comment_Multi_Line'>/* if no match, caller blew it */ 
</span>    <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"get_matching_location: no matching sortgroupref"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>;</span>                  <span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span><span class='Delimiter'>} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * resolve_unique_index_expr 
 *      Infer a unique index from a list of indexElems, for ON 
 *      CONFLICT clause 
 * 
 * Perform parse analysis of expressions and columns appearing within ON 
 * CONFLICT clause.  During planning, the returned list of expressions is used 
 * to infer which unique index to use. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN2996"></a><span class='Declare_Function'>resolve_unique_index_expr</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN1308"><span class='Ref_to_Struct'>InferClause</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>infer</span><span class='Delimiter'>, 
</span><a name="LN2997"></a>                          <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>heapRel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2999"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN3000"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3000"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN2996"><span class='Ref_to_Parameter'>infer</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1311"><span class='Ref_to_Member'>indexElems</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3004"></a>        <a href="../../include/nodes/parsenodes.h.html#LN685"><span class='Ref_to_Struct'>IndexElem</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>ielem</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN685"><span class='Ref_to_Struct'>IndexElem</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3000"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3005"></a>        <a href="../../include/nodes/primnodes.h.html#LN1287"><span class='Ref_to_Struct'>InferenceElem</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pInfer</span> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN1287"><span class='Ref_to_Struct'>InferenceElem</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3006"></a>        <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>parse</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Raw grammar re-uses CREATE INDEX infrastructure for unique index 
         * inference clause, and so will accept opclasses by name and so on. 
         * 
         * Make no attempt to match ASC or DESC ordering or NULLS FIRST/NULLS 
         * LAST ordering, since those are not significant for inference 
         * purposes (any unique index matching the inference specification in 
         * other regards is accepted indifferently).  Actively reject this as 
         * wrong-headed. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3004"><span class='Ref_To_Local'>ielem</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN693"><span class='Ref_to_Member'>ordering</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/parsenodes.h.html#LN49"><span class='Ref_to_EnumConst'>SORTBY_DEFAULT</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_COLUMN_REFERENCE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"ASC/DESC is not allowed in ON CONFLICT clause"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2996"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                        <a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN2996"><span class='Ref_to_Parameter'>infer</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3004"><span class='Ref_To_Local'>ielem</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN694"><span class='Ref_to_Member'>nulls_ordering</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/parsenodes.h.html#LN57"><span class='Ref_to_EnumConst'>SORTBY_NULLS_DEFAULT</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_COLUMN_REFERENCE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>             <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"NULLS FIRST/LAST is not allowed in ON CONFLICT clause"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2996"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                        <a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN2996"><span class='Ref_to_Parameter'>infer</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_clause.c.html#LN3004"><span class='Ref_To_Local'>ielem</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN689"><span class='Ref_to_Member'>expr</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Simple index attribute */ 
</span><a name="LN3034"></a>            <a href="../../include/nodes/parsenodes.h.html#LN231"><span class='Ref_to_Struct'>ColumnRef</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>n</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Grammar won't have built raw expression for us in event of 
             * plain column reference.  Create one directly, and perform 
             * expression transformation.  Planner expects this, and performs 
             * its own normalization for the purposes of matching against 
             * pg_index. 
             */ 
</span>            <a href="parse_clause.c.html#LN3034"><span class='Ref_To_Local'>n</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN231"><span class='Ref_to_Struct'>ColumnRef</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="parse_clause.c.html#LN3034"><span class='Ref_To_Local'>n</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN234"><span class='Ref_to_Member'>fields</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="../nodes/value.c.html#LN51"><span class='Ref_to_Func'>makeString</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3004"><span class='Ref_To_Local'>ielem</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN688"><span class='Ref_to_Member'>name</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* Location is approximately that of inference specification */ 
</span>            <a href="parse_clause.c.html#LN3034"><span class='Ref_To_Local'>n</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN235"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN2996"><span class='Ref_to_Parameter'>infer</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1314"><span class='Ref_to_Member'>location</span></a><span class='Delimiter'>; 
</span>            <a href="parse_clause.c.html#LN3006"><span class='Ref_To_Local'>parse</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN3034"><span class='Ref_To_Local'>n</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Do parse transformation of the raw expression */ 
</span>            <a href="parse_clause.c.html#LN3006"><span class='Ref_To_Local'>parse</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN3004"><span class='Ref_To_Local'>ielem</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN689"><span class='Ref_to_Member'>expr</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * transformExpr() should have already rejected subqueries, 
         * aggregates, and window functions, based on the EXPR_KIND_ for an 
         * index expression.  Expressions returning sets won't have been 
         * rejected, but don't bother doing so here; there should be no 
         * available expression unique index to match any such expression 
         * against anyway. 
         */ 
</span>        <a href="parse_clause.c.html#LN3005"><span class='Ref_To_Local'>pInfer</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1290"><span class='Ref_to_Member'>expr</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_expr.h.html#LN21"><span class='Ref_to_Proto'>transformExpr</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2996"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN3006"><span class='Ref_To_Local'>parse</span></a><span class='Delimiter'>, </span><a href="../../include/parser/parse_node.h.html#LN63"><span class='Ref_to_EnumConst'>EXPR_KIND_INDEX_EXPRESSION</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Perform lookup of collation and operator class as required */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_clause.c.html#LN3004"><span class='Ref_To_Local'>ielem</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN691"><span class='Ref_to_Member'>collation</span></a><span class='Parentheses'>) 
</span>            <a href="parse_clause.c.html#LN3005"><span class='Ref_To_Local'>pInfer</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1291"><span class='Ref_to_Member'>infercollid</span></a> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="parse_clause.c.html#LN3005"><span class='Ref_To_Local'>pInfer</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1291"><span class='Ref_to_Member'>infercollid</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_type.h.html#LN34"><span class='Ref_to_Proto'>LookupCollation</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2996"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN3004"><span class='Ref_To_Local'>ielem</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN691"><span class='Ref_to_Member'>collation</span></a><span class='Delimiter'>, 
</span>                                                  <a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3005"><span class='Ref_To_Local'>pInfer</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1290"><span class='Ref_to_Member'>expr</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_clause.c.html#LN3004"><span class='Ref_To_Local'>ielem</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN692"><span class='Ref_to_Member'>opclass</span></a><span class='Parentheses'>) 
</span>            <a href="parse_clause.c.html#LN3005"><span class='Ref_To_Local'>pInfer</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1292"><span class='Ref_to_Member'>inferopclass</span></a> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="parse_clause.c.html#LN3005"><span class='Ref_To_Local'>pInfer</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1292"><span class='Ref_to_Member'>inferopclass</span></a> <span class='Operator'>= </span><a href="../../include/commands/defrem.h.html#LN103"><span class='Ref_to_Proto'>get_opclass_oid</span></a><span class='Parentheses'>(</span><a href="../../include/catalog/pg_am.h.html#LN69"><span class='Ref_to_Const'>BTREE_AM_OID</span></a><span class='Delimiter'>, 
</span>                                                   <a href="parse_clause.c.html#LN3004"><span class='Ref_To_Local'>ielem</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN692"><span class='Ref_to_Member'>opclass</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="parse_clause.c.html#LN2999"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN2999"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN3005"><span class='Ref_To_Local'>pInfer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="parse_clause.c.html#LN2999"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end resolve_unique_index_expr &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * transformOnConflictArbiter - 
 *      transform arbiter expressions in an ON CONFLICT clause. 
 * 
 * Transformed expressions used to infer one unique index relation to serve as 
 * an ON CONFLICT arbiter.  Partial unique indexes may be inferred using WHERE 
 * clause from inference specification clause. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN3093"></a><span class='Declare_Function'>transformOnConflictArbiter</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, 
</span><a name="LN3094"></a>                           <a href="../../include/nodes/parsenodes.h.html#LN1323"><span class='Ref_to_Struct'>OnConflictClause</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>onConflictClause</span><span class='Delimiter'>, 
</span><a name="LN3095"></a>                           <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>arbiterExpr</span><span class='Delimiter'>, </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>arbiterWhere</span><span class='Delimiter'>, 
</span><a name="LN3096"></a>                           <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>constraint</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3098"></a>    <a href="../../include/nodes/parsenodes.h.html#LN1308"><span class='Ref_to_Struct'>InferClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>infer</span> <span class='Operator'>= </span><a href="parse_clause.c.html#LN3094"><span class='Ref_to_Parameter'>onConflictClause</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1327"><span class='Ref_to_Member'>infer</span></a><span class='Delimiter'>; 
</span> 
    <span class='Operator'>*</span><a href="parse_clause.c.html#LN3095"><span class='Ref_to_Parameter'>arbiterExpr</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="parse_clause.c.html#LN3095"><span class='Ref_to_Parameter'>arbiterWhere</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="parse_clause.c.html#LN3096"><span class='Ref_to_Parameter'>constraint</span></a> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3094"><span class='Ref_to_Parameter'>onConflictClause</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1326"><span class='Ref_to_Member'>action</span></a> <span class='Operator'>== </span><a href="../../include/nodes/nodes.h.html#LN801"><span class='Ref_to_EnumConst'>ONCONFLICT_UPDATE</span></a> <span class='Operator'>&& !</span><a href="parse_clause.c.html#LN3098"><span class='Ref_To_Local'>infer</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_SYNTAX_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"ON CONFLICT DO UPDATE requires inference specification or constraint name"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"For example, ON CONFLICT (column_name)."</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3093"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                  <a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN3094"><span class='Ref_to_Parameter'>onConflictClause</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * To simplify certain aspects of its design, speculative insertion into 
     * system catalogs is disallowed 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/catalog/catalog.h.html#LN31"><span class='Ref_to_Proto'>IsCatalogRelation</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3093"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN178"><span class='Ref_to_Member'>p_target_relation</span></a><span class='Parentheses'>))</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>           <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"ON CONFLICT is not supported with system catalog tables"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3093"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                  <a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN3094"><span class='Ref_to_Parameter'>onConflictClause</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Same applies to table used by logical decoding as catalog table */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/utils/rel.h.html#LN315"><span class='Ref_to_Macro'>RelationIsUsedAsCatalogTable</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3093"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN178"><span class='Ref_to_Member'>p_target_relation</span></a><span class='Parentheses'>))</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"ON CONFLICT is not supported on table \"%s\" used as a catalog table"</span><span class='Delimiter'>, 
</span>                        <a href="../../include/utils/rel.h.html#LN436"><span class='Ref_to_Macro'>RelationGetRelationName</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3093"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN178"><span class='Ref_to_Member'>p_target_relation</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                 <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3093"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                  <a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN3094"><span class='Ref_to_Parameter'>onConflictClause</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* ON CONFLICT DO NOTHING does not require an inference clause */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3098"><span class='Ref_To_Local'>infer</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3135"></a>        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>save_namespace</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * While we process the arbiter expressions, accept only non-qualified 
         * references to the target table. Hide any other relations. 
         */ 
</span>        <a href="parse_clause.c.html#LN3135"><span class='Ref_To_Local'>save_namespace</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN3093"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN172"><span class='Ref_to_Member'>p_namespace</span></a><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN3093"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN172"><span class='Ref_to_Member'>p_namespace</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>        <a href="../../include/parser/parse_relation.h.html#LN114"><span class='Ref_to_Proto'>addRTEtoQuery</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3093"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN3093"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN179"><span class='Ref_to_Member'>p_target_rangetblentry</span></a><span class='Delimiter'>, 
</span>                      <span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3098"><span class='Ref_To_Local'>infer</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1311"><span class='Ref_to_Member'>indexElems</span></a><span class='Parentheses'>) 
</span>            <span class='Operator'>*</span><a href="parse_clause.c.html#LN3095"><span class='Ref_to_Parameter'>arbiterExpr</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN94"><span class='Ref_to_Proto'>resolve_unique_index_expr</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3093"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN3098"><span class='Ref_To_Local'>infer</span></a><span class='Delimiter'>, 
</span>                                                  <a href="parse_clause.c.html#LN3093"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN178"><span class='Ref_to_Member'>p_target_relation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Handling inference WHERE clause (for partial unique index 
         * inference) 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3098"><span class='Ref_To_Local'>infer</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1312"><span class='Ref_to_Member'>whereClause</span></a><span class='Parentheses'>) 
</span>            <span class='Operator'>*</span><a href="parse_clause.c.html#LN3095"><span class='Ref_to_Parameter'>arbiterWhere</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_expr.h.html#LN21"><span class='Ref_to_Proto'>transformExpr</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3093"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN3098"><span class='Ref_To_Local'>infer</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1312"><span class='Ref_to_Member'>whereClause</span></a><span class='Delimiter'>, 
</span>                                          <a href="../../include/parser/parse_node.h.html#LN64"><span class='Ref_to_EnumConst'>EXPR_KIND_INDEX_PREDICATE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="parse_clause.c.html#LN3093"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN172"><span class='Ref_to_Member'>p_namespace</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN3135"><span class='Ref_To_Local'>save_namespace</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3098"><span class='Ref_To_Local'>infer</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1313"><span class='Ref_to_Member'>conname</span></a><span class='Parentheses'>) 
</span>            <span class='Operator'>*</span><a href="parse_clause.c.html#LN3096"><span class='Ref_to_Parameter'>constraint</span></a> <span class='Operator'>= </span><a href="../../include/catalog/pg_constraint_fn.h.html#LN70"><span class='Ref_to_Proto'>get_relation_constraint_oid</span></a><span class='Parentheses'>(</span><a href="../../include/utils/rel.h.html#LN416"><span class='Ref_to_Macro'>RelationGetRelid</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3093"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN178"><span class='Ref_to_Member'>p_target_relation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                      <a href="parse_clause.c.html#LN3098"><span class='Ref_To_Local'>infer</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1313"><span class='Ref_to_Member'>conname</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if infer &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * It's convenient to form a list of expressions based on the 
     * representation used by CREATE INDEX, since the same restrictions are 
     * appropriate (e.g. on subqueries).  However, from here on, a dedicated 
     * primnode representation is used for inference elements, and so 
     * assign_query_collations() can be trusted to do the right thing with the 
     * post parse analysis query tree inference clause representation. 
     */ 
</span><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end transformOnConflictArbiter &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * addTargetToSortList 
 *      If the given targetlist entry isn't already in the SortGroupClause 
 *      list, add it to the end of the list, using the given sort ordering 
 *      info. 
 * 
 * Returns the updated SortGroupClause list. 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN3184"></a><span class='Declare_Function'>addTargetToSortList</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tle</span><span class='Delimiter'>, 
</span><a name="LN3185"></a>                    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sortlist</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>targetlist</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN465"><span class='Ref_to_Struct'>SortBy</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sortby</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3187"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>restype</span> <span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN3184"><span class='Ref_to_Parameter'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3188"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>sortop</span><span class='Delimiter'>; 
</span><a name="LN3189"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>eqop</span><span class='Delimiter'>; 
</span><a name="LN3190"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>hashable</span><span class='Delimiter'>; 
</span><a name="LN3191"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>reverse</span><span class='Delimiter'>; 
</span><a name="LN3192"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>location</span><span class='Delimiter'>; 
</span><a name="LN3193"></a>    <a href="../../include/parser/parse_node.h.html#LN249"><span class='Ref_to_Struct'>ParseCallbackState</span></a> <span class='Declare_Local'>pcbstate</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* if tlist item is an UNKNOWN literal, change it to TEXT */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3187"><span class='Ref_To_Local'>restype</span></a> <span class='Operator'>== </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN43"><span class='Ref_to_Const'>UNKNOWNOID</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="parse_clause.c.html#LN3184"><span class='Ref_to_Parameter'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/parser/parse_coerce.h.html#LN45"><span class='Ref_to_Proto'>coerce_type</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3184"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN3184"><span class='Ref_to_Parameter'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Delimiter'>, 
</span>                                         <a href="parse_clause.c.html#LN3187"><span class='Ref_To_Local'>restype</span></a><span class='Delimiter'>, </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN26"><span class='Ref_to_Const'>TEXTOID</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                                         <a href="../../include/nodes/primnodes.h.html#LN420"><span class='Ref_to_EnumConst'>COERCION_IMPLICIT</span></a><span class='Delimiter'>, 
</span>                                         <a href="../../include/nodes/primnodes.h.html#LN438"><span class='Ref_to_EnumConst'>COERCE_IMPLICIT_CAST</span></a><span class='Delimiter'>, 
</span>                                         <span class='Operator'>-</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN3187"><span class='Ref_To_Local'>restype</span></a> <span class='Operator'>= </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN26"><span class='Ref_to_Const'>TEXTOID</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Rather than clutter the API of get_sort_group_operators and the other 
     * functions we're about to use, make use of error context callback to 
     * mark any error reports with a parse position.  We point to the operator 
     * location if present, else to the expression being sorted.  (NB: use the 
     * original untransformed expression here; the TLE entry might well point 
     * at a duplicate expression in the regular SELECT list.) 
     */ 
</span>    <a href="parse_clause.c.html#LN3192"><span class='Ref_To_Local'>location</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN3185"><span class='Ref_to_Parameter'>sortby</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN472"><span class='Ref_to_Member'>location</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3192"><span class='Ref_To_Local'>location</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="parse_clause.c.html#LN3192"><span class='Ref_To_Local'>location</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3185"><span class='Ref_to_Parameter'>sortby</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN468"><span class='Ref_to_Member'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="parse_node.c.html#LN143"><span class='Ref_to_Func'>setup_parser_errposition_callback</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="parse_clause.c.html#LN3193"><span class='Ref_To_Local'>pcbstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN3184"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN3192"><span class='Ref_To_Local'>location</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* determine the sortop, eqop, and directionality */ 
</span>    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3185"><span class='Ref_to_Parameter'>sortby</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN469"><span class='Ref_to_Member'>sortby_dir</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/parsenodes.h.html#LN49"><span class='Ref_to_EnumConst'>SORTBY_DEFAULT</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/parsenodes.h.html#LN50"><span class='Ref_to_EnumConst'>SORTBY_ASC</span></a><span class='Operator'>: 
</span>            <a href="../../include/parser/parse_oper.h.html#LN47"><span class='Ref_to_Proto'>get_sort_group_operators</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3187"><span class='Ref_To_Local'>restype</span></a><span class='Delimiter'>, 
</span>                                     <span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                                     <span class='Operator'>&</span><a href="parse_clause.c.html#LN3188"><span class='Ref_To_Local'>sortop</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_clause.c.html#LN3189"><span class='Ref_To_Local'>eqop</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                     <span class='Operator'>&</span><a href="parse_clause.c.html#LN3190"><span class='Ref_To_Local'>hashable</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="parse_clause.c.html#LN3191"><span class='Ref_To_Local'>reverse</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/parsenodes.h.html#LN51"><span class='Ref_to_EnumConst'>SORTBY_DESC</span></a><span class='Operator'>: 
</span>            <a href="../../include/parser/parse_oper.h.html#LN47"><span class='Ref_to_Proto'>get_sort_group_operators</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3187"><span class='Ref_To_Local'>restype</span></a><span class='Delimiter'>, 
</span>                                     <span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, 
</span>                                     <span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_clause.c.html#LN3189"><span class='Ref_To_Local'>eqop</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_clause.c.html#LN3188"><span class='Ref_To_Local'>sortop</span></a><span class='Delimiter'>, 
</span>                                     <span class='Operator'>&</span><a href="parse_clause.c.html#LN3190"><span class='Ref_To_Local'>hashable</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="parse_clause.c.html#LN3191"><span class='Ref_To_Local'>reverse</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/parsenodes.h.html#LN52"><span class='Ref_to_EnumConst'>SORTBY_USING</span></a><span class='Operator'>: 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3185"><span class='Ref_to_Parameter'>sortby</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN471"><span class='Ref_to_Member'>useOp</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="parse_clause.c.html#LN3188"><span class='Ref_To_Local'>sortop</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_oper.h.html#LN53"><span class='Ref_to_Proto'>compatible_oper_opid</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3185"><span class='Ref_to_Parameter'>sortby</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN471"><span class='Ref_to_Member'>useOp</span></a><span class='Delimiter'>, 
</span>                                          <a href="parse_clause.c.html#LN3187"><span class='Ref_To_Local'>restype</span></a><span class='Delimiter'>, 
</span>                                          <a href="parse_clause.c.html#LN3187"><span class='Ref_To_Local'>restype</span></a><span class='Delimiter'>, 
</span>                                          <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Verify it's a valid ordering operator, fetch the corresponding 
             * equality operator, and determine whether to consider it like 
             * ASC or DESC. 
             */ 
</span>            <a href="parse_clause.c.html#LN3189"><span class='Ref_To_Local'>eqop</span></a> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN74"><span class='Ref_to_Proto'>get_equality_op_for_ordering_op</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3188"><span class='Ref_To_Local'>sortop</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_clause.c.html#LN3191"><span class='Ref_To_Local'>reverse</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3189"><span class='Ref_To_Local'>eqop</span></a><span class='Parentheses'>))</span> 
                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_WRONG_OBJECT_TYPE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                       <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"operator %s is not a valid ordering operator"</span><span class='Delimiter'>, 
</span>                              <a href="../../include/nodes/value.h.html#LN53"><span class='Ref_to_Macro'>strVal</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN130"><span class='Ref_to_Macro'>llast</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3185"><span class='Ref_to_Parameter'>sortby</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN471"><span class='Ref_to_Member'>useOp</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>, 
</span>                         <a href="../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"Ordering operators must be \"&LT;\" or \"&GT;\" members of btree operator families."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Also see if the equality operator is hashable. 
             */ 
</span>            <a href="parse_clause.c.html#LN3190"><span class='Ref_To_Local'>hashable</span></a> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN103"><span class='Ref_to_Proto'>op_hashjoinable</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3189"><span class='Ref_To_Local'>eqop</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN3187"><span class='Ref_To_Local'>restype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>default</span><span class='Operator'>: 
</span>            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized sortby_dir: %d"</span><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN3185"><span class='Ref_to_Parameter'>sortby</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN469"><span class='Ref_to_Member'>sortby_dir</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="parse_clause.c.html#LN3188"><span class='Ref_To_Local'>sortop</span></a> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span>            <a href="parse_clause.c.html#LN3189"><span class='Ref_To_Local'>eqop</span></a> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>            <a href="parse_clause.c.html#LN3190"><span class='Ref_To_Local'>hashable</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="parse_clause.c.html#LN3191"><span class='Ref_To_Local'>reverse</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch sortby-&GT;sortby_dir &raquo; </span> 
 
    <a href="parse_node.c.html#LN159"><span class='Ref_to_Func'>cancel_parser_errposition_callback</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="parse_clause.c.html#LN3193"><span class='Ref_To_Local'>pcbstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* avoid making duplicate sortlist entries */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/parser/parse_clause.h.html#LN51"><span class='Ref_to_Proto'>targetIsInSortList</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3184"><span class='Ref_to_Parameter'>tle</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN3188"><span class='Ref_To_Local'>sortop</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN3185"><span class='Ref_to_Parameter'>sortlist</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN3276"></a>        <a href="../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sortcl</span> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="parse_clause.c.html#LN3276"><span class='Ref_To_Local'>sortcl</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1164"><span class='Ref_to_Member'>tleSortGroupRef</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_clause.h.html#LN50"><span class='Ref_to_Proto'>assignSortGroupRef</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3184"><span class='Ref_to_Parameter'>tle</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN3185"><span class='Ref_to_Parameter'>targetlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="parse_clause.c.html#LN3276"><span class='Ref_To_Local'>sortcl</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1165"><span class='Ref_to_Member'>eqop</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN3189"><span class='Ref_To_Local'>eqop</span></a><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN3276"><span class='Ref_To_Local'>sortcl</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1166"><span class='Ref_to_Member'>sortop</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN3188"><span class='Ref_To_Local'>sortop</span></a><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN3276"><span class='Ref_To_Local'>sortcl</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1168"><span class='Ref_to_Member'>hashable</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN3190"><span class='Ref_To_Local'>hashable</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3185"><span class='Ref_to_Parameter'>sortby</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN470"><span class='Ref_to_Member'>sortby_nulls</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>case</span> <a href="../../include/nodes/parsenodes.h.html#LN57"><span class='Ref_to_EnumConst'>SORTBY_NULLS_DEFAULT</span></a><span class='Operator'>: 
</span>                <span class='Comment_Multi_Line'>/* NULLS FIRST is default for DESC; other way for ASC */ 
</span>                <a href="parse_clause.c.html#LN3276"><span class='Ref_To_Local'>sortcl</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1167"><span class='Ref_to_Member'>nulls_first</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN3191"><span class='Ref_To_Local'>reverse</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../include/nodes/parsenodes.h.html#LN58"><span class='Ref_to_EnumConst'>SORTBY_NULLS_FIRST</span></a><span class='Operator'>: 
</span>                <a href="parse_clause.c.html#LN3276"><span class='Ref_To_Local'>sortcl</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1167"><span class='Ref_to_Member'>nulls_first</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../include/nodes/parsenodes.h.html#LN59"><span class='Ref_to_EnumConst'>SORTBY_NULLS_LAST</span></a><span class='Operator'>: 
</span>                <a href="parse_clause.c.html#LN3276"><span class='Ref_To_Local'>sortcl</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1167"><span class='Ref_to_Member'>nulls_first</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>default</span><span class='Operator'>: 
</span>                <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized sortby_nulls: %d"</span><span class='Delimiter'>, 
</span>                     <a href="parse_clause.c.html#LN3185"><span class='Ref_to_Parameter'>sortby</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN470"><span class='Ref_to_Member'>sortby_nulls</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="parse_clause.c.html#LN3185"><span class='Ref_to_Parameter'>sortlist</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3185"><span class='Ref_to_Parameter'>sortlist</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN3276"><span class='Ref_To_Local'>sortcl</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !targetIsInSortList(t... &raquo; </span> 
 
    <span class='Control'>return</span> <a href="parse_clause.c.html#LN3185"><span class='Ref_to_Parameter'>sortlist</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end addTargetToSortList &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * addTargetToGroupList 
 *      If the given targetlist entry isn't already in the SortGroupClause 
 *      list, add it to the end of the list, using default sort/group 
 *      semantics. 
 * 
 * This is very similar to addTargetToSortList, except that we allow the 
 * case where only a grouping (equality) operator can be found, and that 
 * the TLE is considered "already in the list" if it appears there with any 
 * sorting semantics. 
 * 
 * location is the parse location to be fingered in event of trouble.  Note 
 * that we can't rely on exprLocation(tle-&GT;expr), because that might point 
 * to a SELECT item that matches the GROUP BY item; it'd be pretty confusing 
 * to report such a location. 
 * 
 * Returns the updated SortGroupClause list. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN3327"></a><span class='Declare_Function'>addTargetToGroupList</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tle</span><span class='Delimiter'>, 
</span><a name="LN3328"></a>                     <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>grouplist</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>targetlist</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>location</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3330"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>restype</span> <span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN3327"><span class='Ref_to_Parameter'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* if tlist item is an UNKNOWN literal, change it to TEXT */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3330"><span class='Ref_To_Local'>restype</span></a> <span class='Operator'>== </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN43"><span class='Ref_to_Const'>UNKNOWNOID</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="parse_clause.c.html#LN3327"><span class='Ref_to_Parameter'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/parser/parse_coerce.h.html#LN45"><span class='Ref_to_Proto'>coerce_type</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3327"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_clause.c.html#LN3327"><span class='Ref_to_Parameter'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Delimiter'>, 
</span>                                         <a href="parse_clause.c.html#LN3330"><span class='Ref_To_Local'>restype</span></a><span class='Delimiter'>, </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN26"><span class='Ref_to_Const'>TEXTOID</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                                         <a href="../../include/nodes/primnodes.h.html#LN420"><span class='Ref_to_EnumConst'>COERCION_IMPLICIT</span></a><span class='Delimiter'>, 
</span>                                         <a href="../../include/nodes/primnodes.h.html#LN438"><span class='Ref_to_EnumConst'>COERCE_IMPLICIT_CAST</span></a><span class='Delimiter'>, 
</span>                                         <span class='Operator'>-</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN3330"><span class='Ref_To_Local'>restype</span></a> <span class='Operator'>= </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN26"><span class='Ref_to_Const'>TEXTOID</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* avoid making duplicate grouplist entries */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/parser/parse_clause.h.html#LN51"><span class='Ref_to_Proto'>targetIsInSortList</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3327"><span class='Ref_to_Parameter'>tle</span></a><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN3328"><span class='Ref_to_Parameter'>grouplist</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN3346"></a>        <a href="../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>grpcl</span> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3347"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>sortop</span><span class='Delimiter'>; 
</span><a name="LN3348"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>eqop</span><span class='Delimiter'>; 
</span><a name="LN3349"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>hashable</span><span class='Delimiter'>; 
</span><a name="LN3350"></a>        <a href="../../include/parser/parse_node.h.html#LN249"><span class='Ref_to_Struct'>ParseCallbackState</span></a> <span class='Declare_Local'>pcbstate</span><span class='Delimiter'>; 
</span> 
        <a href="parse_node.c.html#LN143"><span class='Ref_to_Func'>setup_parser_errposition_callback</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="parse_clause.c.html#LN3350"><span class='Ref_To_Local'>pcbstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN3327"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN3328"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* determine the eqop and optional sortop */ 
</span>        <a href="../../include/parser/parse_oper.h.html#LN47"><span class='Ref_to_Proto'>get_sort_group_operators</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3330"><span class='Ref_To_Local'>restype</span></a><span class='Delimiter'>, 
</span>                                 <span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                                 <span class='Operator'>&</span><a href="parse_clause.c.html#LN3347"><span class='Ref_To_Local'>sortop</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_clause.c.html#LN3348"><span class='Ref_To_Local'>eqop</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                 <span class='Operator'>&</span><a href="parse_clause.c.html#LN3349"><span class='Ref_To_Local'>hashable</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="parse_node.c.html#LN159"><span class='Ref_to_Func'>cancel_parser_errposition_callback</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="parse_clause.c.html#LN3350"><span class='Ref_To_Local'>pcbstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="parse_clause.c.html#LN3346"><span class='Ref_To_Local'>grpcl</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1164"><span class='Ref_to_Member'>tleSortGroupRef</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_clause.h.html#LN50"><span class='Ref_to_Proto'>assignSortGroupRef</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3327"><span class='Ref_to_Parameter'>tle</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN3328"><span class='Ref_to_Parameter'>targetlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN3346"><span class='Ref_To_Local'>grpcl</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1165"><span class='Ref_to_Member'>eqop</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN3348"><span class='Ref_To_Local'>eqop</span></a><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN3346"><span class='Ref_To_Local'>grpcl</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1166"><span class='Ref_to_Member'>sortop</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN3347"><span class='Ref_To_Local'>sortop</span></a><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN3346"><span class='Ref_To_Local'>grpcl</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1167"><span class='Ref_to_Member'>nulls_first</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* OK with or without sortop */ 
</span>        <a href="parse_clause.c.html#LN3346"><span class='Ref_To_Local'>grpcl</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1168"><span class='Ref_to_Member'>hashable</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN3349"><span class='Ref_To_Local'>hashable</span></a><span class='Delimiter'>; 
</span> 
        <a href="parse_clause.c.html#LN3328"><span class='Ref_to_Parameter'>grouplist</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3328"><span class='Ref_to_Parameter'>grouplist</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN3346"><span class='Ref_To_Local'>grpcl</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !targetIsInSortList(t... &raquo; </span> 
 
    <span class='Control'>return</span> <a href="parse_clause.c.html#LN3328"><span class='Ref_to_Parameter'>grouplist</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end addTargetToGroupList &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * assignSortGroupRef 
 *    Assign the targetentry an unused ressortgroupref, if it doesn't 
 *    already have one.  Return the assigned or pre-existing refnumber. 
 * 
 * 'tlist' is the targetlist containing (or to contain) the given targetentry. 
 */ 
</span><a href="../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> 
<a name="LN3382"></a><span class='Declare_Function'>assignSortGroupRef</span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tle</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tlist</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3384"></a>    <a href="../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Local'>maxRef</span><span class='Delimiter'>; 
</span><a name="LN3385"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3382"><span class='Ref_to_Parameter'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1369"><span class='Ref_to_Member'>ressortgroupref</span></a><span class='Parentheses'>)</span>   <span class='Comment_Single_Line'>/* already has one? */ 
</span>        <span class='Control'>return</span> <a href="parse_clause.c.html#LN3382"><span class='Ref_to_Parameter'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1369"><span class='Ref_to_Member'>ressortgroupref</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* easiest way to pick an unused refnumber: max used + 1 */ 
</span>    <a href="parse_clause.c.html#LN3384"><span class='Ref_To_Local'>maxRef</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3385"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN3382"><span class='Ref_to_Parameter'>tlist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3394"></a>        <a href="../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Local'>ref</span> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3385"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>ressortgroupref<span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Keyword'>ref </span><span class='Operator'>&GT; </span><a href="parse_clause.c.html#LN3384"><span class='Ref_To_Local'>maxRef</span></a><span class='Parentheses'>) 
</span>            <a href="parse_clause.c.html#LN3384"><span class='Ref_To_Local'>maxRef</span></a> <span class='Operator'>= </span><span class='Keyword'>ref</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="parse_clause.c.html#LN3382"><span class='Ref_to_Parameter'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1369"><span class='Ref_to_Member'>ressortgroupref</span></a> <span class='Operator'>= </span><a href="parse_clause.c.html#LN3384"><span class='Ref_To_Local'>maxRef</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="parse_clause.c.html#LN3382"><span class='Ref_to_Parameter'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1369"><span class='Ref_to_Member'>ressortgroupref</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end assignSortGroupRef &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * targetIsInSortList 
 *      Is the given target item already in the sortlist? 
 *      If sortop is not InvalidOid, also test for a match to the sortop. 
 * 
 * It is not an oversight that this function ignores the nulls_first flag. 
 * We check sortop when determining if an ORDER BY item is redundant with 
 * earlier ORDER BY items, because it's conceivable that "ORDER BY 
 * foo USING &LT;, foo USING &LT;&LT;&LT;" is not redundant, if &LT;&LT;&LT; distinguishes 
 * values that &LT; considers equal.  We need not check nulls_first 
 * however, because a lower-order column with the same sortop but 
 * opposite nulls direction is redundant.  Also, we can consider 
 * ORDER BY foo ASC, foo DESC redundant, so check for a commutator match. 
 * 
 * Works for both ordering and grouping lists (sortop would normally be 
 * InvalidOid when considering grouping).  Note that the main reason we need 
 * this routine (and not just a quick test for nonzeroness of ressortgroupref) 
 * is that a TLE might be in only one of the lists. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN3423"></a><span class='Declare_Function'>targetIsInSortList</span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tle</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>sortop</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sortList</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3425"></a>    <a href="../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Local'>ref</span> <span class='Operator'>= </span><a href="parse_clause.c.html#LN3423"><span class='Ref_to_Parameter'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1369"><span class='Ref_to_Member'>ressortgroupref</span></a><span class='Delimiter'>; 
</span><a name="LN3426"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* no need to scan list if tle has no marker */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Keyword'>ref </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3426"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN3423"><span class='Ref_to_Parameter'>sortList</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3434"></a>        <a href="../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>scl</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3426"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3434"><span class='Ref_To_Local'>scl</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1164"><span class='Ref_to_Member'>tleSortGroupRef</span></a> <span class='Operator'>== </span><span class='Keyword'>ref </span><span class='Operator'>&& 
</span>            <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3423"><span class='Ref_to_Parameter'>sortop</span></a> <span class='Operator'>== </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a> <span class='Operator'>|| 
</span>             <a href="parse_clause.c.html#LN3423"><span class='Ref_to_Parameter'>sortop</span></a> <span class='Operator'>== </span><a href="parse_clause.c.html#LN3434"><span class='Ref_To_Local'>scl</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1166"><span class='Ref_to_Member'>sortop</span></a> <span class='Operator'>|| 
</span>             <a href="parse_clause.c.html#LN3423"><span class='Ref_to_Parameter'>sortop</span></a> <span class='Operator'>== </span><a href="../../include/utils/lsyscache.h.html#LN106"><span class='Ref_to_Proto'>get_commutator</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3434"><span class='Ref_To_Local'>scl</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1166"><span class='Ref_to_Member'>sortop</span></a><span class='Parentheses'>)))</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end targetIsInSortList &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * findWindowClause 
 *      Find the named WindowClause in the list, or return NULL if not there 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/parsenodes.h.html#LN1252"><span class='Ref_to_Struct'>WindowClause</span></a> <span class='Operator'>* 
</span><a name="LN3450"></a><span class='Declare_Function'>findWindowClause</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>wclist</span><span class='Delimiter'>, </span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>name</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3452"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3452"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN3450"><span class='Ref_to_Parameter'>wclist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3456"></a>        <a href="../../include/nodes/parsenodes.h.html#LN1252"><span class='Ref_to_Struct'>WindowClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>wc</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1252"><span class='Ref_to_Struct'>WindowClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3452"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3456"><span class='Ref_To_Local'>wc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1255"><span class='Ref_to_Member'>name</span></a> <span class='Operator'>&& </span>strcmp<span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3456"><span class='Ref_To_Local'>wc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1255"><span class='Ref_to_Member'>name</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN3450"><span class='Ref_to_Parameter'>name</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <span class='Control'>return</span> <a href="parse_clause.c.html#LN3456"><span class='Ref_To_Local'>wc</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * transformFrameOffset 
 *      Process a window frame offset expression 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN3470"></a><span class='Declare_Function'>transformFrameOffset</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>frameOptions</span><span class='Delimiter'>, </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3472"></a>    <span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Local'>constructName</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN3473"></a>    <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>node</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Quick exit if no offset expression */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3470"><span class='Ref_to_Parameter'>clause</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3470"><span class='Ref_to_Parameter'>frameOptions</span></a> <span class='Operator'>& </span><a href="../../include/nodes/parsenodes.h.html#LN506"><span class='Ref_to_Const'>FRAMEOPTION_ROWS</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Transform the raw expression tree */ 
</span>        <a href="parse_clause.c.html#LN3473"><span class='Ref_To_Local'>node</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_expr.h.html#LN21"><span class='Ref_to_Proto'>transformExpr</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3470"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN3470"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><a href="../../include/parser/parse_node.h.html#LN46"><span class='Ref_to_EnumConst'>EXPR_KIND_WINDOW_FRAME_ROWS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Like LIMIT clause, simply coerce to int8 
         */ 
</span>        <a href="parse_clause.c.html#LN3472"><span class='Ref_To_Local'>constructName</span></a> <span class='Operator'>= </span><span class='String'>"ROWS"</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN3473"><span class='Ref_To_Local'>node</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN56"><span class='Ref_to_Proto'>coerce_to_specific_type</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3470"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN3473"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>, </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN21"><span class='Ref_to_Const'>INT8OID</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN3472"><span class='Ref_To_Local'>constructName</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3470"><span class='Ref_to_Parameter'>frameOptions</span></a> <span class='Operator'>& </span><a href="../../include/nodes/parsenodes.h.html#LN505"><span class='Ref_to_Const'>FRAMEOPTION_RANGE</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Transform the raw expression tree */ 
</span>        <a href="parse_clause.c.html#LN3473"><span class='Ref_To_Local'>node</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_expr.h.html#LN21"><span class='Ref_to_Proto'>transformExpr</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3470"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN3470"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, </span><a href="../../include/parser/parse_node.h.html#LN45"><span class='Ref_to_EnumConst'>EXPR_KIND_WINDOW_FRAME_RANGE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * this needs a lot of thought to decide how to support in the context 
         * of Postgres' extensible datatype framework 
         */ 
</span>        <a href="parse_clause.c.html#LN3472"><span class='Ref_To_Local'>constructName</span></a> <span class='Operator'>= </span><span class='String'>"RANGE"</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* error was already thrown by gram.y, this is just a backstop */ 
</span>        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"window frame with value offset is not implemented"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_clause.c.html#LN3473"><span class='Ref_To_Local'>node</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Disallow variables in frame offsets */ 
</span>    <a href="parse_clause.c.html#LN86"><span class='Ref_to_Proto'>checkExprIsVarFree</span></a><span class='Parentheses'>(</span><a href="parse_clause.c.html#LN3470"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN3473"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>, </span><a href="parse_clause.c.html#LN3472"><span class='Ref_To_Local'>constructName</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="parse_clause.c.html#LN3473"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end transformFrameOffset &raquo; </span> 
</pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>