<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\parser\parse_coerce.c</title>
<LINK REL=StyleSheet HREF="../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\parser\parse_coerce.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:44 2017
</td></tr>
<tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * parse_coerce.c 
 *      handle type coercions/conversions for parser 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * 
 * IDENTIFICATION 
 *    src/backend/parser/parse_coerce.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/htup_details.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_cast.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_class.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_inherits_fn.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_proc.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_type.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/makefuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/nodeFuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_coerce.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_relation.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_type.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/builtins.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/datum.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/lsyscache.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/syscache.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/typcache.h"</span> 
 
 
<a name="LN34"></a><span class='Keyword'>static </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>coerce_type_typmod</span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, 
</span><a name="LN35"></a>                   <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>targetTypeId</span><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a> <span class='Declare_Parameter'>targetTypMod</span><span class='Delimiter'>, 
</span><a name="LN36"></a>                   <a href="../../include/nodes/primnodes.h.html#LN434"><span class='Ref_to_Enum'>CoercionForm</span></a> <span class='Declare_Parameter'>cformat</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>location</span><span class='Delimiter'>, 
</span><a name="LN37"></a>                   <span class='Keyword'>bool </span><span class='Declare_Parameter'>isExplicit</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>hideInputCoercion</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN38"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>hide_coercion_node</span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN39"></a><span class='Keyword'>static </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>build_coercion_expression</span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, 
</span><a name="LN40"></a>                          <a href="../../include/parser/parse_coerce.h.html#LN23"><span class='Ref_to_Enum'>CoercionPathType</span></a> <span class='Declare_Parameter'>pathtype</span><span class='Delimiter'>, 
</span><a name="LN41"></a>                          <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>funcId</span><span class='Delimiter'>, 
</span><a name="LN42"></a>                          <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>targetTypeId</span><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a> <span class='Declare_Parameter'>targetTypMod</span><span class='Delimiter'>, 
</span><a name="LN43"></a>                          <a href="../../include/nodes/primnodes.h.html#LN434"><span class='Ref_to_Enum'>CoercionForm</span></a> <span class='Declare_Parameter'>cformat</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>location</span><span class='Delimiter'>, 
</span><a name="LN44"></a>                          <span class='Keyword'>bool </span><span class='Declare_Parameter'>isExplicit</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN45"></a><span class='Keyword'>static </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>coerce_record_to_complex</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, 
</span><a name="LN46"></a>                         <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>targetTypeId</span><span class='Delimiter'>, 
</span><a name="LN47"></a>                         <a href="../../include/nodes/primnodes.h.html#LN418"><span class='Ref_to_Enum'>CoercionContext</span></a> <span class='Declare_Parameter'>ccontext</span><span class='Delimiter'>, 
</span><a name="LN48"></a>                         <a href="../../include/nodes/primnodes.h.html#LN434"><span class='Ref_to_Enum'>CoercionForm</span></a> <span class='Declare_Parameter'>cformat</span><span class='Delimiter'>, 
</span><a name="LN49"></a>                         <span class='Keyword'>int </span><span class='Declare_Parameter'>location</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN50"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>is_complex_array</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>typid</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN51"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>typeIsOfTypedTable</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>reltypeId</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>reloftypeId</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * coerce_to_target_type() 
 *      Convert an expression to a target type and typmod. 
 * 
 * This is the general-purpose entry point for arbitrary type coercion 
 * operations.  Direct use of the component operations can_coerce_type, 
 * coerce_type, and coerce_type_typmod should be restricted to special 
 * cases (eg, when the conversion is expected to succeed). 
 * 
 * Returns the possibly-transformed expression tree, or NULL if the type 
 * conversion is not possible.  (We do this, rather than ereport'ing directly, 
 * so that callers can generate custom error messages indicating context.) 
 * 
 * pstate - parse state (can be NULL, see coerce_type) 
 * expr - input expression tree (already transformed by transformExpr) 
 * exprtype - result type of expr 
 * targettype - desired result type 
 * targettypmod - desired result typmod 
 * ccontext, cformat - context indicators to control coercions 
 * location - parse location of the coercion request, or -1 if unknown/implicit 
 */ 
</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN76"></a><span class='Declare_Function'>coerce_to_target_type</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>expr</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>exprtype</span><span class='Delimiter'>, 
</span><a name="LN77"></a>                      <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>targettype</span><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a> <span class='Declare_Parameter'>targettypmod</span><span class='Delimiter'>, 
</span><a name="LN78"></a>                      <a href="../../include/nodes/primnodes.h.html#LN418"><span class='Ref_to_Enum'>CoercionContext</span></a> <span class='Declare_Parameter'>ccontext</span><span class='Delimiter'>, 
</span><a name="LN79"></a>                      <a href="../../include/nodes/primnodes.h.html#LN434"><span class='Ref_to_Enum'>CoercionForm</span></a> <span class='Declare_Parameter'>cformat</span><span class='Delimiter'>, 
</span><a name="LN80"></a>                      <span class='Keyword'>int </span><span class='Declare_Parameter'>location</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN82"></a>    <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span><a name="LN83"></a>    <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>origexpr</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/parser/parse_coerce.h.html#LN43"><span class='Ref_to_Proto'>can_coerce_type</span></a><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_coerce.c.html#LN76"><span class='Ref_to_Parameter'>exprtype</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_coerce.c.html#LN77"><span class='Ref_to_Parameter'>targettype</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN78"><span class='Ref_to_Parameter'>ccontext</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the input has a CollateExpr at the top, strip it off, perform the 
     * coercion, and put a new one back on.  This is annoying since it 
     * duplicates logic in coerce_type, but if we don't do this then it's too 
     * hard to tell whether coerce_type actually changed anything, and we 
     * *must* know that to avoid possibly calling hide_coercion_node on 
     * something that wasn't generated by coerce_type.  Note that if there are 
     * multiple stacked CollateExprs, we just discard all but the topmost. 
     */ 
</span>    <a href="parse_coerce.c.html#LN83"><span class='Ref_To_Local'>origexpr</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN76"><span class='Ref_to_Parameter'>expr</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN76"><span class='Ref_to_Parameter'>expr</span></a> <span class='Operator'>&& </span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN76"><span class='Ref_to_Parameter'>expr</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN871"><span class='Ref_to_Struct'>CollateExpr</span></a><span class='Parentheses'>))</span> 
        <a href="parse_coerce.c.html#LN76"><span class='Ref_to_Parameter'>expr</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) ((</span><a href="../../include/nodes/primnodes.h.html#LN871"><span class='Ref_to_Struct'>CollateExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN76"><span class='Ref_to_Parameter'>expr</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>arg<span class='Delimiter'>; 
</span> 
    <a href="parse_coerce.c.html#LN82"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN45"><span class='Ref_to_Proto'>coerce_type</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN76"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN76"><span class='Ref_to_Parameter'>expr</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN76"><span class='Ref_to_Parameter'>exprtype</span></a><span class='Delimiter'>, 
</span>                         <a href="parse_coerce.c.html#LN77"><span class='Ref_to_Parameter'>targettype</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN77"><span class='Ref_to_Parameter'>targettypmod</span></a><span class='Delimiter'>, 
</span>                         <a href="parse_coerce.c.html#LN78"><span class='Ref_to_Parameter'>ccontext</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN79"><span class='Ref_to_Parameter'>cformat</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN80"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the target is a fixed-length type, it may need a length coercion as 
     * well as a type coercion.  If we find ourselves adding both, force the 
     * inner coercion node to implicit display form. 
     */ 
</span>    <a href="parse_coerce.c.html#LN82"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN34"><span class='Ref_to_Proto'>coerce_type_typmod</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN82"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, 
</span>                                <a href="parse_coerce.c.html#LN77"><span class='Ref_to_Parameter'>targettype</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN77"><span class='Ref_to_Parameter'>targettypmod</span></a><span class='Delimiter'>, 
</span>                                <a href="parse_coerce.c.html#LN79"><span class='Ref_to_Parameter'>cformat</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN80"><span class='Ref_to_Parameter'>location</span></a><span class='Delimiter'>, 
</span>                                <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN79"><span class='Ref_to_Parameter'>cformat</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/primnodes.h.html#LN438"><span class='Ref_to_EnumConst'>COERCE_IMPLICIT_CAST</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN82"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>!= </span><a href="parse_coerce.c.html#LN76"><span class='Ref_to_Parameter'>expr</span></a> <span class='Operator'>&& !</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN82"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN76"><span class='Ref_to_Parameter'>expr</span></a> <span class='Operator'>!= </span><a href="parse_coerce.c.html#LN83"><span class='Ref_To_Local'>origexpr</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Reinstall top CollateExpr */ 
</span><a name="LN119"></a>        <a href="../../include/nodes/primnodes.h.html#LN871"><span class='Ref_to_Struct'>CollateExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>coll</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN871"><span class='Ref_to_Struct'>CollateExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN83"><span class='Ref_To_Local'>origexpr</span></a><span class='Delimiter'>; 
</span><a name="LN120"></a>        <a href="../../include/nodes/primnodes.h.html#LN871"><span class='Ref_to_Struct'>CollateExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>newcoll</span> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN871"><span class='Ref_to_Struct'>CollateExpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="parse_coerce.c.html#LN120"><span class='Ref_To_Local'>newcoll</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN874"><span class='Ref_to_Member'>arg</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN82"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span>        <a href="parse_coerce.c.html#LN120"><span class='Ref_To_Local'>newcoll</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN875"><span class='Ref_to_Member'>collOid</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN119"><span class='Ref_To_Local'>coll</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN875"><span class='Ref_to_Member'>collOid</span></a><span class='Delimiter'>; 
</span>        <a href="parse_coerce.c.html#LN120"><span class='Ref_To_Local'>newcoll</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN876"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN119"><span class='Ref_To_Local'>coll</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN876"><span class='Ref_to_Member'>location</span></a><span class='Delimiter'>; 
</span>        <a href="parse_coerce.c.html#LN82"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN120"><span class='Ref_To_Local'>newcoll</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="parse_coerce.c.html#LN82"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end coerce_to_target_type &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * coerce_type() 
 *      Convert an expression to a different type. 
 * 
 * The caller should already have determined that the coercion is possible; 
 * see can_coerce_type. 
 * 
 * Normally, no coercion to a typmod (length) is performed here.  The caller 
 * must call coerce_type_typmod as well, if a typmod constraint is wanted. 
 * (But if the target type is a domain, it may internally contain a 
 * typmod constraint, which will be applied inside coerce_to_domain.) 
 * In some cases pg_cast specifies a type coercion function that also 
 * applies length conversion, and in those cases only, the result will 
 * already be properly coerced to the specified typmod. 
 * 
 * pstate is only used in the case that we are able to resolve the type of 
 * a previously UNKNOWN Param.  It is okay to pass pstate = NULL if the 
 * caller does not want type information updated for Params. 
 * 
 * Note: this function must not modify the given expression tree, only add 
 * decoration on top of it.  See transformSetOperationTree, for example. 
 */ 
</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN155"></a><span class='Declare_Function'>coerce_type</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, 
</span><a name="LN156"></a>            <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>inputTypeId</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>targetTypeId</span><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a> <span class='Declare_Parameter'>targetTypeMod</span><span class='Delimiter'>, 
</span><a name="LN157"></a>            <a href="../../include/nodes/primnodes.h.html#LN418"><span class='Ref_to_Enum'>CoercionContext</span></a> <span class='Declare_Parameter'>ccontext</span><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN434"><span class='Ref_to_Enum'>CoercionForm</span></a> <span class='Declare_Parameter'>cformat</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>location</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN159"></a>    <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span><a name="LN160"></a>    <a href="../../include/parser/parse_coerce.h.html#LN23"><span class='Ref_to_Enum'>CoercionPathType</span></a> <span class='Declare_Local'>pathtype</span><span class='Delimiter'>; 
</span><a name="LN161"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>funcId</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>targetTypeId</span></a> <span class='Operator'>== </span><a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>inputTypeId</span></a> <span class='Operator'>|| 
</span>        <a href="parse_coerce.c.html#LN155"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* no conversion needed */ 
</span>        <span class='Control'>return</span> <a href="parse_coerce.c.html#LN155"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>targetTypeId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN685"><span class='Ref_to_Const'>ANYOID</span></a> <span class='Operator'>|| 
</span>        <a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>targetTypeId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN701"><span class='Ref_to_Const'>ANYELEMENTOID</span></a> <span class='Operator'>|| 
</span>        <a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>targetTypeId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN703"><span class='Ref_to_Const'>ANYNONARRAYOID</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Assume can_coerce_type verified that implicit coercion is okay. 
         * 
         * Note: by returning the unmodified node here, we are saying that 
         * it's OK to treat an UNKNOWN constant as a valid input for a 
         * function accepting ANY, ANYELEMENT, or ANYNONARRAY.  This should be 
         * all right, since an UNKNOWN value is still a perfectly valid Datum. 
         * 
         * NB: we do NOT want a RelabelType here: the exposed type of the 
         * function argument must be its actual type, not the polymorphic 
         * pseudotype. 
         */ 
</span>        <span class='Control'>return</span> <a href="parse_coerce.c.html#LN155"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>targetTypeId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN687"><span class='Ref_to_Const'>ANYARRAYOID</span></a> <span class='Operator'>|| 
</span>        <a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>targetTypeId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN705"><span class='Ref_to_Const'>ANYENUMOID</span></a> <span class='Operator'>|| 
</span>        <a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>targetTypeId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN713"><span class='Ref_to_Const'>ANYRANGEOID</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Assume can_coerce_type verified that implicit coercion is okay. 
         * 
         * These cases are unlike the ones above because the exposed type of 
         * the argument must be an actual array, enum, or range type.  In 
         * particular the argument must *not* be an UNKNOWN constant.  If it 
         * is, we just fall through; below, we'll call anyarray_in, 
         * anyenum_in, or anyrange_in, which will produce an error.  Also, if 
         * what we have is a domain over array, enum, or range, we have to 
         * relabel it to its base type. 
         * 
         * Note: currently, we can't actually see a domain-over-enum here, 
         * since the other functions in this file will not match such a 
         * parameter to ANYENUM.  But that should get changed eventually. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>inputTypeId</span></a> <span class='Operator'>!= </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN43"><span class='Ref_to_Const'>UNKNOWNOID</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN208"></a>            <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>baseTypeId</span> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN168"><span class='Ref_to_Proto'>getBaseType</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>inputTypeId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN208"><span class='Ref_To_Local'>baseTypeId</span></a> <span class='Operator'>!= </span><a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>inputTypeId</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN212"></a>                <a href="../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a> <span class='Operator'>*</span><span class='Declare_Local'>r</span> <span class='Operator'>= </span><a href="../../include/nodes/makefuncs.h.html#LN65"><span class='Ref_to_Proto'>makeRelabelType</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN155"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, 
</span>                                                 <a href="parse_coerce.c.html#LN208"><span class='Ref_To_Local'>baseTypeId</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                                                 <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                                                 <a href="parse_coerce.c.html#LN157"><span class='Ref_to_Parameter'>cformat</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="parse_coerce.c.html#LN212"><span class='Ref_To_Local'>r</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN794"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN157"><span class='Ref_to_Parameter'>location</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN212"><span class='Ref_To_Local'>r</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Comment_Multi_Line'>/* Not a domain type, so return it as-is */ 
</span>            <span class='Control'>return</span> <a href="parse_coerce.c.html#LN155"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if targetTypeId==ANYARRA... &raquo; </span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>inputTypeId</span></a> <span class='Operator'>== </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN43"><span class='Ref_to_Const'>UNKNOWNOID</span></a> <span class='Operator'>&& </span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN155"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Input is a string constant with previously undetermined type. Apply 
         * the target type's typinput function to it to produce a constant of 
         * the target type. 
         * 
         * NOTE: this case cannot be folded together with the other 
         * constant-input case, since the typinput function does not 
         * necessarily behave the same as a type conversion function. For 
         * example, int4's typinput function will reject "1.2", whereas 
         * float-to-int type conversion will round to integer. 
         * 
         * XXX if the typinput function is not immutable, we really ought to 
         * postpone evaluation of the function call until runtime. But there 
         * is no way to represent a typinput function call as an expression 
         * tree, because C-string values are not Datums. (XXX This *is* 
         * possible as of 7.3, do we want to do it?) 
         */ 
</span><a name="LN243"></a>        <a href="../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>con</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN155"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span><a name="LN244"></a>        <a href="../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>newcon</span> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN245"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>baseTypeId</span><span class='Delimiter'>; 
</span><a name="LN246"></a>        <a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>baseTypeMod</span><span class='Delimiter'>; 
</span><a name="LN247"></a>        <a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>inputTypeMod</span><span class='Delimiter'>; 
</span><a name="LN248"></a>        <a href="../../include/parser/parse_type.h.html#LN19"><span class='Ref_to_Typedef'>Type</span></a>        <span class='Declare_Local'>baseType</span><span class='Delimiter'>; 
</span><a name="LN249"></a>        <a href="../../include/parser/parse_node.h.html#LN249"><span class='Ref_to_Struct'>ParseCallbackState</span></a> <span class='Declare_Local'>pcbstate</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If the target type is a domain, we want to call its base type's 
         * input routine, not domain_in().  This is to avoid premature failure 
         * when the domain applies a typmod: existing input routines follow 
         * implicit-coercion semantics for length checks, which is not always 
         * what we want here.  The needed check will be applied properly 
         * inside coerce_to_domain(). 
         */ 
</span>        <a href="parse_coerce.c.html#LN246"><span class='Ref_To_Local'>baseTypeMod</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>targetTypeMod</span></a><span class='Delimiter'>; 
</span>        <a href="parse_coerce.c.html#LN245"><span class='Ref_To_Local'>baseTypeId</span></a> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN169"><span class='Ref_to_Proto'>getBaseTypeAndTypmod</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_coerce.c.html#LN246"><span class='Ref_To_Local'>baseTypeMod</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * For most types we pass typmod -1 to the input routine, because 
         * existing input routines follow implicit-coercion semantics for 
         * length checks, which is not always what we want here.  Any length 
         * constraint will be applied later by our caller.  An exception 
         * however is the INTERVAL type, for which we *must* pass the typmod 
         * or it won't be able to obey the bizarre SQL-spec input rules. (Ugly 
         * as sin, but so is this part of the spec...) 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN245"><span class='Ref_To_Local'>baseTypeId</span></a> <span class='Operator'>== </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN54"><span class='Ref_to_Const'>INTERVALOID</span></a><span class='Parentheses'>) 
</span>            <a href="parse_coerce.c.html#LN247"><span class='Ref_To_Local'>inputTypeMod</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN246"><span class='Ref_To_Local'>baseTypeMod</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="parse_coerce.c.html#LN247"><span class='Ref_To_Local'>inputTypeMod</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
        <a href="parse_coerce.c.html#LN248"><span class='Ref_To_Local'>baseType</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_type.h.html#LN37"><span class='Ref_to_Proto'>typeidType</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN245"><span class='Ref_To_Local'>baseTypeId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="parse_coerce.c.html#LN244"><span class='Ref_To_Local'>newcon</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN191"><span class='Ref_to_Member'>consttype</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN245"><span class='Ref_To_Local'>baseTypeId</span></a><span class='Delimiter'>; 
</span>        <a href="parse_coerce.c.html#LN244"><span class='Ref_To_Local'>newcon</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN192"><span class='Ref_to_Member'>consttypmod</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN247"><span class='Ref_To_Local'>inputTypeMod</span></a><span class='Delimiter'>; 
</span>        <a href="parse_coerce.c.html#LN244"><span class='Ref_To_Local'>newcon</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN193"><span class='Ref_to_Member'>constcollid</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_type.h.html#LN44"><span class='Ref_to_Proto'>typeTypeCollation</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN248"><span class='Ref_To_Local'>baseType</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_coerce.c.html#LN244"><span class='Ref_To_Local'>newcon</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN194"><span class='Ref_to_Member'>constlen</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_type.h.html#LN40"><span class='Ref_to_Proto'>typeLen</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN248"><span class='Ref_To_Local'>baseType</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_coerce.c.html#LN244"><span class='Ref_To_Local'>newcon</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN198"><span class='Ref_to_Member'>constbyval</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_type.h.html#LN41"><span class='Ref_to_Proto'>typeByVal</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN248"><span class='Ref_To_Local'>baseType</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_coerce.c.html#LN244"><span class='Ref_To_Local'>newcon</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN196"><span class='Ref_to_Member'>constisnull</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN243"><span class='Ref_To_Local'>con</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN196"><span class='Ref_to_Member'>constisnull</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We use the original literal's location regardless of the position 
         * of the coercion.  This is a change from pre-9.2 behavior, meant to 
         * simplify life for pg_stat_statements. 
         */ 
</span>        <a href="parse_coerce.c.html#LN244"><span class='Ref_To_Local'>newcon</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN202"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN243"><span class='Ref_To_Local'>con</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN202"><span class='Ref_to_Member'>location</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Set up to point at the constant's text if the input routine throws 
         * an error. 
         */ 
</span>        <a href="parse_node.c.html#LN143"><span class='Ref_to_Func'>setup_parser_errposition_callback</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="parse_coerce.c.html#LN249"><span class='Ref_To_Local'>pcbstate</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN155"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN243"><span class='Ref_To_Local'>con</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN202"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We assume here that UNKNOWN's internal representation is the same 
         * as CSTRING. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_coerce.c.html#LN243"><span class='Ref_To_Local'>con</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN196"><span class='Ref_to_Member'>constisnull</span></a><span class='Parentheses'>) 
</span>            <a href="parse_coerce.c.html#LN244"><span class='Ref_To_Local'>newcon</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_type.h.html#LN45"><span class='Ref_to_Proto'>stringTypeDatum</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN248"><span class='Ref_To_Local'>baseType</span></a><span class='Delimiter'>, 
</span>                                            <a href="../../include/postgres.h.html#LN571"><span class='Ref_to_Macro'>DatumGetCString</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN243"><span class='Ref_To_Local'>con</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                 <a href="parse_coerce.c.html#LN247"><span class='Ref_To_Local'>inputTypeMod</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="parse_coerce.c.html#LN244"><span class='Ref_To_Local'>newcon</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_type.h.html#LN45"><span class='Ref_to_Proto'>stringTypeDatum</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN248"><span class='Ref_To_Local'>baseType</span></a><span class='Delimiter'>, 
</span>                                                 <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                                 <a href="parse_coerce.c.html#LN247"><span class='Ref_To_Local'>inputTypeMod</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If it's a varlena value, force it to be in non-expanded 
         * (non-toasted) format; this avoids any possible dependency on 
         * external values and improves consistency of representation. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_coerce.c.html#LN243"><span class='Ref_To_Local'>con</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN196"><span class='Ref_to_Member'>constisnull</span></a> <span class='Operator'>&& </span><a href="parse_coerce.c.html#LN244"><span class='Ref_To_Local'>newcon</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN194"><span class='Ref_to_Member'>constlen</span></a> <span class='Operator'>== -</span><span class='Number'>1</span><span class='Parentheses'>) 
</span>            <a href="parse_coerce.c.html#LN244"><span class='Ref_To_Local'>newcon</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a> <span class='Operator'>= 
</span>                <a href="../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="../../include/fmgr.h.html#LN204"><span class='Ref_to_Macro'>PG_DETOAST_DATUM</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN244"><span class='Ref_To_Local'>newcon</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> RANDOMIZE_ALLOCATED_MEMORY 
 
        <span class='Comment_Multi_Line'>/* 
         * For pass-by-reference data types, repeat the conversion to see if 
         * the input function leaves any uninitialized bytes in the result. We 
         * can only detect that reliably if RANDOMIZE_ALLOCATED_MEMORY is 
         * enabled, so we don't bother testing otherwise.  The reason we don't 
         * want any instability in the input function is that comparison of 
         * Const nodes relies on bytewise comparison of the datums, so if the 
         * input function leaves garbage then subexpressions that should be 
         * identical may not get recognized as such.  See pgsql-hackers 
         * discussion of 2008-04-04. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_coerce.c.html#LN243"><span class='Ref_To_Local'>con</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN196"><span class='Ref_to_Member'>constisnull</span></a> <span class='Operator'>&& !</span><a href="parse_coerce.c.html#LN244"><span class='Ref_To_Local'>newcon</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN198"><span class='Ref_to_Member'>constbyval</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN335"></a>            <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>val2</span><span class='Delimiter'>; 
</span> 
            <a href="parse_coerce.c.html#LN335"><span class='Ref_To_Local'>val2</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_type.h.html#LN45"><span class='Ref_to_Proto'>stringTypeDatum</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN248"><span class='Ref_To_Local'>baseType</span></a><span class='Delimiter'>, 
</span>                                   <a href="../../include/postgres.h.html#LN571"><span class='Ref_to_Macro'>DatumGetCString</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN243"><span class='Ref_To_Local'>con</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                   <a href="parse_coerce.c.html#LN247"><span class='Ref_To_Local'>inputTypeMod</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN244"><span class='Ref_To_Local'>newcon</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN194"><span class='Ref_to_Member'>constlen</span></a> <span class='Operator'>== -</span><span class='Number'>1</span><span class='Parentheses'>) 
</span>                <a href="parse_coerce.c.html#LN335"><span class='Ref_To_Local'>val2</span></a> <span class='Operator'>= </span><a href="../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="../../include/fmgr.h.html#LN204"><span class='Ref_to_Macro'>PG_DETOAST_DATUM</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN335"><span class='Ref_To_Local'>val2</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/utils/datum.h.html#LN45"><span class='Ref_to_Proto'>datumIsEqual</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN244"><span class='Ref_To_Local'>newcon</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN335"><span class='Ref_To_Local'>val2</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN244"><span class='Ref_To_Local'>newcon</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN194"><span class='Ref_to_Member'>constlen</span></a><span class='Parentheses'>))</span> 
                <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN39"><span class='Ref_to_Const'>WARNING</span></a><span class='Delimiter'>, </span><span class='String'>"type %s has unstable input conversion for \"%s\""</span><span class='Delimiter'>, 
</span>                   <a href="../../include/parser/parse_type.h.html#LN42"><span class='Ref_to_Proto'>typeTypeName</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN248"><span class='Ref_To_Local'>baseType</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="../../include/postgres.h.html#LN571"><span class='Ref_to_Macro'>DatumGetCString</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN243"><span class='Ref_To_Local'>con</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span><span class='Directive'>#endif</span> 
 
        <a href="parse_node.c.html#LN159"><span class='Ref_to_Func'>cancel_parser_errposition_callback</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="parse_coerce.c.html#LN249"><span class='Ref_To_Local'>pcbstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="parse_coerce.c.html#LN159"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN244"><span class='Ref_To_Local'>newcon</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* If target is a domain, apply constraints. */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN245"><span class='Ref_To_Local'>baseTypeId</span></a> <span class='Operator'>!= </span><a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Parentheses'>) 
</span>            <a href="parse_coerce.c.html#LN159"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN48"><span class='Ref_to_Proto'>coerce_to_domain</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN159"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, 
</span>                                      <a href="parse_coerce.c.html#LN245"><span class='Ref_To_Local'>baseTypeId</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN246"><span class='Ref_To_Local'>baseTypeMod</span></a><span class='Delimiter'>, 
</span>                                      <a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Delimiter'>, 
</span>                                      <a href="parse_coerce.c.html#LN157"><span class='Ref_to_Parameter'>cformat</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN157"><span class='Ref_to_Parameter'>location</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN248"><span class='Ref_To_Local'>baseType</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>return</span> <a href="parse_coerce.c.html#LN159"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if inputTypeId==UNKNOWNO... &raquo; </span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN155"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN240"><span class='Ref_to_Struct'>Param</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>        <a href="parse_coerce.c.html#LN155"><span class='Ref_to_Parameter'>pstate</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL </span><span class='Operator'>&& </span><a href="parse_coerce.c.html#LN155"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN208"><span class='Ref_to_Member'>p_coerce_param_hook</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Allow the CoerceParamHook to decide what happens.  It can return a 
         * transformed node (very possibly the same Param node), or return 
         * NULL to indicate we should proceed with normal coercion. 
         */ 
</span>        <a href="parse_coerce.c.html#LN159"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="parse_coerce.c.html#LN155"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN208"><span class='Ref_to_Member'>p_coerce_param_hook</span></a><span class='Parentheses'>) (</span><a href="parse_coerce.c.html#LN155"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                                 <span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN240"><span class='Ref_to_Struct'>Param</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN155"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, 
</span>                                                 <a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Delimiter'>, 
</span>                                                 <a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>targetTypeMod</span></a><span class='Delimiter'>, 
</span>                                                 <a href="parse_coerce.c.html#LN157"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN159"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <a href="parse_coerce.c.html#LN159"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN155"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN871"><span class='Ref_to_Struct'>CollateExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * If we have a COLLATE clause, we have to push the coercion 
         * underneath the COLLATE.  This is really ugly, but there is little 
         * choice because the above hacks on Consts and Params wouldn't happen 
         * otherwise.  This kluge has consequences in coerce_to_target_type. 
         */ 
</span><a name="LN387"></a>        <a href="../../include/nodes/primnodes.h.html#LN871"><span class='Ref_to_Struct'>CollateExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>coll</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN871"><span class='Ref_to_Struct'>CollateExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN155"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span><a name="LN388"></a>        <a href="../../include/nodes/primnodes.h.html#LN871"><span class='Ref_to_Struct'>CollateExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>newcoll</span> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN871"><span class='Ref_to_Struct'>CollateExpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="parse_coerce.c.html#LN388"><span class='Ref_To_Local'>newcoll</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN874"><span class='Ref_to_Member'>arg</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../include/parser/parse_coerce.h.html#LN45"><span class='Ref_to_Proto'>coerce_type</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN155"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN387"><span class='Ref_To_Local'>coll</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN874"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>, 
</span>                        <a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>inputTypeId</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>targetTypeMod</span></a><span class='Delimiter'>, 
</span>                        <a href="parse_coerce.c.html#LN157"><span class='Ref_to_Parameter'>ccontext</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN157"><span class='Ref_to_Parameter'>cformat</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN157"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_coerce.c.html#LN388"><span class='Ref_To_Local'>newcoll</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN875"><span class='Ref_to_Member'>collOid</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN387"><span class='Ref_To_Local'>coll</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN875"><span class='Ref_to_Member'>collOid</span></a><span class='Delimiter'>; 
</span>        <a href="parse_coerce.c.html#LN388"><span class='Ref_To_Local'>newcoll</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN876"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN387"><span class='Ref_To_Local'>coll</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN876"><span class='Ref_to_Member'>location</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN388"><span class='Ref_To_Local'>newcoll</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="parse_coerce.c.html#LN160"><span class='Ref_To_Local'>pathtype</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN86"><span class='Ref_to_Proto'>find_coercion_pathway</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>inputTypeId</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN157"><span class='Ref_to_Parameter'>ccontext</span></a><span class='Delimiter'>, 
</span>                                     <span class='Operator'>&</span><a href="parse_coerce.c.html#LN161"><span class='Ref_To_Local'>funcId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN160"><span class='Ref_To_Local'>pathtype</span></a> <span class='Operator'>!= </span><a href="../../include/parser/parse_coerce.h.html#LN25"><span class='Ref_to_EnumConst'>COERCION_PATH_NONE</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN160"><span class='Ref_To_Local'>pathtype</span></a> <span class='Operator'>!= </span><a href="../../include/parser/parse_coerce.h.html#LN27"><span class='Ref_to_EnumConst'>COERCION_PATH_RELABELTYPE</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Generate an expression tree representing run-time application 
             * of the conversion function.  If we are dealing with a domain 
             * target type, the conversion function will yield the base type, 
             * and we need to extract the correct typmod to use from the 
             * domain's typtypmod. 
             */ 
</span><a name="LN411"></a>            <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>baseTypeId</span><span class='Delimiter'>; 
</span><a name="LN412"></a>            <a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>baseTypeMod</span><span class='Delimiter'>; 
</span> 
            <a href="parse_coerce.c.html#LN412"><span class='Ref_To_Local'>baseTypeMod</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>targetTypeMod</span></a><span class='Delimiter'>; 
</span>            <a href="parse_coerce.c.html#LN411"><span class='Ref_To_Local'>baseTypeId</span></a> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN169"><span class='Ref_to_Proto'>getBaseTypeAndTypmod</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_coerce.c.html#LN412"><span class='Ref_To_Local'>baseTypeMod</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="parse_coerce.c.html#LN159"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN39"><span class='Ref_to_Proto'>build_coercion_expression</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN155"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN160"><span class='Ref_To_Local'>pathtype</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN161"><span class='Ref_To_Local'>funcId</span></a><span class='Delimiter'>, 
</span>                                               <a href="parse_coerce.c.html#LN411"><span class='Ref_To_Local'>baseTypeId</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN412"><span class='Ref_To_Local'>baseTypeMod</span></a><span class='Delimiter'>, 
</span>                                               <a href="parse_coerce.c.html#LN157"><span class='Ref_to_Parameter'>cformat</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN157"><span class='Ref_to_Parameter'>location</span></a><span class='Delimiter'>, 
</span>                                          <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN157"><span class='Ref_to_Parameter'>cformat</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/primnodes.h.html#LN438"><span class='Ref_to_EnumConst'>COERCE_IMPLICIT_CAST</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * If domain, coerce to the domain type and relabel with domain 
             * type ID.  We can skip the internal length-coercion step if the 
             * selected coercion function was a type-and-length coercion. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>targetTypeId</span></a> <span class='Operator'>!= </span><a href="parse_coerce.c.html#LN411"><span class='Ref_To_Local'>baseTypeId</span></a><span class='Parentheses'>) 
</span>                <a href="parse_coerce.c.html#LN159"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN48"><span class='Ref_to_Proto'>coerce_to_domain</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN159"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN411"><span class='Ref_To_Local'>baseTypeId</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN412"><span class='Ref_To_Local'>baseTypeMod</span></a><span class='Delimiter'>, 
</span>                                          <a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Delimiter'>, 
</span>                                          <a href="parse_coerce.c.html#LN157"><span class='Ref_to_Parameter'>cformat</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN157"><span class='Ref_to_Parameter'>location</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, 
</span>                                          <a href="../../include/nodes/nodeFuncs.h.html#LN33"><span class='Ref_to_Proto'>exprIsLengthCoercion</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN159"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, 
</span>                                                               <span class='Null_Value'>NULL</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if pathtype!=COERCION_PA... &raquo; </span> 
        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * We don't need to do a physical conversion, but we do need to 
             * attach a RelabelType node so that the expression will be seen 
             * to have the intended type when inspected by higher-level code. 
             * 
             * Also, domains may have value restrictions beyond the base type 
             * that must be accounted for.  If the destination is a domain 
             * then we won't need a RelabelType node. 
             */ 
</span>            <a href="parse_coerce.c.html#LN159"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN48"><span class='Ref_to_Proto'>coerce_to_domain</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN155"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Delimiter'>, 
</span>                                      <a href="parse_coerce.c.html#LN157"><span class='Ref_to_Parameter'>cformat</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN157"><span class='Ref_to_Parameter'>location</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN159"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>== </span><a href="parse_coerce.c.html#LN155"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * XXX could we label result with exprTypmod(node) instead of 
                 * default -1 typmod, to save a possible length-coercion 
                 * later? Would work if both types have same interpretation of 
                 * typmod, which is likely but not certain. 
                 */ 
</span><a name="LN455"></a>                <a href="../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a> <span class='Operator'>*</span><span class='Declare_Local'>r</span> <span class='Operator'>= </span><a href="../../include/nodes/makefuncs.h.html#LN65"><span class='Ref_to_Proto'>makeRelabelType</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN159"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, 
</span>                                                 <a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                                                 <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                                                 <a href="parse_coerce.c.html#LN157"><span class='Ref_to_Parameter'>cformat</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="parse_coerce.c.html#LN455"><span class='Ref_To_Local'>r</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN794"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN157"><span class='Ref_to_Parameter'>location</span></a><span class='Delimiter'>; 
</span>                <a href="parse_coerce.c.html#LN159"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN455"><span class='Ref_To_Local'>r</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
        <span class='Control'>return</span> <a href="parse_coerce.c.html#LN159"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if pathtype!=COERCION_PA... &raquo; </span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>inputTypeId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN679"><span class='Ref_to_Const'>RECORDOID</span></a> <span class='Operator'>&& 
</span>        <a href="../../include/parser/parse_type.h.html#LN52"><span class='Ref_to_Macro'>ISCOMPLEX</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Coerce a RECORD to a specific complex type */ 
</span>        <span class='Control'>return</span> <a href="parse_coerce.c.html#LN45"><span class='Ref_to_Proto'>coerce_record_to_complex</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN155"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN155"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Delimiter'>, 
</span>                                        <a href="parse_coerce.c.html#LN157"><span class='Ref_to_Parameter'>ccontext</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN157"><span class='Ref_to_Parameter'>cformat</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN157"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>targetTypeId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN679"><span class='Ref_to_Const'>RECORDOID</span></a> <span class='Operator'>&& 
</span>        <a href="../../include/parser/parse_type.h.html#LN52"><span class='Ref_to_Macro'>ISCOMPLEX</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>inputTypeId</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Coerce a specific complex type to RECORD */ 
</span>        <span class='Comment_Multi_Line'>/* NB: we do NOT want a RelabelType here */ 
</span>        <span class='Control'>return</span> <a href="parse_coerce.c.html#LN155"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span><span class='Directive'>#ifdef</span> NOT_USED 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>inputTypeId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN681"><span class='Ref_to_Const'>RECORDARRAYOID</span></a> <span class='Operator'>&& 
</span>        <a href="parse_coerce.c.html#LN50"><span class='Ref_to_Proto'>is_complex_array</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Coerce record[] to a specific complex array type */ 
</span>        <span class='Comment_Multi_Line'>/* not implemented yet ... */ 
</span>    <span class='Delimiter'>} 
</span><span class='Directive'>#endif</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>targetTypeId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN681"><span class='Ref_to_Const'>RECORDARRAYOID</span></a> <span class='Operator'>&& 
</span>        <a href="parse_coerce.c.html#LN50"><span class='Ref_to_Proto'>is_complex_array</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>inputTypeId</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Coerce a specific complex array type to record[] */ 
</span>        <span class='Comment_Multi_Line'>/* NB: we do NOT want a RelabelType here */ 
</span>        <span class='Control'>return</span> <a href="parse_coerce.c.html#LN155"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/catalog/pg_inherits_fn.h.html#LN23"><span class='Ref_to_Proto'>typeInheritsFrom</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>inputTypeId</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>|| </span><a href="parse_coerce.c.html#LN51"><span class='Ref_to_Proto'>typeIsOfTypedTable</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>inputTypeId</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Input class type is a subclass of target, so generate an 
         * appropriate runtime conversion (removing unneeded columns and 
         * possibly rearranging the ones that are wanted). 
         */ 
</span><a name="LN503"></a>        <a href="../../include/nodes/primnodes.h.html#LN854"><span class='Ref_to_Struct'>ConvertRowtypeExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>r</span> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN854"><span class='Ref_to_Struct'>ConvertRowtypeExpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="parse_coerce.c.html#LN503"><span class='Ref_To_Local'>r</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN857"><span class='Ref_to_Member'>arg</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN155"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span>        <a href="parse_coerce.c.html#LN503"><span class='Ref_To_Local'>r</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN858"><span class='Ref_to_Member'>resulttype</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Delimiter'>; 
</span>        <a href="parse_coerce.c.html#LN503"><span class='Ref_To_Local'>r</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN860"><span class='Ref_to_Member'>convertformat</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN157"><span class='Ref_to_Parameter'>cformat</span></a><span class='Delimiter'>; 
</span>        <a href="parse_coerce.c.html#LN503"><span class='Ref_To_Local'>r</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN861"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN157"><span class='Ref_to_Parameter'>location</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN503"><span class='Ref_To_Local'>r</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Comment_Multi_Line'>/* If we get here, caller blew it */ 
</span>    <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"failed to find conversion function from %s to %s"</span><span class='Delimiter'>, 
</span>         <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>inputTypeId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN156"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>;</span>                <span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end coerce_type &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * can_coerce_type() 
 *      Can input_typeids be coerced to target_typeids? 
 * 
 * We must be told the context (CAST construct, assignment, implicit coercion) 
 * as this determines the set of available casts. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN526"></a><span class='Declare_Function'>can_coerce_type</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>nargs</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>input_typeids</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>target_typeids</span><span class='Delimiter'>, 
</span><a name="LN527"></a>                <a href="../../include/nodes/primnodes.h.html#LN418"><span class='Ref_to_Enum'>CoercionContext</span></a> <span class='Declare_Parameter'>ccontext</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN529"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>have_generics</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN530"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* run through argument list... */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN530"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="parse_coerce.c.html#LN530"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="parse_coerce.c.html#LN526"><span class='Ref_to_Parameter'>nargs</span></a><span class='Delimiter'>; </span><a href="parse_coerce.c.html#LN530"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN535"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>inputTypeId</span> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN526"><span class='Ref_to_Parameter'>input_typeids</span></a><span class='Delimiter'>[</span><a href="parse_coerce.c.html#LN530"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span><a name="LN536"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>targetTypeId</span> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN526"><span class='Ref_to_Parameter'>target_typeids</span></a><span class='Delimiter'>[</span><a href="parse_coerce.c.html#LN530"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span><a name="LN537"></a>        <a href="../../include/parser/parse_coerce.h.html#LN23"><span class='Ref_to_Enum'>CoercionPathType</span></a> <span class='Declare_Local'>pathtype</span><span class='Delimiter'>; 
</span><a name="LN538"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>funcId</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* no problem if same type */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN535"><span class='Ref_To_Local'>inputTypeId</span></a> <span class='Operator'>== </span><a href="parse_coerce.c.html#LN536"><span class='Ref_To_Local'>targetTypeId</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* accept if target is ANY */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN536"><span class='Ref_To_Local'>targetTypeId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN685"><span class='Ref_to_Const'>ANYOID</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* accept if target is polymorphic, for now */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/catalog/pg_type.h.html#LN744"><span class='Ref_to_Macro'>IsPolymorphicType</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN536"><span class='Ref_To_Local'>targetTypeId</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="parse_coerce.c.html#LN529"><span class='Ref_To_Local'>have_generics</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* do more checking later */ 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If input is an untyped string constant, assume we can convert it to 
         * anything. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN535"><span class='Ref_To_Local'>inputTypeId</span></a> <span class='Operator'>== </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN43"><span class='Ref_to_Const'>UNKNOWNOID</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If pg_cast shows that we can coerce, accept.  This test now covers 
         * both binary-compatible and coercion-function cases. 
         */ 
</span>        <a href="parse_coerce.c.html#LN537"><span class='Ref_To_Local'>pathtype</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN86"><span class='Ref_to_Proto'>find_coercion_pathway</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN536"><span class='Ref_To_Local'>targetTypeId</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN535"><span class='Ref_To_Local'>inputTypeId</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN527"><span class='Ref_to_Parameter'>ccontext</span></a><span class='Delimiter'>, 
</span>                                         <span class='Operator'>&</span><a href="parse_coerce.c.html#LN538"><span class='Ref_To_Local'>funcId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN537"><span class='Ref_To_Local'>pathtype</span></a> <span class='Operator'>!= </span><a href="../../include/parser/parse_coerce.h.html#LN25"><span class='Ref_to_EnumConst'>COERCION_PATH_NONE</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If input is RECORD and target is a composite type, assume we can 
         * coerce (may need tighter checking here) 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN535"><span class='Ref_To_Local'>inputTypeId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN679"><span class='Ref_to_Const'>RECORDOID</span></a> <span class='Operator'>&& 
</span>            <a href="../../include/parser/parse_type.h.html#LN52"><span class='Ref_to_Macro'>ISCOMPLEX</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN536"><span class='Ref_To_Local'>targetTypeId</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If input is a composite type and target is RECORD, accept 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN536"><span class='Ref_To_Local'>targetTypeId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN679"><span class='Ref_to_Const'>RECORDOID</span></a> <span class='Operator'>&& 
</span>            <a href="../../include/parser/parse_type.h.html#LN52"><span class='Ref_to_Macro'>ISCOMPLEX</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN535"><span class='Ref_To_Local'>inputTypeId</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> NOT_USED                 <span class='Comment_Single_Line'>/* not implemented yet */ 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If input is record[] and target is a composite array type, assume 
         * we can coerce (may need tighter checking here) 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN535"><span class='Ref_To_Local'>inputTypeId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN681"><span class='Ref_to_Const'>RECORDARRAYOID</span></a> <span class='Operator'>&& 
</span>            <a href="parse_coerce.c.html#LN50"><span class='Ref_to_Proto'>is_complex_array</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN536"><span class='Ref_To_Local'>targetTypeId</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
        <span class='Comment_Multi_Line'>/* 
         * If input is a composite array type and target is record[], accept 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN536"><span class='Ref_To_Local'>targetTypeId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN681"><span class='Ref_to_Const'>RECORDARRAYOID</span></a> <span class='Operator'>&& 
</span>            <a href="parse_coerce.c.html#LN50"><span class='Ref_to_Proto'>is_complex_array</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN535"><span class='Ref_To_Local'>inputTypeId</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If input is a class type that inherits from target, accept 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/catalog/pg_inherits_fn.h.html#LN23"><span class='Ref_to_Proto'>typeInheritsFrom</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN535"><span class='Ref_To_Local'>inputTypeId</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN536"><span class='Ref_To_Local'>targetTypeId</span></a><span class='Parentheses'>) 
</span>            <span class='Operator'>|| </span><a href="parse_coerce.c.html#LN51"><span class='Ref_to_Proto'>typeIsOfTypedTable</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN535"><span class='Ref_To_Local'>inputTypeId</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN536"><span class='Ref_To_Local'>targetTypeId</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Else, cannot coerce at this argument position 
         */ 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;nargs;i++ &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* If we found any generic argument types, cross-check them */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN529"><span class='Ref_To_Local'>have_generics</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/parser/parse_coerce.h.html#LN74"><span class='Ref_to_Proto'>check_generic_type_consistency</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN526"><span class='Ref_to_Parameter'>input_typeids</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN526"><span class='Ref_to_Parameter'>target_typeids</span></a><span class='Delimiter'>, 
</span>                                            <a href="parse_coerce.c.html#LN526"><span class='Ref_to_Parameter'>nargs</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end can_coerce_type &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Create an expression tree to represent coercion to a domain type. 
 * 
 * 'arg': input expression 
 * 'baseTypeId': base type of domain, if known (pass InvalidOid if caller 
 *      has not bothered to look this up) 
 * 'baseTypeMod': base type typmod of domain, if known (pass -1 if caller 
 *      has not bothered to look this up) 
 * 'typeId': target type to coerce to 
 * 'cformat': coercion format 
 * 'location': coercion request location 
 * 'hideInputCoercion': if true, hide the input coercion under this one. 
 * 'lengthCoercionDone': if true, caller already accounted for length, 
 *      ie the input is already of baseTypMod as well as baseTypeId. 
 * 
 * If the target type isn't a domain, the given 'arg' is returned as-is. 
 */ 
</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN647"></a><span class='Declare_Function'>coerce_to_domain</span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>arg</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>baseTypeId</span><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a> <span class='Declare_Parameter'>baseTypeMod</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>typeId</span><span class='Delimiter'>, 
</span><a name="LN648"></a>                 <a href="../../include/nodes/primnodes.h.html#LN434"><span class='Ref_to_Enum'>CoercionForm</span></a> <span class='Declare_Parameter'>cformat</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>location</span><span class='Delimiter'>, 
</span><a name="LN649"></a>                 <span class='Keyword'>bool </span><span class='Declare_Parameter'>hideInputCoercion</span><span class='Delimiter'>, 
</span><a name="LN650"></a>                 <span class='Keyword'>bool </span><span class='Declare_Parameter'>lengthCoercionDone</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN652"></a>    <a href="../../include/nodes/primnodes.h.html#LN1215"><span class='Ref_to_Struct'>CoerceToDomain</span></a> <span class='Operator'>*</span><span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Get the base type if it hasn't been supplied */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN647"><span class='Ref_to_Parameter'>baseTypeId</span></a> <span class='Operator'>== </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>) 
</span>        <a href="parse_coerce.c.html#LN647"><span class='Ref_to_Parameter'>baseTypeId</span></a> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN169"><span class='Ref_to_Proto'>getBaseTypeAndTypmod</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN647"><span class='Ref_to_Parameter'>typeId</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_coerce.c.html#LN647"><span class='Ref_to_Parameter'>baseTypeMod</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If it isn't a domain, return the node as it was passed in */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN647"><span class='Ref_to_Parameter'>baseTypeId</span></a> <span class='Operator'>== </span><a href="parse_coerce.c.html#LN647"><span class='Ref_to_Parameter'>typeId</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="parse_coerce.c.html#LN647"><span class='Ref_to_Parameter'>arg</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Suppress display of nested coercion steps */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN649"><span class='Ref_to_Parameter'>hideInputCoercion</span></a><span class='Parentheses'>) 
</span>        <a href="parse_coerce.c.html#LN38"><span class='Ref_to_Proto'>hide_coercion_node</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN647"><span class='Ref_to_Parameter'>arg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the domain applies a typmod to its base type, build the appropriate 
     * coercion step.  Mark it implicit for display purposes, because we don't 
     * want it shown separately by ruleutils.c; but the isExplicit flag passed 
     * to the conversion function depends on the manner in which the domain 
     * coercion is invoked, so that the semantics of implicit and explicit 
     * coercion differ.  (Is that really the behavior we want?) 
     * 
     * NOTE: because we apply this as part of the fixed expression structure, 
     * ALTER DOMAIN cannot alter the typtypmod.  But it's unclear that that 
     * would be safe to do anyway, without lots of knowledge about what the 
     * base type thinks the typmod means. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_coerce.c.html#LN650"><span class='Ref_to_Parameter'>lengthCoercionDone</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN647"><span class='Ref_to_Parameter'>baseTypeMod</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <a href="parse_coerce.c.html#LN647"><span class='Ref_to_Parameter'>arg</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN34"><span class='Ref_to_Proto'>coerce_type_typmod</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN647"><span class='Ref_to_Parameter'>arg</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN647"><span class='Ref_to_Parameter'>baseTypeId</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN647"><span class='Ref_to_Parameter'>baseTypeMod</span></a><span class='Delimiter'>, 
</span>                                     <a href="../../include/nodes/primnodes.h.html#LN438"><span class='Ref_to_EnumConst'>COERCE_IMPLICIT_CAST</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN648"><span class='Ref_to_Parameter'>location</span></a><span class='Delimiter'>, 
</span>                                     <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN648"><span class='Ref_to_Parameter'>cformat</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/primnodes.h.html#LN438"><span class='Ref_to_EnumConst'>COERCE_IMPLICIT_CAST</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                     <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now build the domain coercion node.  This represents run-time checking 
     * of any constraints currently attached to the domain.  This also ensures 
     * that the expression is properly labeled as to result type. 
     */ 
</span>    <a href="parse_coerce.c.html#LN652"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN1215"><span class='Ref_to_Struct'>CoerceToDomain</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="parse_coerce.c.html#LN652"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1218"><span class='Ref_to_Member'>arg</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN647"><span class='Ref_to_Parameter'>arg</span></a><span class='Delimiter'>; 
</span>    <a href="parse_coerce.c.html#LN652"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1219"><span class='Ref_to_Member'>resulttype</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN647"><span class='Ref_to_Parameter'>typeId</span></a><span class='Delimiter'>; 
</span>    <a href="parse_coerce.c.html#LN652"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1220"><span class='Ref_to_Member'>resulttypmod</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* currently, always -1 for domains */ 
</span>    <span class='Comment_Multi_Line'>/* resultcollid will be set by parse_collate.c */ 
</span>    <a href="parse_coerce.c.html#LN652"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1222"><span class='Ref_to_Member'>coercionformat</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN648"><span class='Ref_to_Parameter'>cformat</span></a><span class='Delimiter'>; 
</span>    <a href="parse_coerce.c.html#LN652"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1223"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN648"><span class='Ref_to_Parameter'>location</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN652"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end coerce_to_domain &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * coerce_type_typmod() 
 *      Force a value to a particular typmod, if meaningful and possible. 
 * 
 * This is applied to values that are going to be stored in a relation 
 * (where we have an atttypmod for the column) as well as values being 
 * explicitly CASTed (where the typmod comes from the target type spec). 
 * 
 * The caller must have already ensured that the value is of the correct 
 * type, typically by applying coerce_type. 
 * 
 * cformat determines the display properties of the generated node (if any), 
 * while isExplicit may affect semantics.  If hideInputCoercion is true 
 * *and* we generate a node, the input node is forced to IMPLICIT display 
 * form, so that only the typmod coercion node will be visible when 
 * displaying the expression. 
 * 
 * NOTE: this does not need to work on domain types, because any typmod 
 * coercion for a domain is considered to be part of the type coercion 
 * needed to produce the domain value in the first place.  So, no getBaseType. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN727"></a><span class='Declare_Function'>coerce_type_typmod</span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>targetTypeId</span><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a> <span class='Declare_Parameter'>targetTypMod</span><span class='Delimiter'>, 
</span><a name="LN728"></a>                   <a href="../../include/nodes/primnodes.h.html#LN434"><span class='Ref_to_Enum'>CoercionForm</span></a> <span class='Declare_Parameter'>cformat</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>location</span><span class='Delimiter'>, 
</span><a name="LN729"></a>                   <span class='Keyword'>bool </span><span class='Declare_Parameter'>isExplicit</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>hideInputCoercion</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN731"></a>    <a href="../../include/parser/parse_coerce.h.html#LN23"><span class='Ref_to_Enum'>CoercionPathType</span></a> <span class='Declare_Local'>pathtype</span><span class='Delimiter'>; 
</span><a name="LN732"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>funcId</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * A negative typmod is assumed to mean that no coercion is wanted. Also, 
     * skip coercion if already done. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN727"><span class='Ref_to_Parameter'>targetTypMod</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span> <span class='Operator'>|| </span><a href="parse_coerce.c.html#LN727"><span class='Ref_to_Parameter'>targetTypMod</span></a> <span class='Operator'>== </span><a href="../../include/nodes/nodeFuncs.h.html#LN32"><span class='Ref_to_Proto'>exprTypmod</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN727"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <a href="parse_coerce.c.html#LN727"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
    <a href="parse_coerce.c.html#LN731"><span class='Ref_To_Local'>pathtype</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN90"><span class='Ref_to_Proto'>find_typmod_coercion_function</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN727"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_coerce.c.html#LN732"><span class='Ref_To_Local'>funcId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN731"><span class='Ref_To_Local'>pathtype</span></a> <span class='Operator'>!= </span><a href="../../include/parser/parse_coerce.h.html#LN25"><span class='Ref_to_EnumConst'>COERCION_PATH_NONE</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Suppress display of nested coercion steps */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN729"><span class='Ref_to_Parameter'>hideInputCoercion</span></a><span class='Parentheses'>) 
</span>            <a href="parse_coerce.c.html#LN38"><span class='Ref_to_Proto'>hide_coercion_node</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN727"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="parse_coerce.c.html#LN727"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN39"><span class='Ref_to_Proto'>build_coercion_expression</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN727"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN731"><span class='Ref_To_Local'>pathtype</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN732"><span class='Ref_To_Local'>funcId</span></a><span class='Delimiter'>, 
</span>                                         <a href="parse_coerce.c.html#LN727"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN727"><span class='Ref_to_Parameter'>targetTypMod</span></a><span class='Delimiter'>, 
</span>                                         <a href="parse_coerce.c.html#LN728"><span class='Ref_to_Parameter'>cformat</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN728"><span class='Ref_to_Parameter'>location</span></a><span class='Delimiter'>, 
</span>                                         <a href="parse_coerce.c.html#LN729"><span class='Ref_to_Parameter'>isExplicit</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="parse_coerce.c.html#LN727"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end coerce_type_typmod &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Mark a coercion node as IMPLICIT so it will never be displayed by 
 * ruleutils.c.  We use this when we generate a nest of coercion nodes 
 * to implement what is logically one conversion; the inner nodes are 
 * forced to IMPLICIT_CAST format.  This does not change their semantics, 
 * only display behavior. 
 * 
 * It is caller error to call this on something that doesn't have a 
 * CoercionForm field. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN769"></a><span class='Declare_Function'>hide_coercion_node</span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN769"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a><span class='Parentheses'>))</span> 
        <span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN769"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>funcformat <span class='Operator'>= </span><a href="../../include/nodes/primnodes.h.html#LN438"><span class='Ref_to_EnumConst'>COERCE_IMPLICIT_CAST</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN769"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a><span class='Parentheses'>))</span> 
        <span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN769"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>relabelformat <span class='Operator'>= </span><a href="../../include/nodes/primnodes.h.html#LN438"><span class='Ref_to_EnumConst'>COERCE_IMPLICIT_CAST</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN769"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN806"><span class='Ref_to_Struct'>CoerceViaIO</span></a><span class='Parentheses'>))</span> 
        <span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN806"><span class='Ref_to_Struct'>CoerceViaIO</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN769"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>coerceformat <span class='Operator'>= </span><a href="../../include/nodes/primnodes.h.html#LN438"><span class='Ref_to_EnumConst'>COERCE_IMPLICIT_CAST</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN769"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN829"><span class='Ref_to_Struct'>ArrayCoerceExpr</span></a><span class='Parentheses'>))</span> 
        <span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN829"><span class='Ref_to_Struct'>ArrayCoerceExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN769"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>coerceformat <span class='Operator'>= </span><a href="../../include/nodes/primnodes.h.html#LN438"><span class='Ref_to_EnumConst'>COERCE_IMPLICIT_CAST</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN769"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN854"><span class='Ref_to_Struct'>ConvertRowtypeExpr</span></a><span class='Parentheses'>))</span> 
        <span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN854"><span class='Ref_to_Struct'>ConvertRowtypeExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN769"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>convertformat <span class='Operator'>= </span><a href="../../include/nodes/primnodes.h.html#LN438"><span class='Ref_to_EnumConst'>COERCE_IMPLICIT_CAST</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN769"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN981"><span class='Ref_to_Struct'>RowExpr</span></a><span class='Parentheses'>))</span> 
        <span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN981"><span class='Ref_to_Struct'>RowExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN769"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>row_format <span class='Operator'>= </span><a href="../../include/nodes/primnodes.h.html#LN438"><span class='Ref_to_EnumConst'>COERCE_IMPLICIT_CAST</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN769"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN1215"><span class='Ref_to_Struct'>CoerceToDomain</span></a><span class='Parentheses'>))</span> 
        <span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN1215"><span class='Ref_to_Struct'>CoerceToDomain</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN769"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>coercionformat <span class='Operator'>= </span><a href="../../include/nodes/primnodes.h.html#LN438"><span class='Ref_to_EnumConst'>COERCE_IMPLICIT_CAST</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unsupported node type: %d"</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="../../include/nodes/nodes.h.html#LN513"><span class='Ref_to_Macro'>nodeTag</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN769"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end hide_coercion_node &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * build_coercion_expression() 
 *      Construct an expression tree for applying a pg_cast entry. 
 * 
 * This is used for both type-coercion and length-coercion operations, 
 * since there is no difference in terms of the calling convention. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN797"></a><span class='Declare_Function'>build_coercion_expression</span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, 
</span><a name="LN798"></a>                          <a href="../../include/parser/parse_coerce.h.html#LN23"><span class='Ref_to_Enum'>CoercionPathType</span></a> <span class='Declare_Parameter'>pathtype</span><span class='Delimiter'>, 
</span><a name="LN799"></a>                          <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>funcId</span><span class='Delimiter'>, 
</span><a name="LN800"></a>                          <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>targetTypeId</span><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a> <span class='Declare_Parameter'>targetTypMod</span><span class='Delimiter'>, 
</span><a name="LN801"></a>                          <a href="../../include/nodes/primnodes.h.html#LN434"><span class='Ref_to_Enum'>CoercionForm</span></a> <span class='Declare_Parameter'>cformat</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>location</span><span class='Delimiter'>, 
</span><a name="LN802"></a>                          <span class='Keyword'>bool </span><span class='Declare_Parameter'>isExplicit</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN804"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>nargs</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN799"><span class='Ref_to_Parameter'>funcId</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN808"></a>        <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>tp</span><span class='Delimiter'>; 
</span><a name="LN809"></a>        <a href="../../include/catalog/pg_proc.h.html#LN82"><span class='Ref_to_Typedef'>Form_pg_proc</span></a> <span class='Declare_Local'>procstruct</span><span class='Delimiter'>; 
</span> 
        <a href="parse_coerce.c.html#LN808"><span class='Ref_To_Local'>tp</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN155"><span class='Ref_to_Macro'>SearchSysCache1</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN76"><span class='Ref_to_EnumConst'>PROCOID</span></a><span class='Delimiter'>, </span><a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN799"><span class='Ref_to_Parameter'>funcId</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN808"><span class='Ref_To_Local'>tp</span></a><span class='Parentheses'>))</span> 
            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for function %u"</span><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN799"><span class='Ref_to_Parameter'>funcId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_coerce.c.html#LN809"><span class='Ref_To_Local'>procstruct</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_proc.h.html#LN82"><span class='Ref_to_Typedef'>Form_pg_proc</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN808"><span class='Ref_To_Local'>tp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * These Asserts essentially check that function is a legal coercion 
         * function.  We can't make the seemingly obvious tests on prorettype 
         * and proargtypes[0], even in the COERCION_PATH_FUNC case, because of 
         * various binary-compatibility cases. 
         */ 
</span>        <span class='Comment_Multi_Line'>/* Assert(targetTypeId == procstruct-&GT;prorettype); */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_coerce.c.html#LN809"><span class='Ref_To_Local'>procstruct</span></a><span class='Operator'>-&GT;</span>proretset<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_coerce.c.html#LN809"><span class='Ref_To_Local'>procstruct</span></a><span class='Operator'>-&GT;</span>proisagg<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_coerce.c.html#LN809"><span class='Ref_To_Local'>procstruct</span></a><span class='Operator'>-&GT;</span>proiswindow<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_coerce.c.html#LN804"><span class='Ref_To_Local'>nargs</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN809"><span class='Ref_To_Local'>procstruct</span></a><span class='Operator'>-&GT;</span>pronargs<span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN804"><span class='Ref_To_Local'>nargs</span></a> <span class='Operator'>&GT;= </span><span class='Number'>1</span> <span class='Operator'>&& </span><a href="parse_coerce.c.html#LN804"><span class='Ref_To_Local'>nargs</span></a> <span class='Operator'>&LT;= </span><span class='Number'>3</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Assert(procstruct-&GT;proargtypes.values[0] == exprType(node)); */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN804"><span class='Ref_To_Local'>nargs</span></a> <span class='Operator'>&LT; </span><span class='Number'>2</span> <span class='Operator'>|| </span><a href="parse_coerce.c.html#LN809"><span class='Ref_To_Local'>procstruct</span></a><span class='Operator'>-&GT;</span>proargtypes<span class='Operator'>.</span>values<span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>== </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN24"><span class='Ref_to_Const'>INT4OID</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN804"><span class='Ref_To_Local'>nargs</span></a> <span class='Operator'>&LT; </span><span class='Number'>3</span> <span class='Operator'>|| </span><a href="parse_coerce.c.html#LN809"><span class='Ref_To_Local'>procstruct</span></a><span class='Operator'>-&GT;</span>proargtypes<span class='Operator'>.</span>values<span class='Delimiter'>[</span><span class='Number'>2</span><span class='Delimiter'>] </span><span class='Operator'>== </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN17"><span class='Ref_to_Const'>BOOLOID</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN808"><span class='Ref_To_Local'>tp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if OidIsValid(funcId) &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN798"><span class='Ref_to_Parameter'>pathtype</span></a> <span class='Operator'>== </span><a href="../../include/parser/parse_coerce.h.html#LN26"><span class='Ref_to_EnumConst'>COERCION_PATH_FUNC</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* We build an ordinary FuncExpr with special arguments */ 
</span><a name="LN838"></a>        <a href="../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>fexpr</span><span class='Delimiter'>; 
</span><a name="LN839"></a>        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>args</span><span class='Delimiter'>; 
</span><a name="LN840"></a>        <a href="../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>cons</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN799"><span class='Ref_to_Parameter'>funcId</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <a href="parse_coerce.c.html#LN839"><span class='Ref_To_Local'>args</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN797"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN804"><span class='Ref_To_Local'>nargs</span></a> <span class='Operator'>&GT;= </span><span class='Number'>2</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Pass target typmod as an int4 constant */ 
</span>            <a href="parse_coerce.c.html#LN840"><span class='Ref_To_Local'>cons</span></a> <span class='Operator'>= </span><a href="../../include/nodes/makefuncs.h.html#LN49"><span class='Ref_to_Proto'>makeConst</span></a><span class='Parentheses'>(</span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN24"><span class='Ref_to_Const'>INT4OID</span></a><span class='Delimiter'>, 
</span>                             <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                             <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                             <span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <a href="../../include/postgres.h.html#LN484"><span class='Ref_to_Macro'>Int32GetDatum</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN800"><span class='Ref_to_Parameter'>targetTypMod</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                             <span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="parse_coerce.c.html#LN839"><span class='Ref_To_Local'>args</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN839"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN840"><span class='Ref_To_Local'>cons</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN804"><span class='Ref_To_Local'>nargs</span></a> <span class='Operator'>== </span><span class='Number'>3</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Pass it a boolean isExplicit parameter, too */ 
</span>            <a href="parse_coerce.c.html#LN840"><span class='Ref_To_Local'>cons</span></a> <span class='Operator'>= </span><a href="../../include/nodes/makefuncs.h.html#LN49"><span class='Ref_to_Proto'>makeConst</span></a><span class='Parentheses'>(</span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN17"><span class='Ref_to_Const'>BOOLOID</span></a><span class='Delimiter'>, 
</span>                             <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                             <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                             <span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>bool</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <a href="../../include/postgres.h.html#LN407"><span class='Ref_to_Macro'>BoolGetDatum</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN802"><span class='Ref_to_Parameter'>isExplicit</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                             <span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="parse_coerce.c.html#LN839"><span class='Ref_To_Local'>args</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN839"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN840"><span class='Ref_To_Local'>cons</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="parse_coerce.c.html#LN838"><span class='Ref_To_Local'>fexpr</span></a> <span class='Operator'>= </span><a href="../../include/nodes/makefuncs.h.html#LN77"><span class='Ref_to_Proto'>makeFuncExpr</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN799"><span class='Ref_to_Parameter'>funcId</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN800"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN839"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>, 
</span>                             <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN801"><span class='Ref_to_Parameter'>cformat</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_coerce.c.html#LN838"><span class='Ref_To_Local'>fexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN456"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN801"><span class='Ref_to_Parameter'>location</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN838"><span class='Ref_To_Local'>fexpr</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if pathtype==COERCION_PA... &raquo; </span> 
    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN798"><span class='Ref_to_Parameter'>pathtype</span></a> <span class='Operator'>== </span><a href="../../include/parser/parse_coerce.h.html#LN28"><span class='Ref_to_EnumConst'>COERCION_PATH_ARRAYCOERCE</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* We need to build an ArrayCoerceExpr */ 
</span><a name="LN882"></a>        <a href="../../include/nodes/primnodes.h.html#LN829"><span class='Ref_to_Struct'>ArrayCoerceExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>acoerce</span> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN829"><span class='Ref_to_Struct'>ArrayCoerceExpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="parse_coerce.c.html#LN882"><span class='Ref_To_Local'>acoerce</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN832"><span class='Ref_to_Member'>arg</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN797"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span>        <a href="parse_coerce.c.html#LN882"><span class='Ref_To_Local'>acoerce</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN833"><span class='Ref_to_Member'>elemfuncid</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN799"><span class='Ref_to_Parameter'>funcId</span></a><span class='Delimiter'>; 
</span>        <a href="parse_coerce.c.html#LN882"><span class='Ref_To_Local'>acoerce</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN834"><span class='Ref_to_Member'>resulttype</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN800"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Label the output as having a particular typmod only if we are 
         * really invoking a length-coercion function, ie one with more than 
         * one argument. 
         */ 
</span>        <a href="parse_coerce.c.html#LN882"><span class='Ref_To_Local'>acoerce</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN835"><span class='Ref_to_Member'>resulttypmod</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN804"><span class='Ref_To_Local'>nargs</span></a> <span class='Operator'>&GT;= </span><span class='Number'>2</span><span class='Parentheses'>) </span><span class='Operator'>? </span><a href="parse_coerce.c.html#LN800"><span class='Ref_to_Parameter'>targetTypMod</span></a> <span class='Operator'>: -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* resultcollid will be set by parse_collate.c */ 
</span>        <a href="parse_coerce.c.html#LN882"><span class='Ref_To_Local'>acoerce</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN837"><span class='Ref_to_Member'>isExplicit</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN802"><span class='Ref_to_Parameter'>isExplicit</span></a><span class='Delimiter'>; 
</span>        <a href="parse_coerce.c.html#LN882"><span class='Ref_To_Local'>acoerce</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN838"><span class='Ref_to_Member'>coerceformat</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN801"><span class='Ref_to_Parameter'>cformat</span></a><span class='Delimiter'>; 
</span>        <a href="parse_coerce.c.html#LN882"><span class='Ref_To_Local'>acoerce</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN839"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN801"><span class='Ref_to_Parameter'>location</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN882"><span class='Ref_To_Local'>acoerce</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if pathtype==COERCION_PA... &raquo; </span> 
    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN798"><span class='Ref_to_Parameter'>pathtype</span></a> <span class='Operator'>== </span><a href="../../include/parser/parse_coerce.h.html#LN29"><span class='Ref_to_EnumConst'>COERCION_PATH_COERCEVIAIO</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* We need to build a CoerceViaIO node */ 
</span><a name="LN904"></a>        <a href="../../include/nodes/primnodes.h.html#LN806"><span class='Ref_to_Struct'>CoerceViaIO</span></a> <span class='Operator'>*</span><span class='Declare_Local'>iocoerce</span> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN806"><span class='Ref_to_Struct'>CoerceViaIO</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN799"><span class='Ref_to_Parameter'>funcId</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <a href="parse_coerce.c.html#LN904"><span class='Ref_To_Local'>iocoerce</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN809"><span class='Ref_to_Member'>arg</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN797"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span>        <a href="parse_coerce.c.html#LN904"><span class='Ref_To_Local'>iocoerce</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN810"><span class='Ref_to_Member'>resulttype</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN800"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* resultcollid will be set by parse_collate.c */ 
</span>        <a href="parse_coerce.c.html#LN904"><span class='Ref_To_Local'>iocoerce</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN813"><span class='Ref_to_Member'>coerceformat</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN801"><span class='Ref_to_Parameter'>cformat</span></a><span class='Delimiter'>; 
</span>        <a href="parse_coerce.c.html#LN904"><span class='Ref_To_Local'>iocoerce</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN814"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN801"><span class='Ref_to_Parameter'>location</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN904"><span class='Ref_To_Local'>iocoerce</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unsupported pathtype %d in build_coercion_expression"</span><span class='Delimiter'>, 
</span>             <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN798"><span class='Ref_to_Parameter'>pathtype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end build_coercion_expression &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * coerce_record_to_complex 
 *      Coerce a RECORD to a specific composite type. 
 * 
 * Currently we only support this for inputs that are RowExprs or whole-row 
 * Vars. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN933"></a><span class='Declare_Function'>coerce_record_to_complex</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, 
</span><a name="LN934"></a>                         <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>targetTypeId</span><span class='Delimiter'>, 
</span><a name="LN935"></a>                         <a href="../../include/nodes/primnodes.h.html#LN418"><span class='Ref_to_Enum'>CoercionContext</span></a> <span class='Declare_Parameter'>ccontext</span><span class='Delimiter'>, 
</span><a name="LN936"></a>                         <a href="../../include/nodes/primnodes.h.html#LN434"><span class='Ref_to_Enum'>CoercionForm</span></a> <span class='Declare_Parameter'>cformat</span><span class='Delimiter'>, 
</span><a name="LN937"></a>                         <span class='Keyword'>int </span><span class='Declare_Parameter'>location</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN939"></a>    <a href="../../include/nodes/primnodes.h.html#LN981"><span class='Ref_to_Struct'>RowExpr</span></a>    <span class='Operator'>*</span><span class='Declare_Local'>rowexpr</span><span class='Delimiter'>; 
</span><a name="LN940"></a>    <a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Local'>tupdesc</span><span class='Delimiter'>; 
</span><a name="LN941"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>args</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN942"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>newargs</span><span class='Delimiter'>; 
</span><a name="LN943"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN944"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>ucolno</span><span class='Delimiter'>; 
</span><a name="LN945"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>arg</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN933"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>&& </span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN933"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN981"><span class='Ref_to_Struct'>RowExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Since the RowExpr must be of type RECORD, we needn't worry about it 
         * containing any dropped columns. 
         */ 
</span>        <a href="parse_coerce.c.html#LN941"><span class='Ref_To_Local'>args</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN981"><span class='Ref_to_Struct'>RowExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN933"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>args<span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN933"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>&& </span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN933"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>             <span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN933"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>varattno <span class='Operator'>== </span><a href="../../include/access/attnum.h.html#LN22"><span class='Ref_to_Const'>InvalidAttrNumber</span></a><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span><a name="LN958"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>rtindex</span> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN933"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>varno<span class='Delimiter'>; 
</span><a name="LN959"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>sublevels_up</span> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN933"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>varlevelsup<span class='Delimiter'>; 
</span><a name="LN960"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>vlocation</span> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN933"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>location<span class='Delimiter'>; 
</span><a name="LN961"></a>        <a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span><span class='Delimiter'>; 
</span> 
        <a href="parse_coerce.c.html#LN961"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_relation.h.html#LN50"><span class='Ref_to_Proto'>GetRTEByRangeTablePosn</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN933"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN958"><span class='Ref_To_Local'>rtindex</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN959"><span class='Ref_To_Local'>sublevels_up</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/parser/parse_relation.h.html#LN120"><span class='Ref_to_Proto'>expandRTE</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN961"><span class='Ref_To_Local'>rte</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN958"><span class='Ref_To_Local'>rtindex</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN959"><span class='Ref_To_Local'>sublevels_up</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN960"><span class='Ref_To_Local'>vlocation</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                  <span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_coerce.c.html#LN941"><span class='Ref_To_Local'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_CANNOT_COERCE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"cannot cast type %s to %s"</span><span class='Delimiter'>, 
</span>                        <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="../../include/catalog/pg_type.h.html#LN679"><span class='Ref_to_Const'>RECORDOID</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                        <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN934"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                 <a href="../../include/parser/parse_coerce.h.html#LN64"><span class='Ref_to_Proto'>parser_coercion_errposition</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN933"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN937"><span class='Ref_to_Parameter'>location</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN933"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <a href="parse_coerce.c.html#LN940"><span class='Ref_To_Local'>tupdesc</span></a> <span class='Operator'>= </span><a href="../../include/utils/typcache.h.html#LN151"><span class='Ref_to_Proto'>lookup_rowtype_tupdesc</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN934"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="parse_coerce.c.html#LN942"><span class='Ref_To_Local'>newargs</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="parse_coerce.c.html#LN944"><span class='Ref_To_Local'>ucolno</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <a href="parse_coerce.c.html#LN945"><span class='Ref_To_Local'>arg</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN941"><span class='Ref_To_Local'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN943"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="parse_coerce.c.html#LN943"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="parse_coerce.c.html#LN940"><span class='Ref_To_Local'>tupdesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tupdesc.h.html#LN72"><span class='Ref_to_Member'>natts</span></a><span class='Delimiter'>; </span><a href="parse_coerce.c.html#LN943"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN981"></a>        <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>expr</span><span class='Delimiter'>; 
</span><a name="LN982"></a>        <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>cexpr</span><span class='Delimiter'>; 
</span><a name="LN983"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>exprtype</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Fill in NULLs for dropped columns in rowtype */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN940"><span class='Ref_To_Local'>tupdesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tupdesc.h.html#LN73"><span class='Ref_to_Member'>attrs</span></a><span class='Delimiter'>[</span><a href="parse_coerce.c.html#LN943"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>-&GT;</span>attisdropped<span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * can't use atttypid here, but it doesn't really matter what type 
             * the Const claims to be. 
             */ 
</span>            <a href="parse_coerce.c.html#LN942"><span class='Ref_To_Local'>newargs</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN942"><span class='Ref_To_Local'>newargs</span></a><span class='Delimiter'>, 
</span>                              <a href="../../include/nodes/makefuncs.h.html#LN57"><span class='Ref_to_Proto'>makeNullConst</span></a><span class='Parentheses'>(</span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN24"><span class='Ref_to_Const'>INT4OID</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN945"><span class='Ref_To_Local'>arg</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_CANNOT_COERCE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"cannot cast type %s to %s"</span><span class='Delimiter'>, 
</span>                            <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="../../include/catalog/pg_type.h.html#LN679"><span class='Ref_to_Const'>RECORDOID</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                            <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN934"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"Input has too few columns."</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../include/parser/parse_coerce.h.html#LN64"><span class='Ref_to_Proto'>parser_coercion_errposition</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN933"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN937"><span class='Ref_to_Parameter'>location</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN933"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <a href="parse_coerce.c.html#LN981"><span class='Ref_To_Local'>expr</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN945"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_coerce.c.html#LN983"><span class='Ref_To_Local'>exprtype</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN981"><span class='Ref_To_Local'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="parse_coerce.c.html#LN982"><span class='Ref_To_Local'>cexpr</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN37"><span class='Ref_to_Proto'>coerce_to_target_type</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN933"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                      <a href="parse_coerce.c.html#LN981"><span class='Ref_To_Local'>expr</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN983"><span class='Ref_To_Local'>exprtype</span></a><span class='Delimiter'>, 
</span>                                      <a href="parse_coerce.c.html#LN940"><span class='Ref_To_Local'>tupdesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tupdesc.h.html#LN73"><span class='Ref_to_Member'>attrs</span></a><span class='Delimiter'>[</span><a href="parse_coerce.c.html#LN943"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>-&GT;</span>atttypid<span class='Delimiter'>, 
</span>                                      <a href="parse_coerce.c.html#LN940"><span class='Ref_To_Local'>tupdesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tupdesc.h.html#LN73"><span class='Ref_to_Member'>attrs</span></a><span class='Delimiter'>[</span><a href="parse_coerce.c.html#LN943"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>-&GT;</span>atttypmod<span class='Delimiter'>, 
</span>                                      <a href="parse_coerce.c.html#LN935"><span class='Ref_to_Parameter'>ccontext</span></a><span class='Delimiter'>, 
</span>                                      <a href="../../include/nodes/primnodes.h.html#LN438"><span class='Ref_to_EnumConst'>COERCE_IMPLICIT_CAST</span></a><span class='Delimiter'>, 
</span>                                      <span class='Operator'>-</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN982"><span class='Ref_To_Local'>cexpr</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_CANNOT_COERCE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"cannot cast type %s to %s"</span><span class='Delimiter'>, 
</span>                            <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="../../include/catalog/pg_type.h.html#LN679"><span class='Ref_to_Const'>RECORDOID</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                            <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN934"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"Cannot cast type %s to %s in column %d."</span><span class='Delimiter'>, 
</span>                               <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN983"><span class='Ref_To_Local'>exprtype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                               <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN940"><span class='Ref_To_Local'>tupdesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tupdesc.h.html#LN73"><span class='Ref_to_Member'>attrs</span></a><span class='Delimiter'>[</span><a href="parse_coerce.c.html#LN943"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>-&GT;</span>atttypid<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                               <a href="parse_coerce.c.html#LN944"><span class='Ref_To_Local'>ucolno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../include/parser/parse_coerce.h.html#LN64"><span class='Ref_to_Proto'>parser_coercion_errposition</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN933"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN937"><span class='Ref_to_Parameter'>location</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN981"><span class='Ref_To_Local'>expr</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <a href="parse_coerce.c.html#LN942"><span class='Ref_To_Local'>newargs</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN942"><span class='Ref_To_Local'>newargs</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN982"><span class='Ref_To_Local'>cexpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_coerce.c.html#LN944"><span class='Ref_To_Local'>ucolno</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <a href="parse_coerce.c.html#LN945"><span class='Ref_To_Local'>arg</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN945"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;tupdesc-&GT;natts;... &raquo; </span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN945"><span class='Ref_To_Local'>arg</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_CANNOT_COERCE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"cannot cast type %s to %s"</span><span class='Delimiter'>, 
</span>                        <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="../../include/catalog/pg_type.h.html#LN679"><span class='Ref_to_Const'>RECORDOID</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                        <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN934"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"Input has too many columns."</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../include/parser/parse_coerce.h.html#LN64"><span class='Ref_to_Proto'>parser_coercion_errposition</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN933"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN937"><span class='Ref_to_Parameter'>location</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN933"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/access/tupdesc.h.html#LN106"><span class='Ref_to_Macro'>ReleaseTupleDesc</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN940"><span class='Ref_To_Local'>tupdesc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="parse_coerce.c.html#LN939"><span class='Ref_To_Local'>rowexpr</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN981"><span class='Ref_to_Struct'>RowExpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="parse_coerce.c.html#LN939"><span class='Ref_To_Local'>rowexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN984"><span class='Ref_to_Member'>args</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN942"><span class='Ref_To_Local'>newargs</span></a><span class='Delimiter'>; 
</span>    <a href="parse_coerce.c.html#LN939"><span class='Ref_To_Local'>rowexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN985"><span class='Ref_to_Member'>row_typeid</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN934"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Delimiter'>; 
</span>    <a href="parse_coerce.c.html#LN939"><span class='Ref_To_Local'>rowexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN996"><span class='Ref_to_Member'>row_format</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN936"><span class='Ref_to_Parameter'>cformat</span></a><span class='Delimiter'>; 
</span>    <a href="parse_coerce.c.html#LN939"><span class='Ref_To_Local'>rowexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN997"><span class='Ref_to_Member'>colnames</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* not needed for named target type */ 
</span>    <a href="parse_coerce.c.html#LN939"><span class='Ref_To_Local'>rowexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN998"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN937"><span class='Ref_to_Parameter'>location</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN939"><span class='Ref_To_Local'>rowexpr</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end coerce_record_to_complex &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * coerce_to_boolean() 
 *      Coerce an argument of a construct that requires boolean input 
 *      (AND, OR, NOT, etc).  Also check that input is not a set. 
 * 
 * Returns the possibly-transformed node tree. 
 * 
 * As with coerce_type, pstate may be NULL if no special unknown-Param 
 * processing is wanted. 
 */ 
</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN1061"></a><span class='Declare_Function'>coerce_to_boolean</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, 
</span><a name="LN1062"></a>                  <span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>constructName</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1064"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>inputTypeId</span> <span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1061"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1064"><span class='Ref_To_Local'>inputTypeId</span></a> <span class='Operator'>!= </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN17"><span class='Ref_to_Const'>BOOLOID</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1068"></a>        <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>newnode</span><span class='Delimiter'>; 
</span> 
        <a href="parse_coerce.c.html#LN1068"><span class='Ref_To_Local'>newnode</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN37"><span class='Ref_to_Proto'>coerce_to_target_type</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1061"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN1061"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN1064"><span class='Ref_To_Local'>inputTypeId</span></a><span class='Delimiter'>, 
</span>                                        <a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN17"><span class='Ref_to_Const'>BOOLOID</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                                        <a href="../../include/nodes/primnodes.h.html#LN421"><span class='Ref_to_EnumConst'>COERCION_ASSIGNMENT</span></a><span class='Delimiter'>, 
</span>                                        <a href="../../include/nodes/primnodes.h.html#LN438"><span class='Ref_to_EnumConst'>COERCE_IMPLICIT_CAST</span></a><span class='Delimiter'>, 
</span>                                        <span class='Operator'>-</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1068"><span class='Ref_To_Local'>newnode</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_DATATYPE_MISMATCH<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>            <span class='Comment_Multi_Line'>/* translator: first %s is name of a SQL construct, eg WHERE */ 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"argument of %s must be type %s, not type %s"</span><span class='Delimiter'>, 
</span>                            <a href="parse_coerce.c.html#LN1062"><span class='Ref_to_Parameter'>constructName</span></a><span class='Delimiter'>, </span><span class='String'>"boolean"</span><span class='Delimiter'>, 
</span>                            <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1064"><span class='Ref_To_Local'>inputTypeId</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1061"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1061"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>        <a href="parse_coerce.c.html#LN1061"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN1068"><span class='Ref_To_Local'>newnode</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodeFuncs.h.html#LN36"><span class='Ref_to_Proto'>expression_returns_set</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1061"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>))</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_DATATYPE_MISMATCH<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>        <span class='Comment_Multi_Line'>/* translator: %s is name of a SQL construct, eg WHERE */ 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"argument of %s must not return a set"</span><span class='Delimiter'>, 
</span>                        <a href="parse_coerce.c.html#LN1062"><span class='Ref_to_Parameter'>constructName</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1061"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1061"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="parse_coerce.c.html#LN1061"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end coerce_to_boolean &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * coerce_to_specific_type_typmod() 
 *      Coerce an argument of a construct that requires a specific data type, 
 *      with a specific typmod.  Also check that input is not a set. 
 * 
 * Returns the possibly-transformed node tree. 
 * 
 * As with coerce_type, pstate may be NULL if no special unknown-Param 
 * processing is wanted. 
 */ 
</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN1108"></a><span class='Declare_Function'>coerce_to_specific_type_typmod</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, 
</span><a name="LN1109"></a>                               <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>targetTypeId</span><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a> <span class='Declare_Parameter'>targetTypmod</span><span class='Delimiter'>, 
</span><a name="LN1110"></a>                               <span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>constructName</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1112"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>inputTypeId</span> <span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1108"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1112"><span class='Ref_To_Local'>inputTypeId</span></a> <span class='Operator'>!= </span><a href="parse_coerce.c.html#LN1109"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1116"></a>        <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>newnode</span><span class='Delimiter'>; 
</span> 
        <a href="parse_coerce.c.html#LN1116"><span class='Ref_To_Local'>newnode</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN37"><span class='Ref_to_Proto'>coerce_to_target_type</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1108"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN1108"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN1112"><span class='Ref_To_Local'>inputTypeId</span></a><span class='Delimiter'>, 
</span>                                        <a href="parse_coerce.c.html#LN1109"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN1109"><span class='Ref_to_Parameter'>targetTypmod</span></a><span class='Delimiter'>, 
</span>                                        <a href="../../include/nodes/primnodes.h.html#LN421"><span class='Ref_to_EnumConst'>COERCION_ASSIGNMENT</span></a><span class='Delimiter'>, 
</span>                                        <a href="../../include/nodes/primnodes.h.html#LN438"><span class='Ref_to_EnumConst'>COERCE_IMPLICIT_CAST</span></a><span class='Delimiter'>, 
</span>                                        <span class='Operator'>-</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1116"><span class='Ref_To_Local'>newnode</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_DATATYPE_MISMATCH<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>            <span class='Comment_Multi_Line'>/* translator: first %s is name of a SQL construct, eg LIMIT */ 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"argument of %s must be type %s, not type %s"</span><span class='Delimiter'>, 
</span>                            <a href="parse_coerce.c.html#LN1110"><span class='Ref_to_Parameter'>constructName</span></a><span class='Delimiter'>, 
</span>                            <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1109"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                            <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1112"><span class='Ref_To_Local'>inputTypeId</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1108"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1108"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>        <a href="parse_coerce.c.html#LN1108"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN1116"><span class='Ref_To_Local'>newnode</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if inputTypeId!=targetTy... &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodeFuncs.h.html#LN36"><span class='Ref_to_Proto'>expression_returns_set</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1108"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>))</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_DATATYPE_MISMATCH<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>        <span class='Comment_Multi_Line'>/* translator: %s is name of a SQL construct, eg LIMIT */ 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"argument of %s must not return a set"</span><span class='Delimiter'>, 
</span>                        <a href="parse_coerce.c.html#LN1110"><span class='Ref_to_Parameter'>constructName</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1108"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1108"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="parse_coerce.c.html#LN1108"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end coerce_to_specific_type_typmod &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * coerce_to_specific_type() 
 *      Coerce an argument of a construct that requires a specific data type. 
 *      Also check that input is not a set. 
 * 
 * Returns the possibly-transformed node tree. 
 * 
 * As with coerce_type, pstate may be NULL if no special unknown-Param 
 * processing is wanted. 
 */ 
</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN1157"></a><span class='Declare_Function'>coerce_to_specific_type</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, 
</span><a name="LN1158"></a>                        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>targetTypeId</span><span class='Delimiter'>, 
</span><a name="LN1159"></a>                        <span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>constructName</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="../../include/parser/parse_coerce.h.html#LN60"><span class='Ref_to_Proto'>coerce_to_specific_type_typmod</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1157"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN1157"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, 
</span>                                          <a href="parse_coerce.c.html#LN1158"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                                          <a href="parse_coerce.c.html#LN1159"><span class='Ref_to_Parameter'>constructName</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * parser_coercion_errposition - report coercion error location, if possible 
 * 
 * We prefer to point at the coercion request (CAST, ::, etc) if possible; 
 * but there may be no such location in the case of an implicit coercion. 
 * In that case point at the input expression. 
 * 
 * XXX possibly this is more generally useful than coercion errors; 
 * if so, should rename and place with parser_errposition. 
 */ 
</span><span class='Keyword'>int 
</span><a name="LN1177"></a><span class='Declare_Function'>parser_coercion_errposition</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, 
</span><a name="LN1178"></a>                            <span class='Keyword'>int </span><span class='Declare_Parameter'>coerce_location</span><span class='Delimiter'>, 
</span><a name="LN1179"></a>                            <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>input_expr</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1178"><span class='Ref_to_Parameter'>coerce_location</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1177"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN1178"><span class='Ref_to_Parameter'>coerce_location</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <span class='Control'>return</span> <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1177"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1179"><span class='Ref_to_Parameter'>input_expr</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * select_common_type() 
 *      Determine the common supertype of a list of input expressions. 
 *      This is used for determining the output type of CASE, UNION, 
 *      and similar constructs. 
 * 
 * 'exprs' is a *nonempty* list of expressions.  Note that earlier items 
 * in the list will be preferred if there is doubt. 
 * 'context' is a phrase to use in the error message if we fail to select 
 * a usable type.  Pass NULL to have the routine return InvalidOid 
 * rather than throwing an error on failure. 
 * 'which_expr': if not NULL, receives a pointer to the particular input 
 * expression from which the result type was taken. 
 */ 
</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> 
<a name="LN1203"></a><span class='Declare_Function'>select_common_type</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>exprs</span><span class='Delimiter'>, </span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Delimiter'>, 
</span><a name="LN1204"></a>                   <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>which_expr</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1206"></a>    <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>pexpr</span><span class='Delimiter'>; 
</span><a name="LN1207"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>ptype</span><span class='Delimiter'>; 
</span><a name="LN1208"></a>    <a href="../../include/parser/parse_coerce.h.html#LN20"><span class='Ref_to_Typedef'>TYPCATEGORY</span></a> <span class='Declare_Local'>pcategory</span><span class='Delimiter'>; 
</span><a name="LN1209"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>pispreferred</span><span class='Delimiter'>; 
</span><a name="LN1210"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1203"><span class='Ref_to_Parameter'>exprs</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="parse_coerce.c.html#LN1206"><span class='Ref_To_Local'>pexpr</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1203"><span class='Ref_to_Parameter'>exprs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="parse_coerce.c.html#LN1210"><span class='Ref_To_Local'>lc</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1203"><span class='Ref_to_Parameter'>exprs</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="parse_coerce.c.html#LN1207"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1206"><span class='Ref_To_Local'>pexpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If all input types are valid and exactly the same, just pick that type. 
     * This is the only way that we will resolve the result as being a domain 
     * type; otherwise domains are smashed to their base types for comparison. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1207"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>!= </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN43"><span class='Ref_to_Const'>UNKNOWNOID</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../include/nodes/pg_list.h.html#LN168"><span class='Ref_to_Macro'>for_each_cell</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1210"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN1210"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1226"></a>            <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>nexpr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1210"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1227"></a>            <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>ntype</span> <span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1226"><span class='Ref_To_Local'>nexpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1227"><span class='Ref_To_Local'>ntype</span></a> <span class='Operator'>!= </span><a href="parse_coerce.c.html#LN1207"><span class='Ref_To_Local'>ptype</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1210"><span class='Ref_To_Local'>lc</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span>         <span class='Comment_Single_Line'>/* got to the end of the list? */ 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1204"><span class='Ref_to_Parameter'>which_expr</span></a><span class='Parentheses'>) 
</span>                <span class='Operator'>*</span><a href="parse_coerce.c.html#LN1204"><span class='Ref_to_Parameter'>which_expr</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN1206"><span class='Ref_To_Local'>pexpr</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <a href="parse_coerce.c.html#LN1207"><span class='Ref_To_Local'>ptype</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Nope, so set up for the full algorithm.  Note that at this point, lc 
     * points to the first list item with type different from pexpr's; we need 
     * not re-examine any items the previous loop advanced over. 
     */ 
</span>    <a href="parse_coerce.c.html#LN1207"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN168"><span class='Ref_to_Proto'>getBaseType</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1207"><span class='Ref_To_Local'>ptype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/utils/lsyscache.h.html#LN153"><span class='Ref_to_Proto'>get_type_category_preferred</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1207"><span class='Ref_To_Local'>ptype</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_coerce.c.html#LN1208"><span class='Ref_To_Local'>pcategory</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_coerce.c.html#LN1209"><span class='Ref_To_Local'>pispreferred</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN168"><span class='Ref_to_Macro'>for_each_cell</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1210"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN1210"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1250"></a>        <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>nexpr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1210"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1251"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>ntype</span> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN168"><span class='Ref_to_Proto'>getBaseType</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1250"><span class='Ref_To_Local'>nexpr</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* move on to next one if no new information... */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1251"><span class='Ref_To_Local'>ntype</span></a> <span class='Operator'>!= </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN43"><span class='Ref_to_Const'>UNKNOWNOID</span></a> <span class='Operator'>&& </span><a href="parse_coerce.c.html#LN1251"><span class='Ref_To_Local'>ntype</span></a> <span class='Operator'>!= </span><a href="parse_coerce.c.html#LN1207"><span class='Ref_To_Local'>ptype</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1256"></a>            <a href="../../include/parser/parse_coerce.h.html#LN20"><span class='Ref_to_Typedef'>TYPCATEGORY</span></a> <span class='Declare_Local'>ncategory</span><span class='Delimiter'>; 
</span><a name="LN1257"></a>            <span class='Keyword'>bool</span>        <span class='Declare_Local'>nispreferred</span><span class='Delimiter'>; 
</span> 
            <a href="../../include/utils/lsyscache.h.html#LN153"><span class='Ref_to_Proto'>get_type_category_preferred</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1251"><span class='Ref_To_Local'>ntype</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_coerce.c.html#LN1256"><span class='Ref_To_Local'>ncategory</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_coerce.c.html#LN1257"><span class='Ref_To_Local'>nispreferred</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1207"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>== </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN43"><span class='Ref_to_Const'>UNKNOWNOID</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* so far, only unknowns so take anything... */ 
</span>                <a href="parse_coerce.c.html#LN1206"><span class='Ref_To_Local'>pexpr</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN1250"><span class='Ref_To_Local'>nexpr</span></a><span class='Delimiter'>; 
</span>                <a href="parse_coerce.c.html#LN1207"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN1251"><span class='Ref_To_Local'>ntype</span></a><span class='Delimiter'>; 
</span>                <a href="parse_coerce.c.html#LN1208"><span class='Ref_To_Local'>pcategory</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN1256"><span class='Ref_To_Local'>ncategory</span></a><span class='Delimiter'>; 
</span>                <a href="parse_coerce.c.html#LN1209"><span class='Ref_To_Local'>pispreferred</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN1257"><span class='Ref_To_Local'>nispreferred</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1256"><span class='Ref_To_Local'>ncategory</span></a> <span class='Operator'>!= </span><a href="parse_coerce.c.html#LN1208"><span class='Ref_To_Local'>pcategory</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * both types in different categories? then not much hope... 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1203"><span class='Ref_to_Parameter'>context</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>                    <span class='Control'>return</span> <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_DATATYPE_MISMATCH<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                <span class='Comment_Multi_Line'>/*------ 
                  translator: first %s is name of a SQL construct, eg CASE */ 
</span>                         <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"%s types %s and %s cannot be matched"</span><span class='Delimiter'>, 
</span>                                <a href="parse_coerce.c.html#LN1203"><span class='Ref_to_Parameter'>context</span></a><span class='Delimiter'>, 
</span>                                <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1207"><span class='Ref_To_Local'>ptype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1251"><span class='Ref_To_Local'>ntype</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                         <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1203"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1250"><span class='Ref_To_Local'>nexpr</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_coerce.c.html#LN1209"><span class='Ref_To_Local'>pispreferred</span></a> <span class='Operator'>&& 
</span>                     <a href="../../include/parser/parse_coerce.h.html#LN43"><span class='Ref_to_Proto'>can_coerce_type</span></a><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_coerce.c.html#LN1207"><span class='Ref_To_Local'>ptype</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_coerce.c.html#LN1251"><span class='Ref_To_Local'>ntype</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN420"><span class='Ref_to_EnumConst'>COERCION_IMPLICIT</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                     <span class='Operator'>!</span><a href="../../include/parser/parse_coerce.h.html#LN43"><span class='Ref_to_Proto'>can_coerce_type</span></a><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_coerce.c.html#LN1251"><span class='Ref_To_Local'>ntype</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_coerce.c.html#LN1207"><span class='Ref_To_Local'>ptype</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN420"><span class='Ref_to_EnumConst'>COERCION_IMPLICIT</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * take new type if can coerce to it implicitly but not the 
                 * other way; but if we have a preferred type, stay on it. 
                 */ 
</span>                <a href="parse_coerce.c.html#LN1206"><span class='Ref_To_Local'>pexpr</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN1250"><span class='Ref_To_Local'>nexpr</span></a><span class='Delimiter'>; 
</span>                <a href="parse_coerce.c.html#LN1207"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN1251"><span class='Ref_To_Local'>ntype</span></a><span class='Delimiter'>; 
</span>                <a href="parse_coerce.c.html#LN1208"><span class='Ref_To_Local'>pcategory</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN1256"><span class='Ref_To_Local'>ncategory</span></a><span class='Delimiter'>; 
</span>                <a href="parse_coerce.c.html#LN1209"><span class='Ref_To_Local'>pispreferred</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN1257"><span class='Ref_To_Local'>nispreferred</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if ntype!=UNKNOWNOID&&nt... &raquo; </span> 
    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If all the inputs were UNKNOWN type --- ie, unknown-type literals --- 
     * then resolve as type TEXT.  This situation comes up with constructs 
     * like SELECT (CASE WHEN foo THEN 'bar' ELSE 'baz' END); SELECT 'foo' 
     * UNION SELECT 'bar'; It might seem desirable to leave the construct's 
     * output type as UNKNOWN, but that really doesn't work, because we'd 
     * probably end up needing a runtime coercion from UNKNOWN to something 
     * else, and we usually won't have it.  We need to coerce the unknown 
     * literals while they are still literals, so a decision has to be made 
     * now. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1207"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>== </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN43"><span class='Ref_to_Const'>UNKNOWNOID</span></a><span class='Parentheses'>) 
</span>        <a href="parse_coerce.c.html#LN1207"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN26"><span class='Ref_to_Const'>TEXTOID</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1204"><span class='Ref_to_Parameter'>which_expr</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>*</span><a href="parse_coerce.c.html#LN1204"><span class='Ref_to_Parameter'>which_expr</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN1206"><span class='Ref_To_Local'>pexpr</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="parse_coerce.c.html#LN1207"><span class='Ref_To_Local'>ptype</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end select_common_type &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * coerce_to_common_type() 
 *      Coerce an expression to the given type. 
 * 
 * This is used following select_common_type() to coerce the individual 
 * expressions to the desired type.  'context' is a phrase to use in the 
 * error message if we fail to coerce. 
 * 
 * As with coerce_type, pstate may be NULL if no special unknown-Param 
 * processing is wanted. 
 */ 
</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN1332"></a><span class='Declare_Function'>coerce_to_common_type</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, 
</span><a name="LN1333"></a>                      <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>targetTypeId</span><span class='Delimiter'>, </span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1335"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>inputTypeId</span> <span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1332"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1335"><span class='Ref_To_Local'>inputTypeId</span></a> <span class='Operator'>== </span><a href="parse_coerce.c.html#LN1333"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="parse_coerce.c.html#LN1332"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* no work */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/parser/parse_coerce.h.html#LN43"><span class='Ref_to_Proto'>can_coerce_type</span></a><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_coerce.c.html#LN1335"><span class='Ref_To_Local'>inputTypeId</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_coerce.c.html#LN1333"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN420"><span class='Ref_to_EnumConst'>COERCION_IMPLICIT</span></a><span class='Parentheses'>))</span> 
        <a href="parse_coerce.c.html#LN1332"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN45"><span class='Ref_to_Proto'>coerce_type</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1332"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN1332"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN1335"><span class='Ref_To_Local'>inputTypeId</span></a><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN1333"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                           <a href="../../include/nodes/primnodes.h.html#LN420"><span class='Ref_to_EnumConst'>COERCION_IMPLICIT</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN438"><span class='Ref_to_EnumConst'>COERCE_IMPLICIT_CAST</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_CANNOT_COERCE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>        <span class='Comment_Multi_Line'>/* translator: first %s is name of a SQL construct, eg CASE */ 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"%s could not convert type %s to %s"</span><span class='Delimiter'>, 
</span>                        <a href="parse_coerce.c.html#LN1333"><span class='Ref_to_Parameter'>context</span></a><span class='Delimiter'>, 
</span>                        <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1335"><span class='Ref_To_Local'>inputTypeId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                        <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1333"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                 <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1332"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1332"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="parse_coerce.c.html#LN1332"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end coerce_to_common_type &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * check_generic_type_consistency() 
 *      Are the actual arguments potentially compatible with a 
 *      polymorphic function? 
 * 
 * The argument consistency rules are: 
 * 
 * 1) All arguments declared ANYELEMENT must have the same datatype. 
 * 2) All arguments declared ANYARRAY must have the same datatype, 
 *    which must be a varlena array type. 
 * 3) All arguments declared ANYRANGE must have the same datatype, 
 *    which must be a range type. 
 * 4) If there are arguments of both ANYELEMENT and ANYARRAY, make sure the 
 *    actual ANYELEMENT datatype is in fact the element type for the actual 
 *    ANYARRAY datatype. 
 * 5) Similarly, if there are arguments of both ANYELEMENT and ANYRANGE, 
 *    make sure the actual ANYELEMENT datatype is in fact the subtype for 
 *    the actual ANYRANGE type. 
 * 6) ANYENUM is treated the same as ANYELEMENT except that if it is used 
 *    (alone or in combination with plain ANYELEMENT), we add the extra 
 *    condition that the ANYELEMENT type must be an enum. 
 * 7) ANYNONARRAY is treated the same as ANYELEMENT except that if it is used, 
 *    we add the extra condition that the ANYELEMENT type must not be an array. 
 *    (This is a no-op if used in combination with ANYARRAY or ANYENUM, but 
 *    is an extra restriction if not.) 
 * 
 * Domains over arrays match ANYARRAY, and are immediately flattened to their 
 * base type.  (Thus, for example, we will consider it a match if one ANYARRAY 
 * argument is a domain over int4[] while another one is just int4[].)  Also 
 * notice that such a domain does *not* match ANYNONARRAY. 
 * 
 * Similarly, domains over ranges match ANYRANGE, and are immediately 
 * flattened to their base type. 
 * 
 * Note that domains aren't currently considered to match ANYENUM, 
 * even if their base type would match. 
 * 
 * If we have UNKNOWN input (ie, an untyped literal) for any polymorphic 
 * argument, assume it is okay. 
 * 
 * If an input is of type ANYARRAY (ie, we know it's an array, but not 
 * what element type), we will accept it as a match to an argument declared 
 * ANYARRAY, so long as we don't have to determine an element type --- 
 * that is, so long as there is no use of ANYELEMENT.  This is mostly for 
 * backwards compatibility with the pre-7.4 behavior of ANYARRAY. 
 * 
 * We do not ereport here, but just return FALSE if a rule is violated. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN1403"></a><span class='Declare_Function'>check_generic_type_consistency</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>actual_arg_types</span><span class='Delimiter'>, 
</span><a name="LN1404"></a>                               <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>declared_arg_types</span><span class='Delimiter'>, 
</span><a name="LN1405"></a>                               <span class='Keyword'>int </span><span class='Declare_Parameter'>nargs</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1407"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>j</span><span class='Delimiter'>; 
</span><a name="LN1408"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>elem_typeid</span> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span><a name="LN1409"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>array_typeid</span> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span><a name="LN1410"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>array_typelem</span><span class='Delimiter'>; 
</span><a name="LN1411"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>range_typeid</span> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span><a name="LN1412"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>range_typelem</span><span class='Delimiter'>; 
</span><a name="LN1413"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>have_anyelement</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN1414"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>have_anynonarray</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN1415"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>have_anyenum</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Loop through the arguments to see if we have any that are polymorphic. 
     * If so, require the actual types to be consistent. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1407"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="parse_coerce.c.html#LN1407"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>&LT; </span><a href="parse_coerce.c.html#LN1405"><span class='Ref_to_Parameter'>nargs</span></a><span class='Delimiter'>; </span><a href="parse_coerce.c.html#LN1407"><span class='Ref_To_Local'>j</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1423"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>decl_type</span> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN1404"><span class='Ref_to_Parameter'>declared_arg_types</span></a><span class='Delimiter'>[</span><a href="parse_coerce.c.html#LN1407"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]; 
</span><a name="LN1424"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>actual_type</span> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN1403"><span class='Ref_to_Parameter'>actual_arg_types</span></a><span class='Delimiter'>[</span><a href="parse_coerce.c.html#LN1407"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1423"><span class='Ref_To_Local'>decl_type</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN701"><span class='Ref_to_Const'>ANYELEMENTOID</span></a> <span class='Operator'>|| 
</span>            <a href="parse_coerce.c.html#LN1423"><span class='Ref_To_Local'>decl_type</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN703"><span class='Ref_to_Const'>ANYNONARRAYOID</span></a> <span class='Operator'>|| 
</span>            <a href="parse_coerce.c.html#LN1423"><span class='Ref_To_Local'>decl_type</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN705"><span class='Ref_to_Const'>ANYENUMOID</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="parse_coerce.c.html#LN1413"><span class='Ref_To_Local'>have_anyelement</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1423"><span class='Ref_To_Local'>decl_type</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN703"><span class='Ref_to_Const'>ANYNONARRAYOID</span></a><span class='Parentheses'>) 
</span>                <a href="parse_coerce.c.html#LN1414"><span class='Ref_To_Local'>have_anynonarray</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1423"><span class='Ref_To_Local'>decl_type</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN705"><span class='Ref_to_Const'>ANYENUMOID</span></a><span class='Parentheses'>) 
</span>                <a href="parse_coerce.c.html#LN1415"><span class='Ref_To_Local'>have_anyenum</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1424"><span class='Ref_To_Local'>actual_type</span></a> <span class='Operator'>== </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN43"><span class='Ref_to_Const'>UNKNOWNOID</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1408"><span class='Ref_To_Local'>elem_typeid</span></a><span class='Parentheses'>) </span><span class='Operator'>&& </span><a href="parse_coerce.c.html#LN1424"><span class='Ref_To_Local'>actual_type</span></a> <span class='Operator'>!= </span><a href="parse_coerce.c.html#LN1408"><span class='Ref_To_Local'>elem_typeid</span></a><span class='Parentheses'>)</span> 
                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="parse_coerce.c.html#LN1408"><span class='Ref_To_Local'>elem_typeid</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN1424"><span class='Ref_To_Local'>actual_type</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1423"><span class='Ref_To_Local'>decl_type</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN687"><span class='Ref_to_Const'>ANYARRAYOID</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1424"><span class='Ref_To_Local'>actual_type</span></a> <span class='Operator'>== </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN43"><span class='Ref_to_Const'>UNKNOWNOID</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <a href="parse_coerce.c.html#LN1424"><span class='Ref_To_Local'>actual_type</span></a> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN168"><span class='Ref_to_Proto'>getBaseType</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1424"><span class='Ref_To_Local'>actual_type</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* flatten domains */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1409"><span class='Ref_To_Local'>array_typeid</span></a><span class='Parentheses'>) </span><span class='Operator'>&& </span><a href="parse_coerce.c.html#LN1424"><span class='Ref_To_Local'>actual_type</span></a> <span class='Operator'>!= </span><a href="parse_coerce.c.html#LN1409"><span class='Ref_To_Local'>array_typeid</span></a><span class='Parentheses'>)</span> 
                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="parse_coerce.c.html#LN1409"><span class='Ref_To_Local'>array_typeid</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN1424"><span class='Ref_To_Local'>actual_type</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1423"><span class='Ref_To_Local'>decl_type</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN713"><span class='Ref_to_Const'>ANYRANGEOID</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1424"><span class='Ref_To_Local'>actual_type</span></a> <span class='Operator'>== </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN43"><span class='Ref_to_Const'>UNKNOWNOID</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <a href="parse_coerce.c.html#LN1424"><span class='Ref_To_Local'>actual_type</span></a> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN168"><span class='Ref_to_Proto'>getBaseType</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1424"><span class='Ref_To_Local'>actual_type</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* flatten domains */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1411"><span class='Ref_To_Local'>range_typeid</span></a><span class='Parentheses'>) </span><span class='Operator'>&& </span><a href="parse_coerce.c.html#LN1424"><span class='Ref_To_Local'>actual_type</span></a> <span class='Operator'>!= </span><a href="parse_coerce.c.html#LN1411"><span class='Ref_To_Local'>range_typeid</span></a><span class='Parentheses'>)</span> 
                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="parse_coerce.c.html#LN1411"><span class='Ref_To_Local'>range_typeid</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN1424"><span class='Ref_To_Local'>actual_type</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for j=0;j&LT;nargs;j++ &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Get the element type based on the array type, if we have one */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1409"><span class='Ref_To_Local'>array_typeid</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1409"><span class='Ref_To_Local'>array_typeid</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN687"><span class='Ref_to_Const'>ANYARRAYOID</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Special case for ANYARRAY input: okay iff no ANYELEMENT */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1413"><span class='Ref_To_Local'>have_anyelement</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="parse_coerce.c.html#LN1410"><span class='Ref_To_Local'>array_typelem</span></a> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN157"><span class='Ref_to_Proto'>get_element_type</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1409"><span class='Ref_To_Local'>array_typeid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1410"><span class='Ref_To_Local'>array_typelem</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* should be an array, but isn't */ 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1408"><span class='Ref_To_Local'>elem_typeid</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * if we don't have an element type yet, use the one we just got 
             */ 
</span>            <a href="parse_coerce.c.html#LN1408"><span class='Ref_To_Local'>elem_typeid</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN1410"><span class='Ref_To_Local'>array_typelem</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1410"><span class='Ref_To_Local'>array_typelem</span></a> <span class='Operator'>!= </span><a href="parse_coerce.c.html#LN1408"><span class='Ref_To_Local'>elem_typeid</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* otherwise, they better match */ 
</span>            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if OidIsValid(array_type... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Get the element type based on the range type, if we have one */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1411"><span class='Ref_To_Local'>range_typeid</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="parse_coerce.c.html#LN1412"><span class='Ref_To_Local'>range_typelem</span></a> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN177"><span class='Ref_to_Proto'>get_range_subtype</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1411"><span class='Ref_To_Local'>range_typeid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1412"><span class='Ref_To_Local'>range_typelem</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* should be a range, but isn't */ 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1408"><span class='Ref_To_Local'>elem_typeid</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * if we don't have an element type yet, use the one we just got 
             */ 
</span>            <a href="parse_coerce.c.html#LN1408"><span class='Ref_To_Local'>elem_typeid</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN1412"><span class='Ref_To_Local'>range_typelem</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1412"><span class='Ref_To_Local'>range_typelem</span></a> <span class='Operator'>!= </span><a href="parse_coerce.c.html#LN1408"><span class='Ref_To_Local'>elem_typeid</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* otherwise, they better match */ 
</span>            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1414"><span class='Ref_To_Local'>have_anynonarray</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* require the element type to not be an array or domain over array */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/utils/lsyscache.h.html#LN181"><span class='Ref_to_Macro'>type_is_array_domain</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1408"><span class='Ref_To_Local'>elem_typeid</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1415"><span class='Ref_To_Local'>have_anyenum</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* require the element type to be an enum */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/utils/lsyscache.h.html#LN151"><span class='Ref_to_Proto'>type_is_enum</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1408"><span class='Ref_To_Local'>elem_typeid</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Looks valid */ 
</span>    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end check_generic_type_consistency &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * enforce_generic_type_consistency() 
 *      Make sure a polymorphic function is legally callable, and 
 *      deduce actual argument and result types. 
 * 
 * If any polymorphic pseudotype is used in a function's arguments or 
 * return type, we make sure the actual data types are consistent with 
 * each other.  The argument consistency rules are shown above for 
 * check_generic_type_consistency(). 
 * 
 * If we have UNKNOWN input (ie, an untyped literal) for any polymorphic 
 * argument, we attempt to deduce the actual type it should have.  If 
 * successful, we alter that position of declared_arg_types[] so that 
 * make_fn_arguments will coerce the literal to the right thing. 
 * 
 * Rules are applied to the function's return type (possibly altering it) 
 * if it is declared as a polymorphic type: 
 * 
 * 1) If return type is ANYARRAY, and any argument is ANYARRAY, use the 
 *    argument's actual type as the function's return type. 
 * 2) Similarly, if return type is ANYRANGE, and any argument is ANYRANGE, 
 *    use the argument's actual type as the function's return type. 
 * 3) If return type is ANYARRAY, no argument is ANYARRAY, but any argument is 
 *    ANYELEMENT, use the actual type of the argument to determine the 
 *    function's return type, i.e. the element type's corresponding array 
 *    type.  (Note: similar behavior does not exist for ANYRANGE, because it's 
 *    impossible to determine the range type from the subtype alone.) 
 * 4) If return type is ANYARRAY, but no argument is ANYARRAY or ANYELEMENT, 
 *    generate an error.  Similarly, if return type is ANYRANGE, but no 
 *    argument is ANYRANGE, generate an error.  (These conditions are 
 *    prevented by CREATE FUNCTION and therefore are not expected here.) 
 * 5) If return type is ANYELEMENT, and any argument is ANYELEMENT, use the 
 *    argument's actual type as the function's return type. 
 * 6) If return type is ANYELEMENT, no argument is ANYELEMENT, but any argument 
 *    is ANYARRAY or ANYRANGE, use the actual type of the argument to determine 
 *    the function's return type, i.e. the array type's corresponding element 
 *    type or the range type's corresponding subtype (or both, in which case 
 *    they must match). 
 * 7) If return type is ANYELEMENT, no argument is ANYELEMENT, ANYARRAY, or 
 *    ANYRANGE, generate an error.  (This condition is prevented by CREATE 
 *    FUNCTION and therefore is not expected here.) 
 * 8) ANYENUM is treated the same as ANYELEMENT except that if it is used 
 *    (alone or in combination with plain ANYELEMENT), we add the extra 
 *    condition that the ANYELEMENT type must be an enum. 
 * 9) ANYNONARRAY is treated the same as ANYELEMENT except that if it is used, 
 *    we add the extra condition that the ANYELEMENT type must not be an array. 
 *    (This is a no-op if used in combination with ANYARRAY or ANYENUM, but 
 *    is an extra restriction if not.) 
 * 
 * Domains over arrays or ranges match ANYARRAY or ANYRANGE arguments, 
 * respectively, and are immediately flattened to their base type. (In 
 * particular, if the return type is also ANYARRAY or ANYRANGE, we'll set it 
 * to the base type not the domain type.) 
 * 
 * When allow_poly is false, we are not expecting any of the actual_arg_types 
 * to be polymorphic, and we should not return a polymorphic result type 
 * either.  When allow_poly is true, it is okay to have polymorphic "actual" 
 * arg types, and we can return ANYARRAY, ANYRANGE, or ANYELEMENT as the 
 * result.  (This case is currently used only to check compatibility of an 
 * aggregate's declaration with the underlying transfn.) 
 * 
 * A special case is that we could see ANYARRAY as an actual_arg_type even 
 * when allow_poly is false (this is possible only because pg_statistic has 
 * columns shown as anyarray in the catalogs).  We allow this to match a 
 * declared ANYARRAY argument, but only if there is no ANYELEMENT argument 
 * or result (since we can't determine a specific element type to match to 
 * ANYELEMENT).  Note this means that functions taking ANYARRAY had better 
 * behave sanely if applied to the pg_statistic columns; they can't just 
 * assume that successive inputs are of the same actual element type. 
 */ 
</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> 
<a name="LN1600"></a><span class='Declare_Function'>enforce_generic_type_consistency</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>actual_arg_types</span><span class='Delimiter'>, 
</span><a name="LN1601"></a>                                 <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>declared_arg_types</span><span class='Delimiter'>, 
</span><a name="LN1602"></a>                                 <span class='Keyword'>int </span><span class='Declare_Parameter'>nargs</span><span class='Delimiter'>, 
</span><a name="LN1603"></a>                                 <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>rettype</span><span class='Delimiter'>, 
</span><a name="LN1604"></a>                                 <span class='Keyword'>bool </span><span class='Declare_Parameter'>allow_poly</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1606"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>j</span><span class='Delimiter'>; 
</span><a name="LN1607"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>have_generics</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN1608"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>have_unknowns</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN1609"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>elem_typeid</span> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span><a name="LN1610"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>array_typeid</span> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span><a name="LN1611"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>range_typeid</span> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span><a name="LN1612"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>array_typelem</span><span class='Delimiter'>; 
</span><a name="LN1613"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>range_typelem</span><span class='Delimiter'>; 
</span><a name="LN1614"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>have_anyelement</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1603"><span class='Ref_to_Parameter'>rettype</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN701"><span class='Ref_to_Const'>ANYELEMENTOID</span></a> <span class='Operator'>|| 
</span>                                   <a href="parse_coerce.c.html#LN1603"><span class='Ref_to_Parameter'>rettype</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN703"><span class='Ref_to_Const'>ANYNONARRAYOID</span></a> <span class='Operator'>|| 
</span>                                   <a href="parse_coerce.c.html#LN1603"><span class='Ref_to_Parameter'>rettype</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN705"><span class='Ref_to_Const'>ANYENUMOID</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1617"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>have_anynonarray</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1603"><span class='Ref_to_Parameter'>rettype</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN703"><span class='Ref_to_Const'>ANYNONARRAYOID</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1618"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>have_anyenum</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1603"><span class='Ref_to_Parameter'>rettype</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN705"><span class='Ref_to_Const'>ANYENUMOID</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Loop through the arguments to see if we have any that are polymorphic. 
     * If so, require the actual types to be consistent. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1606"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="parse_coerce.c.html#LN1606"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>&LT; </span><a href="parse_coerce.c.html#LN1602"><span class='Ref_to_Parameter'>nargs</span></a><span class='Delimiter'>; </span><a href="parse_coerce.c.html#LN1606"><span class='Ref_To_Local'>j</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1626"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>decl_type</span> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN1601"><span class='Ref_to_Parameter'>declared_arg_types</span></a><span class='Delimiter'>[</span><a href="parse_coerce.c.html#LN1606"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]; 
</span><a name="LN1627"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>actual_type</span> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN1600"><span class='Ref_to_Parameter'>actual_arg_types</span></a><span class='Delimiter'>[</span><a href="parse_coerce.c.html#LN1606"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1626"><span class='Ref_To_Local'>decl_type</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN701"><span class='Ref_to_Const'>ANYELEMENTOID</span></a> <span class='Operator'>|| 
</span>            <a href="parse_coerce.c.html#LN1626"><span class='Ref_To_Local'>decl_type</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN703"><span class='Ref_to_Const'>ANYNONARRAYOID</span></a> <span class='Operator'>|| 
</span>            <a href="parse_coerce.c.html#LN1626"><span class='Ref_To_Local'>decl_type</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN705"><span class='Ref_to_Const'>ANYENUMOID</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="parse_coerce.c.html#LN1607"><span class='Ref_To_Local'>have_generics</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN1614"><span class='Ref_To_Local'>have_anyelement</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1626"><span class='Ref_To_Local'>decl_type</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN703"><span class='Ref_to_Const'>ANYNONARRAYOID</span></a><span class='Parentheses'>) 
</span>                <a href="parse_coerce.c.html#LN1617"><span class='Ref_To_Local'>have_anynonarray</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1626"><span class='Ref_To_Local'>decl_type</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN705"><span class='Ref_to_Const'>ANYENUMOID</span></a><span class='Parentheses'>) 
</span>                <a href="parse_coerce.c.html#LN1618"><span class='Ref_To_Local'>have_anyenum</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1627"><span class='Ref_To_Local'>actual_type</span></a> <span class='Operator'>== </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN43"><span class='Ref_to_Const'>UNKNOWNOID</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="parse_coerce.c.html#LN1608"><span class='Ref_To_Local'>have_unknowns</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1604"><span class='Ref_to_Parameter'>allow_poly</span></a> <span class='Operator'>&& </span><a href="parse_coerce.c.html#LN1626"><span class='Ref_To_Local'>decl_type</span></a> <span class='Operator'>== </span><a href="parse_coerce.c.html#LN1627"><span class='Ref_To_Local'>actual_type</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>continue</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* no new information here */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1609"><span class='Ref_To_Local'>elem_typeid</span></a><span class='Parentheses'>) </span><span class='Operator'>&& </span><a href="parse_coerce.c.html#LN1627"><span class='Ref_To_Local'>actual_type</span></a> <span class='Operator'>!= </span><a href="parse_coerce.c.html#LN1609"><span class='Ref_To_Local'>elem_typeid</span></a><span class='Parentheses'>)</span> 
                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_DATATYPE_MISMATCH<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"arguments declared \"anyelement\" are not all alike"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"%s versus %s"</span><span class='Delimiter'>, 
</span>                                   <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1609"><span class='Ref_To_Local'>elem_typeid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                   <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1627"><span class='Ref_To_Local'>actual_type</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>            <a href="parse_coerce.c.html#LN1609"><span class='Ref_To_Local'>elem_typeid</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN1627"><span class='Ref_To_Local'>actual_type</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if decl_type==ANYELEMENT... &raquo; </span> 
        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1626"><span class='Ref_To_Local'>decl_type</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN687"><span class='Ref_to_Const'>ANYARRAYOID</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="parse_coerce.c.html#LN1607"><span class='Ref_To_Local'>have_generics</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1627"><span class='Ref_To_Local'>actual_type</span></a> <span class='Operator'>== </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN43"><span class='Ref_to_Const'>UNKNOWNOID</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="parse_coerce.c.html#LN1608"><span class='Ref_To_Local'>have_unknowns</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1604"><span class='Ref_to_Parameter'>allow_poly</span></a> <span class='Operator'>&& </span><a href="parse_coerce.c.html#LN1626"><span class='Ref_To_Local'>decl_type</span></a> <span class='Operator'>== </span><a href="parse_coerce.c.html#LN1627"><span class='Ref_To_Local'>actual_type</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>continue</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* no new information here */ 
</span>            <a href="parse_coerce.c.html#LN1627"><span class='Ref_To_Local'>actual_type</span></a> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN168"><span class='Ref_to_Proto'>getBaseType</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1627"><span class='Ref_To_Local'>actual_type</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* flatten domains */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1610"><span class='Ref_To_Local'>array_typeid</span></a><span class='Parentheses'>) </span><span class='Operator'>&& </span><a href="parse_coerce.c.html#LN1627"><span class='Ref_To_Local'>actual_type</span></a> <span class='Operator'>!= </span><a href="parse_coerce.c.html#LN1610"><span class='Ref_To_Local'>array_typeid</span></a><span class='Parentheses'>)</span> 
                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_DATATYPE_MISMATCH<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"arguments declared \"anyarray\" are not all alike"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"%s versus %s"</span><span class='Delimiter'>, 
</span>                                   <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1610"><span class='Ref_To_Local'>array_typeid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                   <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1627"><span class='Ref_To_Local'>actual_type</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>            <a href="parse_coerce.c.html#LN1610"><span class='Ref_To_Local'>array_typeid</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN1627"><span class='Ref_To_Local'>actual_type</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if decl_type==ANYARRAYOI... &raquo; </span> 
        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1626"><span class='Ref_To_Local'>decl_type</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN713"><span class='Ref_to_Const'>ANYRANGEOID</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="parse_coerce.c.html#LN1607"><span class='Ref_To_Local'>have_generics</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1627"><span class='Ref_To_Local'>actual_type</span></a> <span class='Operator'>== </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN43"><span class='Ref_to_Const'>UNKNOWNOID</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="parse_coerce.c.html#LN1608"><span class='Ref_To_Local'>have_unknowns</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1604"><span class='Ref_to_Parameter'>allow_poly</span></a> <span class='Operator'>&& </span><a href="parse_coerce.c.html#LN1626"><span class='Ref_To_Local'>decl_type</span></a> <span class='Operator'>== </span><a href="parse_coerce.c.html#LN1627"><span class='Ref_To_Local'>actual_type</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>continue</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* no new information here */ 
</span>            <a href="parse_coerce.c.html#LN1627"><span class='Ref_To_Local'>actual_type</span></a> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN168"><span class='Ref_to_Proto'>getBaseType</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1627"><span class='Ref_To_Local'>actual_type</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* flatten domains */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1611"><span class='Ref_To_Local'>range_typeid</span></a><span class='Parentheses'>) </span><span class='Operator'>&& </span><a href="parse_coerce.c.html#LN1627"><span class='Ref_To_Local'>actual_type</span></a> <span class='Operator'>!= </span><a href="parse_coerce.c.html#LN1611"><span class='Ref_To_Local'>range_typeid</span></a><span class='Parentheses'>)</span> 
                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_DATATYPE_MISMATCH<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"arguments declared \"anyrange\" are not all alike"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"%s versus %s"</span><span class='Delimiter'>, 
</span>                                   <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1611"><span class='Ref_To_Local'>range_typeid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                   <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1627"><span class='Ref_To_Local'>actual_type</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>            <a href="parse_coerce.c.html#LN1611"><span class='Ref_To_Local'>range_typeid</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN1627"><span class='Ref_To_Local'>actual_type</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if decl_type==ANYRANGEOI... &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for j=0;j&LT;nargs;j++ &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Fast Track: if none of the arguments are polymorphic, return the 
     * unmodified rettype.  We assume it can't be polymorphic either. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_coerce.c.html#LN1607"><span class='Ref_To_Local'>have_generics</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="parse_coerce.c.html#LN1603"><span class='Ref_to_Parameter'>rettype</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Get the element type based on the array type, if we have one */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1610"><span class='Ref_To_Local'>array_typeid</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1610"><span class='Ref_To_Local'>array_typeid</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN687"><span class='Ref_to_Const'>ANYARRAYOID</span></a> <span class='Operator'>&& !</span><a href="parse_coerce.c.html#LN1614"><span class='Ref_To_Local'>have_anyelement</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Special case for ANYARRAY input: okay iff no ANYELEMENT */ 
</span>            <a href="parse_coerce.c.html#LN1612"><span class='Ref_To_Local'>array_typelem</span></a> <span class='Operator'>= </span><a href="../../include/catalog/pg_type.h.html#LN701"><span class='Ref_to_Const'>ANYELEMENTOID</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="parse_coerce.c.html#LN1612"><span class='Ref_To_Local'>array_typelem</span></a> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN157"><span class='Ref_to_Proto'>get_element_type</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1610"><span class='Ref_To_Local'>array_typeid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1612"><span class='Ref_To_Local'>array_typelem</span></a><span class='Parentheses'>))</span> 
                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_DATATYPE_MISMATCH<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                   <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"argument declared %s is not an array but type %s"</span><span class='Delimiter'>, 
</span>                          <span class='String'>"anyarray"</span><span class='Delimiter'>, </span><a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1610"><span class='Ref_To_Local'>array_typeid</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1609"><span class='Ref_To_Local'>elem_typeid</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * if we don't have an element type yet, use the one we just got 
             */ 
</span>            <a href="parse_coerce.c.html#LN1609"><span class='Ref_To_Local'>elem_typeid</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN1612"><span class='Ref_To_Local'>array_typelem</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1612"><span class='Ref_To_Local'>array_typelem</span></a> <span class='Operator'>!= </span><a href="parse_coerce.c.html#LN1609"><span class='Ref_To_Local'>elem_typeid</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* otherwise, they better match */ 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_DATATYPE_MISMATCH<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"argument declared %s is not consistent with argument declared %s"</span><span class='Delimiter'>, 
</span>                            <span class='String'>"anyarray"</span><span class='Delimiter'>, </span><span class='String'>"anyelement"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"%s versus %s"</span><span class='Delimiter'>, 
</span>                               <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1610"><span class='Ref_To_Local'>array_typeid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                               <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1609"><span class='Ref_To_Local'>elem_typeid</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if OidIsValid(array_type... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Get the element type based on the range type, if we have one */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1611"><span class='Ref_To_Local'>range_typeid</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1611"><span class='Ref_To_Local'>range_typeid</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN713"><span class='Ref_to_Const'>ANYRANGEOID</span></a> <span class='Operator'>&& !</span><a href="parse_coerce.c.html#LN1614"><span class='Ref_To_Local'>have_anyelement</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Special case for ANYRANGE input: okay iff no ANYELEMENT */ 
</span>            <a href="parse_coerce.c.html#LN1613"><span class='Ref_To_Local'>range_typelem</span></a> <span class='Operator'>= </span><a href="../../include/catalog/pg_type.h.html#LN701"><span class='Ref_to_Const'>ANYELEMENTOID</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="parse_coerce.c.html#LN1613"><span class='Ref_To_Local'>range_typelem</span></a> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN177"><span class='Ref_to_Proto'>get_range_subtype</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1611"><span class='Ref_To_Local'>range_typeid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1613"><span class='Ref_To_Local'>range_typelem</span></a><span class='Parentheses'>))</span> 
                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_DATATYPE_MISMATCH<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"argument declared %s is not a range type but type %s"</span><span class='Delimiter'>, 
</span>                       <span class='String'>"anyrange"</span><span class='Delimiter'>, 
</span>                       <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1611"><span class='Ref_To_Local'>range_typeid</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1609"><span class='Ref_To_Local'>elem_typeid</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * if we don't have an element type yet, use the one we just got 
             */ 
</span>            <a href="parse_coerce.c.html#LN1609"><span class='Ref_To_Local'>elem_typeid</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN1613"><span class='Ref_To_Local'>range_typelem</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1613"><span class='Ref_To_Local'>range_typelem</span></a> <span class='Operator'>!= </span><a href="parse_coerce.c.html#LN1609"><span class='Ref_To_Local'>elem_typeid</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* otherwise, they better match */ 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_DATATYPE_MISMATCH<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"argument declared %s is not consistent with argument declared %s"</span><span class='Delimiter'>, 
</span>                            <span class='String'>"anyrange"</span><span class='Delimiter'>, </span><span class='String'>"anyelement"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"%s versus %s"</span><span class='Delimiter'>, 
</span>                               <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1611"><span class='Ref_To_Local'>range_typeid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                               <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1609"><span class='Ref_To_Local'>elem_typeid</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if OidIsValid(range_type... &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1609"><span class='Ref_To_Local'>elem_typeid</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1604"><span class='Ref_to_Parameter'>allow_poly</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="parse_coerce.c.html#LN1609"><span class='Ref_To_Local'>elem_typeid</span></a> <span class='Operator'>= </span><a href="../../include/catalog/pg_type.h.html#LN701"><span class='Ref_to_Const'>ANYELEMENTOID</span></a><span class='Delimiter'>; 
</span>            <a href="parse_coerce.c.html#LN1610"><span class='Ref_To_Local'>array_typeid</span></a> <span class='Operator'>= </span><a href="../../include/catalog/pg_type.h.html#LN687"><span class='Ref_to_Const'>ANYARRAYOID</span></a><span class='Delimiter'>; 
</span>            <a href="parse_coerce.c.html#LN1611"><span class='Ref_To_Local'>range_typeid</span></a> <span class='Operator'>= </span><a href="../../include/catalog/pg_type.h.html#LN713"><span class='Ref_to_Const'>ANYRANGEOID</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Only way to get here is if all the generic args are UNKNOWN */ 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_DATATYPE_MISMATCH<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not determine polymorphic type because input has type %s"</span><span class='Delimiter'>, 
</span>                            <span class='String'>"unknown"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1617"><span class='Ref_To_Local'>have_anynonarray</span></a> <span class='Operator'>&& </span><a href="parse_coerce.c.html#LN1609"><span class='Ref_To_Local'>elem_typeid</span></a> <span class='Operator'>!= </span><a href="../../include/catalog/pg_type.h.html#LN701"><span class='Ref_to_Const'>ANYELEMENTOID</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* require the element type to not be an array or domain over array */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/utils/lsyscache.h.html#LN181"><span class='Ref_to_Macro'>type_is_array_domain</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1609"><span class='Ref_To_Local'>elem_typeid</span></a><span class='Parentheses'>))</span> 
            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_DATATYPE_MISMATCH<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                   <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"type matched to anynonarray is an array type: %s"</span><span class='Delimiter'>, 
</span>                          <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1609"><span class='Ref_To_Local'>elem_typeid</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1618"><span class='Ref_To_Local'>have_anyenum</span></a> <span class='Operator'>&& </span><a href="parse_coerce.c.html#LN1609"><span class='Ref_To_Local'>elem_typeid</span></a> <span class='Operator'>!= </span><a href="../../include/catalog/pg_type.h.html#LN701"><span class='Ref_to_Const'>ANYELEMENTOID</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* require the element type to be an enum */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/utils/lsyscache.h.html#LN151"><span class='Ref_to_Proto'>type_is_enum</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1609"><span class='Ref_To_Local'>elem_typeid</span></a><span class='Parentheses'>))</span> 
            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_DATATYPE_MISMATCH<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"type matched to anyenum is not an enum type: %s"</span><span class='Delimiter'>, 
</span>                            <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1609"><span class='Ref_To_Local'>elem_typeid</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we had any unknown inputs, re-scan to assign correct types 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1608"><span class='Ref_To_Local'>have_unknowns</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1606"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="parse_coerce.c.html#LN1606"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>&LT; </span><a href="parse_coerce.c.html#LN1602"><span class='Ref_to_Parameter'>nargs</span></a><span class='Delimiter'>; </span><a href="parse_coerce.c.html#LN1606"><span class='Ref_To_Local'>j</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1825"></a>            <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>decl_type</span> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN1601"><span class='Ref_to_Parameter'>declared_arg_types</span></a><span class='Delimiter'>[</span><a href="parse_coerce.c.html#LN1606"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]; 
</span><a name="LN1826"></a>            <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>actual_type</span> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN1600"><span class='Ref_to_Parameter'>actual_arg_types</span></a><span class='Delimiter'>[</span><a href="parse_coerce.c.html#LN1606"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1826"><span class='Ref_To_Local'>actual_type</span></a> <span class='Operator'>!= </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN43"><span class='Ref_to_Const'>UNKNOWNOID</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1825"><span class='Ref_To_Local'>decl_type</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN701"><span class='Ref_to_Const'>ANYELEMENTOID</span></a> <span class='Operator'>|| 
</span>                <a href="parse_coerce.c.html#LN1825"><span class='Ref_To_Local'>decl_type</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN703"><span class='Ref_to_Const'>ANYNONARRAYOID</span></a> <span class='Operator'>|| 
</span>                <a href="parse_coerce.c.html#LN1825"><span class='Ref_To_Local'>decl_type</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN705"><span class='Ref_to_Const'>ANYENUMOID</span></a><span class='Parentheses'>) 
</span>                <a href="parse_coerce.c.html#LN1601"><span class='Ref_to_Parameter'>declared_arg_types</span></a><span class='Delimiter'>[</span><a href="parse_coerce.c.html#LN1606"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="parse_coerce.c.html#LN1609"><span class='Ref_To_Local'>elem_typeid</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1825"><span class='Ref_To_Local'>decl_type</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN687"><span class='Ref_to_Const'>ANYARRAYOID</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1610"><span class='Ref_To_Local'>array_typeid</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <a href="parse_coerce.c.html#LN1610"><span class='Ref_To_Local'>array_typeid</span></a> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN158"><span class='Ref_to_Proto'>get_array_type</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1609"><span class='Ref_To_Local'>elem_typeid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1610"><span class='Ref_To_Local'>array_typeid</span></a><span class='Parentheses'>))</span> 
                        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_UNDEFINED_OBJECT<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not find array type for data type %s"</span><span class='Delimiter'>, 
</span>                                <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1609"><span class='Ref_To_Local'>elem_typeid</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <a href="parse_coerce.c.html#LN1601"><span class='Ref_to_Parameter'>declared_arg_types</span></a><span class='Delimiter'>[</span><a href="parse_coerce.c.html#LN1606"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="parse_coerce.c.html#LN1610"><span class='Ref_To_Local'>array_typeid</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1825"><span class='Ref_To_Local'>decl_type</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN713"><span class='Ref_to_Const'>ANYRANGEOID</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1611"><span class='Ref_To_Local'>range_typeid</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_UNDEFINED_OBJECT<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not find range type for data type %s"</span><span class='Delimiter'>, 
</span>                                <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1609"><span class='Ref_To_Local'>elem_typeid</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <a href="parse_coerce.c.html#LN1601"><span class='Ref_to_Parameter'>declared_arg_types</span></a><span class='Delimiter'>[</span><a href="parse_coerce.c.html#LN1606"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="parse_coerce.c.html#LN1611"><span class='Ref_To_Local'>range_typeid</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for j=0;j&LT;nargs;j++ &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if have_unknowns &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* if we return ANYARRAY use the appropriate argument type */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1603"><span class='Ref_to_Parameter'>rettype</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN687"><span class='Ref_to_Const'>ANYARRAYOID</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1610"><span class='Ref_To_Local'>array_typeid</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="parse_coerce.c.html#LN1610"><span class='Ref_To_Local'>array_typeid</span></a> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN158"><span class='Ref_to_Proto'>get_array_type</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1609"><span class='Ref_To_Local'>elem_typeid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1610"><span class='Ref_To_Local'>array_typeid</span></a><span class='Parentheses'>))</span> 
                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_UNDEFINED_OBJECT<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not find array type for data type %s"</span><span class='Delimiter'>, 
</span>                                <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1609"><span class='Ref_To_Local'>elem_typeid</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>return</span> <a href="parse_coerce.c.html#LN1610"><span class='Ref_To_Local'>array_typeid</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* if we return ANYRANGE use the appropriate argument type */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1603"><span class='Ref_to_Parameter'>rettype</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN713"><span class='Ref_to_Const'>ANYRANGEOID</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1611"><span class='Ref_To_Local'>range_typeid</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_UNDEFINED_OBJECT<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not find range type for data type %s"</span><span class='Delimiter'>, 
</span>                            <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1609"><span class='Ref_To_Local'>elem_typeid</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>return</span> <a href="parse_coerce.c.html#LN1611"><span class='Ref_To_Local'>range_typeid</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* if we return ANYELEMENT use the appropriate argument type */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1603"><span class='Ref_to_Parameter'>rettype</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN701"><span class='Ref_to_Const'>ANYELEMENTOID</span></a> <span class='Operator'>|| 
</span>        <a href="parse_coerce.c.html#LN1603"><span class='Ref_to_Parameter'>rettype</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN703"><span class='Ref_to_Const'>ANYNONARRAYOID</span></a> <span class='Operator'>|| 
</span>        <a href="parse_coerce.c.html#LN1603"><span class='Ref_to_Parameter'>rettype</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN705"><span class='Ref_to_Const'>ANYENUMOID</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="parse_coerce.c.html#LN1609"><span class='Ref_To_Local'>elem_typeid</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* we don't return a generic type; send back the original return type */ 
</span>    <span class='Control'>return</span> <a href="parse_coerce.c.html#LN1603"><span class='Ref_to_Parameter'>rettype</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end enforce_generic_type_consistency &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * resolve_generic_type() 
 *      Deduce an individual actual datatype on the assumption that 
 *      the rules for polymorphic types are being followed. 
 * 
 * declared_type is the declared datatype we want to resolve. 
 * context_actual_type is the actual input datatype to some argument 
 * that has declared datatype context_declared_type. 
 * 
 * If declared_type isn't polymorphic, we just return it.  Otherwise, 
 * context_declared_type must be polymorphic, and we deduce the correct 
 * return type based on the relationship of the two polymorphic types. 
 */ 
</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> 
<a name="LN1914"></a><span class='Declare_Function'>resolve_generic_type</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>declared_type</span><span class='Delimiter'>, 
</span><a name="LN1915"></a>                     <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>context_actual_type</span><span class='Delimiter'>, 
</span><a name="LN1916"></a>                     <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>context_declared_type</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1914"><span class='Ref_to_Parameter'>declared_type</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN687"><span class='Ref_to_Const'>ANYARRAYOID</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1916"><span class='Ref_to_Parameter'>context_declared_type</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN687"><span class='Ref_to_Const'>ANYARRAYOID</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Use actual type, but it must be an array; or if it's a domain 
             * over array, use the base array type. 
             */ 
</span><a name="LN1926"></a>            <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>context_base_type</span> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN168"><span class='Ref_to_Proto'>getBaseType</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1915"><span class='Ref_to_Parameter'>context_actual_type</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1927"></a>            <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>array_typelem</span> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN157"><span class='Ref_to_Proto'>get_element_type</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1926"><span class='Ref_To_Local'>context_base_type</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1927"><span class='Ref_To_Local'>array_typelem</span></a><span class='Parentheses'>))</span> 
                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_DATATYPE_MISMATCH<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                   <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"argument declared %s is not an array but type %s"</span><span class='Delimiter'>, 
</span>                          <span class='String'>"anyarray"</span><span class='Delimiter'>, </span><a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1926"><span class='Ref_To_Local'>context_base_type</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <a href="parse_coerce.c.html#LN1926"><span class='Ref_To_Local'>context_base_type</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1916"><span class='Ref_to_Parameter'>context_declared_type</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN701"><span class='Ref_to_Const'>ANYELEMENTOID</span></a> <span class='Operator'>|| 
</span>                 <a href="parse_coerce.c.html#LN1916"><span class='Ref_to_Parameter'>context_declared_type</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN703"><span class='Ref_to_Const'>ANYNONARRAYOID</span></a> <span class='Operator'>|| 
</span>                 <a href="parse_coerce.c.html#LN1916"><span class='Ref_to_Parameter'>context_declared_type</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN705"><span class='Ref_to_Const'>ANYENUMOID</span></a> <span class='Operator'>|| 
</span>                 <a href="parse_coerce.c.html#LN1916"><span class='Ref_to_Parameter'>context_declared_type</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN713"><span class='Ref_to_Const'>ANYRANGEOID</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Use the array type corresponding to actual type */ 
</span><a name="LN1942"></a>            <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>array_typeid</span> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN158"><span class='Ref_to_Proto'>get_array_type</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1915"><span class='Ref_to_Parameter'>context_actual_type</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1942"><span class='Ref_To_Local'>array_typeid</span></a><span class='Parentheses'>))</span> 
                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_UNDEFINED_OBJECT<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not find array type for data type %s"</span><span class='Delimiter'>, 
</span>                                <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1915"><span class='Ref_to_Parameter'>context_actual_type</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <a href="parse_coerce.c.html#LN1942"><span class='Ref_To_Local'>array_typeid</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if declared_type==ANYARR... &raquo; </span> 
    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1914"><span class='Ref_to_Parameter'>declared_type</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN701"><span class='Ref_to_Const'>ANYELEMENTOID</span></a> <span class='Operator'>|| 
</span>             <a href="parse_coerce.c.html#LN1914"><span class='Ref_to_Parameter'>declared_type</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN703"><span class='Ref_to_Const'>ANYNONARRAYOID</span></a> <span class='Operator'>|| 
</span>             <a href="parse_coerce.c.html#LN1914"><span class='Ref_to_Parameter'>declared_type</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN705"><span class='Ref_to_Const'>ANYENUMOID</span></a> <span class='Operator'>|| 
</span>             <a href="parse_coerce.c.html#LN1914"><span class='Ref_to_Parameter'>declared_type</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN713"><span class='Ref_to_Const'>ANYRANGEOID</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1916"><span class='Ref_to_Parameter'>context_declared_type</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN687"><span class='Ref_to_Const'>ANYARRAYOID</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Use the element type corresponding to actual type */ 
</span><a name="LN1960"></a>            <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>context_base_type</span> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN168"><span class='Ref_to_Proto'>getBaseType</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1915"><span class='Ref_to_Parameter'>context_actual_type</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1961"></a>            <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>array_typelem</span> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN157"><span class='Ref_to_Proto'>get_element_type</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1960"><span class='Ref_To_Local'>context_base_type</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1961"><span class='Ref_To_Local'>array_typelem</span></a><span class='Parentheses'>))</span> 
                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_DATATYPE_MISMATCH<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                   <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"argument declared %s is not an array but type %s"</span><span class='Delimiter'>, 
</span>                          <span class='String'>"anyarray"</span><span class='Delimiter'>, </span><a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1960"><span class='Ref_To_Local'>context_base_type</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <a href="parse_coerce.c.html#LN1961"><span class='Ref_To_Local'>array_typelem</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1916"><span class='Ref_to_Parameter'>context_declared_type</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN713"><span class='Ref_to_Const'>ANYRANGEOID</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Use the element type corresponding to actual type */ 
</span><a name="LN1973"></a>            <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>context_base_type</span> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN168"><span class='Ref_to_Proto'>getBaseType</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1915"><span class='Ref_to_Parameter'>context_actual_type</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1974"></a>            <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>range_typelem</span> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN177"><span class='Ref_to_Proto'>get_range_subtype</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1973"><span class='Ref_To_Local'>context_base_type</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1974"><span class='Ref_To_Local'>range_typelem</span></a><span class='Parentheses'>))</span> 
                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_DATATYPE_MISMATCH<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"argument declared %s is not a range type but type %s"</span><span class='Delimiter'>, 
</span>                       <span class='String'>"anyrange"</span><span class='Delimiter'>, </span><a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1973"><span class='Ref_To_Local'>context_base_type</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <a href="parse_coerce.c.html#LN1974"><span class='Ref_To_Local'>range_typelem</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN1916"><span class='Ref_to_Parameter'>context_declared_type</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN701"><span class='Ref_to_Const'>ANYELEMENTOID</span></a> <span class='Operator'>|| 
</span>                 <a href="parse_coerce.c.html#LN1916"><span class='Ref_to_Parameter'>context_declared_type</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN703"><span class='Ref_to_Const'>ANYNONARRAYOID</span></a> <span class='Operator'>|| 
</span>                 <a href="parse_coerce.c.html#LN1916"><span class='Ref_to_Parameter'>context_declared_type</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN705"><span class='Ref_to_Const'>ANYENUMOID</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Use the actual type; it doesn't matter if array or not */ 
</span>            <span class='Control'>return</span> <a href="parse_coerce.c.html#LN1915"><span class='Ref_to_Parameter'>context_actual_type</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if declared_type==ANYELE... &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* declared_type isn't polymorphic, so return it as-is */ 
</span>        <span class='Control'>return</span> <a href="parse_coerce.c.html#LN1914"><span class='Ref_to_Parameter'>declared_type</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Comment_Multi_Line'>/* If we get here, declared_type is polymorphic and context isn't */ 
</span>    <span class='Comment_Multi_Line'>/* NB: this is a calling-code logic error, not a user error */ 
</span>    <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"could not determine polymorphic type because context isn't polymorphic"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end resolve_generic_type &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* TypeCategory() 
 *      Assign a category to the specified type OID. 
 * 
 * NB: this must not return TYPCATEGORY_INVALID. 
 */ 
</span><a href="../../include/parser/parse_coerce.h.html#LN20"><span class='Ref_to_Typedef'>TYPCATEGORY</span></a> 
<a name="LN2009"></a><span class='Declare_Function'>TypeCategory</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>type</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2011"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>typcategory</span><span class='Delimiter'>; 
</span><a name="LN2012"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>typispreferred</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/utils/lsyscache.h.html#LN153"><span class='Ref_to_Proto'>get_type_category_preferred</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2009"><span class='Ref_to_Parameter'>type</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_coerce.c.html#LN2011"><span class='Ref_To_Local'>typcategory</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_coerce.c.html#LN2012"><span class='Ref_To_Local'>typispreferred</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2011"><span class='Ref_To_Local'>typcategory</span></a> <span class='Operator'>!= </span><a href="../../include/catalog/pg_type.h.html#LN726"><span class='Ref_to_Const'>TYPCATEGORY_INVALID</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../include/parser/parse_coerce.h.html#LN20"><span class='Ref_to_Typedef'>TYPCATEGORY</span></a><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN2011"><span class='Ref_To_Local'>typcategory</span></a><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* IsPreferredType() 
 *      Check if this type is a preferred type for the given category. 
 * 
 * If category is TYPCATEGORY_INVALID, then we'll return TRUE for preferred 
 * types of any category; otherwise, only for preferred types of that 
 * category. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN2028"></a><span class='Declare_Function'>IsPreferredType</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_coerce.h.html#LN20"><span class='Ref_to_Typedef'>TYPCATEGORY</span></a> <span class='Declare_Parameter'>category</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>type</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2030"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>typcategory</span><span class='Delimiter'>; 
</span><a name="LN2031"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>typispreferred</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/utils/lsyscache.h.html#LN153"><span class='Ref_to_Proto'>get_type_category_preferred</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2028"><span class='Ref_to_Parameter'>type</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_coerce.c.html#LN2030"><span class='Ref_To_Local'>typcategory</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_coerce.c.html#LN2031"><span class='Ref_To_Local'>typispreferred</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2028"><span class='Ref_to_Parameter'>category</span></a> <span class='Operator'>== </span><a href="parse_coerce.c.html#LN2030"><span class='Ref_To_Local'>typcategory</span></a> <span class='Operator'>|| </span><a href="parse_coerce.c.html#LN2028"><span class='Ref_to_Parameter'>category</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN726"><span class='Ref_to_Const'>TYPCATEGORY_INVALID</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="parse_coerce.c.html#LN2031"><span class='Ref_To_Local'>typispreferred</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* IsBinaryCoercible() 
 *      Check if srctype is binary-coercible to targettype. 
 * 
 * This notion allows us to cheat and directly exchange values without 
 * going through the trouble of calling a conversion function.  Note that 
 * in general, this should only be an implementation shortcut.  Before 7.4, 
 * this was also used as a heuristic for resolving overloaded functions and 
 * operators, but that's basically a bad idea. 
 * 
 * As of 7.3, binary coercibility isn't hardwired into the code anymore. 
 * We consider two types binary-coercible if there is an implicitly 
 * invokable, no-function-needed pg_cast entry.  Also, a domain is always 
 * binary-coercible to its base type, though *not* vice versa (in the other 
 * direction, one must apply domain constraint checks before accepting the 
 * value as legitimate).  We also need to special-case various polymorphic 
 * types. 
 * 
 * This function replaces IsBinaryCompatible(), which was an inherently 
 * symmetric test.  Since the pg_cast entries aren't necessarily symmetric, 
 * the order of the operands is now significant. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN2063"></a><span class='Declare_Function'>IsBinaryCoercible</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>srctype</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>targettype</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2065"></a>    <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>tuple</span><span class='Delimiter'>; 
</span><a name="LN2066"></a>    <a href="../../include/catalog/pg_cast.h.html#LN41"><span class='Ref_to_Typedef'>Form_pg_cast</span></a> <span class='Declare_Local'>castForm</span><span class='Delimiter'>; 
</span><a name="LN2067"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Fast path if same type */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2063"><span class='Ref_to_Parameter'>srctype</span></a> <span class='Operator'>== </span><a href="parse_coerce.c.html#LN2063"><span class='Ref_to_Parameter'>targettype</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Anything is coercible to ANY or ANYELEMENT */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2063"><span class='Ref_to_Parameter'>targettype</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN685"><span class='Ref_to_Const'>ANYOID</span></a> <span class='Operator'>|| </span><a href="parse_coerce.c.html#LN2063"><span class='Ref_to_Parameter'>targettype</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN701"><span class='Ref_to_Const'>ANYELEMENTOID</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If srctype is a domain, reduce to its base type */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2063"><span class='Ref_to_Parameter'>srctype</span></a><span class='Parentheses'>))</span> 
        <a href="parse_coerce.c.html#LN2063"><span class='Ref_to_Parameter'>srctype</span></a> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN168"><span class='Ref_to_Proto'>getBaseType</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2063"><span class='Ref_to_Parameter'>srctype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Somewhat-fast path for domain -&GT; base type case */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2063"><span class='Ref_to_Parameter'>srctype</span></a> <span class='Operator'>== </span><a href="parse_coerce.c.html#LN2063"><span class='Ref_to_Parameter'>targettype</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Also accept any array type as coercible to ANYARRAY */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2063"><span class='Ref_to_Parameter'>targettype</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN687"><span class='Ref_to_Const'>ANYARRAYOID</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/utils/lsyscache.h.html#LN179"><span class='Ref_to_Macro'>type_is_array</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2063"><span class='Ref_to_Parameter'>srctype</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Also accept any non-array type as coercible to ANYNONARRAY */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2063"><span class='Ref_to_Parameter'>targettype</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN703"><span class='Ref_to_Const'>ANYNONARRAYOID</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/utils/lsyscache.h.html#LN179"><span class='Ref_to_Macro'>type_is_array</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2063"><span class='Ref_to_Parameter'>srctype</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Also accept any enum type as coercible to ANYENUM */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2063"><span class='Ref_to_Parameter'>targettype</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN705"><span class='Ref_to_Const'>ANYENUMOID</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/utils/lsyscache.h.html#LN151"><span class='Ref_to_Proto'>type_is_enum</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2063"><span class='Ref_to_Parameter'>srctype</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Also accept any range type as coercible to ANYRANGE */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2063"><span class='Ref_to_Parameter'>targettype</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN713"><span class='Ref_to_Const'>ANYRANGEOID</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/utils/lsyscache.h.html#LN152"><span class='Ref_to_Proto'>type_is_range</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2063"><span class='Ref_to_Parameter'>srctype</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Also accept any composite type as coercible to RECORD */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2063"><span class='Ref_to_Parameter'>targettype</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN679"><span class='Ref_to_Const'>RECORDOID</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/parser/parse_type.h.html#LN52"><span class='Ref_to_Macro'>ISCOMPLEX</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2063"><span class='Ref_to_Parameter'>srctype</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Also accept any composite array type as coercible to RECORD[] */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2063"><span class='Ref_to_Parameter'>targettype</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN681"><span class='Ref_to_Const'>RECORDARRAYOID</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN50"><span class='Ref_to_Proto'>is_complex_array</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2063"><span class='Ref_to_Parameter'>srctype</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Else look in pg_cast */ 
</span>    <a href="parse_coerce.c.html#LN2065"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN157"><span class='Ref_to_Macro'>SearchSysCache2</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN45"><span class='Ref_to_EnumConst'>CASTSOURCETARGET</span></a><span class='Delimiter'>, 
</span>                            <a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2063"><span class='Ref_to_Parameter'>srctype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                            <a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2063"><span class='Ref_to_Parameter'>targettype</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2065"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* no cast */ 
</span>    <a href="parse_coerce.c.html#LN2066"><span class='Ref_To_Local'>castForm</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_cast.h.html#LN41"><span class='Ref_to_Typedef'>Form_pg_cast</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2065"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="parse_coerce.c.html#LN2067"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2066"><span class='Ref_To_Local'>castForm</span></a><span class='Operator'>-&GT;</span>castmethod <span class='Operator'>== </span><a href="../../include/catalog/pg_cast.h.html#LN67"><span class='Ref_to_EnumConst'>COERCION_METHOD_BINARY</span></a> <span class='Operator'>&& 
</span>              <a href="parse_coerce.c.html#LN2066"><span class='Ref_To_Local'>castForm</span></a><span class='Operator'>-&GT;</span>castcontext <span class='Operator'>== </span><a href="../../include/catalog/pg_cast.h.html#LN54"><span class='Ref_to_EnumConst'>COERCION_CODE_IMPLICIT</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2065"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="parse_coerce.c.html#LN2067"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end IsBinaryCoercible &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * find_coercion_pathway 
 *      Look for a coercion pathway between two types. 
 * 
 * Currently, this deals only with scalar-type cases; it does not consider 
 * polymorphic types nor casts between composite types.  (Perhaps fold 
 * those in someday?) 
 * 
 * ccontext determines the set of available casts. 
 * 
 * The possible result codes are: 
 *  COERCION_PATH_NONE: failed to find any coercion pathway 
 *              *funcid is set to InvalidOid 
 *  COERCION_PATH_FUNC: apply the coercion function returned in *funcid 
 *  COERCION_PATH_RELABELTYPE: binary-compatible cast, no function needed 
 *              *funcid is set to InvalidOid 
 *  COERCION_PATH_ARRAYCOERCE: need an ArrayCoerceExpr node 
 *              *funcid is set to the element cast function, or InvalidOid 
 *              if the array elements are binary-compatible 
 *  COERCION_PATH_COERCEVIAIO: need a CoerceViaIO node 
 *              *funcid is set to InvalidOid 
 * 
 * Note: COERCION_PATH_RELABELTYPE does not necessarily mean that no work is 
 * needed to do the coercion; if the target is a domain then we may need to 
 * apply domain constraint checking.  If you want to check for a zero-effort 
 * conversion then use IsBinaryCoercible(). 
 */ 
</span><a href="../../include/parser/parse_coerce.h.html#LN23"><span class='Ref_to_Enum'>CoercionPathType</span></a> 
<a name="LN2160"></a><span class='Declare_Function'>find_coercion_pathway</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>targetTypeId</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>sourceTypeId</span><span class='Delimiter'>, 
</span><a name="LN2161"></a>                      <a href="../../include/nodes/primnodes.h.html#LN418"><span class='Ref_to_Enum'>CoercionContext</span></a> <span class='Declare_Parameter'>ccontext</span><span class='Delimiter'>, 
</span><a name="LN2162"></a>                      <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>funcid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2164"></a>    <a href="../../include/parser/parse_coerce.h.html#LN23"><span class='Ref_to_Enum'>CoercionPathType</span></a> <span class='Declare_Local'>result</span> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN25"><span class='Ref_to_EnumConst'>COERCION_PATH_NONE</span></a><span class='Delimiter'>; 
</span><a name="LN2165"></a>    <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>tuple</span><span class='Delimiter'>; 
</span> 
    <span class='Operator'>*</span><a href="parse_coerce.c.html#LN2162"><span class='Ref_to_Parameter'>funcid</span></a> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Perhaps the types are domains; if so, look at their base types */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2160"><span class='Ref_to_Parameter'>sourceTypeId</span></a><span class='Parentheses'>))</span> 
        <a href="parse_coerce.c.html#LN2160"><span class='Ref_to_Parameter'>sourceTypeId</span></a> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN168"><span class='Ref_to_Proto'>getBaseType</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2160"><span class='Ref_to_Parameter'>sourceTypeId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2160"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Parentheses'>))</span> 
        <a href="parse_coerce.c.html#LN2160"><span class='Ref_to_Parameter'>targetTypeId</span></a> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN168"><span class='Ref_to_Proto'>getBaseType</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2160"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Domains are always coercible to and from their base type */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2160"><span class='Ref_to_Parameter'>sourceTypeId</span></a> <span class='Operator'>== </span><a href="parse_coerce.c.html#LN2160"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="../../include/parser/parse_coerce.h.html#LN27"><span class='Ref_to_EnumConst'>COERCION_PATH_RELABELTYPE</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Look in pg_cast */ 
</span>    <a href="parse_coerce.c.html#LN2165"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN157"><span class='Ref_to_Macro'>SearchSysCache2</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN45"><span class='Ref_to_EnumConst'>CASTSOURCETARGET</span></a><span class='Delimiter'>, 
</span>                            <a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2160"><span class='Ref_to_Parameter'>sourceTypeId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                            <a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2160"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2165"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN2186"></a>        <a href="../../include/catalog/pg_cast.h.html#LN41"><span class='Ref_to_Typedef'>Form_pg_cast</span></a> <span class='Declare_Local'>castForm</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_cast.h.html#LN41"><span class='Ref_to_Typedef'>Form_pg_cast</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2165"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2187"></a>        <a href="../../include/nodes/primnodes.h.html#LN418"><span class='Ref_to_Enum'>CoercionContext</span></a> <span class='Declare_Local'>castcontext</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* convert char value for castcontext to CoercionContext enum */ 
</span>        <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2186"><span class='Ref_To_Local'>castForm</span></a><span class='Operator'>-&GT;</span>castcontext<span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>case</span> <a href="../../include/catalog/pg_cast.h.html#LN54"><span class='Ref_to_EnumConst'>COERCION_CODE_IMPLICIT</span></a><span class='Operator'>: 
</span>                <a href="parse_coerce.c.html#LN2187"><span class='Ref_To_Local'>castcontext</span></a> <span class='Operator'>= </span><a href="../../include/nodes/primnodes.h.html#LN420"><span class='Ref_to_EnumConst'>COERCION_IMPLICIT</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../include/catalog/pg_cast.h.html#LN55"><span class='Ref_to_EnumConst'>COERCION_CODE_ASSIGNMENT</span></a><span class='Operator'>: 
</span>                <a href="parse_coerce.c.html#LN2187"><span class='Ref_To_Local'>castcontext</span></a> <span class='Operator'>= </span><a href="../../include/nodes/primnodes.h.html#LN421"><span class='Ref_to_EnumConst'>COERCION_ASSIGNMENT</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../include/catalog/pg_cast.h.html#LN56"><span class='Ref_to_EnumConst'>COERCION_CODE_EXPLICIT</span></a><span class='Operator'>: 
</span>                <a href="parse_coerce.c.html#LN2187"><span class='Ref_To_Local'>castcontext</span></a> <span class='Operator'>= </span><a href="../../include/nodes/primnodes.h.html#LN422"><span class='Ref_to_EnumConst'>COERCION_EXPLICIT</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>default</span><span class='Operator'>: 
</span>                <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized castcontext: %d"</span><span class='Delimiter'>, 
</span>                     <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN2186"><span class='Ref_To_Local'>castForm</span></a><span class='Operator'>-&GT;</span>castcontext<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="parse_coerce.c.html#LN2187"><span class='Ref_To_Local'>castcontext</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Rely on ordering of enum for correct behavior here */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2161"><span class='Ref_to_Parameter'>ccontext</span></a> <span class='Operator'>&GT;= </span><a href="parse_coerce.c.html#LN2187"><span class='Ref_To_Local'>castcontext</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2186"><span class='Ref_To_Local'>castForm</span></a><span class='Operator'>-&GT;</span>castmethod<span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>case</span> <a href="../../include/catalog/pg_cast.h.html#LN66"><span class='Ref_to_EnumConst'>COERCION_METHOD_FUNCTION</span></a><span class='Operator'>: 
</span>                    <a href="parse_coerce.c.html#LN2164"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN26"><span class='Ref_to_EnumConst'>COERCION_PATH_FUNC</span></a><span class='Delimiter'>; 
</span>                    <span class='Operator'>*</span><a href="parse_coerce.c.html#LN2162"><span class='Ref_to_Parameter'>funcid</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN2186"><span class='Ref_To_Local'>castForm</span></a><span class='Operator'>-&GT;</span>castfunc<span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>case</span> <a href="../../include/catalog/pg_cast.h.html#LN68"><span class='Ref_to_EnumConst'>COERCION_METHOD_INOUT</span></a><span class='Operator'>: 
</span>                    <a href="parse_coerce.c.html#LN2164"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN29"><span class='Ref_to_EnumConst'>COERCION_PATH_COERCEVIAIO</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>case</span> <a href="../../include/catalog/pg_cast.h.html#LN67"><span class='Ref_to_EnumConst'>COERCION_METHOD_BINARY</span></a><span class='Operator'>: 
</span>                    <a href="parse_coerce.c.html#LN2164"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN27"><span class='Ref_to_EnumConst'>COERCION_PATH_RELABELTYPE</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>default</span><span class='Operator'>: 
</span>                    <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized castmethod: %d"</span><span class='Delimiter'>, 
</span>                         <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="parse_coerce.c.html#LN2186"><span class='Ref_To_Local'>castForm</span></a><span class='Operator'>-&GT;</span>castmethod<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if ccontext&GT;=castcontext &raquo; </span> 
 
        <a href="../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2165"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if HeapTupleIsValid(tupl... &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * If there's no pg_cast entry, perhaps we are dealing with a pair of 
         * array types.  If so, and if the element types have a suitable cast, 
         * report that we can coerce with an ArrayCoerceExpr. 
         * 
         * Note that the source type can be a domain over array, but not the 
         * target, because ArrayCoerceExpr won't check domain constraints. 
         * 
         * Hack: disallow coercions to oidvector and int2vector, which 
         * otherwise tend to capture coercions that should go to "real" array 
         * types.  We want those types to be considered "real" arrays for many 
         * purposes, but not this one.  (Also, ArrayCoerceExpr isn't 
         * guaranteed to produce an output that meets the restrictions of 
         * these datatypes, such as being 1-dimensional.) 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2160"><span class='Ref_to_Parameter'>targetTypeId</span></a> <span class='Operator'>!= </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN31"><span class='Ref_to_Const'>OIDVECTOROID</span></a> <span class='Operator'>&& </span><a href="parse_coerce.c.html#LN2160"><span class='Ref_to_Parameter'>targetTypeId</span></a> <span class='Operator'>!= </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN23"><span class='Ref_to_Const'>INT2VECTOROID</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN2251"></a>            <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>targetElem</span><span class='Delimiter'>; 
</span><a name="LN2252"></a>            <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>sourceElem</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="parse_coerce.c.html#LN2251"><span class='Ref_To_Local'>targetElem</span></a> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN157"><span class='Ref_to_Proto'>get_element_type</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2160"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a> <span class='Operator'>&& 
</span>            <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2252"><span class='Ref_To_Local'>sourceElem</span></a> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN160"><span class='Ref_to_Proto'>get_base_element_type</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2160"><span class='Ref_to_Parameter'>sourceTypeId</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>)</span> 
            <span class='Delimiter'>{ 
</span><a name="LN2257"></a>                <a href="../../include/parser/parse_coerce.h.html#LN23"><span class='Ref_to_Enum'>CoercionPathType</span></a> <span class='Declare_Local'>elempathtype</span><span class='Delimiter'>; 
</span><a name="LN2258"></a>                <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>elemfuncid</span><span class='Delimiter'>; 
</span> 
                <a href="parse_coerce.c.html#LN2257"><span class='Ref_To_Local'>elempathtype</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN86"><span class='Ref_to_Proto'>find_coercion_pathway</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2251"><span class='Ref_To_Local'>targetElem</span></a><span class='Delimiter'>, 
</span>                                                     <a href="parse_coerce.c.html#LN2252"><span class='Ref_To_Local'>sourceElem</span></a><span class='Delimiter'>, 
</span>                                                     <a href="parse_coerce.c.html#LN2161"><span class='Ref_to_Parameter'>ccontext</span></a><span class='Delimiter'>, 
</span>                                                     <span class='Operator'>&</span><a href="parse_coerce.c.html#LN2258"><span class='Ref_To_Local'>elemfuncid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2257"><span class='Ref_To_Local'>elempathtype</span></a> <span class='Operator'>!= </span><a href="../../include/parser/parse_coerce.h.html#LN25"><span class='Ref_to_EnumConst'>COERCION_PATH_NONE</span></a> <span class='Operator'>&& 
</span>                    <a href="parse_coerce.c.html#LN2257"><span class='Ref_To_Local'>elempathtype</span></a> <span class='Operator'>!= </span><a href="../../include/parser/parse_coerce.h.html#LN28"><span class='Ref_to_EnumConst'>COERCION_PATH_ARRAYCOERCE</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Operator'>*</span><a href="parse_coerce.c.html#LN2162"><span class='Ref_to_Parameter'>funcid</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN2258"><span class='Ref_To_Local'>elemfuncid</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2257"><span class='Ref_To_Local'>elempathtype</span></a> <span class='Operator'>== </span><a href="../../include/parser/parse_coerce.h.html#LN29"><span class='Ref_to_EnumConst'>COERCION_PATH_COERCEVIAIO</span></a><span class='Parentheses'>) 
</span>                        <a href="parse_coerce.c.html#LN2164"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN29"><span class='Ref_to_EnumConst'>COERCION_PATH_COERCEVIAIO</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>else</span> 
                        <a href="parse_coerce.c.html#LN2164"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN28"><span class='Ref_to_EnumConst'>COERCION_PATH_ARRAYCOERCE</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if (targetElem=get_eleme... &raquo; </span> 
        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if targetTypeId!=OIDVECT... &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* 
         * If we still haven't found a possibility, consider automatic casting 
         * using I/O functions.  We allow assignment casts to string types and 
         * explicit casts from string types to be handled this way. (The 
         * CoerceViaIO mechanism is a lot more general than that, but this is 
         * all we want to allow in the absence of a pg_cast entry.) It would 
         * probably be better to insist on explicit casts in both directions, 
         * but this is a compromise to preserve something of the pre-8.3 
         * behavior that many types had implicit (yipes!) casts to text. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2164"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>== </span><a href="../../include/parser/parse_coerce.h.html#LN25"><span class='Ref_to_EnumConst'>COERCION_PATH_NONE</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2161"><span class='Ref_to_Parameter'>ccontext</span></a> <span class='Operator'>&GT;= </span><a href="../../include/nodes/primnodes.h.html#LN421"><span class='Ref_to_EnumConst'>COERCION_ASSIGNMENT</span></a> <span class='Operator'>&& 
</span>                <a href="../../include/parser/parse_coerce.h.html#LN35"><span class='Ref_to_Proto'>TypeCategory</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2160"><span class='Ref_to_Parameter'>targetTypeId</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN737"><span class='Ref_to_Const'>TYPCATEGORY_STRING</span></a><span class='Parentheses'>)</span> 
                <a href="parse_coerce.c.html#LN2164"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN29"><span class='Ref_to_EnumConst'>COERCION_PATH_COERCEVIAIO</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2161"><span class='Ref_to_Parameter'>ccontext</span></a> <span class='Operator'>&GT;= </span><a href="../../include/nodes/primnodes.h.html#LN422"><span class='Ref_to_EnumConst'>COERCION_EXPLICIT</span></a> <span class='Operator'>&& 
</span>                     <a href="../../include/parser/parse_coerce.h.html#LN35"><span class='Ref_to_Proto'>TypeCategory</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2160"><span class='Ref_to_Parameter'>sourceTypeId</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN737"><span class='Ref_to_Const'>TYPCATEGORY_STRING</span></a><span class='Parentheses'>)</span> 
                <a href="parse_coerce.c.html#LN2164"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN29"><span class='Ref_to_EnumConst'>COERCION_PATH_COERCEVIAIO</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <span class='Control'>return</span> <a href="parse_coerce.c.html#LN2164"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end find_coercion_pathway &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * find_typmod_coercion_function -- does the given type need length coercion? 
 * 
 * If the target type possesses a pg_cast function from itself to itself, 
 * it must need length coercion. 
 * 
 * "bpchar" (ie, char(N)) and "numeric" are examples of such types. 
 * 
 * If the given type is a varlena array type, we do not look for a coercion 
 * function associated directly with the array type, but instead look for 
 * one associated with the element type.  An ArrayCoerceExpr node must be 
 * used to apply such a function. 
 * 
 * We use the same result enum as find_coercion_pathway, but the only possible 
 * result codes are: 
 *  COERCION_PATH_NONE: no length coercion needed 
 *  COERCION_PATH_FUNC: apply the function returned in *funcid 
 *  COERCION_PATH_ARRAYCOERCE: apply the function using ArrayCoerceExpr 
 */ 
</span><a href="../../include/parser/parse_coerce.h.html#LN23"><span class='Ref_to_Enum'>CoercionPathType</span></a> 
<a name="LN2321"></a><span class='Declare_Function'>find_typmod_coercion_function</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>typeId</span><span class='Delimiter'>, 
</span><a name="LN2322"></a>                              <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>funcid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2324"></a>    <a href="../../include/parser/parse_coerce.h.html#LN23"><span class='Ref_to_Enum'>CoercionPathType</span></a> <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span><a name="LN2325"></a>    <a href="../../include/parser/parse_type.h.html#LN19"><span class='Ref_to_Typedef'>Type</span></a>        <span class='Declare_Local'>targetType</span><span class='Delimiter'>; 
</span><a name="LN2326"></a>    <a href="../../include/catalog/pg_type.h.html#LN232"><span class='Ref_to_Typedef'>Form_pg_type</span></a> <span class='Declare_Local'>typeForm</span><span class='Delimiter'>; 
</span><a name="LN2327"></a>    <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>tuple</span><span class='Delimiter'>; 
</span> 
    <span class='Operator'>*</span><a href="parse_coerce.c.html#LN2322"><span class='Ref_to_Parameter'>funcid</span></a> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>    <a href="parse_coerce.c.html#LN2324"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN26"><span class='Ref_to_EnumConst'>COERCION_PATH_FUNC</span></a><span class='Delimiter'>; 
</span> 
    <a href="parse_coerce.c.html#LN2325"><span class='Ref_To_Local'>targetType</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_type.h.html#LN37"><span class='Ref_to_Proto'>typeidType</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2321"><span class='Ref_to_Parameter'>typeId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="parse_coerce.c.html#LN2326"><span class='Ref_To_Local'>typeForm</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_type.h.html#LN232"><span class='Ref_to_Typedef'>Form_pg_type</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2325"><span class='Ref_To_Local'>targetType</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Check for a varlena array type */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2326"><span class='Ref_To_Local'>typeForm</span></a><span class='Operator'>-&GT;</span>typelem <span class='Operator'>!= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a> <span class='Operator'>&& </span><a href="parse_coerce.c.html#LN2326"><span class='Ref_To_Local'>typeForm</span></a><span class='Operator'>-&GT;</span>typlen <span class='Operator'>== -</span><span class='Number'>1</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Yes, switch our attention to the element type */ 
</span>        <a href="parse_coerce.c.html#LN2321"><span class='Ref_to_Parameter'>typeId</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN2326"><span class='Ref_To_Local'>typeForm</span></a><span class='Operator'>-&GT;</span>typelem<span class='Delimiter'>; 
</span>        <a href="parse_coerce.c.html#LN2324"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN28"><span class='Ref_to_EnumConst'>COERCION_PATH_ARRAYCOERCE</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2325"><span class='Ref_To_Local'>targetType</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Look in pg_cast */ 
</span>    <a href="parse_coerce.c.html#LN2327"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN157"><span class='Ref_to_Macro'>SearchSysCache2</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN45"><span class='Ref_to_EnumConst'>CASTSOURCETARGET</span></a><span class='Delimiter'>, 
</span>                            <a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2321"><span class='Ref_to_Parameter'>typeId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                            <a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2321"><span class='Ref_to_Parameter'>typeId</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2327"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN2351"></a>        <a href="../../include/catalog/pg_cast.h.html#LN41"><span class='Ref_to_Typedef'>Form_pg_cast</span></a> <span class='Declare_Local'>castForm</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_cast.h.html#LN41"><span class='Ref_to_Typedef'>Form_pg_cast</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2327"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Operator'>*</span><a href="parse_coerce.c.html#LN2322"><span class='Ref_to_Parameter'>funcid</span></a> <span class='Operator'>= </span><a href="parse_coerce.c.html#LN2351"><span class='Ref_To_Local'>castForm</span></a><span class='Operator'>-&GT;</span>castfunc<span class='Delimiter'>; 
</span>        <a href="../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2327"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="parse_coerce.c.html#LN2322"><span class='Ref_to_Parameter'>funcid</span></a><span class='Parentheses'>))</span> 
        <a href="parse_coerce.c.html#LN2324"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN25"><span class='Ref_to_EnumConst'>COERCION_PATH_NONE</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="parse_coerce.c.html#LN2324"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end find_typmod_coercion_function &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * is_complex_array 
 *      Is this type an array of composite? 
 * 
 * Note: this will not return true for record[]; check for RECORDARRAYOID 
 * separately if needed. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN2371"></a><span class='Declare_Function'>is_complex_array</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>typid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2373"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>elemtype</span> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN157"><span class='Ref_to_Proto'>get_element_type</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2371"><span class='Ref_to_Parameter'>typid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2373"><span class='Ref_To_Local'>elemtype</span></a><span class='Parentheses'>) </span><span class='Operator'>&& </span><a href="../../include/parser/parse_type.h.html#LN52"><span class='Ref_to_Macro'>ISCOMPLEX</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2373"><span class='Ref_To_Local'>elemtype</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Check whether reltypeId is the row type of a typed table of type 
 * reloftypeId.  (This is conceptually similar to the subtype 
 * relationship checked by typeInheritsFrom().) 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN2385"></a><span class='Declare_Function'>typeIsOfTypedTable</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>reltypeId</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>reloftypeId</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2387"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>relid</span> <span class='Operator'>= </span><a href="../../include/parser/parse_type.h.html#LN47"><span class='Ref_to_Proto'>typeidTypeRelid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2385"><span class='Ref_to_Parameter'>reltypeId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2388"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>result</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2387"><span class='Ref_To_Local'>relid</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2392"></a>        <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>tp</span><span class='Delimiter'>; 
</span><a name="LN2393"></a>        <a href="../../include/catalog/pg_class.h.html#LN94"><span class='Ref_to_Typedef'>Form_pg_class</span></a> <span class='Declare_Local'>reltup</span><span class='Delimiter'>; 
</span> 
        <a href="parse_coerce.c.html#LN2392"><span class='Ref_To_Local'>tp</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN155"><span class='Ref_to_Macro'>SearchSysCache1</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN83"><span class='Ref_to_EnumConst'>RELOID</span></a><span class='Delimiter'>, </span><a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2387"><span class='Ref_To_Local'>relid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2392"><span class='Ref_To_Local'>tp</span></a><span class='Parentheses'>))</span> 
            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for relation %u"</span><span class='Delimiter'>, </span><a href="parse_coerce.c.html#LN2387"><span class='Ref_To_Local'>relid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="parse_coerce.c.html#LN2393"><span class='Ref_To_Local'>reltup</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_class.h.html#LN94"><span class='Ref_to_Typedef'>Form_pg_class</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2392"><span class='Ref_To_Local'>tp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2393"><span class='Ref_To_Local'>reltup</span></a><span class='Operator'>-&GT;</span>reloftype <span class='Operator'>== </span><a href="parse_coerce.c.html#LN2385"><span class='Ref_to_Parameter'>reloftypeId</span></a><span class='Parentheses'>) 
</span>            <a href="parse_coerce.c.html#LN2388"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="parse_coerce.c.html#LN2392"><span class='Ref_To_Local'>tp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="parse_coerce.c.html#LN2388"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end typeIsOfTypedTable &raquo; </span> 
</pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>