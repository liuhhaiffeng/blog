<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\parser\parse_collate.c</title>
<LINK REL=StyleSheet HREF="../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\parser\parse_collate.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:44 2017
</td></tr>
<tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * parse_collate.c 
 *      Routines for assigning collation information. 
 * 
 * We choose to handle collation analysis in a post-pass over the output 
 * of expression parse analysis.  This is because we need more state to 
 * perform this processing than is needed in the finished tree.  If we 
 * did it on-the-fly while building the tree, all that state would have 
 * to be kept in expression node trees permanently.  This way, the extra 
 * storage is just local variables in this recursive routine. 
 * 
 * The info that is actually saved in the finished tree is: 
 * 1. The output collation of each expression node, or InvalidOid if it 
 * returns a noncollatable data type.  This can also be InvalidOid if the 
 * result type is collatable but the collation is indeterminate. 
 * 2. The collation to be used in executing each function.  InvalidOid means 
 * that there are no collatable inputs or their collation is indeterminate. 
 * This value is only stored in node types that might call collation-using 
 * functions. 
 * 
 * You might think we could get away with storing only one collation per 
 * node, but the two concepts really need to be kept distinct.  Otherwise 
 * it's too confusing when a function produces a collatable output type but 
 * has no collatable inputs or produces noncollatable output from collatable 
 * inputs. 
 * 
 * Cases with indeterminate collation might result in an error being thrown 
 * at runtime.  If we knew exactly which functions require collation 
 * information, we could throw those errors at parse time instead. 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * 
 * IDENTIFICATION 
 *    src/backend/parser/parse_collate.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_aggregate.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_collation.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/makefuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/nodeFuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_collate.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/lsyscache.h"</span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Collation strength (the SQL standard calls this "derivation").  Order is 
 * chosen to allow comparisons to work usefully.  Note: the standard doesn't 
 * seem to distinguish between NONE and CONFLICT. 
 */ 
</span><span class='Control'>typedef</span> <span class='Control'>enum</span> 
<span class='Delimiter'>{ 
</span><a name="LN57"></a>    <span class='Declare_Enum_Const'>COLLATE_NONE</span><span class='Delimiter'>,</span>               <span class='Comment_Single_Line'>/* expression is of a noncollatable datatype */ 
</span><a name="LN58"></a>    <span class='Declare_Enum_Const'>COLLATE_IMPLICIT</span><span class='Delimiter'>,</span>           <span class='Comment_Single_Line'>/* collation was derived implicitly */ 
</span><a name="LN59"></a>    <span class='Declare_Enum_Const'>COLLATE_CONFLICT</span><span class='Delimiter'>,</span>           <span class='Comment_Single_Line'>/* we had a conflict of implicit collations */ 
</span><a name="LN60"></a>    <span class='Declare_Enum_Const'>COLLATE_EXPLICIT</span>            <span class='Comment_Single_Line'>/* collation was derived explicitly */ 
</span><a name="LN61"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CollateStrength</span><span class='Delimiter'>; 
</span> 
<span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN65"></a>    <a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Member'>pstate</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* parse state (for error reporting) */ 
</span><a name="LN66"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>collation</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* OID of current collation, if any */ 
</span><a name="LN67"></a>    <a href="parse_collate.c.html#LN55"><span class='Ref_to_Typedef'>CollateStrength</span></a> <span class='Declare_Member'>strength</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* strength of current collation choice */ 
</span><a name="LN68"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* location of expr that set collation */ 
</span>    <span class='Comment_Multi_Line'>/* Remaining fields are only valid when strength == COLLATE_CONFLICT */ 
</span><a name="LN70"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>collation2</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* OID of conflicting collation */ 
</span><a name="LN71"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location2</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* location of expr that set collation2 */ 
</span><a name="LN72"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>assign_collations_context</span><span class='Delimiter'>; 
</span> 
<a name="LN74"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>assign_query_collations_walker</span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN75"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>assign_collations_walker</span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, 
</span><a name="LN76"></a>                         <a href="parse_collate.c.html#LN63"><span class='Ref_to_Typedef'>assign_collations_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN77"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>merge_collation_state</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>collation</span><span class='Delimiter'>, 
</span><a name="LN78"></a>                      <a href="parse_collate.c.html#LN55"><span class='Ref_to_Typedef'>CollateStrength</span></a> <span class='Declare_Parameter'>strength</span><span class='Delimiter'>, 
</span><a name="LN79"></a>                      <span class='Keyword'>int </span><span class='Declare_Parameter'>location</span><span class='Delimiter'>, 
</span><a name="LN80"></a>                      <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>collation2</span><span class='Delimiter'>, 
</span><a name="LN81"></a>                      <span class='Keyword'>int </span><span class='Declare_Parameter'>location2</span><span class='Delimiter'>, 
</span><a name="LN82"></a>                      <a href="parse_collate.c.html#LN63"><span class='Ref_to_Typedef'>assign_collations_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN83"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>assign_aggregate_collations</span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggref</span><span class='Delimiter'>, 
</span><a name="LN84"></a>                            <a href="parse_collate.c.html#LN63"><span class='Ref_to_Typedef'>assign_collations_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>loccontext</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN85"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>assign_ordered_set_collations</span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggref</span><span class='Delimiter'>, 
</span><a name="LN86"></a>                              <a href="parse_collate.c.html#LN63"><span class='Ref_to_Typedef'>assign_collations_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>loccontext</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN87"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>assign_hypothetical_collations</span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggref</span><span class='Delimiter'>, 
</span><a name="LN88"></a>                               <a href="parse_collate.c.html#LN63"><span class='Ref_to_Typedef'>assign_collations_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>loccontext</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * assign_query_collations() 
 *      Mark all expressions in the given Query with collation information. 
 * 
 * This should be applied to each Query after completion of parse analysis 
 * for expressions.  Note that we do not recurse into sub-Queries, since 
 * those should have been processed when built. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN100"></a><span class='Declare_Function'>assign_query_collations</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>query</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * We just use query_tree_walker() to visit all the contained expressions. 
     * We can skip the rangetable and CTE subqueries, though, since RTEs and 
     * subqueries had better have been processed already (else Vars referring 
     * to them would not get created with the right collation). 
     */ 
</span>    <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="../../include/nodes/nodeFuncs.h.html#LN57"><span class='Ref_to_Proto'>query_tree_walker</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN100"><span class='Ref_to_Parameter'>query</span></a><span class='Delimiter'>, 
</span>                             <a href="parse_collate.c.html#LN74"><span class='Ref_to_Proto'>assign_query_collations_walker</span></a><span class='Delimiter'>, 
</span>                             <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN100"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                             <a href="../../include/nodes/nodeFuncs.h.html#LN23"><span class='Ref_to_Const'>QTW_IGNORE_RANGE_TABLE</span></a> <span class='Operator'>| 
</span>                             <a href="../../include/nodes/nodeFuncs.h.html#LN20"><span class='Ref_to_Const'>QTW_IGNORE_CTE_SUBQUERIES</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Walker for assign_query_collations 
 * 
 * Each expression found by query_tree_walker is processed independently. 
 * Note that query_tree_walker may pass us a whole List, such as the 
 * targetlist, in which case each subexpression must be processed 
 * independently --- we don't want to bleat if two different targetentries 
 * have different collations. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN125"></a><span class='Declare_Function'>assign_query_collations_walker</span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* Need do nothing for empty subexpressions */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_collate.c.html#LN125"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We don't want to recurse into a set-operations tree; it's already been 
     * fully processed in transformSetOperationStmt. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN125"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN1545"><span class='Ref_to_Struct'>SetOperationStmt</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN125"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a><span class='Parentheses'>))</span> 
        <a href="../../include/parser/parse_collate.h.html#LN20"><span class='Ref_to_Proto'>assign_list_collations</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN125"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN125"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="../../include/parser/parse_collate.h.html#LN22"><span class='Ref_to_Proto'>assign_expr_collations</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN125"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_collate.c.html#LN125"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end assign_query_collations_walker &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * assign_list_collations() 
 *      Mark all nodes in the list of expressions with collation information. 
 * 
 * The list member expressions are processed independently; they do not have 
 * to share a common collation. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN154"></a><span class='Declare_Function'>assign_list_collations</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>exprs</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN156"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN156"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="parse_collate.c.html#LN154"><span class='Ref_to_Parameter'>exprs</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN160"></a>        <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>node</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN156"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/parser/parse_collate.h.html#LN22"><span class='Ref_to_Proto'>assign_expr_collations</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN154"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_collate.c.html#LN160"><span class='Ref_To_Local'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * assign_expr_collations() 
 *      Mark all nodes in the given expression tree with collation information. 
 * 
 * This is exported for the benefit of various utility commands that process 
 * expressions without building a complete Query.  It should be applied after 
 * calling transformExpr() plus any expression-modifying operations such as 
 * coerce_to_boolean(). 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN176"></a><span class='Declare_Function'>assign_expr_collations</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>expr</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN178"></a>    <a href="parse_collate.c.html#LN63"><span class='Ref_to_Typedef'>assign_collations_context</span></a> <span class='Declare_Local'>context</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* initialize context for tree walk */ 
</span>    <a href="parse_collate.c.html#LN178"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN65"><span class='Ref_to_Member'>pstate</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN176"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>; 
</span>    <a href="parse_collate.c.html#LN178"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN66"><span class='Ref_to_Member'>collation</span></a> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>    <a href="parse_collate.c.html#LN178"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN67"><span class='Ref_to_Member'>strength</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN57"><span class='Ref_to_EnumConst'>COLLATE_NONE</span></a><span class='Delimiter'>; 
</span>    <a href="parse_collate.c.html#LN178"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN68"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* and away we go */ 
</span>    <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN75"><span class='Ref_to_Proto'>assign_collations_walker</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN176"><span class='Ref_to_Parameter'>expr</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_collate.c.html#LN178"><span class='Ref_To_Local'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * select_common_collation() 
 *      Identify a common collation for a list of expressions. 
 * 
 * The expressions should all return the same datatype, else this is not 
 * terribly meaningful. 
 * 
 * none_ok means that it is permitted to return InvalidOid, indicating that 
 * no common collation could be identified, even for collatable datatypes. 
 * Otherwise, an error is thrown for conflict of implicit collations. 
 * 
 * In theory, none_ok = true reflects the rules of SQL standard clause "Result 
 * of data type combinations", none_ok = false reflects the rules of clause 
 * "Collation determination" (in some cases invoked via "Grouping 
 * operations"). 
 */ 
</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> 
<a name="LN207"></a><span class='Declare_Function'>select_common_collation</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>exprs</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>none_ok</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN209"></a>    <a href="parse_collate.c.html#LN63"><span class='Ref_to_Typedef'>assign_collations_context</span></a> <span class='Declare_Local'>context</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* initialize context for tree walk */ 
</span>    <a href="parse_collate.c.html#LN209"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN65"><span class='Ref_to_Member'>pstate</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN207"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>; 
</span>    <a href="parse_collate.c.html#LN209"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN66"><span class='Ref_to_Member'>collation</span></a> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>    <a href="parse_collate.c.html#LN209"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN67"><span class='Ref_to_Member'>strength</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN57"><span class='Ref_to_EnumConst'>COLLATE_NONE</span></a><span class='Delimiter'>; 
</span>    <a href="parse_collate.c.html#LN209"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN68"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* and away we go */ 
</span>    <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN75"><span class='Ref_to_Proto'>assign_collations_walker</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN207"><span class='Ref_to_Parameter'>exprs</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_collate.c.html#LN209"><span class='Ref_To_Local'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* deal with collation conflict */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_collate.c.html#LN209"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN67"><span class='Ref_to_Member'>strength</span></a> <span class='Operator'>== </span><a href="parse_collate.c.html#LN59"><span class='Ref_to_EnumConst'>COLLATE_CONFLICT</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_collate.c.html#LN207"><span class='Ref_to_Parameter'>none_ok</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_COLLATION_MISMATCH<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"collation mismatch between implicit collations \"%s\" and \"%s\""</span><span class='Delimiter'>, 
</span>                        <a href="../../include/utils/lsyscache.h.html#LN93"><span class='Ref_to_Proto'>get_collation_name</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN209"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN66"><span class='Ref_to_Member'>collation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                        <a href="../../include/utils/lsyscache.h.html#LN93"><span class='Ref_to_Proto'>get_collation_name</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN209"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN70"><span class='Ref_to_Member'>collation2</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"You can choose the collation by applying the COLLATE clause to one or both expressions."</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN209"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN65"><span class='Ref_to_Member'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_collate.c.html#LN209"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN71"><span class='Ref_to_Member'>location2</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Note: if strength is still COLLATE_NONE, we'll return InvalidOid, but 
     * that's okay because it must mean none of the expressions returned 
     * collatable datatypes. 
     */ 
</span>    <span class='Control'>return</span> <a href="parse_collate.c.html#LN209"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN66"><span class='Ref_to_Member'>collation</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end select_common_collation &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * assign_collations_walker() 
 *      Recursive guts of collation processing. 
 * 
 * Nodes with no children (eg, Vars, Consts, Params) must have been marked 
 * when built.  All upper-level nodes are marked here. 
 * 
 * Note: if this is invoked directly on a List, it will attempt to infer a 
 * common collation for all the list members.  In particular, it will throw 
 * error if there are conflicting explicit collations for different members. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN254"></a><span class='Declare_Function'>assign_collations_walker</span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><a href="parse_collate.c.html#LN63"><span class='Ref_to_Typedef'>assign_collations_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN256"></a>    <a href="parse_collate.c.html#LN63"><span class='Ref_to_Typedef'>assign_collations_context</span></a> <span class='Declare_Local'>loccontext</span><span class='Delimiter'>; 
</span><a name="LN257"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>collation</span><span class='Delimiter'>; 
</span><a name="LN258"></a>    <a href="parse_collate.c.html#LN55"><span class='Ref_to_Typedef'>CollateStrength</span></a> <span class='Declare_Local'>strength</span><span class='Delimiter'>; 
</span><a name="LN259"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>location</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Need do nothing for empty subexpressions */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Prepare for recursion.  For most node types, though not all, the first 
     * thing we do is recurse to process all nodes below this one. Each level 
     * of the tree has its own local context. 
     */ 
</span>    <a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN65"><span class='Ref_to_Member'>pstate</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_collate.c.html#LN65"><span class='Ref_to_Member'>pstate</span></a><span class='Delimiter'>; 
</span>    <a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN66"><span class='Ref_to_Member'>collation</span></a> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>    <a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN67"><span class='Ref_to_Member'>strength</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN57"><span class='Ref_to_EnumConst'>COLLATE_NONE</span></a><span class='Delimiter'>; 
</span>    <a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN68"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* Set these fields just to suppress uninitialized-value warnings: */ 
</span>    <a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN70"><span class='Ref_to_Member'>collation2</span></a> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>    <a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN71"><span class='Ref_to_Member'>location2</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Recurse if appropriate, then determine the collation for this node. 
     * 
     * Note: the general cases are at the bottom of the switch, after various 
     * special cases. 
     */ 
</span>    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN513"><span class='Ref_to_Macro'>nodeTag</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN168"><span class='Ref_to_EnumConst'>T_CollateExpr</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * COLLATE sets an explicitly derived collation, regardless of 
                 * what the child state is.  But we must recurse to set up 
                 * collation info below here. 
                 */ 
</span><a name="LN293"></a>                <a href="../../include/nodes/primnodes.h.html#LN871"><span class='Ref_to_Struct'>CollateExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN871"><span class='Ref_to_Struct'>CollateExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
                <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="../../include/nodes/nodeFuncs.h.html#LN52"><span class='Ref_to_Proto'>expression_tree_walker</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, 
</span>                                              <a href="parse_collate.c.html#LN75"><span class='Ref_to_Proto'>assign_collations_walker</span></a><span class='Delimiter'>, 
</span>                                              <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="parse_collate.c.html#LN257"><span class='Ref_To_Local'>collation</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN293"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN875"><span class='Ref_to_Member'>collOid</span></a><span class='Delimiter'>; 
</span>                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN257"><span class='Ref_To_Local'>collation</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <a href="parse_collate.c.html#LN258"><span class='Ref_To_Local'>strength</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN60"><span class='Ref_to_EnumConst'>COLLATE_EXPLICIT</span></a><span class='Delimiter'>; 
</span>                <a href="parse_collate.c.html#LN259"><span class='Ref_To_Local'>location</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN293"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN876"><span class='Ref_to_Member'>location</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN162"><span class='Ref_to_EnumConst'>T_FieldSelect</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * For FieldSelect, the result has the field's declared 
                 * collation, independently of what happened in the arguments. 
                 * (The immediate argument must be composite and thus not 
                 * collatable, anyhow.)  The field's collation was already 
                 * looked up and saved in the node. 
                 */ 
</span><a name="LN314"></a>                <a href="../../include/nodes/primnodes.h.html#LN737"><span class='Ref_to_Struct'>FieldSelect</span></a> <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN737"><span class='Ref_to_Struct'>FieldSelect</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* ... but first, recurse */ 
</span>                <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="../../include/nodes/nodeFuncs.h.html#LN52"><span class='Ref_to_Proto'>expression_tree_walker</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, 
</span>                                              <a href="parse_collate.c.html#LN75"><span class='Ref_to_Proto'>assign_collations_walker</span></a><span class='Delimiter'>, 
</span>                                              <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN314"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN745"><span class='Ref_to_Member'>resultcollid</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* Node's result type is collatable. */ 
</span>                    <span class='Comment_Multi_Line'>/* Pass up field's collation as an implicit choice. */ 
</span>                    <a href="parse_collate.c.html#LN257"><span class='Ref_To_Local'>collation</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN314"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN745"><span class='Ref_to_Member'>resultcollid</span></a><span class='Delimiter'>; 
</span>                    <a href="parse_collate.c.html#LN258"><span class='Ref_To_Local'>strength</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN58"><span class='Ref_to_EnumConst'>COLLATE_IMPLICIT</span></a><span class='Delimiter'>; 
</span>                    <a href="parse_collate.c.html#LN259"><span class='Ref_To_Local'>location</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>else</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* Node's result type isn't collatable. */ 
</span>                    <a href="parse_collate.c.html#LN257"><span class='Ref_To_Local'>collation</span></a> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>                    <a href="parse_collate.c.html#LN258"><span class='Ref_To_Local'>strength</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN57"><span class='Ref_to_EnumConst'>COLLATE_NONE</span></a><span class='Delimiter'>; 
</span>                    <a href="parse_collate.c.html#LN259"><span class='Ref_To_Local'>location</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* won't be used */ 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN173"><span class='Ref_to_EnumConst'>T_RowExpr</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * RowExpr is a special case because the subexpressions are 
                 * independent: we don't want to complain if some of them have 
                 * incompatible explicit collations. 
                 */ 
</span><a name="LN345"></a>                <a href="../../include/nodes/primnodes.h.html#LN981"><span class='Ref_to_Struct'>RowExpr</span></a>    <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN981"><span class='Ref_to_Struct'>RowExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
                <a href="../../include/parser/parse_collate.h.html#LN20"><span class='Ref_to_Proto'>assign_list_collations</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_collate.c.html#LN65"><span class='Ref_to_Member'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_collate.c.html#LN345"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN984"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Since the result is always composite and therefore never 
                 * has a collation, we can just stop here: this node has no 
                 * impact on the collation of its parent. 
                 */ 
</span>                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* done */ 
</span>            <span class='Delimiter'>} 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN174"><span class='Ref_to_EnumConst'>T_RowCompareExpr</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * For RowCompare, we have to find the common collation of 
                 * each pair of input columns and build a list.  If we can't 
                 * find a common collation, we just put InvalidOid into the 
                 * list, which may or may not cause an error at runtime. 
                 */ 
</span><a name="LN364"></a>                <a href="../../include/nodes/primnodes.h.html#LN1026"><span class='Ref_to_Struct'>RowCompareExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN1026"><span class='Ref_to_Struct'>RowCompareExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span><a name="LN365"></a>                <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>colls</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN366"></a>                <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span><a name="LN367"></a>                <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>r</span><span class='Delimiter'>; 
</span> 
                <a href="../../include/nodes/pg_list.h.html#LN179"><span class='Ref_to_Macro'>forboth</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN366"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="parse_collate.c.html#LN364"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1033"><span class='Ref_to_Member'>largs</span></a><span class='Delimiter'>, </span><a href="parse_collate.c.html#LN367"><span class='Ref_To_Local'>r</span></a><span class='Delimiter'>, </span><a href="parse_collate.c.html#LN364"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1034"><span class='Ref_to_Member'>rargs</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN371"></a>                    <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>le</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN366"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN372"></a>                    <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>re</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN367"><span class='Ref_To_Local'>r</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN373"></a>                    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>coll</span><span class='Delimiter'>; 
</span> 
                    <a href="parse_collate.c.html#LN373"><span class='Ref_To_Local'>coll</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_collate.h.html#LN24"><span class='Ref_to_Proto'>select_common_collation</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_collate.c.html#LN65"><span class='Ref_to_Member'>pstate</span></a><span class='Delimiter'>, 
</span>                                                   <a href="../../include/nodes/pg_list.h.html#LN139"><span class='Ref_to_Macro'>list_make2</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN371"><span class='Ref_To_Local'>le</span></a><span class='Delimiter'>, </span><a href="parse_collate.c.html#LN372"><span class='Ref_To_Local'>re</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                   <span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="parse_collate.c.html#LN365"><span class='Ref_To_Local'>colls</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN162"><span class='Ref_to_Func'>lappend_oid</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN365"><span class='Ref_To_Local'>colls</span></a><span class='Delimiter'>, </span><a href="parse_collate.c.html#LN373"><span class='Ref_To_Local'>coll</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <a href="parse_collate.c.html#LN364"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1032"><span class='Ref_to_Member'>inputcollids</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN365"><span class='Ref_To_Local'>colls</span></a><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Since the result is always boolean and therefore never has 
                 * a collation, we can just stop here: this node has no impact 
                 * on the collation of its parent. 
                 */ 
</span>                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* done */ 
</span>            <span class='Delimiter'>} 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN181"><span class='Ref_to_EnumConst'>T_CoerceToDomain</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * If the domain declaration included a non-default COLLATE 
                 * spec, then use that collation as the output collation of 
                 * the coercion.  Otherwise allow the input collation to 
                 * bubble up.  (The input should be of the domain's base type, 
                 * therefore we don't need to worry about it not being 
                 * collatable when the domain is.) 
                 */ 
</span><a name="LN399"></a>                <a href="../../include/nodes/primnodes.h.html#LN1215"><span class='Ref_to_Struct'>CoerceToDomain</span></a> <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN1215"><span class='Ref_to_Struct'>CoerceToDomain</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span><a name="LN400"></a>                <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>typcollation</span> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN166"><span class='Ref_to_Proto'>get_typcollation</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN399"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1219"><span class='Ref_to_Member'>resulttype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* ... but first, recurse */ 
</span>                <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="../../include/nodes/nodeFuncs.h.html#LN52"><span class='Ref_to_Proto'>expression_tree_walker</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, 
</span>                                              <a href="parse_collate.c.html#LN75"><span class='Ref_to_Proto'>assign_collations_walker</span></a><span class='Delimiter'>, 
</span>                                              <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN400"><span class='Ref_To_Local'>typcollation</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* Node's result type is collatable. */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_collate.c.html#LN400"><span class='Ref_To_Local'>typcollation</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_collation.h.html#LN74"><span class='Ref_to_Const'>DEFAULT_COLLATION_OID</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Comment_Multi_Line'>/* Collation state bubbles up from child. */ 
</span>                        <a href="parse_collate.c.html#LN257"><span class='Ref_To_Local'>collation</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN66"><span class='Ref_to_Member'>collation</span></a><span class='Delimiter'>; 
</span>                        <a href="parse_collate.c.html#LN258"><span class='Ref_To_Local'>strength</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN67"><span class='Ref_to_Member'>strength</span></a><span class='Delimiter'>; 
</span>                        <a href="parse_collate.c.html#LN259"><span class='Ref_To_Local'>location</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN68"><span class='Ref_to_Member'>location</span></a><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <span class='Control'>else</span> 
                    <span class='Delimiter'>{ 
</span>                        <span class='Comment_Multi_Line'>/* Use domain's collation as an implicit choice. */ 
</span>                        <a href="parse_collate.c.html#LN257"><span class='Ref_To_Local'>collation</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN400"><span class='Ref_To_Local'>typcollation</span></a><span class='Delimiter'>; 
</span>                        <a href="parse_collate.c.html#LN258"><span class='Ref_To_Local'>strength</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN58"><span class='Ref_to_EnumConst'>COLLATE_IMPLICIT</span></a><span class='Delimiter'>; 
</span>                        <a href="parse_collate.c.html#LN259"><span class='Ref_To_Local'>location</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>else</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* Node's result type isn't collatable. */ 
</span>                    <a href="parse_collate.c.html#LN257"><span class='Ref_To_Local'>collation</span></a> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>                    <a href="parse_collate.c.html#LN258"><span class='Ref_To_Local'>strength</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN57"><span class='Ref_to_EnumConst'>COLLATE_NONE</span></a><span class='Delimiter'>; 
</span>                    <a href="parse_collate.c.html#LN259"><span class='Ref_To_Local'>location</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* won't be used */ 
</span>                <span class='Delimiter'>} 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Save the state into the expression node.  We know it 
                 * doesn't care about input collation. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_collate.c.html#LN258"><span class='Ref_To_Local'>strength</span></a> <span class='Operator'>== </span><a href="parse_collate.c.html#LN59"><span class='Ref_to_EnumConst'>COLLATE_CONFLICT</span></a><span class='Parentheses'>) 
</span>                    <a href="../../include/nodes/nodeFuncs.h.html#LN40"><span class='Ref_to_Proto'>exprSetCollation</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>else</span> 
                    <a href="../../include/nodes/nodeFuncs.h.html#LN40"><span class='Ref_to_Proto'>exprSetCollation</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="parse_collate.c.html#LN257"><span class='Ref_To_Local'>collation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN186"><span class='Ref_to_EnumConst'>T_TargetEntry</span></a><span class='Operator'>: 
</span>            <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="../../include/nodes/nodeFuncs.h.html#LN52"><span class='Ref_to_Proto'>expression_tree_walker</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, 
</span>                                          <a href="parse_collate.c.html#LN75"><span class='Ref_to_Proto'>assign_collations_walker</span></a><span class='Delimiter'>, 
</span>                                          <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * TargetEntry can have only one child, and should bubble that 
             * state up to its parent.  We can't use the general-case code 
             * below because exprType and friends don't work on TargetEntry. 
             */ 
</span>            <a href="parse_collate.c.html#LN257"><span class='Ref_To_Local'>collation</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN66"><span class='Ref_to_Member'>collation</span></a><span class='Delimiter'>; 
</span>            <a href="parse_collate.c.html#LN258"><span class='Ref_To_Local'>strength</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN67"><span class='Ref_to_Member'>strength</span></a><span class='Delimiter'>; 
</span>            <a href="parse_collate.c.html#LN259"><span class='Ref_To_Local'>location</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN68"><span class='Ref_to_Member'>location</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Throw error if the collation is indeterminate for a TargetEntry 
             * that is a sort/group target.  We prefer to do this now, instead 
             * of leaving the comparison functions to fail at runtime, because 
             * we can give a syntax error pointer to help locate the problem. 
             * There are some cases where there might not be a failure, for 
             * example if the planner chooses to use hash aggregation instead 
             * of sorting for grouping; but it seems better to predictably 
             * throw an error.  (Compare transformSetOperationTree, which will 
             * throw error for indeterminate collation of set-op columns, even 
             * though the planner might be able to implement the set-op 
             * without sorting.) 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_collate.c.html#LN258"><span class='Ref_To_Local'>strength</span></a> <span class='Operator'>== </span><a href="parse_collate.c.html#LN59"><span class='Ref_to_EnumConst'>COLLATE_CONFLICT</span></a> <span class='Operator'>&& 
</span>                <span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>ressortgroupref <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_COLLATION_MISMATCH<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"collation mismatch between implicit collations \"%s\" and \"%s\""</span><span class='Delimiter'>, 
</span>                                <a href="../../include/utils/lsyscache.h.html#LN93"><span class='Ref_to_Proto'>get_collation_name</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN66"><span class='Ref_to_Member'>collation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                <a href="../../include/utils/lsyscache.h.html#LN93"><span class='Ref_to_Proto'>get_collation_name</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN70"><span class='Ref_to_Member'>collation2</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                         <a href="../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"You can choose the collation by applying the COLLATE clause to one or both expressions."</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_collate.c.html#LN65"><span class='Ref_to_Member'>pstate</span></a><span class='Delimiter'>, 
</span>                                            <a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN71"><span class='Ref_to_Member'>location2</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN185"><span class='Ref_to_EnumConst'>T_InferenceElem</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN187"><span class='Ref_to_EnumConst'>T_RangeTblRef</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN188"><span class='Ref_to_EnumConst'>T_JoinExpr</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN189"><span class='Ref_to_EnumConst'>T_FromExpr</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN190"><span class='Ref_to_EnumConst'>T_OnConflictExpr</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN448"><span class='Ref_to_EnumConst'>T_SortGroupClause</span></a><span class='Operator'>: 
</span>            <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="../../include/nodes/nodeFuncs.h.html#LN52"><span class='Ref_to_Proto'>expression_tree_walker</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, 
</span>                                          <a href="parse_collate.c.html#LN75"><span class='Ref_to_Proto'>assign_collations_walker</span></a><span class='Delimiter'>, 
</span>                                          <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * When we're invoked on a query's jointree, we don't need to do 
             * anything with join nodes except recurse through them to process 
             * WHERE/ON expressions.  So just stop here.  Likewise, we don't 
             * need to do anything when invoked on sort/group lists. 
             */ 
</span>            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN303"><span class='Ref_to_EnumConst'>T_Query</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * We get here when we're invoked on the Query belonging to a 
                 * SubLink.  Act as though the Query returns its first output 
                 * column, which indeed is what it does for EXPR_SUBLINK and 
                 * ARRAY_SUBLINK cases.  In the cases where the SubLink 
                 * returns boolean, this info will be ignored.  Special case: 
                 * in EXISTS, the Query might return no columns, in which case 
                 * we need do nothing. 
                 * 
                 * We needn't recurse, since the Query is already processed. 
                 */ 
</span><a name="LN511"></a>                <a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>qtree</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span><a name="LN512"></a>                <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tent</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_collate.c.html#LN511"><span class='Ref_To_Local'>qtree</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>                    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                <a href="parse_collate.c.html#LN512"><span class='Ref_To_Local'>tent</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN113"><span class='Ref_to_Macro'>linitial_node</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a><span class='Delimiter'>, </span><a href="parse_collate.c.html#LN511"><span class='Ref_To_Local'>qtree</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_collate.c.html#LN512"><span class='Ref_To_Local'>tent</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1373"><span class='Ref_to_Member'>resjunk</span></a><span class='Parentheses'>) 
</span>                    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
                <a href="parse_collate.c.html#LN257"><span class='Ref_To_Local'>collation</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN38"><span class='Ref_to_Proto'>exprCollation</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN512"><span class='Ref_To_Local'>tent</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Comment_Multi_Line'>/* collation doesn't change if it's converted to array */ 
</span>                <a href="parse_collate.c.html#LN258"><span class='Ref_To_Local'>strength</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN58"><span class='Ref_to_EnumConst'>COLLATE_IMPLICIT</span></a><span class='Delimiter'>; 
</span>                <a href="parse_collate.c.html#LN259"><span class='Ref_To_Local'>location</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN512"><span class='Ref_To_Local'>tent</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN290"><span class='Ref_to_EnumConst'>T_List</span></a><span class='Operator'>: 
</span>            <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="../../include/nodes/nodeFuncs.h.html#LN52"><span class='Ref_to_Proto'>expression_tree_walker</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, 
</span>                                          <a href="parse_collate.c.html#LN75"><span class='Ref_to_Proto'>assign_collations_walker</span></a><span class='Delimiter'>, 
</span>                                          <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * When processing a list, collation state just bubbles up from 
             * the list elements. 
             */ 
</span>            <a href="parse_collate.c.html#LN257"><span class='Ref_To_Local'>collation</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN66"><span class='Ref_to_Member'>collation</span></a><span class='Delimiter'>; 
</span>            <a href="parse_collate.c.html#LN258"><span class='Ref_To_Local'>strength</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN67"><span class='Ref_to_Member'>strength</span></a><span class='Delimiter'>; 
</span>            <a href="parse_collate.c.html#LN259"><span class='Ref_To_Local'>location</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN68"><span class='Ref_to_Member'>location</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN145"><span class='Ref_to_EnumConst'>T_Var</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN146"><span class='Ref_to_EnumConst'>T_Const</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN147"><span class='Ref_to_EnumConst'>T_Param</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN182"><span class='Ref_to_EnumConst'>T_CoerceToDomainValue</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN171"><span class='Ref_to_EnumConst'>T_CaseTestExpr</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN183"><span class='Ref_to_EnumConst'>T_SetToDefault</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN184"><span class='Ref_to_EnumConst'>T_CurrentOfExpr</span></a><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * General case for childless expression nodes.  These should 
             * already have a collation assigned; it is not this function's 
             * responsibility to look into the catalogs for base-case 
             * information. 
             */ 
</span>            <a href="parse_collate.c.html#LN257"><span class='Ref_To_Local'>collation</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN38"><span class='Ref_to_Proto'>exprCollation</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Note: in most cases, there will be an assigned collation 
             * whenever type_is_collatable(exprType(node)); but an exception 
             * occurs for a Var referencing a subquery output column for which 
             * a unique collation was not determinable.  That may lead to a 
             * runtime failure if a collation-sensitive function is applied to 
             * the Var. 
             */ 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN257"><span class='Ref_To_Local'>collation</span></a><span class='Parentheses'>))</span> 
                <a href="parse_collate.c.html#LN258"><span class='Ref_To_Local'>strength</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN58"><span class='Ref_to_EnumConst'>COLLATE_IMPLICIT</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="parse_collate.c.html#LN258"><span class='Ref_To_Local'>strength</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN57"><span class='Ref_to_EnumConst'>COLLATE_NONE</span></a><span class='Delimiter'>; 
</span>            <a href="parse_collate.c.html#LN259"><span class='Ref_To_Local'>location</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>default</span><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * General case for most expression nodes with children. First 
                 * recurse, then figure out what to assign to this node. 
                 */ 
</span><a name="LN578"></a>                <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>typcollation</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * For most node types, we want to treat all the child 
                 * expressions alike; but there are a few exceptions, hence 
                 * this inner switch. 
                 */ 
</span>                <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN513"><span class='Ref_to_Macro'>nodeTag</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN148"><span class='Ref_to_EnumConst'>T_Aggref</span></a><span class='Operator'>: 
</span>                        <span class='Delimiter'>{ 
</span>                            <span class='Comment_Multi_Line'>/* 
                             * Aggref is messy enough that we give it its own 
                             * function, in fact three of them.  The FILTER 
                             * clause is independent of the rest of the 
                             * aggregate, however, so it can be processed 
                             * separately. 
                             */ 
</span><a name="LN596"></a>                            <a href="../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>aggref</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
                            <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="parse_collate.c.html#LN596"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN307"><span class='Ref_to_Member'>aggkind</span></a><span class='Parentheses'>) 
</span>                            <span class='Delimiter'>{ 
</span>                                <span class='Control'>case</span> <a href="../../include/catalog/pg_aggregate.h.html#LN123"><span class='Ref_to_Const'>AGGKIND_NORMAL</span></a><span class='Operator'>: 
</span>                                    <a href="parse_collate.c.html#LN83"><span class='Ref_to_Proto'>assign_aggregate_collations</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN596"><span class='Ref_To_Local'>aggref</span></a><span class='Delimiter'>, 
</span>                                                                <span class='Operator'>&</span><a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                                <span class='Control'>case</span> <a href="../../include/catalog/pg_aggregate.h.html#LN124"><span class='Ref_to_Const'>AGGKIND_ORDERED_SET</span></a><span class='Operator'>: 
</span>                                    <a href="parse_collate.c.html#LN85"><span class='Ref_to_Proto'>assign_ordered_set_collations</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN596"><span class='Ref_To_Local'>aggref</span></a><span class='Delimiter'>, 
</span>                                                                <span class='Operator'>&</span><a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                                <span class='Control'>case</span> <a href="../../include/catalog/pg_aggregate.h.html#LN125"><span class='Ref_to_Const'>AGGKIND_HYPOTHETICAL</span></a><span class='Operator'>: 
</span>                                    <a href="parse_collate.c.html#LN87"><span class='Ref_to_Proto'>assign_hypothetical_collations</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN596"><span class='Ref_To_Local'>aggref</span></a><span class='Delimiter'>, 
</span>                                                                <span class='Operator'>&</span><a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                                <span class='Control'>default</span><span class='Operator'>: 
</span>                                    <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized aggkind: %d"</span><span class='Delimiter'>, 
</span>                                         <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN596"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN307"><span class='Ref_to_Member'>aggkind</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                            <span class='Delimiter'>} 
</span> 
                            <a href="../../include/parser/parse_collate.h.html#LN22"><span class='Ref_to_Proto'>assign_expr_collations</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_collate.c.html#LN65"><span class='Ref_to_Member'>pstate</span></a><span class='Delimiter'>, 
</span>                                                 <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN596"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN303"><span class='Ref_to_Member'>aggfilter</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                        <span class='Control'>break</span><span class='Delimiter'>; 
</span>                    <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN150"><span class='Ref_to_EnumConst'>T_WindowFunc</span></a><span class='Operator'>: 
</span>                        <span class='Delimiter'>{ 
</span>                            <span class='Comment_Multi_Line'>/* 
                             * WindowFunc requires special processing only for 
                             * its aggfilter clause, as for aggregates. 
                             */ 
</span><a name="LN627"></a>                            <a href="../../include/nodes/primnodes.h.html#LN351"><span class='Ref_to_Struct'>WindowFunc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>wfunc</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN351"><span class='Ref_to_Struct'>WindowFunc</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
                            <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN75"><span class='Ref_to_Proto'>assign_collations_walker</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN627"><span class='Ref_To_Local'>wfunc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN358"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>, 
</span>                                                            <span class='Operator'>&</span><a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                            <a href="../../include/parser/parse_collate.h.html#LN22"><span class='Ref_to_Proto'>assign_expr_collations</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_collate.c.html#LN65"><span class='Ref_to_Member'>pstate</span></a><span class='Delimiter'>, 
</span>                                                   <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN627"><span class='Ref_To_Local'>wfunc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN359"><span class='Ref_to_Member'>aggfilter</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                        <span class='Control'>break</span><span class='Delimiter'>; 
</span>                    <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN169"><span class='Ref_to_EnumConst'>T_CaseExpr</span></a><span class='Operator'>: 
</span>                        <span class='Delimiter'>{ 
</span>                            <span class='Comment_Multi_Line'>/* 
                             * CaseExpr is a special case because we do not 
                             * want to recurse into the test expression (if 
                             * any).  It was already marked with collations 
                             * during transformCaseExpr, and furthermore its 
                             * collation is not relevant to the result of the 
                             * CASE --- only the output expressions are. 
                             */ 
</span><a name="LN646"></a>                            <a href="../../include/nodes/primnodes.h.html#LN901"><span class='Ref_to_Struct'>CaseExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN901"><span class='Ref_to_Struct'>CaseExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span><a name="LN647"></a>                            <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
                            <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN647"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="parse_collate.c.html#LN646"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN907"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>) 
</span>                            <span class='Delimiter'>{ 
</span><a name="LN651"></a>                                <a href="../../include/nodes/primnodes.h.html#LN915"><span class='Ref_to_Struct'>CaseWhen</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>when</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN108"><span class='Ref_to_Macro'>lfirst_node</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN915"><span class='Ref_to_Struct'>CaseWhen</span></a><span class='Delimiter'>, </span><a href="parse_collate.c.html#LN647"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                                <span class='Comment_Multi_Line'>/* 
                                 * The condition expressions mustn't affect 
                                 * the CASE's result collation either; but 
                                 * since they are known to yield boolean, it's 
                                 * safe to recurse directly on them --- they 
                                 * won't change loccontext. 
                                 */ 
</span>                                <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN75"><span class='Ref_to_Proto'>assign_collations_walker</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN651"><span class='Ref_To_Local'>when</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN918"><span class='Ref_to_Member'>expr</span></a><span class='Delimiter'>, 
</span>                                                                <span class='Operator'>&</span><a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                                <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN75"><span class='Ref_to_Proto'>assign_collations_walker</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN651"><span class='Ref_To_Local'>when</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN919"><span class='Ref_to_Member'>result</span></a><span class='Delimiter'>, 
</span>                                                                <span class='Operator'>&</span><a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                            <span class='Delimiter'>} 
</span>                            <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN75"><span class='Ref_to_Proto'>assign_collations_walker</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN646"><span class='Ref_To_Local'>expr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN908"><span class='Ref_to_Member'>defresult</span></a><span class='Delimiter'>, 
</span>                                                            <span class='Operator'>&</span><a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                        <span class='Control'>break</span><span class='Delimiter'>; 
</span>                    <span class='Control'>default</span><span class='Operator'>: 
</span> 
                        <span class='Comment_Multi_Line'>/* 
                         * Normal case: all child expressions contribute 
                         * equally to loccontext. 
                         */ 
</span>                        <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="../../include/nodes/nodeFuncs.h.html#LN52"><span class='Ref_to_Proto'>expression_tree_walker</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, 
</span>                                                    <a href="parse_collate.c.html#LN75"><span class='Ref_to_Proto'>assign_collations_walker</span></a><span class='Delimiter'>, 
</span>                                                      <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch nodeTag(node) &raquo; </span> 
 
                <span class='Comment_Multi_Line'>/* 
                 * Now figure out what collation to assign to this node. 
                 */ 
</span>                <a href="parse_collate.c.html#LN578"><span class='Ref_To_Local'>typcollation</span></a> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN166"><span class='Ref_to_Proto'>get_typcollation</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN578"><span class='Ref_To_Local'>typcollation</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* Node's result is collatable; what about its input? */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN67"><span class='Ref_to_Member'>strength</span></a> <span class='Operator'>&GT; </span><a href="parse_collate.c.html#LN57"><span class='Ref_to_EnumConst'>COLLATE_NONE</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Comment_Multi_Line'>/* Collation state bubbles up from children. */ 
</span>                        <a href="parse_collate.c.html#LN257"><span class='Ref_To_Local'>collation</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN66"><span class='Ref_to_Member'>collation</span></a><span class='Delimiter'>; 
</span>                        <a href="parse_collate.c.html#LN258"><span class='Ref_To_Local'>strength</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN67"><span class='Ref_to_Member'>strength</span></a><span class='Delimiter'>; 
</span>                        <a href="parse_collate.c.html#LN259"><span class='Ref_To_Local'>location</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN68"><span class='Ref_to_Member'>location</span></a><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <span class='Control'>else</span> 
                    <span class='Delimiter'>{ 
</span>                        <span class='Comment_Multi_Line'>/* 
                         * Collatable output produced without any collatable 
                         * input.  Use the type's collation (which is usually 
                         * DEFAULT_COLLATION_OID, but might be different for a 
                         * domain). 
                         */ 
</span>                        <a href="parse_collate.c.html#LN257"><span class='Ref_To_Local'>collation</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN578"><span class='Ref_To_Local'>typcollation</span></a><span class='Delimiter'>; 
</span>                        <a href="parse_collate.c.html#LN258"><span class='Ref_To_Local'>strength</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN58"><span class='Ref_to_EnumConst'>COLLATE_IMPLICIT</span></a><span class='Delimiter'>; 
</span>                        <a href="parse_collate.c.html#LN259"><span class='Ref_To_Local'>location</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if OidIsValid(typcollati... &raquo; </span> 
                <span class='Control'>else</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* Node's result type isn't collatable. */ 
</span>                    <a href="parse_collate.c.html#LN257"><span class='Ref_To_Local'>collation</span></a> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>                    <a href="parse_collate.c.html#LN258"><span class='Ref_To_Local'>strength</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN57"><span class='Ref_to_EnumConst'>COLLATE_NONE</span></a><span class='Delimiter'>; 
</span>                    <a href="parse_collate.c.html#LN259"><span class='Ref_To_Local'>location</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* won't be used */ 
</span>                <span class='Delimiter'>} 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Save the result collation into the expression node. If the 
                 * state is COLLATE_CONFLICT, we'll set the collation to 
                 * InvalidOid, which might result in an error at runtime. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_collate.c.html#LN258"><span class='Ref_To_Local'>strength</span></a> <span class='Operator'>== </span><a href="parse_collate.c.html#LN59"><span class='Ref_to_EnumConst'>COLLATE_CONFLICT</span></a><span class='Parentheses'>) 
</span>                    <a href="../../include/nodes/nodeFuncs.h.html#LN40"><span class='Ref_to_Proto'>exprSetCollation</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>else</span> 
                    <a href="../../include/nodes/nodeFuncs.h.html#LN40"><span class='Ref_to_Proto'>exprSetCollation</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="parse_collate.c.html#LN257"><span class='Ref_To_Local'>collation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Likewise save the input collation, which is the one that 
                 * any function called by this node should use. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN67"><span class='Ref_to_Member'>strength</span></a> <span class='Operator'>== </span><a href="parse_collate.c.html#LN59"><span class='Ref_to_EnumConst'>COLLATE_CONFLICT</span></a><span class='Parentheses'>) 
</span>                    <a href="../../include/nodes/nodeFuncs.h.html#LN41"><span class='Ref_to_Proto'>exprSetInputCollation</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>else</span> 
                    <a href="../../include/nodes/nodeFuncs.h.html#LN41"><span class='Ref_to_Proto'>exprSetInputCollation</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN66"><span class='Ref_to_Member'>collation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch nodeTag(node) &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Now, merge my information into my parent's state. 
     */ 
</span>    <a href="parse_collate.c.html#LN77"><span class='Ref_to_Proto'>merge_collation_state</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN257"><span class='Ref_To_Local'>collation</span></a><span class='Delimiter'>, 
</span>                          <a href="parse_collate.c.html#LN258"><span class='Ref_To_Local'>strength</span></a><span class='Delimiter'>, 
</span>                          <a href="parse_collate.c.html#LN259"><span class='Ref_To_Local'>location</span></a><span class='Delimiter'>, 
</span>                          <a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN70"><span class='Ref_to_Member'>collation2</span></a><span class='Delimiter'>, 
</span>                          <a href="parse_collate.c.html#LN256"><span class='Ref_To_Local'>loccontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN71"><span class='Ref_to_Member'>location2</span></a><span class='Delimiter'>, 
</span>                          <a href="parse_collate.c.html#LN254"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end assign_collations_walker &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Merge collation state of a subexpression into the context for its parent. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN755"></a><span class='Declare_Function'>merge_collation_state</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>collation</span><span class='Delimiter'>, 
</span><a name="LN756"></a>                      <a href="parse_collate.c.html#LN55"><span class='Ref_to_Typedef'>CollateStrength</span></a> <span class='Declare_Parameter'>strength</span><span class='Delimiter'>, 
</span><a name="LN757"></a>                      <span class='Keyword'>int </span><span class='Declare_Parameter'>location</span><span class='Delimiter'>, 
</span><a name="LN758"></a>                      <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>collation2</span><span class='Delimiter'>, 
</span><a name="LN759"></a>                      <span class='Keyword'>int </span><span class='Declare_Parameter'>location2</span><span class='Delimiter'>, 
</span><a name="LN760"></a>                      <a href="parse_collate.c.html#LN63"><span class='Ref_to_Typedef'>assign_collations_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * If the collation strength for this node is different from what's 
     * already in *context, then this node either dominates or is dominated by 
     * earlier siblings. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_collate.c.html#LN756"><span class='Ref_to_Parameter'>strength</span></a> <span class='Operator'>&GT; </span><a href="parse_collate.c.html#LN760"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_collate.c.html#LN67"><span class='Ref_to_Member'>strength</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Override previous parent state */ 
</span>        <a href="parse_collate.c.html#LN760"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_collate.c.html#LN66"><span class='Ref_to_Member'>collation</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN755"><span class='Ref_to_Parameter'>collation</span></a><span class='Delimiter'>; 
</span>        <a href="parse_collate.c.html#LN760"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_collate.c.html#LN67"><span class='Ref_to_Member'>strength</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN756"><span class='Ref_to_Parameter'>strength</span></a><span class='Delimiter'>; 
</span>        <a href="parse_collate.c.html#LN760"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_collate.c.html#LN68"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN757"><span class='Ref_to_Parameter'>location</span></a><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Bubble up error info if applicable */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_collate.c.html#LN756"><span class='Ref_to_Parameter'>strength</span></a> <span class='Operator'>== </span><a href="parse_collate.c.html#LN59"><span class='Ref_to_EnumConst'>COLLATE_CONFLICT</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="parse_collate.c.html#LN760"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_collate.c.html#LN70"><span class='Ref_to_Member'>collation2</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN758"><span class='Ref_to_Parameter'>collation2</span></a><span class='Delimiter'>; 
</span>            <a href="parse_collate.c.html#LN760"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_collate.c.html#LN71"><span class='Ref_to_Member'>location2</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN759"><span class='Ref_to_Parameter'>location2</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_collate.c.html#LN756"><span class='Ref_to_Parameter'>strength</span></a> <span class='Operator'>== </span><a href="parse_collate.c.html#LN760"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_collate.c.html#LN67"><span class='Ref_to_Member'>strength</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Merge, or detect error if there's a collation conflict */ 
</span>        <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="parse_collate.c.html#LN756"><span class='Ref_to_Parameter'>strength</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>case</span> <a href="parse_collate.c.html#LN57"><span class='Ref_to_EnumConst'>COLLATE_NONE</span></a><span class='Operator'>: 
</span>                <span class='Comment_Multi_Line'>/* Nothing + nothing is still nothing */ 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="parse_collate.c.html#LN58"><span class='Ref_to_EnumConst'>COLLATE_IMPLICIT</span></a><span class='Operator'>: 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_collate.c.html#LN755"><span class='Ref_to_Parameter'>collation</span></a> <span class='Operator'>!= </span><a href="parse_collate.c.html#LN760"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_collate.c.html#LN66"><span class='Ref_to_Member'>collation</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* 
                     * Non-default implicit collation always beats default. 
                     */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_collate.c.html#LN760"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_collate.c.html#LN66"><span class='Ref_to_Member'>collation</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_collation.h.html#LN74"><span class='Ref_to_Const'>DEFAULT_COLLATION_OID</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Comment_Multi_Line'>/* Override previous parent state */ 
</span>                        <a href="parse_collate.c.html#LN760"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_collate.c.html#LN66"><span class='Ref_to_Member'>collation</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN755"><span class='Ref_to_Parameter'>collation</span></a><span class='Delimiter'>; 
</span>                        <a href="parse_collate.c.html#LN760"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_collate.c.html#LN67"><span class='Ref_to_Member'>strength</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN756"><span class='Ref_to_Parameter'>strength</span></a><span class='Delimiter'>; 
</span>                        <a href="parse_collate.c.html#LN760"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_collate.c.html#LN68"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN757"><span class='Ref_to_Parameter'>location</span></a><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_collate.c.html#LN755"><span class='Ref_to_Parameter'>collation</span></a> <span class='Operator'>!= </span><a href="../../include/catalog/pg_collation.h.html#LN74"><span class='Ref_to_Const'>DEFAULT_COLLATION_OID</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Comment_Multi_Line'>/* 
                         * Oops, we have a conflict.  We cannot throw error 
                         * here, since the conflict could be resolved by a 
                         * later sibling CollateExpr, or the parent might not 
                         * care about collation anyway.  Return enough info to 
                         * throw the error later, if needed. 
                         */ 
</span>                        <a href="parse_collate.c.html#LN760"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_collate.c.html#LN67"><span class='Ref_to_Member'>strength</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN59"><span class='Ref_to_EnumConst'>COLLATE_CONFLICT</span></a><span class='Delimiter'>; 
</span>                        <a href="parse_collate.c.html#LN760"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_collate.c.html#LN70"><span class='Ref_to_Member'>collation2</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN755"><span class='Ref_to_Parameter'>collation</span></a><span class='Delimiter'>; 
</span>                        <a href="parse_collate.c.html#LN760"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_collate.c.html#LN71"><span class='Ref_to_Member'>location2</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN757"><span class='Ref_to_Parameter'>location</span></a><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if collation!=context-&GT;c... &raquo; </span> 
                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="parse_collate.c.html#LN59"><span class='Ref_to_EnumConst'>COLLATE_CONFLICT</span></a><span class='Operator'>: 
</span>                <span class='Comment_Multi_Line'>/* We're still conflicted ... */ 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="parse_collate.c.html#LN60"><span class='Ref_to_EnumConst'>COLLATE_EXPLICIT</span></a><span class='Operator'>: 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_collate.c.html#LN755"><span class='Ref_to_Parameter'>collation</span></a> <span class='Operator'>!= </span><a href="parse_collate.c.html#LN760"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_collate.c.html#LN66"><span class='Ref_to_Member'>collation</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* 
                     * Oops, we have a conflict of explicit COLLATE clauses. 
                     * Here we choose to throw error immediately; that is what 
                     * the SQL standard says to do, and there's no good reason 
                     * to be less strict. 
                     */ 
</span>                    <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_COLLATION_MISMATCH<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"collation mismatch between explicit collations \"%s\" and \"%s\""</span><span class='Delimiter'>, 
</span>                                    <a href="../../include/utils/lsyscache.h.html#LN93"><span class='Ref_to_Proto'>get_collation_name</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN760"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_collate.c.html#LN66"><span class='Ref_to_Member'>collation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                    <a href="../../include/utils/lsyscache.h.html#LN93"><span class='Ref_to_Proto'>get_collation_name</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN755"><span class='Ref_to_Parameter'>collation</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                             <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN760"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="parse_collate.c.html#LN65"><span class='Ref_to_Member'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_collate.c.html#LN757"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch strength &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if strength==context-&GT;st... &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end merge_collation_state &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Aggref is a special case because expressions used only for ordering 
 * shouldn't be taken to conflict with each other or with regular args, 
 * indeed shouldn't affect the aggregate's result collation at all. 
 * We handle this by applying assign_expr_collations() to them rather than 
 * passing down our loccontext. 
 * 
 * Note that we recurse to each TargetEntry, not directly to its contained 
 * expression, so that the case above for T_TargetEntry will complain if we 
 * can't resolve a collation for an ORDER BY item (whether or not it is also 
 * a normal aggregate arg). 
 * 
 * We need not recurse into the aggorder or aggdistinct lists, because those 
 * contain only SortGroupClause nodes which we need not process. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN856"></a><span class='Declare_Function'>assign_aggregate_collations</span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggref</span><span class='Delimiter'>, 
</span><a name="LN857"></a>                            <a href="parse_collate.c.html#LN63"><span class='Ref_to_Typedef'>assign_collations_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>loccontext</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN859"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Plain aggregates have no direct args */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN856"><span class='Ref_to_Parameter'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN299"><span class='Ref_to_Member'>aggdirectargs</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Process aggregated args, holding resjunk ones at arm's length */ 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN859"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="parse_collate.c.html#LN856"><span class='Ref_to_Parameter'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN300"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN867"></a>        <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN108"><span class='Ref_to_Macro'>lfirst_node</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a><span class='Delimiter'>, </span><a href="parse_collate.c.html#LN859"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_collate.c.html#LN867"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1373"><span class='Ref_to_Member'>resjunk</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/parser/parse_collate.h.html#LN22"><span class='Ref_to_Proto'>assign_expr_collations</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN857"><span class='Ref_to_Parameter'>loccontext</span></a><span class='Operator'>-&GT;</span><a href="parse_collate.c.html#LN65"><span class='Ref_to_Member'>pstate</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN867"><span class='Ref_To_Local'>tle</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN75"><span class='Ref_to_Proto'>assign_collations_walker</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN867"><span class='Ref_To_Local'>tle</span></a><span class='Delimiter'>, </span><a href="parse_collate.c.html#LN857"><span class='Ref_to_Parameter'>loccontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end assign_aggregate_collations &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * For ordered-set aggregates, it's somewhat unclear how best to proceed. 
 * The spec-defined inverse distribution functions have only one sort column 
 * and don't return collatable types, but this is clearly too restrictive in 
 * the general case.  Our solution is to consider that the aggregate's direct 
 * arguments contribute normally to determination of the aggregate's own 
 * collation, while aggregated arguments contribute only when the aggregate 
 * is designed to have exactly one aggregated argument (i.e., it has a single 
 * aggregated argument and is non-variadic).  If it can have more than one 
 * aggregated argument, we process the aggregated arguments as independent 
 * sort columns.  This avoids throwing error for something like 
 *      agg(...) within group (order by x collate "foo", y collate "bar") 
 * while also guaranteeing that variadic aggregates don't change in behavior 
 * depending on how many sort columns a particular call happens to have. 
 * 
 * Otherwise this is much like the plain-aggregate case. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN894"></a><span class='Declare_Function'>assign_ordered_set_collations</span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggref</span><span class='Delimiter'>, 
</span><a name="LN895"></a>                              <a href="parse_collate.c.html#LN63"><span class='Ref_to_Typedef'>assign_collations_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>loccontext</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN897"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>merge_sort_collations</span><span class='Delimiter'>; 
</span><a name="LN898"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Merge sort collations to parent only if there can be only one */ 
</span>    <a href="parse_collate.c.html#LN897"><span class='Ref_To_Local'>merge_sort_collations</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN894"><span class='Ref_to_Parameter'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN300"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>1</span> <span class='Operator'>&& 
</span>                      <a href="../../include/utils/lsyscache.h.html#LN115"><span class='Ref_to_Proto'>get_func_variadictype</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN894"><span class='Ref_to_Parameter'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN293"><span class='Ref_to_Member'>aggfnoid</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Direct args, if any, are normal children of the Aggref node */ 
</span>    <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN75"><span class='Ref_to_Proto'>assign_collations_walker</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN894"><span class='Ref_to_Parameter'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN299"><span class='Ref_to_Member'>aggdirectargs</span></a><span class='Delimiter'>, 
</span>                                    <a href="parse_collate.c.html#LN895"><span class='Ref_to_Parameter'>loccontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Process aggregated args appropriately */ 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN898"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="parse_collate.c.html#LN894"><span class='Ref_to_Parameter'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN300"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN911"></a>        <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN108"><span class='Ref_to_Macro'>lfirst_node</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a><span class='Delimiter'>, </span><a href="parse_collate.c.html#LN898"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_collate.c.html#LN897"><span class='Ref_To_Local'>merge_sort_collations</span></a><span class='Parentheses'>) 
</span>            <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN75"><span class='Ref_to_Proto'>assign_collations_walker</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN911"><span class='Ref_To_Local'>tle</span></a><span class='Delimiter'>, </span><a href="parse_collate.c.html#LN895"><span class='Ref_to_Parameter'>loccontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="../../include/parser/parse_collate.h.html#LN22"><span class='Ref_to_Proto'>assign_expr_collations</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN895"><span class='Ref_to_Parameter'>loccontext</span></a><span class='Operator'>-&GT;</span><a href="parse_collate.c.html#LN65"><span class='Ref_to_Member'>pstate</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN911"><span class='Ref_To_Local'>tle</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end assign_ordered_set_collations &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Hypothetical-set aggregates are even more special: per spec, we need to 
 * unify the collations of each pair of hypothetical and aggregated args. 
 * And we need to force the choice of collation down into the sort column 
 * to ensure that the sort happens with the chosen collation.  Other than 
 * that, the behavior is like regular ordered-set aggregates.  Note that 
 * hypothetical direct arguments contribute to the aggregate collation 
 * only when their partner aggregated arguments do. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN930"></a><span class='Declare_Function'>assign_hypothetical_collations</span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggref</span><span class='Delimiter'>, 
</span><a name="LN931"></a>                               <a href="parse_collate.c.html#LN63"><span class='Ref_to_Typedef'>assign_collations_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>loccontext</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN933"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>h_cell</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN930"><span class='Ref_to_Parameter'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN299"><span class='Ref_to_Member'>aggdirectargs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN934"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>s_cell</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN930"><span class='Ref_to_Parameter'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN300"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN935"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>merge_sort_collations</span><span class='Delimiter'>; 
</span><a name="LN936"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>extra_args</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Merge sort collations to parent only if there can be only one */ 
</span>    <a href="parse_collate.c.html#LN935"><span class='Ref_To_Local'>merge_sort_collations</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN930"><span class='Ref_to_Parameter'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN300"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>1</span> <span class='Operator'>&& 
</span>                      <a href="../../include/utils/lsyscache.h.html#LN115"><span class='Ref_to_Proto'>get_func_variadictype</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN930"><span class='Ref_to_Parameter'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN293"><span class='Ref_to_Member'>aggfnoid</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Process any non-hypothetical direct args */ 
</span>    <a href="parse_collate.c.html#LN936"><span class='Ref_To_Local'>extra_args</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN930"><span class='Ref_to_Parameter'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN299"><span class='Ref_to_Member'>aggdirectargs</span></a><span class='Parentheses'>) </span><span class='Operator'>- </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN930"><span class='Ref_to_Parameter'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN300"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN936"><span class='Ref_To_Local'>extra_args</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="parse_collate.c.html#LN936"><span class='Ref_To_Local'>extra_args</span></a><span class='Operator'>-- &GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN75"><span class='Ref_to_Proto'>assign_collations_walker</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN933"><span class='Ref_To_Local'>h_cell</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="parse_collate.c.html#LN931"><span class='Ref_to_Parameter'>loccontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_collate.c.html#LN933"><span class='Ref_To_Local'>h_cell</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN933"><span class='Ref_To_Local'>h_cell</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Scan hypothetical args and aggregated args in parallel */ 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="parse_collate.c.html#LN933"><span class='Ref_To_Local'>h_cell</span></a> <span class='Operator'>&& </span><a href="parse_collate.c.html#LN934"><span class='Ref_To_Local'>s_cell</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN954"></a>        <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>h_arg</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN933"><span class='Ref_To_Local'>h_cell</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN955"></a>        <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>s_tle</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN934"><span class='Ref_To_Local'>s_cell</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN956"></a>        <a href="parse_collate.c.html#LN63"><span class='Ref_to_Typedef'>assign_collations_context</span></a> <span class='Declare_Local'>paircontext</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Assign collations internally in this pair of expressions, then 
         * choose a common collation for them.  This should match 
         * select_common_collation(), but we can't use that function as-is 
         * because we need access to the whole collation state so we can 
         * bubble it up to the aggregate function's level. 
         */ 
</span>        <a href="parse_collate.c.html#LN956"><span class='Ref_To_Local'>paircontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN65"><span class='Ref_to_Member'>pstate</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN931"><span class='Ref_to_Parameter'>loccontext</span></a><span class='Operator'>-&GT;</span><a href="parse_collate.c.html#LN65"><span class='Ref_to_Member'>pstate</span></a><span class='Delimiter'>; 
</span>        <a href="parse_collate.c.html#LN956"><span class='Ref_To_Local'>paircontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN66"><span class='Ref_to_Member'>collation</span></a> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>        <a href="parse_collate.c.html#LN956"><span class='Ref_To_Local'>paircontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN67"><span class='Ref_to_Member'>strength</span></a> <span class='Operator'>= </span><a href="parse_collate.c.html#LN57"><span class='Ref_to_EnumConst'>COLLATE_NONE</span></a><span class='Delimiter'>; 
</span>        <a href="parse_collate.c.html#LN956"><span class='Ref_To_Local'>paircontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN68"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Set these fields just to suppress uninitialized-value warnings: */ 
</span>        <a href="parse_collate.c.html#LN956"><span class='Ref_To_Local'>paircontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN70"><span class='Ref_to_Member'>collation2</span></a> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>        <a href="parse_collate.c.html#LN956"><span class='Ref_To_Local'>paircontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN71"><span class='Ref_to_Member'>location2</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
        <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN75"><span class='Ref_to_Proto'>assign_collations_walker</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN954"><span class='Ref_To_Local'>h_arg</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_collate.c.html#LN956"><span class='Ref_To_Local'>paircontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN75"><span class='Ref_to_Proto'>assign_collations_walker</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN955"><span class='Ref_To_Local'>s_tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_collate.c.html#LN956"><span class='Ref_To_Local'>paircontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* deal with collation conflict */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_collate.c.html#LN956"><span class='Ref_To_Local'>paircontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN67"><span class='Ref_to_Member'>strength</span></a> <span class='Operator'>== </span><a href="parse_collate.c.html#LN59"><span class='Ref_to_EnumConst'>COLLATE_CONFLICT</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_COLLATION_MISMATCH<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"collation mismatch between implicit collations \"%s\" and \"%s\""</span><span class='Delimiter'>, 
</span>                            <a href="../../include/utils/lsyscache.h.html#LN93"><span class='Ref_to_Proto'>get_collation_name</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN956"><span class='Ref_To_Local'>paircontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN66"><span class='Ref_to_Member'>collation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                            <a href="../../include/utils/lsyscache.h.html#LN93"><span class='Ref_to_Proto'>get_collation_name</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN956"><span class='Ref_To_Local'>paircontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN70"><span class='Ref_to_Member'>collation2</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"You can choose the collation by applying the COLLATE clause to one or both expressions."</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN956"><span class='Ref_To_Local'>paircontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN65"><span class='Ref_to_Member'>pstate</span></a><span class='Delimiter'>, 
</span>                                        <a href="parse_collate.c.html#LN956"><span class='Ref_To_Local'>paircontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN71"><span class='Ref_to_Member'>location2</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * At this point paircontext.collation can be InvalidOid only if the 
         * type is not collatable; no need to do anything in that case.  If we 
         * do have to change the sort column's collation, do it by inserting a 
         * RelabelType node into the sort column TLE. 
         * 
         * XXX This is pretty grotty for a couple of reasons: 
         * assign_collations_walker isn't supposed to be changing the 
         * expression structure like this, and a parse-time change of 
         * collation ought to be signaled by a CollateExpr not a RelabelType 
         * (the use of RelabelType for collation marking is supposed to be a 
         * planner/executor thing only).  But we have no better alternative. 
         * In particular, injecting a CollateExpr could result in the 
         * expression being interpreted differently after dump/reload, since 
         * we might be effectively promoting an implicit collation to 
         * explicit.  This kluge is relying on ruleutils.c not printing a 
         * COLLATE clause for a RelabelType, and probably on some other 
         * fragile behaviors. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN956"><span class='Ref_To_Local'>paircontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN66"><span class='Ref_to_Member'>collation</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>            <a href="parse_collate.c.html#LN956"><span class='Ref_To_Local'>paircontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN66"><span class='Ref_to_Member'>collation</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/nodeFuncs.h.html#LN38"><span class='Ref_to_Proto'>exprCollation</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN955"><span class='Ref_To_Local'>s_tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="parse_collate.c.html#LN955"><span class='Ref_To_Local'>s_tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                <a href="../../include/nodes/makefuncs.h.html#LN65"><span class='Ref_to_Proto'>makeRelabelType</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN955"><span class='Ref_To_Local'>s_tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Delimiter'>, 
</span>                                <a href="../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN955"><span class='Ref_To_Local'>s_tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                <a href="../../include/nodes/nodeFuncs.h.html#LN32"><span class='Ref_to_Proto'>exprTypmod</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_collate.c.html#LN955"><span class='Ref_To_Local'>s_tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                <a href="parse_collate.c.html#LN956"><span class='Ref_To_Local'>paircontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN66"><span class='Ref_to_Member'>collation</span></a><span class='Delimiter'>, 
</span>                                <a href="../../include/nodes/primnodes.h.html#LN438"><span class='Ref_to_EnumConst'>COERCE_IMPLICIT_CAST</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If appropriate, merge this column's collation state up to the 
         * aggregate function. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_collate.c.html#LN935"><span class='Ref_To_Local'>merge_sort_collations</span></a><span class='Parentheses'>) 
</span>            <a href="parse_collate.c.html#LN77"><span class='Ref_to_Proto'>merge_collation_state</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN956"><span class='Ref_To_Local'>paircontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN66"><span class='Ref_to_Member'>collation</span></a><span class='Delimiter'>, 
</span>                                  <a href="parse_collate.c.html#LN956"><span class='Ref_To_Local'>paircontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN67"><span class='Ref_to_Member'>strength</span></a><span class='Delimiter'>, 
</span>                                  <a href="parse_collate.c.html#LN956"><span class='Ref_To_Local'>paircontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN68"><span class='Ref_to_Member'>location</span></a><span class='Delimiter'>, 
</span>                                  <a href="parse_collate.c.html#LN956"><span class='Ref_To_Local'>paircontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN70"><span class='Ref_to_Member'>collation2</span></a><span class='Delimiter'>, 
</span>                                  <a href="parse_collate.c.html#LN956"><span class='Ref_To_Local'>paircontext</span></a><span class='Operator'>.</span><a href="parse_collate.c.html#LN71"><span class='Ref_to_Member'>location2</span></a><span class='Delimiter'>, 
</span>                                  <a href="parse_collate.c.html#LN931"><span class='Ref_to_Parameter'>loccontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="parse_collate.c.html#LN933"><span class='Ref_To_Local'>h_cell</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN933"><span class='Ref_To_Local'>h_cell</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_collate.c.html#LN934"><span class='Ref_To_Local'>s_cell</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN934"><span class='Ref_To_Local'>s_cell</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while h_cell&&s_cell &raquo; </span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_collate.c.html#LN933"><span class='Ref_To_Local'>h_cell</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>&& </span><a href="parse_collate.c.html#LN934"><span class='Ref_To_Local'>s_cell</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end assign_hypothetical_collations &raquo; </span> 
</pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>