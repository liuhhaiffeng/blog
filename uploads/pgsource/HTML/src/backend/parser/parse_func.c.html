<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\parser\parse_func.c</title>
<LINK REL=StyleSheet HREF="../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\parser\parse_func.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:44 2017
</td></tr>
<tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * parse_func.c 
 *      handle function calls in parser 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * 
 * IDENTIFICATION 
 *    src/backend/parser/parse_func.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/htup_details.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_aggregate.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_proc.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_type.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"funcapi.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"lib/stringinfo.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/makefuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/nodeFuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_agg.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_clause.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_coerce.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_expr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_func.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_relation.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_target.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_type.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/builtins.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/lsyscache.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/syscache.h"</span> 
 
 
<a name="LN37"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>unify_hypothetical_args</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, 
</span><a name="LN38"></a>                        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>fargs</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>numAggregatedArgs</span><span class='Delimiter'>, 
</span><a name="LN39"></a>                        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>actual_arg_types</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>declared_arg_types</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN40"></a><span class='Keyword'>static </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>  <span class='Declare_Prototype'>FuncNameAsType</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>funcname</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN41"></a><span class='Keyword'>static </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>ParseComplexProjection</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Declare_Parameter'>funcname</span><span class='Delimiter'>, 
</span><a name="LN42"></a>                       <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>first_arg</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>location</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 *  Parse a function call 
 * 
 *  For historical reasons, Postgres tries to treat the notations tab.col 
 *  and col(tab) as equivalent: if a single-argument function call has an 
 *  argument of complex type and the (unqualified) function name matches 
 *  any attribute of the type, we take it as a column projection.  Conversely 
 *  a function of a single complex-type argument can be written like a 
 *  column reference, allowing functions to act like computed columns. 
 * 
 *  Hence, both cases come through here.  If fn is null, we're dealing with 
 *  column syntax not function syntax, but in principle that should not 
 *  affect the lookup behavior, only which error messages we deliver. 
 *  The FuncCall struct is needed however to carry various decoration that 
 *  applies to aggregate and window functions. 
 * 
 *  Also, when fn is null, we return NULL on failure rather than 
 *  reporting a no-such-function error. 
 * 
 *  The argument expressions (in fargs) must have been transformed 
 *  already.  However, nothing in *fn has been transformed. 
 */ 
</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN68"></a><span class='Declare_Function'>ParseFuncOrColumn</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>funcname</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>fargs</span><span class='Delimiter'>, 
</span><a name="LN69"></a>                  <a href="../../include/nodes/parsenodes.h.html#LN346"><span class='Ref_to_Struct'>FuncCall</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>fn</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>location</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN71"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>is_column</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>fn</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN72"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>agg_order</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>fn</span></a> <span class='Operator'>? </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>fn</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN351"><span class='Ref_to_Member'>agg_order</span></a> <span class='Operator'>: </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN73"></a>    <a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>agg_filter</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN74"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>agg_within_group</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>fn</span></a> <span class='Operator'>? </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>fn</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN353"><span class='Ref_to_Member'>agg_within_group</span></a> <span class='Operator'>: </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN75"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>agg_star</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>fn</span></a> <span class='Operator'>? </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>fn</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN354"><span class='Ref_to_Member'>agg_star</span></a> <span class='Operator'>: </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN76"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>agg_distinct</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>fn</span></a> <span class='Operator'>? </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>fn</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN355"><span class='Ref_to_Member'>agg_distinct</span></a> <span class='Operator'>: </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN77"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>func_variadic</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>fn</span></a> <span class='Operator'>? </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>fn</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN356"><span class='Ref_to_Member'>func_variadic</span></a> <span class='Operator'>: </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN78"></a>    <a href="../../include/nodes/parsenodes.h.html#LN483"><span class='Ref_to_Struct'>WindowDef</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>over</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>fn</span></a> <span class='Operator'>? </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>fn</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN357"><span class='Ref_to_Member'>over</span></a> <span class='Operator'>: </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN79"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>rettype</span><span class='Delimiter'>; 
</span><a name="LN80"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>funcid</span><span class='Delimiter'>; 
</span><a name="LN81"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span><a name="LN82"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>nextl</span><span class='Delimiter'>; 
</span><a name="LN83"></a>    <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>first_arg</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN84"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>nargs</span><span class='Delimiter'>; 
</span><a name="LN85"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>nargsplusdefs</span><span class='Delimiter'>; 
</span><a name="LN86"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>actual_arg_types</span><span class='Delimiter'>[</span><a href="../../include/pg_config_manual.h.html#LN36"><span class='Ref_to_Const'>FUNC_MAX_ARGS</span></a><span class='Delimiter'>]; 
</span><a name="LN87"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>declared_arg_types</span><span class='Delimiter'>; 
</span><a name="LN88"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>argnames</span><span class='Delimiter'>; 
</span><a name="LN89"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>argdefaults</span><span class='Delimiter'>; 
</span><a name="LN90"></a>    <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>retval</span><span class='Delimiter'>; 
</span><a name="LN91"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>retset</span><span class='Delimiter'>; 
</span><a name="LN92"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>nvargs</span><span class='Delimiter'>; 
</span><a name="LN93"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>vatype</span><span class='Delimiter'>; 
</span><a name="LN94"></a>    <a href="../../include/parser/parse_func.h.html#LN21"><span class='Ref_to_Typedef'>FuncDetailCode</span></a> <span class='Declare_Local'>fdresult</span><span class='Delimiter'>; 
</span><a name="LN95"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>aggkind</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN96"></a>    <a href="../../include/parser/parse_node.h.html#LN249"><span class='Ref_to_Struct'>ParseCallbackState</span></a> <span class='Declare_Local'>pcbstate</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If there's an aggregate filter, transform it using transformWhereClause 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>fn</span></a> <span class='Operator'>&& </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>fn</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN352"><span class='Ref_to_Member'>agg_filter</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="parse_func.c.html#LN73"><span class='Ref_To_Local'>agg_filter</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/parser/parse_clause.h.html#LN23"><span class='Ref_to_Proto'>transformWhereClause</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>fn</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN352"><span class='Ref_to_Member'>agg_filter</span></a><span class='Delimiter'>, 
</span>                                                   <a href="../../include/parser/parse_node.h.html#LN42"><span class='Ref_to_EnumConst'>EXPR_KIND_FILTER</span></a><span class='Delimiter'>, 
</span>                                                   <span class='String'>"FILTER"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Most of the rest of the parser just assumes that functions do not have 
     * more than FUNC_MAX_ARGS parameters.  We have to test here to protect 
     * against array overruns, etc.  Of course, this may not be a function, 
     * but the test doesn't hurt. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>fargs</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT; </span><a href="../../include/pg_config_manual.h.html#LN36"><span class='Ref_to_Const'>FUNC_MAX_ARGS</span></a><span class='Parentheses'>)</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_TOO_MANY_ARGUMENTS<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>             <a href="../utils/error/elog.c.html#LN848"><span class='Ref_to_Func'>errmsg_plural</span></a><span class='Parentheses'>(</span><span class='String'>"cannot pass more than %d argument to a function"</span><span class='Delimiter'>, 
</span>                           <span class='String'>"cannot pass more than %d arguments to a function"</span><span class='Delimiter'>, 
</span>                           <a href="../../include/pg_config_manual.h.html#LN36"><span class='Ref_to_Const'>FUNC_MAX_ARGS</span></a><span class='Delimiter'>, 
</span>                           <a href="../../include/pg_config_manual.h.html#LN36"><span class='Ref_to_Const'>FUNC_MAX_ARGS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Extract arg type info in preparation for function lookup. 
     * 
     * If any arguments are Param markers of type VOID, we discard them from 
     * the parameter list. This is a hack to allow the JDBC driver to not have 
     * to distinguish "input" and "output" parameter symbols while parsing 
     * function-call constructs.  Don't do this if dealing with column syntax, 
     * nor if we had WITHIN GROUP (because in that case it's critical to keep 
     * the argument count unchanged).  We can't use foreach() because we may 
     * modify the list ... 
     */ 
</span>    <a href="parse_func.c.html#LN84"><span class='Ref_To_Local'>nargs</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN81"><span class='Ref_To_Local'>l</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>fargs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; </span><a href="parse_func.c.html#LN81"><span class='Ref_To_Local'>l</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; </span><a href="parse_func.c.html#LN81"><span class='Ref_To_Local'>l</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN82"><span class='Ref_To_Local'>nextl</span></a><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span><a name="LN135"></a>        <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>arg</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN81"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN136"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>argtype</span> <span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN135"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="parse_func.c.html#LN82"><span class='Ref_To_Local'>nextl</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN81"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN136"><span class='Ref_To_Local'>argtype</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN689"><span class='Ref_to_Const'>VOIDOID</span></a> <span class='Operator'>&& </span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN135"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN240"><span class='Ref_to_Struct'>Param</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>            <span class='Operator'>!</span><a href="parse_func.c.html#LN71"><span class='Ref_To_Local'>is_column</span></a> <span class='Operator'>&& !</span><a href="parse_func.c.html#LN74"><span class='Ref_To_Local'>agg_within_group</span></a><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>fargs</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN234"><span class='Ref_to_Proto'>list_delete_ptr</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>fargs</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN135"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="parse_func.c.html#LN86"><span class='Ref_To_Local'>actual_arg_types</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN84"><span class='Ref_To_Local'>nargs</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="parse_func.c.html#LN136"><span class='Ref_To_Local'>argtype</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Check for named arguments; if there are any, build a list of names. 
     * 
     * We allow mixed notation (some named and some not), but only with all 
     * the named parameters after all the unnamed ones.  So the name list 
     * corresponds to the last N actual parameters and we don't need any extra 
     * bookkeeping to match things up. 
     */ 
</span>    <a href="parse_func.c.html#LN88"><span class='Ref_To_Local'>argnames</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN81"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>fargs</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN161"></a>        <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>arg</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN81"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN161"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN473"><span class='Ref_to_Struct'>NamedArgExpr</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN165"></a>            <a href="../../include/nodes/primnodes.h.html#LN473"><span class='Ref_to_Struct'>NamedArgExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>na</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN473"><span class='Ref_to_Struct'>NamedArgExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_func.c.html#LN161"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>; 
</span><a name="LN166"></a>            <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Reject duplicate arg names */ 
</span>            <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN166"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN88"><span class='Ref_To_Local'>argnames</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="parse_func.c.html#LN165"><span class='Ref_To_Local'>na</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN477"><span class='Ref_to_Member'>name</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN166"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>))</span> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                    <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_SYNTAX_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                           <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"argument name \"%s\" used more than once"</span><span class='Delimiter'>, 
</span>                                  <a href="parse_func.c.html#LN165"><span class='Ref_To_Local'>na</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN477"><span class='Ref_to_Member'>name</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN165"><span class='Ref_To_Local'>na</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN479"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <a href="parse_func.c.html#LN88"><span class='Ref_To_Local'>argnames</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN88"><span class='Ref_To_Local'>argnames</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN165"><span class='Ref_To_Local'>na</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN477"><span class='Ref_to_Member'>name</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN88"><span class='Ref_To_Local'>argnames</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_SYNTAX_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                  <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"positional argument cannot follow named argument"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN161"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>fargs</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="parse_func.c.html#LN83"><span class='Ref_To_Local'>first_arg</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>fargs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_func.c.html#LN83"><span class='Ref_To_Local'>first_arg</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Check for column projection: if function has one argument, and that 
     * argument is of complex type, and function name is not qualified, then 
     * the "function call" could be a projection.  We also check that there 
     * wasn't any aggregate or variadic decoration, nor an argument name. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN84"><span class='Ref_To_Local'>nargs</span></a> <span class='Operator'>== </span><span class='Number'>1</span> <span class='Operator'>&& </span><a href="parse_func.c.html#LN72"><span class='Ref_To_Local'>agg_order</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>&& </span><a href="parse_func.c.html#LN73"><span class='Ref_To_Local'>agg_filter</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>&& !</span><a href="parse_func.c.html#LN75"><span class='Ref_To_Local'>agg_star</span></a> <span class='Operator'>&& 
</span>        <span class='Operator'>!</span><a href="parse_func.c.html#LN76"><span class='Ref_To_Local'>agg_distinct</span></a> <span class='Operator'>&& </span><a href="parse_func.c.html#LN78"><span class='Ref_To_Local'>over</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>&& !</span><a href="parse_func.c.html#LN77"><span class='Ref_To_Local'>func_variadic</span></a> <span class='Operator'>&& </span><a href="parse_func.c.html#LN88"><span class='Ref_To_Local'>argnames</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>&& 
</span>        <a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>funcname</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span><a name="LN206"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>argtype</span> <span class='Operator'>= </span><a href="parse_func.c.html#LN86"><span class='Ref_To_Local'>actual_arg_types</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN206"><span class='Ref_To_Local'>argtype</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN679"><span class='Ref_to_Const'>RECORDOID</span></a> <span class='Operator'>|| </span><a href="../../include/parser/parse_type.h.html#LN52"><span class='Ref_to_Macro'>ISCOMPLEX</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN206"><span class='Ref_To_Local'>argtype</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="parse_func.c.html#LN90"><span class='Ref_To_Local'>retval</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN41"><span class='Ref_to_Proto'>ParseComplexProjection</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                            <a href="../../include/nodes/value.h.html#LN53"><span class='Ref_to_Macro'>strVal</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>funcname</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                                            <a href="parse_func.c.html#LN83"><span class='Ref_To_Local'>first_arg</span></a><span class='Delimiter'>, 
</span>                                            <a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN90"><span class='Ref_To_Local'>retval</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>return</span> <a href="parse_func.c.html#LN90"><span class='Ref_To_Local'>retval</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * If ParseComplexProjection doesn't recognize it as a projection, 
             * just press on. 
             */ 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if nargs==1&&agg_order==... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Okay, it's not a column projection, so it must really be a function. 
     * func_get_detail looks up the function in the catalogs, does 
     * disambiguation for polymorphic functions, handles inheritance, and 
     * returns the funcid and type and set or singleton status of the 
     * function's return value.  It also returns the true argument types to 
     * the function. 
     * 
     * Note: for a named-notation or variadic function call, the reported 
     * "true" types aren't really what is in pg_proc: the types are reordered 
     * to match the given argument order of named arguments, and a variadic 
     * argument is replaced by a suitable number of copies of its element 
     * type.  We'll fix up the variadic case below.  We may also have to deal 
     * with default arguments. 
     */ 
</span> 
    <a href="parse_node.c.html#LN143"><span class='Ref_to_Func'>setup_parser_errposition_callback</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="parse_func.c.html#LN96"><span class='Ref_To_Local'>pcbstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="parse_func.c.html#LN94"><span class='Ref_To_Local'>fdresult</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_func.h.html#LN35"><span class='Ref_to_Proto'>func_get_detail</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>funcname</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>fargs</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN88"><span class='Ref_To_Local'>argnames</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN84"><span class='Ref_To_Local'>nargs</span></a><span class='Delimiter'>, 
</span>                               <a href="parse_func.c.html#LN86"><span class='Ref_To_Local'>actual_arg_types</span></a><span class='Delimiter'>, 
</span>                               <span class='Operator'>!</span><a href="parse_func.c.html#LN77"><span class='Ref_To_Local'>func_variadic</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, 
</span>                               <span class='Operator'>&</span><a href="parse_func.c.html#LN80"><span class='Ref_To_Local'>funcid</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_func.c.html#LN79"><span class='Ref_To_Local'>rettype</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_func.c.html#LN91"><span class='Ref_To_Local'>retset</span></a><span class='Delimiter'>, 
</span>                               <span class='Operator'>&</span><a href="parse_func.c.html#LN92"><span class='Ref_To_Local'>nvargs</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_func.c.html#LN93"><span class='Ref_To_Local'>vatype</span></a><span class='Delimiter'>, 
</span>                               <span class='Operator'>&</span><a href="parse_func.c.html#LN87"><span class='Ref_To_Local'>declared_arg_types</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_func.c.html#LN89"><span class='Ref_To_Local'>argdefaults</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="parse_node.c.html#LN159"><span class='Ref_to_Func'>cancel_parser_errposition_callback</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="parse_func.c.html#LN96"><span class='Ref_To_Local'>pcbstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN94"><span class='Ref_To_Local'>fdresult</span></a> <span class='Operator'>== </span><a href="../../include/parser/parse_func.h.html#LN28"><span class='Ref_to_EnumConst'>FUNCDETAIL_COERCION</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We interpreted it as a type coercion. coerce_type can handle these 
         * cases, so why duplicate code... 
         */ 
</span>        <span class='Control'>return</span> <a href="../../include/parser/parse_coerce.h.html#LN45"><span class='Ref_to_Proto'>coerce_type</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>fargs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                           <a href="parse_func.c.html#LN86"><span class='Ref_To_Local'>actual_arg_types</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>], </span><a href="parse_func.c.html#LN79"><span class='Ref_To_Local'>rettype</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                           <a href="../../include/nodes/primnodes.h.html#LN422"><span class='Ref_to_EnumConst'>COERCION_EXPLICIT</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN436"><span class='Ref_to_EnumConst'>COERCE_EXPLICIT_CALL</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN94"><span class='Ref_To_Local'>fdresult</span></a> <span class='Operator'>== </span><a href="../../include/parser/parse_func.h.html#LN25"><span class='Ref_to_EnumConst'>FUNCDETAIL_NORMAL</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Normal function found; was there anything indicating it must be an 
         * aggregate? 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN75"><span class='Ref_To_Local'>agg_star</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_WRONG_OBJECT_TYPE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>               <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"%s(*) specified, but %s is not an aggregate function"</span><span class='Delimiter'>, 
</span>                      <a href="../../include/catalog/namespace.h.html#LN120"><span class='Ref_to_Proto'>NameListToString</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>funcname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                      <a href="../../include/catalog/namespace.h.html#LN120"><span class='Ref_to_Proto'>NameListToString</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>funcname</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN76"><span class='Ref_To_Local'>agg_distinct</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_WRONG_OBJECT_TYPE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>            <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"DISTINCT specified, but %s is not an aggregate function"</span><span class='Delimiter'>, 
</span>                   <a href="../../include/catalog/namespace.h.html#LN120"><span class='Ref_to_Proto'>NameListToString</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>funcname</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN74"><span class='Ref_To_Local'>agg_within_group</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_WRONG_OBJECT_TYPE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"WITHIN GROUP specified, but %s is not an aggregate function"</span><span class='Delimiter'>, 
</span>                            <a href="../../include/catalog/namespace.h.html#LN120"><span class='Ref_to_Proto'>NameListToString</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>funcname</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN72"><span class='Ref_To_Local'>agg_order</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_WRONG_OBJECT_TYPE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>            <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"ORDER BY specified, but %s is not an aggregate function"</span><span class='Delimiter'>, 
</span>                   <a href="../../include/catalog/namespace.h.html#LN120"><span class='Ref_to_Proto'>NameListToString</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>funcname</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN73"><span class='Ref_To_Local'>agg_filter</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_WRONG_OBJECT_TYPE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>              <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"FILTER specified, but %s is not an aggregate function"</span><span class='Delimiter'>, 
</span>                     <a href="../../include/catalog/namespace.h.html#LN120"><span class='Ref_to_Proto'>NameListToString</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>funcname</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN78"><span class='Ref_To_Local'>over</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_WRONG_OBJECT_TYPE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"OVER specified, but %s is not a window function nor an aggregate function"</span><span class='Delimiter'>, 
</span>                            <a href="../../include/catalog/namespace.h.html#LN120"><span class='Ref_to_Proto'>NameListToString</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>funcname</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if fdresult==FUNCDETAIL_... &raquo; </span> 
    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN94"><span class='Ref_To_Local'>fdresult</span></a> <span class='Operator'>== </span><a href="../../include/parser/parse_func.h.html#LN26"><span class='Ref_to_EnumConst'>FUNCDETAIL_AGGREGATE</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * It's an aggregate; fetch needed info from the pg_aggregate entry. 
         */ 
</span><a name="LN310"></a>        <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>tup</span><span class='Delimiter'>; 
</span><a name="LN311"></a>        <a href="../../include/catalog/pg_aggregate.h.html#LN86"><span class='Ref_to_Typedef'>Form_pg_aggregate</span></a> <span class='Declare_Local'>classForm</span><span class='Delimiter'>; 
</span><a name="LN312"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>catDirectArgs</span><span class='Delimiter'>; 
</span> 
        <a href="parse_func.c.html#LN310"><span class='Ref_To_Local'>tup</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN155"><span class='Ref_to_Macro'>SearchSysCache1</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN33"><span class='Ref_to_EnumConst'>AGGFNOID</span></a><span class='Delimiter'>, </span><a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN80"><span class='Ref_To_Local'>funcid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN310"><span class='Ref_To_Local'>tup</span></a><span class='Parentheses'>))</span>     <span class='Comment_Single_Line'>/* should not happen */ 
</span>            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for aggregate %u"</span><span class='Delimiter'>, </span><a href="parse_func.c.html#LN80"><span class='Ref_To_Local'>funcid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_func.c.html#LN311"><span class='Ref_To_Local'>classForm</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_aggregate.h.html#LN86"><span class='Ref_to_Typedef'>Form_pg_aggregate</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN310"><span class='Ref_To_Local'>tup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_func.c.html#LN95"><span class='Ref_To_Local'>aggkind</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN311"><span class='Ref_To_Local'>classForm</span></a><span class='Operator'>-&GT;</span>aggkind<span class='Delimiter'>; 
</span>        <a href="parse_func.c.html#LN312"><span class='Ref_To_Local'>catDirectArgs</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN311"><span class='Ref_To_Local'>classForm</span></a><span class='Operator'>-&GT;</span>aggnumdirectargs<span class='Delimiter'>; 
</span>        <a href="../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN310"><span class='Ref_To_Local'>tup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Now check various disallowed cases. */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/catalog/pg_aggregate.h.html#LN128"><span class='Ref_to_Macro'>AGGKIND_IS_ORDERED_SET</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN95"><span class='Ref_To_Local'>aggkind</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN325"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>numAggregatedArgs</span><span class='Delimiter'>; 
</span><a name="LN326"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>numDirectArgs</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_func.c.html#LN74"><span class='Ref_To_Local'>agg_within_group</span></a><span class='Parentheses'>) 
</span>                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_WRONG_OBJECT_TYPE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"WITHIN GROUP is required for ordered-set aggregate %s"</span><span class='Delimiter'>, 
</span>                                <a href="../../include/catalog/namespace.h.html#LN120"><span class='Ref_to_Proto'>NameListToString</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>funcname</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                         <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN78"><span class='Ref_To_Local'>over</span></a><span class='Parentheses'>) 
</span>                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"OVER is not supported for ordered-set aggregate %s"</span><span class='Delimiter'>, 
</span>                        <a href="../../include/catalog/namespace.h.html#LN120"><span class='Ref_to_Proto'>NameListToString</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>funcname</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                         <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* gram.y rejects DISTINCT + WITHIN GROUP */ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_func.c.html#LN76"><span class='Ref_To_Local'>agg_distinct</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* gram.y rejects VARIADIC + WITHIN GROUP */ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_func.c.html#LN77"><span class='Ref_To_Local'>func_variadic</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Since func_get_detail was working with an undifferentiated list 
             * of arguments, it might have selected an aggregate that doesn't 
             * really match because it requires a different division of direct 
             * and aggregated arguments.  Check that the number of direct 
             * arguments is actually OK; if not, throw an "undefined function" 
             * error, similarly to the case where a misplaced ORDER BY is used 
             * in a regular aggregate call. 
             */ 
</span>            <a href="parse_func.c.html#LN325"><span class='Ref_To_Local'>numAggregatedArgs</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN72"><span class='Ref_To_Local'>agg_order</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="parse_func.c.html#LN326"><span class='Ref_To_Local'>numDirectArgs</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN84"><span class='Ref_To_Local'>nargs</span></a> <span class='Operator'>- </span><a href="parse_func.c.html#LN325"><span class='Ref_To_Local'>numAggregatedArgs</span></a><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_func.c.html#LN326"><span class='Ref_To_Local'>numDirectArgs</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN93"><span class='Ref_To_Local'>vatype</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Test is simple if aggregate isn't variadic */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN326"><span class='Ref_To_Local'>numDirectArgs</span></a> <span class='Operator'>!= </span><a href="parse_func.c.html#LN312"><span class='Ref_To_Local'>catDirectArgs</span></a><span class='Parentheses'>) 
</span>                    <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_UNDEFINED_FUNCTION<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"function %s does not exist"</span><span class='Delimiter'>, 
</span>                                    <a href="../../include/parser/parse_func.h.html#LN59"><span class='Ref_to_Proto'>func_signature_string</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>funcname</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN84"><span class='Ref_To_Local'>nargs</span></a><span class='Delimiter'>, 
</span>                                                          <a href="parse_func.c.html#LN88"><span class='Ref_To_Local'>argnames</span></a><span class='Delimiter'>, 
</span>                                                          <a href="parse_func.c.html#LN86"><span class='Ref_To_Local'>actual_arg_types</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                             <a href="../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"There is an ordered-set aggregate %s, but it requires %d direct arguments, not %d."</span><span class='Delimiter'>, 
</span>                                     <a href="../../include/catalog/namespace.h.html#LN120"><span class='Ref_to_Proto'>NameListToString</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>funcname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                     <a href="parse_func.c.html#LN312"><span class='Ref_To_Local'>catDirectArgs</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN326"><span class='Ref_To_Local'>numDirectArgs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * If it's variadic, we have two cases depending on whether 
                 * the agg was "... ORDER BY VARIADIC" or "..., VARIADIC ORDER 
                 * BY VARIADIC".  It's the latter if catDirectArgs equals 
                 * pronargs; to save a catalog lookup, we reverse-engineer 
                 * pronargs from the info we got from func_get_detail. 
                 */ 
</span><a name="LN382"></a>                <span class='Keyword'>int</span>         <span class='Declare_Local'>pronargs</span><span class='Delimiter'>; 
</span> 
                <a href="parse_func.c.html#LN382"><span class='Ref_To_Local'>pronargs</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN84"><span class='Ref_To_Local'>nargs</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN92"><span class='Ref_To_Local'>nvargs</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>                    <a href="parse_func.c.html#LN382"><span class='Ref_To_Local'>pronargs</span></a> <span class='Operator'>-= </span><a href="parse_func.c.html#LN92"><span class='Ref_To_Local'>nvargs</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN312"><span class='Ref_To_Local'>catDirectArgs</span></a> <span class='Operator'>&LT; </span><a href="parse_func.c.html#LN382"><span class='Ref_To_Local'>pronargs</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* VARIADIC isn't part of direct args, so still easy */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN326"><span class='Ref_To_Local'>numDirectArgs</span></a> <span class='Operator'>!= </span><a href="parse_func.c.html#LN312"><span class='Ref_To_Local'>catDirectArgs</span></a><span class='Parentheses'>) 
</span>                        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_UNDEFINED_FUNCTION<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"function %s does not exist"</span><span class='Delimiter'>, 
</span>                                        <a href="../../include/parser/parse_func.h.html#LN59"><span class='Ref_to_Proto'>func_signature_string</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>funcname</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN84"><span class='Ref_To_Local'>nargs</span></a><span class='Delimiter'>, 
</span>                                                              <a href="parse_func.c.html#LN88"><span class='Ref_To_Local'>argnames</span></a><span class='Delimiter'>, 
</span>                                                          <a href="parse_func.c.html#LN86"><span class='Ref_To_Local'>actual_arg_types</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                                 <a href="../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"There is an ordered-set aggregate %s, but it requires %d direct arguments, not %d."</span><span class='Delimiter'>, 
</span>                                         <a href="../../include/catalog/namespace.h.html#LN120"><span class='Ref_to_Proto'>NameListToString</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>funcname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                         <a href="parse_func.c.html#LN312"><span class='Ref_To_Local'>catDirectArgs</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN326"><span class='Ref_To_Local'>numDirectArgs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                 <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>else</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* 
                     * Both direct and aggregated args were declared variadic. 
                     * For a standard ordered-set aggregate, it's okay as long 
                     * as there aren't too few direct args.  For a 
                     * hypothetical-set aggregate, we assume that the 
                     * hypothetical arguments are those that matched the 
                     * variadic parameter; there must be just as many of them 
                     * as there are aggregated arguments. 
                     */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN95"><span class='Ref_To_Local'>aggkind</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_aggregate.h.html#LN125"><span class='Ref_to_Const'>AGGKIND_HYPOTHETICAL</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN92"><span class='Ref_To_Local'>nvargs</span></a> <span class='Operator'>!= </span><span class='Number'>2</span> <span class='Operator'>* </span><a href="parse_func.c.html#LN325"><span class='Ref_To_Local'>numAggregatedArgs</span></a><span class='Parentheses'>) 
</span>                            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_UNDEFINED_FUNCTION<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"function %s does not exist"</span><span class='Delimiter'>, 
</span>                                       <a href="../../include/parser/parse_func.h.html#LN59"><span class='Ref_to_Proto'>func_signature_string</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>funcname</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN84"><span class='Ref_To_Local'>nargs</span></a><span class='Delimiter'>, 
</span>                                                             <a href="parse_func.c.html#LN88"><span class='Ref_To_Local'>argnames</span></a><span class='Delimiter'>, 
</span>                                                          <a href="parse_func.c.html#LN86"><span class='Ref_To_Local'>actual_arg_types</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                                     <a href="../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"To use the hypothetical-set aggregate %s, the number of hypothetical direct arguments (here %d) must match the number of ordering columns (here %d)."</span><span class='Delimiter'>, 
</span>                                             <a href="../../include/catalog/namespace.h.html#LN120"><span class='Ref_to_Proto'>NameListToString</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>funcname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                              <a href="parse_func.c.html#LN92"><span class='Ref_To_Local'>nvargs</span></a> <span class='Operator'>- </span><a href="parse_func.c.html#LN325"><span class='Ref_To_Local'>numAggregatedArgs</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN325"><span class='Ref_To_Local'>numAggregatedArgs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <span class='Control'>else</span> 
                    <span class='Delimiter'>{ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN92"><span class='Ref_To_Local'>nvargs</span></a> <span class='Operator'>&LT;= </span><a href="parse_func.c.html#LN325"><span class='Ref_To_Local'>numAggregatedArgs</span></a><span class='Parentheses'>) 
</span>                            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_UNDEFINED_FUNCTION<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"function %s does not exist"</span><span class='Delimiter'>, 
</span>                                       <a href="../../include/parser/parse_func.h.html#LN59"><span class='Ref_to_Proto'>func_signature_string</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>funcname</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN84"><span class='Ref_To_Local'>nargs</span></a><span class='Delimiter'>, 
</span>                                                             <a href="parse_func.c.html#LN88"><span class='Ref_To_Local'>argnames</span></a><span class='Delimiter'>, 
</span>                                                          <a href="parse_func.c.html#LN86"><span class='Ref_To_Local'>actual_arg_types</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                                     <a href="../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"There is an ordered-set aggregate %s, but it requires at least %d direct arguments."</span><span class='Delimiter'>, 
</span>                                             <a href="../../include/catalog/namespace.h.html#LN120"><span class='Ref_to_Proto'>NameListToString</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>funcname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                             <a href="parse_func.c.html#LN312"><span class='Ref_To_Local'>catDirectArgs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
            <span class='Comment_Multi_Line'>/* Check type matching of hypothetical arguments */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN95"><span class='Ref_To_Local'>aggkind</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_aggregate.h.html#LN125"><span class='Ref_to_Const'>AGGKIND_HYPOTHETICAL</span></a><span class='Parentheses'>) 
</span>                <a href="parse_func.c.html#LN37"><span class='Ref_to_Proto'>unify_hypothetical_args</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>fargs</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN325"><span class='Ref_To_Local'>numAggregatedArgs</span></a><span class='Delimiter'>, 
</span>                                        <a href="parse_func.c.html#LN86"><span class='Ref_To_Local'>actual_arg_types</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN87"><span class='Ref_To_Local'>declared_arg_types</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if AGGKIND_IS_ORDERED_SE... &raquo; </span> 
        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Normal aggregate, so it can't have WITHIN GROUP */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN74"><span class='Ref_To_Local'>agg_within_group</span></a><span class='Parentheses'>) 
</span>                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_WRONG_OBJECT_TYPE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"%s is not an ordered-set aggregate, so it cannot have WITHIN GROUP"</span><span class='Delimiter'>, 
</span>                                <a href="../../include/catalog/namespace.h.html#LN120"><span class='Ref_to_Proto'>NameListToString</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>funcname</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                         <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if fdresult==FUNCDETAIL_... &raquo; </span> 
    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN94"><span class='Ref_To_Local'>fdresult</span></a> <span class='Operator'>== </span><a href="../../include/parser/parse_func.h.html#LN27"><span class='Ref_to_EnumConst'>FUNCDETAIL_WINDOWFUNC</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * True window functions must be called with a window definition. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_func.c.html#LN78"><span class='Ref_To_Local'>over</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_WRONG_OBJECT_TYPE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"window function %s requires an OVER clause"</span><span class='Delimiter'>, 
</span>                            <a href="../../include/catalog/namespace.h.html#LN120"><span class='Ref_to_Proto'>NameListToString</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>funcname</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* And, per spec, WITHIN GROUP isn't allowed */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN74"><span class='Ref_To_Local'>agg_within_group</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_WRONG_OBJECT_TYPE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"window function %s cannot have WITHIN GROUP"</span><span class='Delimiter'>, 
</span>                            <a href="../../include/catalog/namespace.h.html#LN120"><span class='Ref_to_Proto'>NameListToString</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>funcname</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Oops.  Time to die. 
         * 
         * If we are dealing with the attribute notation rel.function, let the 
         * caller handle failure. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN71"><span class='Ref_To_Local'>is_column</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Else generate a detailed complaint for a function 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN94"><span class='Ref_To_Local'>fdresult</span></a> <span class='Operator'>== </span><a href="../../include/parser/parse_func.h.html#LN24"><span class='Ref_to_EnumConst'>FUNCDETAIL_MULTIPLE</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_AMBIGUOUS_FUNCTION<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"function %s is not unique"</span><span class='Delimiter'>, 
</span>                            <a href="../../include/parser/parse_func.h.html#LN59"><span class='Ref_to_Proto'>func_signature_string</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>funcname</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN84"><span class='Ref_To_Local'>nargs</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN88"><span class='Ref_To_Local'>argnames</span></a><span class='Delimiter'>, 
</span>                                                  <a href="parse_func.c.html#LN86"><span class='Ref_To_Local'>actual_arg_types</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"Could not choose a best candidate function. "</span> 
                             <span class='String'>"You might need to add explicit type casts."</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN72"><span class='Ref_To_Local'>agg_order</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT; </span><span class='Number'>1</span> <span class='Operator'>&& !</span><a href="parse_func.c.html#LN74"><span class='Ref_To_Local'>agg_within_group</span></a><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* It's agg(x, ORDER BY y,z) ... perhaps misplaced ORDER BY */ 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_UNDEFINED_FUNCTION<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"function %s does not exist"</span><span class='Delimiter'>, 
</span>                            <a href="../../include/parser/parse_func.h.html#LN59"><span class='Ref_to_Proto'>func_signature_string</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>funcname</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN84"><span class='Ref_To_Local'>nargs</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN88"><span class='Ref_To_Local'>argnames</span></a><span class='Delimiter'>, 
</span>                                                  <a href="parse_func.c.html#LN86"><span class='Ref_To_Local'>actual_arg_types</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"No aggregate function matches the given name and argument types. "</span> 
                      <span class='String'>"Perhaps you misplaced ORDER BY; ORDER BY must appear "</span> 
                             <span class='String'>"after all regular arguments of the aggregate."</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_UNDEFINED_FUNCTION<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"function %s does not exist"</span><span class='Delimiter'>, 
</span>                            <a href="../../include/parser/parse_func.h.html#LN59"><span class='Ref_to_Proto'>func_signature_string</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>funcname</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN84"><span class='Ref_To_Local'>nargs</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN88"><span class='Ref_To_Local'>argnames</span></a><span class='Delimiter'>, 
</span>                                                  <a href="parse_func.c.html#LN86"><span class='Ref_To_Local'>actual_arg_types</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>            <a href="../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"No function matches the given name and argument types. "</span> 
                    <span class='String'>"You might need to add explicit type casts."</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * If there are default arguments, we have to include their types in 
     * actual_arg_types for the purpose of checking generic type consistency. 
     * However, we do NOT put them into the generated parse node, because 
     * their actual values might change before the query gets run.  The 
     * planner has to insert the up-to-date values at plan time. 
     */ 
</span>    <a href="parse_func.c.html#LN85"><span class='Ref_To_Local'>nargsplusdefs</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN84"><span class='Ref_To_Local'>nargs</span></a><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN81"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN89"><span class='Ref_To_Local'>argdefaults</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN536"></a>        <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN81"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* probably shouldn't happen ... */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN85"><span class='Ref_To_Local'>nargsplusdefs</span></a> <span class='Operator'>&GT;= </span><a href="../../include/pg_config_manual.h.html#LN36"><span class='Ref_to_Const'>FUNC_MAX_ARGS</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_TOO_MANY_ARGUMENTS<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>             <a href="../utils/error/elog.c.html#LN848"><span class='Ref_to_Func'>errmsg_plural</span></a><span class='Parentheses'>(</span><span class='String'>"cannot pass more than %d argument to a function"</span><span class='Delimiter'>, 
</span>                           <span class='String'>"cannot pass more than %d arguments to a function"</span><span class='Delimiter'>, 
</span>                           <a href="../../include/pg_config_manual.h.html#LN36"><span class='Ref_to_Const'>FUNC_MAX_ARGS</span></a><span class='Delimiter'>, 
</span>                           <a href="../../include/pg_config_manual.h.html#LN36"><span class='Ref_to_Const'>FUNC_MAX_ARGS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <a href="parse_func.c.html#LN86"><span class='Ref_To_Local'>actual_arg_types</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN85"><span class='Ref_To_Local'>nargsplusdefs</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN536"><span class='Ref_To_Local'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * enforce consistency with polymorphic argument and return types, 
     * possibly adjusting return type or declared_arg_types (which will be 
     * used as the cast destination by make_fn_arguments) 
     */ 
</span>    <a href="parse_func.c.html#LN79"><span class='Ref_To_Local'>rettype</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN77"><span class='Ref_to_Proto'>enforce_generic_type_consistency</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN86"><span class='Ref_To_Local'>actual_arg_types</span></a><span class='Delimiter'>, 
</span>                                               <a href="parse_func.c.html#LN87"><span class='Ref_To_Local'>declared_arg_types</span></a><span class='Delimiter'>, 
</span>                                               <a href="parse_func.c.html#LN85"><span class='Ref_To_Local'>nargsplusdefs</span></a><span class='Delimiter'>, 
</span>                                               <a href="parse_func.c.html#LN79"><span class='Ref_To_Local'>rettype</span></a><span class='Delimiter'>, 
</span>                                               <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* perform the necessary typecasting of arguments */ 
</span>    <a href="../../include/parser/parse_func.h.html#LN52"><span class='Ref_to_Proto'>make_fn_arguments</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>fargs</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN86"><span class='Ref_To_Local'>actual_arg_types</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN87"><span class='Ref_To_Local'>declared_arg_types</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the function isn't actually variadic, forget any VARIADIC decoration 
     * on the call.  (Perhaps we should throw an error instead, but 
     * historically we've allowed people to write that.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN93"><span class='Ref_To_Local'>vatype</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_func.c.html#LN92"><span class='Ref_To_Local'>nvargs</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_func.c.html#LN77"><span class='Ref_To_Local'>func_variadic</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If it's a variadic function call, transform the last nvargs arguments 
     * into an array --- unless it's an "any" variadic. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN92"><span class='Ref_To_Local'>nvargs</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="parse_func.c.html#LN93"><span class='Ref_To_Local'>vatype</span></a> <span class='Operator'>!= </span><a href="../../include/catalog/pg_type.h.html#LN685"><span class='Ref_to_Const'>ANYOID</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN582"></a>        <a href="../../include/nodes/primnodes.h.html#LN947"><span class='Ref_to_Struct'>ArrayExpr</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>newa</span> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN947"><span class='Ref_to_Struct'>ArrayExpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN583"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>non_var_args</span> <span class='Operator'>= </span><a href="parse_func.c.html#LN84"><span class='Ref_To_Local'>nargs</span></a> <span class='Operator'>- </span><a href="parse_func.c.html#LN92"><span class='Ref_To_Local'>nvargs</span></a><span class='Delimiter'>; 
</span><a name="LN584"></a>        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>vargs</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_func.c.html#LN583"><span class='Ref_To_Local'>non_var_args</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_func.c.html#LN584"><span class='Ref_To_Local'>vargs</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN269"><span class='Ref_to_Proto'>list_copy_tail</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>fargs</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN583"><span class='Ref_To_Local'>non_var_args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>fargs</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN220"><span class='Ref_to_Proto'>list_truncate</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>fargs</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN583"><span class='Ref_To_Local'>non_var_args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="parse_func.c.html#LN582"><span class='Ref_To_Local'>newa</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN953"><span class='Ref_to_Member'>elements</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN584"><span class='Ref_To_Local'>vargs</span></a><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* assume all the variadic arguments were coerced to the same type */ 
</span>        <a href="parse_func.c.html#LN582"><span class='Ref_To_Local'>newa</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN952"><span class='Ref_to_Member'>element_typeid</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN584"><span class='Ref_To_Local'>vargs</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="parse_func.c.html#LN582"><span class='Ref_To_Local'>newa</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN950"><span class='Ref_to_Member'>array_typeid</span></a> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN158"><span class='Ref_to_Proto'>get_array_type</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN582"><span class='Ref_To_Local'>newa</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN952"><span class='Ref_to_Member'>element_typeid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN582"><span class='Ref_To_Local'>newa</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN950"><span class='Ref_to_Member'>array_typeid</span></a><span class='Parentheses'>))</span> 
            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_UNDEFINED_OBJECT<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not find array type for data type %s"</span><span class='Delimiter'>, 
</span>                            <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN582"><span class='Ref_To_Local'>newa</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN952"><span class='Ref_to_Member'>element_typeid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                  <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_func.c.html#LN584"><span class='Ref_To_Local'>vargs</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* array_collid will be set by parse_collate.c */ 
</span>        <a href="parse_func.c.html#LN582"><span class='Ref_To_Local'>newa</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN954"><span class='Ref_to_Member'>multidims</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="parse_func.c.html#LN582"><span class='Ref_To_Local'>newa</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN955"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_func.c.html#LN584"><span class='Ref_To_Local'>vargs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>fargs</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>fargs</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN582"><span class='Ref_To_Local'>newa</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* We could not have had VARIADIC marking before ... */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_func.c.html#LN77"><span class='Ref_To_Local'>func_variadic</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* ... but now, it's a VARIADIC call */ 
</span>        <a href="parse_func.c.html#LN77"><span class='Ref_To_Local'>func_variadic</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if nvargs&GT;0&&vatype!=ANY... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * If an "any" variadic is called with explicit VARIADIC marking, insist 
     * that the variadic parameter be of some array type. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN84"><span class='Ref_To_Local'>nargs</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="parse_func.c.html#LN93"><span class='Ref_To_Local'>vatype</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN685"><span class='Ref_to_Const'>ANYOID</span></a> <span class='Operator'>&& </span><a href="parse_func.c.html#LN77"><span class='Ref_To_Local'>func_variadic</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN618"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>va_arr_typid</span> <span class='Operator'>= </span><a href="parse_func.c.html#LN86"><span class='Ref_To_Local'>actual_arg_types</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN84"><span class='Ref_To_Local'>nargs</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="../../include/utils/lsyscache.h.html#LN160"><span class='Ref_to_Proto'>get_base_element_type</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN618"><span class='Ref_To_Local'>va_arr_typid</span></a><span class='Parentheses'>)))</span> 
            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_DATATYPE_MISMATCH<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"VARIADIC argument must be an array"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                      <a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN130"><span class='Ref_to_Macro'>llast</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>fargs</span></a><span class='Parentheses'>)))))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* if it returns a set, check that's OK */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN91"><span class='Ref_To_Local'>retset</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/parser/parse_func.h.html#LN69"><span class='Ref_to_Proto'>check_srf_call_placement</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* build the appropriate output structure */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN94"><span class='Ref_To_Local'>fdresult</span></a> <span class='Operator'>== </span><a href="../../include/parser/parse_func.h.html#LN25"><span class='Ref_to_EnumConst'>FUNCDETAIL_NORMAL</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN635"></a>        <a href="../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>funcexpr</span> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="parse_func.c.html#LN635"><span class='Ref_To_Local'>funcexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN447"><span class='Ref_to_Member'>funcid</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN80"><span class='Ref_To_Local'>funcid</span></a><span class='Delimiter'>; 
</span>        <a href="parse_func.c.html#LN635"><span class='Ref_To_Local'>funcexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN448"><span class='Ref_to_Member'>funcresulttype</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN79"><span class='Ref_To_Local'>rettype</span></a><span class='Delimiter'>; 
</span>        <a href="parse_func.c.html#LN635"><span class='Ref_To_Local'>funcexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN449"><span class='Ref_to_Member'>funcretset</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN91"><span class='Ref_To_Local'>retset</span></a><span class='Delimiter'>; 
</span>        <a href="parse_func.c.html#LN635"><span class='Ref_To_Local'>funcexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN450"><span class='Ref_to_Member'>funcvariadic</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN77"><span class='Ref_To_Local'>func_variadic</span></a><span class='Delimiter'>; 
</span>        <a href="parse_func.c.html#LN635"><span class='Ref_To_Local'>funcexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN452"><span class='Ref_to_Member'>funcformat</span></a> <span class='Operator'>= </span><a href="../../include/nodes/primnodes.h.html#LN436"><span class='Ref_to_EnumConst'>COERCE_EXPLICIT_CALL</span></a><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* funccollid and inputcollid will be set by parse_collate.c */ 
</span>        <a href="parse_func.c.html#LN635"><span class='Ref_To_Local'>funcexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN455"><span class='Ref_to_Member'>args</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>fargs</span></a><span class='Delimiter'>; 
</span>        <a href="parse_func.c.html#LN635"><span class='Ref_To_Local'>funcexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN456"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>location</span></a><span class='Delimiter'>; 
</span> 
        <a href="parse_func.c.html#LN90"><span class='Ref_To_Local'>retval</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_func.c.html#LN635"><span class='Ref_To_Local'>funcexpr</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN94"><span class='Ref_To_Local'>fdresult</span></a> <span class='Operator'>== </span><a href="../../include/parser/parse_func.h.html#LN26"><span class='Ref_to_EnumConst'>FUNCDETAIL_AGGREGATE</span></a> <span class='Operator'>&& !</span><a href="parse_func.c.html#LN78"><span class='Ref_To_Local'>over</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* aggregate function */ 
</span><a name="LN651"></a>        <a href="../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>aggref</span> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="parse_func.c.html#LN651"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN293"><span class='Ref_to_Member'>aggfnoid</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN80"><span class='Ref_To_Local'>funcid</span></a><span class='Delimiter'>; 
</span>        <a href="parse_func.c.html#LN651"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN294"><span class='Ref_to_Member'>aggtype</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN79"><span class='Ref_To_Local'>rettype</span></a><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* aggcollid and inputcollid will be set by parse_collate.c */ 
</span>        <a href="parse_func.c.html#LN651"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN297"><span class='Ref_to_Member'>aggtranstype</span></a> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* will be set by planner */ 
</span>        <span class='Comment_Multi_Line'>/* aggargtypes will be set by transformAggregateCall */ 
</span>        <span class='Comment_Multi_Line'>/* aggdirectargs and args will be set by transformAggregateCall */ 
</span>        <span class='Comment_Multi_Line'>/* aggorder and aggdistinct will be set by transformAggregateCall */ 
</span>        <a href="parse_func.c.html#LN651"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN303"><span class='Ref_to_Member'>aggfilter</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN73"><span class='Ref_To_Local'>agg_filter</span></a><span class='Delimiter'>; 
</span>        <a href="parse_func.c.html#LN651"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN304"><span class='Ref_to_Member'>aggstar</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN75"><span class='Ref_To_Local'>agg_star</span></a><span class='Delimiter'>; 
</span>        <a href="parse_func.c.html#LN651"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN305"><span class='Ref_to_Member'>aggvariadic</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN77"><span class='Ref_To_Local'>func_variadic</span></a><span class='Delimiter'>; 
</span>        <a href="parse_func.c.html#LN651"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN307"><span class='Ref_to_Member'>aggkind</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN95"><span class='Ref_To_Local'>aggkind</span></a><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* agglevelsup will be set by transformAggregateCall */ 
</span>        <a href="parse_func.c.html#LN651"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN309"><span class='Ref_to_Member'>aggsplit</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN758"><span class='Ref_to_EnumConst'>AGGSPLIT_SIMPLE</span></a><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* planner might change this */ 
</span>        <a href="parse_func.c.html#LN651"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN310"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>location</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Reject attempt to call a parameterless aggregate without (*) 
         * syntax.  This is mere pedantry but some folks insisted ... 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>fargs</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>&& !</span><a href="parse_func.c.html#LN75"><span class='Ref_To_Local'>agg_star</span></a> <span class='Operator'>&& !</span><a href="parse_func.c.html#LN74"><span class='Ref_To_Local'>agg_within_group</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_WRONG_OBJECT_TYPE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"%s(*) must be used to call a parameterless aggregate function"</span><span class='Delimiter'>, 
</span>                            <a href="../../include/catalog/namespace.h.html#LN120"><span class='Ref_to_Proto'>NameListToString</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>funcname</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN91"><span class='Ref_To_Local'>retset</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_FUNCTION_DEFINITION<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"aggregates cannot return sets"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We might want to support named arguments later, but disallow it for 
         * now.  We'd need to figure out the parsed representation (should the 
         * NamedArgExprs go above or below the TargetEntry nodes?) and then 
         * teach the planner to reorder the list properly.  Or maybe we could 
         * make transformAggregateCall do that?  However, if you'd also like 
         * to allow default arguments for aggregates, we'd need to do it in 
         * planning to avoid semantic problems. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN88"><span class='Ref_To_Local'>argnames</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"aggregates cannot use named arguments"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* parse_agg.c does additional aggregate-specific processing */ 
</span>        <a href="../../include/parser/parse_agg.h.html#LN17"><span class='Ref_to_Proto'>transformAggregateCall</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN651"><span class='Ref_To_Local'>aggref</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>fargs</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN72"><span class='Ref_To_Local'>agg_order</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN76"><span class='Ref_To_Local'>agg_distinct</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="parse_func.c.html#LN90"><span class='Ref_To_Local'>retval</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_func.c.html#LN651"><span class='Ref_To_Local'>aggref</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if fdresult==FUNCDETAIL_... &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* window function */ 
</span><a name="LN708"></a>        <a href="../../include/nodes/primnodes.h.html#LN351"><span class='Ref_to_Struct'>WindowFunc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>wfunc</span> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN351"><span class='Ref_to_Struct'>WindowFunc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_func.c.html#LN78"><span class='Ref_To_Local'>over</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* lack of this was checked above */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_func.c.html#LN74"><span class='Ref_To_Local'>agg_within_group</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* also checked above */ 
</span> 
        <a href="parse_func.c.html#LN708"><span class='Ref_To_Local'>wfunc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN354"><span class='Ref_to_Member'>winfnoid</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN80"><span class='Ref_To_Local'>funcid</span></a><span class='Delimiter'>; 
</span>        <a href="parse_func.c.html#LN708"><span class='Ref_To_Local'>wfunc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN355"><span class='Ref_to_Member'>wintype</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN79"><span class='Ref_To_Local'>rettype</span></a><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* wincollid and inputcollid will be set by parse_collate.c */ 
</span>        <a href="parse_func.c.html#LN708"><span class='Ref_To_Local'>wfunc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN358"><span class='Ref_to_Member'>args</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>fargs</span></a><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* winref will be set by transformWindowFuncCall */ 
</span>        <a href="parse_func.c.html#LN708"><span class='Ref_To_Local'>wfunc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN361"><span class='Ref_to_Member'>winstar</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN75"><span class='Ref_To_Local'>agg_star</span></a><span class='Delimiter'>; 
</span>        <a href="parse_func.c.html#LN708"><span class='Ref_To_Local'>wfunc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN362"><span class='Ref_to_Member'>winagg</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="parse_func.c.html#LN94"><span class='Ref_To_Local'>fdresult</span></a> <span class='Operator'>== </span><a href="../../include/parser/parse_func.h.html#LN26"><span class='Ref_to_EnumConst'>FUNCDETAIL_AGGREGATE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_func.c.html#LN708"><span class='Ref_To_Local'>wfunc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN359"><span class='Ref_to_Member'>aggfilter</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN73"><span class='Ref_To_Local'>agg_filter</span></a><span class='Delimiter'>; 
</span>        <a href="parse_func.c.html#LN708"><span class='Ref_To_Local'>wfunc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN363"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>location</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * agg_star is allowed for aggregate functions but distinct isn't 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN76"><span class='Ref_To_Local'>agg_distinct</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                  <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"DISTINCT is not implemented for window functions"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Reject attempt to call a parameterless aggregate without (*) 
         * syntax.  This is mere pedantry but some folks insisted ... 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN708"><span class='Ref_To_Local'>wfunc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN362"><span class='Ref_to_Member'>winagg</span></a> <span class='Operator'>&& </span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>fargs</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>&& !</span><a href="parse_func.c.html#LN75"><span class='Ref_To_Local'>agg_star</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_WRONG_OBJECT_TYPE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"%s(*) must be used to call a parameterless aggregate function"</span><span class='Delimiter'>, 
</span>                            <a href="../../include/catalog/namespace.h.html#LN120"><span class='Ref_to_Proto'>NameListToString</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>funcname</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * ordered aggs not allowed in windows yet 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN72"><span class='Ref_To_Local'>agg_order</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"aggregate ORDER BY is not implemented for window functions"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * FILTER is not yet supported with true window functions 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_func.c.html#LN708"><span class='Ref_To_Local'>wfunc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN362"><span class='Ref_to_Member'>winagg</span></a> <span class='Operator'>&& </span><a href="parse_func.c.html#LN73"><span class='Ref_To_Local'>agg_filter</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"FILTER is not implemented for non-aggregate window functions"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN91"><span class='Ref_To_Local'>retset</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_FUNCTION_DEFINITION<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"window functions cannot return sets"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN69"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* parse_agg.c does additional window-func-specific processing */ 
</span>        <a href="../../include/parser/parse_agg.h.html#LN23"><span class='Ref_to_Proto'>transformWindowFuncCall</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN68"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN708"><span class='Ref_To_Local'>wfunc</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN78"><span class='Ref_To_Local'>over</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="parse_func.c.html#LN90"><span class='Ref_To_Local'>retval</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_func.c.html#LN708"><span class='Ref_To_Local'>wfunc</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <span class='Control'>return</span> <a href="parse_func.c.html#LN90"><span class='Ref_To_Local'>retval</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ParseFuncOrColumn &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* func_match_argtypes() 
 * 
 * Given a list of candidate functions (having the right name and number 
 * of arguments) and an array of input datatype OIDs, produce a shortlist of 
 * those candidates that actually accept the input datatypes (either exactly 
 * or by coercion), and return the number of such candidates. 
 * 
 * Note that can_coerce_type will assume that UNKNOWN inputs are coercible to 
 * anything, so candidates will not be eliminated on that basis. 
 * 
 * NB: okay to modify input list structure, as long as we find at least 
 * one match.  If no match at all, the list must remain unmodified. 
 */ 
</span><span class='Keyword'>int 
</span><a name="LN791"></a><span class='Declare_Function'>func_match_argtypes</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>nargs</span><span class='Delimiter'>, 
</span><a name="LN792"></a>                    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>input_typeids</span><span class='Delimiter'>, 
</span><a name="LN793"></a>                    <a href="../../include/catalog/namespace.h.html#LN27"><span class='Ref_to_Typedef'>FuncCandidateList</span></a> <span class='Declare_Parameter'>raw_candidates</span><span class='Delimiter'>, 
</span><a name="LN794"></a>                    <a href="../../include/catalog/namespace.h.html#LN27"><span class='Ref_to_Typedef'>FuncCandidateList</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>candidates</span><span class='Parentheses'>)</span>      <span class='Comment_Single_Line'>/* return value */ 
</span><span class='Delimiter'>{ 
</span><a name="LN796"></a>    <a href="../../include/catalog/namespace.h.html#LN27"><span class='Ref_to_Typedef'>FuncCandidateList</span></a> <span class='Declare_Local'>current_candidate</span><span class='Delimiter'>; 
</span><a name="LN797"></a>    <a href="../../include/catalog/namespace.h.html#LN27"><span class='Ref_to_Typedef'>FuncCandidateList</span></a> <span class='Declare_Local'>next_candidate</span><span class='Delimiter'>; 
</span><a name="LN798"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>ncandidates</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Operator'>*</span><a href="parse_func.c.html#LN794"><span class='Ref_to_Parameter'>candidates</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN796"><span class='Ref_To_Local'>current_candidate</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN793"><span class='Ref_to_Parameter'>raw_candidates</span></a><span class='Delimiter'>; 
</span>         <a href="parse_func.c.html#LN796"><span class='Ref_To_Local'>current_candidate</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>         <a href="parse_func.c.html#LN796"><span class='Ref_To_Local'>current_candidate</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN797"><span class='Ref_To_Local'>next_candidate</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="parse_func.c.html#LN797"><span class='Ref_To_Local'>next_candidate</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN796"><span class='Ref_To_Local'>current_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN29"><span class='Ref_to_Member'>next</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/parser/parse_coerce.h.html#LN43"><span class='Ref_to_Proto'>can_coerce_type</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN791"><span class='Ref_to_Parameter'>nargs</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN792"><span class='Ref_to_Parameter'>input_typeids</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN796"><span class='Ref_To_Local'>current_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN36"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>, 
</span>                            <a href="../../include/nodes/primnodes.h.html#LN420"><span class='Ref_to_EnumConst'>COERCION_IMPLICIT</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="parse_func.c.html#LN796"><span class='Ref_To_Local'>current_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN29"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= *</span><a href="parse_func.c.html#LN794"><span class='Ref_to_Parameter'>candidates</span></a><span class='Delimiter'>; 
</span>            <span class='Operator'>*</span><a href="parse_func.c.html#LN794"><span class='Ref_to_Parameter'>candidates</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN796"><span class='Ref_To_Local'>current_candidate</span></a><span class='Delimiter'>; 
</span>            <a href="parse_func.c.html#LN798"><span class='Ref_To_Local'>ncandidates</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="parse_func.c.html#LN798"><span class='Ref_To_Local'>ncandidates</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end func_match_argtypes &raquo; </span>   <span class='Comment_Single_Line'>/* func_match_argtypes() */ 
</span> 
 
<span class='Comment_Multi_Line'>/* func_select_candidate() 
 *      Given the input argtype array and more than one candidate 
 *      for the function, attempt to resolve the conflict. 
 * 
 * Returns the selected candidate if the conflict can be resolved, 
 * otherwise returns NULL. 
 * 
 * Note that the caller has already determined that there is no candidate 
 * exactly matching the input argtypes, and has pruned away any "candidates" 
 * that aren't actually coercion-compatible with the input types. 
 * 
 * This is also used for resolving ambiguous operator references.  Formerly 
 * parse_oper.c had its own, essentially duplicate code for the purpose. 
 * The following comments (formerly in parse_oper.c) are kept to record some 
 * of the history of these heuristics. 
 * 
 * OLD COMMENTS: 
 * 
 * This routine is new code, replacing binary_oper_select_candidate() 
 * which dates from v4.2/v1.0.x days. It tries very hard to match up 
 * operators with types, including allowing type coercions if necessary. 
 * The important thing is that the code do as much as possible, 
 * while _never_ doing the wrong thing, where "the wrong thing" would 
 * be returning an operator when other better choices are available, 
 * or returning an operator which is a non-intuitive possibility. 
 * - thomas 1998-05-21 
 * 
 * The comments below came from binary_oper_select_candidate(), and 
 * illustrate the issues and choices which are possible: 
 * - thomas 1998-05-20 
 * 
 * current wisdom holds that the default operator should be one in which 
 * both operands have the same type (there will only be one such 
 * operator) 
 * 
 * 7.27.93 - I have decided not to do this; it's too hard to justify, and 
 * it's easy enough to typecast explicitly - avi 
 * [the rest of this routine was commented out since then - ay] 
 * 
 * 6/23/95 - I don't complete agree with avi. In particular, casting 
 * floats is a pain for users. Whatever the rationale behind not doing 
 * this is, I need the following special case to work. 
 * 
 * In the WHERE clause of a query, if a float is specified without 
 * quotes, we treat it as float8. I added the float48* operators so 
 * that we can operate on float4 and float8. But now we have more than 
 * one matching operator if the right arg is unknown (eg. float 
 * specified with quotes). This break some stuff in the regression 
 * test where there are floats in quotes not properly casted. Below is 
 * the solution. In addition to requiring the operator operates on the 
 * same type for both operands [as in the code Avi originally 
 * commented out], we also require that the operators be equivalent in 
 * some sense. (see equivalentOpersAfterPromotion for details.) 
 * - ay 6/95 
 */ 
</span><a href="../../include/catalog/namespace.h.html#LN27"><span class='Ref_to_Typedef'>FuncCandidateList</span></a> 
<a name="LN876"></a><span class='Declare_Function'>func_select_candidate</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>nargs</span><span class='Delimiter'>, 
</span><a name="LN877"></a>                      <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>input_typeids</span><span class='Delimiter'>, 
</span><a name="LN878"></a>                      <a href="../../include/catalog/namespace.h.html#LN27"><span class='Ref_to_Typedef'>FuncCandidateList</span></a> <span class='Declare_Parameter'>candidates</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN880"></a>    <a href="../../include/catalog/namespace.h.html#LN27"><span class='Ref_to_Typedef'>FuncCandidateList</span></a> <span class='Declare_Local'>current_candidate</span><span class='Delimiter'>, 
</span><a name="LN881"></a>                <span class='Declare_Local'>first_candidate</span><span class='Delimiter'>, 
</span><a name="LN882"></a>                <span class='Declare_Local'>last_candidate</span><span class='Delimiter'>; 
</span><a name="LN883"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>current_typeids</span><span class='Delimiter'>; 
</span><a name="LN884"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>current_type</span><span class='Delimiter'>; 
</span><a name="LN885"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN886"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>ncandidates</span><span class='Delimiter'>; 
</span><a name="LN887"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>nbestMatch</span><span class='Delimiter'>, 
</span><a name="LN888"></a>                <span class='Declare_Local'>nmatch</span><span class='Delimiter'>, 
</span><a name="LN889"></a>                <span class='Declare_Local'>nunknowns</span><span class='Delimiter'>; 
</span><a name="LN890"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>input_base_typeids</span><span class='Delimiter'>[</span><a href="../../include/pg_config_manual.h.html#LN36"><span class='Ref_to_Const'>FUNC_MAX_ARGS</span></a><span class='Delimiter'>]; 
</span><a name="LN891"></a>    <a href="../../include/parser/parse_coerce.h.html#LN20"><span class='Ref_to_Typedef'>TYPCATEGORY</span></a> <span class='Declare_Local'>slot_category</span><span class='Delimiter'>[</span><a href="../../include/pg_config_manual.h.html#LN36"><span class='Ref_to_Const'>FUNC_MAX_ARGS</span></a><span class='Delimiter'>], 
</span><a name="LN892"></a>                <span class='Declare_Local'>current_category</span><span class='Delimiter'>; 
</span><a name="LN893"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>current_is_preferred</span><span class='Delimiter'>; 
</span><a name="LN894"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>slot_has_preferred_type</span><span class='Delimiter'>[</span><a href="../../include/pg_config_manual.h.html#LN36"><span class='Ref_to_Const'>FUNC_MAX_ARGS</span></a><span class='Delimiter'>]; 
</span><a name="LN895"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>resolved_unknowns</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* protect local fixed-size arrays */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN876"><span class='Ref_to_Parameter'>nargs</span></a> <span class='Operator'>&GT; </span><a href="../../include/pg_config_manual.h.html#LN36"><span class='Ref_to_Const'>FUNC_MAX_ARGS</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_TOO_MANY_ARGUMENTS<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>             <a href="../utils/error/elog.c.html#LN848"><span class='Ref_to_Func'>errmsg_plural</span></a><span class='Parentheses'>(</span><span class='String'>"cannot pass more than %d argument to a function"</span><span class='Delimiter'>, 
</span>                           <span class='String'>"cannot pass more than %d arguments to a function"</span><span class='Delimiter'>, 
</span>                           <a href="../../include/pg_config_manual.h.html#LN36"><span class='Ref_to_Const'>FUNC_MAX_ARGS</span></a><span class='Delimiter'>, 
</span>                           <a href="../../include/pg_config_manual.h.html#LN36"><span class='Ref_to_Const'>FUNC_MAX_ARGS</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If any input types are domains, reduce them to their base types. This 
     * ensures that we will consider functions on the base type to be "exact 
     * matches" in the exact-match heuristic; it also makes it possible to do 
     * something useful with the type-category heuristics. Note that this 
     * makes it difficult, but not impossible, to use functions declared to 
     * take a domain as an input datatype.  Such a function will be selected 
     * over the base-type function only if it is an exact match at all 
     * argument positions, and so was already chosen by our caller. 
     * 
     * While we're at it, count the number of unknown-type arguments for use 
     * later. 
     */ 
</span>    <a href="parse_func.c.html#LN889"><span class='Ref_To_Local'>nunknowns</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="parse_func.c.html#LN876"><span class='Ref_to_Parameter'>nargs</span></a><span class='Delimiter'>; </span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN877"><span class='Ref_to_Parameter'>input_typeids</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>!= </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN43"><span class='Ref_to_Const'>UNKNOWNOID</span></a><span class='Parentheses'>) 
</span>            <a href="parse_func.c.html#LN890"><span class='Ref_To_Local'>input_base_typeids</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN168"><span class='Ref_to_Proto'>getBaseType</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN877"><span class='Ref_to_Parameter'>input_typeids</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* no need to call getBaseType on UNKNOWNOID */ 
</span>            <a href="parse_func.c.html#LN890"><span class='Ref_To_Local'>input_base_typeids</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN43"><span class='Ref_to_Const'>UNKNOWNOID</span></a><span class='Delimiter'>; 
</span>            <a href="parse_func.c.html#LN889"><span class='Ref_To_Local'>nunknowns</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Run through all candidates and keep those with the most matches on 
     * exact types. Keep all candidates if none match. 
     */ 
</span>    <a href="parse_func.c.html#LN886"><span class='Ref_To_Local'>ncandidates</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="parse_func.c.html#LN887"><span class='Ref_To_Local'>nbestMatch</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="parse_func.c.html#LN882"><span class='Ref_To_Local'>last_candidate</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN880"><span class='Ref_To_Local'>current_candidate</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN878"><span class='Ref_to_Parameter'>candidates</span></a><span class='Delimiter'>; 
</span>         <a href="parse_func.c.html#LN880"><span class='Ref_To_Local'>current_candidate</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>         <a href="parse_func.c.html#LN880"><span class='Ref_To_Local'>current_candidate</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN880"><span class='Ref_To_Local'>current_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN29"><span class='Ref_to_Member'>next</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="parse_func.c.html#LN883"><span class='Ref_To_Local'>current_typeids</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN880"><span class='Ref_To_Local'>current_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN36"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>; 
</span>        <a href="parse_func.c.html#LN888"><span class='Ref_To_Local'>nmatch</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="parse_func.c.html#LN876"><span class='Ref_to_Parameter'>nargs</span></a><span class='Delimiter'>; </span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN890"><span class='Ref_To_Local'>input_base_typeids</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>!= </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN43"><span class='Ref_to_Const'>UNKNOWNOID</span></a> <span class='Operator'>&& 
</span>                <a href="parse_func.c.html#LN883"><span class='Ref_To_Local'>current_typeids</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><a href="parse_func.c.html#LN890"><span class='Ref_To_Local'>input_base_typeids</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>                <a href="parse_func.c.html#LN888"><span class='Ref_To_Local'>nmatch</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* take this one as the best choice so far? */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="parse_func.c.html#LN888"><span class='Ref_To_Local'>nmatch</span></a> <span class='Operator'>&GT; </span><a href="parse_func.c.html#LN887"><span class='Ref_To_Local'>nbestMatch</span></a><span class='Parentheses'>) </span><span class='Operator'>|| </span><span class='Parentheses'>(</span><a href="parse_func.c.html#LN882"><span class='Ref_To_Local'>last_candidate</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="parse_func.c.html#LN887"><span class='Ref_To_Local'>nbestMatch</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN888"><span class='Ref_To_Local'>nmatch</span></a><span class='Delimiter'>; 
</span>            <a href="parse_func.c.html#LN878"><span class='Ref_to_Parameter'>candidates</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN880"><span class='Ref_To_Local'>current_candidate</span></a><span class='Delimiter'>; 
</span>            <a href="parse_func.c.html#LN882"><span class='Ref_To_Local'>last_candidate</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN880"><span class='Ref_To_Local'>current_candidate</span></a><span class='Delimiter'>; 
</span>            <a href="parse_func.c.html#LN886"><span class='Ref_To_Local'>ncandidates</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Comment_Multi_Line'>/* no worse than the last choice, so keep this one too? */ 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN888"><span class='Ref_To_Local'>nmatch</span></a> <span class='Operator'>== </span><a href="parse_func.c.html#LN887"><span class='Ref_To_Local'>nbestMatch</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="parse_func.c.html#LN882"><span class='Ref_To_Local'>last_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN29"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN880"><span class='Ref_To_Local'>current_candidate</span></a><span class='Delimiter'>; 
</span>            <a href="parse_func.c.html#LN882"><span class='Ref_To_Local'>last_candidate</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN880"><span class='Ref_To_Local'>current_candidate</span></a><span class='Delimiter'>; 
</span>            <a href="parse_func.c.html#LN886"><span class='Ref_To_Local'>ncandidates</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Comment_Multi_Line'>/* otherwise, don't bother keeping this one... */ 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for current_candidate=can... &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN882"><span class='Ref_To_Local'>last_candidate</span></a><span class='Parentheses'>)</span>         <span class='Comment_Single_Line'>/* terminate rebuilt list */ 
</span>        <a href="parse_func.c.html#LN882"><span class='Ref_To_Local'>last_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN29"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN886"><span class='Ref_To_Local'>ncandidates</span></a> <span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="parse_func.c.html#LN878"><span class='Ref_to_Parameter'>candidates</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Still too many candidates? Now look for candidates which have either 
     * exact matches or preferred types at the args that will require 
     * coercion. (Restriction added in 7.4: preferred type must be of same 
     * category as input type; give no preference to cross-category 
     * conversions to preferred types.)  Keep all candidates if none match. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="parse_func.c.html#LN876"><span class='Ref_to_Parameter'>nargs</span></a><span class='Delimiter'>; </span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) </span><span class='Comment_Single_Line'>/* avoid multiple lookups */ 
</span>        <a href="parse_func.c.html#LN891"><span class='Ref_To_Local'>slot_category</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN35"><span class='Ref_to_Proto'>TypeCategory</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN890"><span class='Ref_To_Local'>input_base_typeids</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="parse_func.c.html#LN886"><span class='Ref_To_Local'>ncandidates</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="parse_func.c.html#LN887"><span class='Ref_To_Local'>nbestMatch</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="parse_func.c.html#LN882"><span class='Ref_To_Local'>last_candidate</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN880"><span class='Ref_To_Local'>current_candidate</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN878"><span class='Ref_to_Parameter'>candidates</span></a><span class='Delimiter'>; 
</span>         <a href="parse_func.c.html#LN880"><span class='Ref_To_Local'>current_candidate</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>         <a href="parse_func.c.html#LN880"><span class='Ref_To_Local'>current_candidate</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN880"><span class='Ref_To_Local'>current_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN29"><span class='Ref_to_Member'>next</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="parse_func.c.html#LN883"><span class='Ref_To_Local'>current_typeids</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN880"><span class='Ref_To_Local'>current_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN36"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>; 
</span>        <a href="parse_func.c.html#LN888"><span class='Ref_To_Local'>nmatch</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="parse_func.c.html#LN876"><span class='Ref_to_Parameter'>nargs</span></a><span class='Delimiter'>; </span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN890"><span class='Ref_To_Local'>input_base_typeids</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>!= </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN43"><span class='Ref_to_Const'>UNKNOWNOID</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN883"><span class='Ref_To_Local'>current_typeids</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><a href="parse_func.c.html#LN890"><span class='Ref_To_Local'>input_base_typeids</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>|| 
</span>                    <a href="../../include/parser/parse_coerce.h.html#LN34"><span class='Ref_to_Proto'>IsPreferredType</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN891"><span class='Ref_To_Local'>slot_category</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], </span><a href="parse_func.c.html#LN883"><span class='Ref_To_Local'>current_typeids</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>))</span> 
                    <a href="parse_func.c.html#LN888"><span class='Ref_To_Local'>nmatch</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="parse_func.c.html#LN888"><span class='Ref_To_Local'>nmatch</span></a> <span class='Operator'>&GT; </span><a href="parse_func.c.html#LN887"><span class='Ref_To_Local'>nbestMatch</span></a><span class='Parentheses'>) </span><span class='Operator'>|| </span><span class='Parentheses'>(</span><a href="parse_func.c.html#LN882"><span class='Ref_To_Local'>last_candidate</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="parse_func.c.html#LN887"><span class='Ref_To_Local'>nbestMatch</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN888"><span class='Ref_To_Local'>nmatch</span></a><span class='Delimiter'>; 
</span>            <a href="parse_func.c.html#LN878"><span class='Ref_to_Parameter'>candidates</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN880"><span class='Ref_To_Local'>current_candidate</span></a><span class='Delimiter'>; 
</span>            <a href="parse_func.c.html#LN882"><span class='Ref_To_Local'>last_candidate</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN880"><span class='Ref_To_Local'>current_candidate</span></a><span class='Delimiter'>; 
</span>            <a href="parse_func.c.html#LN886"><span class='Ref_To_Local'>ncandidates</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN888"><span class='Ref_To_Local'>nmatch</span></a> <span class='Operator'>== </span><a href="parse_func.c.html#LN887"><span class='Ref_To_Local'>nbestMatch</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="parse_func.c.html#LN882"><span class='Ref_To_Local'>last_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN29"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN880"><span class='Ref_To_Local'>current_candidate</span></a><span class='Delimiter'>; 
</span>            <a href="parse_func.c.html#LN882"><span class='Ref_To_Local'>last_candidate</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN880"><span class='Ref_To_Local'>current_candidate</span></a><span class='Delimiter'>; 
</span>            <a href="parse_func.c.html#LN886"><span class='Ref_To_Local'>ncandidates</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for current_candidate=can... &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN882"><span class='Ref_To_Local'>last_candidate</span></a><span class='Parentheses'>)</span>         <span class='Comment_Single_Line'>/* terminate rebuilt list */ 
</span>        <a href="parse_func.c.html#LN882"><span class='Ref_To_Local'>last_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN29"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN886"><span class='Ref_To_Local'>ncandidates</span></a> <span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="parse_func.c.html#LN878"><span class='Ref_to_Parameter'>candidates</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Still too many candidates?  Try assigning types for the unknown inputs. 
     * 
     * If there are no unknown inputs, we have no more heuristics that apply, 
     * and must fail. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN889"><span class='Ref_To_Local'>nunknowns</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* failed to select a best candidate */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The next step examines each unknown argument position to see if we can 
     * determine a "type category" for it.  If any candidate has an input 
     * datatype of STRING category, use STRING category (this bias towards 
     * STRING is appropriate since unknown-type literals look like strings). 
     * Otherwise, if all the candidates agree on the type category of this 
     * argument position, use that category.  Otherwise, fail because we 
     * cannot determine a category. 
     * 
     * If we are able to determine a type category, also notice whether any of 
     * the candidates takes a preferred datatype within the category. 
     * 
     * Having completed this examination, remove candidates that accept the 
     * wrong category at any unknown position.  Also, if at least one 
     * candidate accepted a preferred type at a position, remove candidates 
     * that accept non-preferred types.  If just one candidate remains, return 
     * that one.  However, if this rule turns out to reject all candidates, 
     * keep them all instead. 
     */ 
</span>    <a href="parse_func.c.html#LN895"><span class='Ref_To_Local'>resolved_unknowns</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="parse_func.c.html#LN876"><span class='Ref_to_Parameter'>nargs</span></a><span class='Delimiter'>; </span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1056"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>have_conflict</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN890"><span class='Ref_To_Local'>input_base_typeids</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>!= </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN43"><span class='Ref_to_Const'>UNKNOWNOID</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <a href="parse_func.c.html#LN895"><span class='Ref_To_Local'>resolved_unknowns</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* assume we can do it */ 
</span>        <a href="parse_func.c.html#LN891"><span class='Ref_To_Local'>slot_category</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/catalog/pg_type.h.html#LN726"><span class='Ref_to_Const'>TYPCATEGORY_INVALID</span></a><span class='Delimiter'>; 
</span>        <a href="parse_func.c.html#LN894"><span class='Ref_To_Local'>slot_has_preferred_type</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="parse_func.c.html#LN1056"><span class='Ref_To_Local'>have_conflict</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN880"><span class='Ref_To_Local'>current_candidate</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN878"><span class='Ref_to_Parameter'>candidates</span></a><span class='Delimiter'>; 
</span>             <a href="parse_func.c.html#LN880"><span class='Ref_To_Local'>current_candidate</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>             <a href="parse_func.c.html#LN880"><span class='Ref_To_Local'>current_candidate</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN880"><span class='Ref_To_Local'>current_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN29"><span class='Ref_to_Member'>next</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="parse_func.c.html#LN883"><span class='Ref_To_Local'>current_typeids</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN880"><span class='Ref_To_Local'>current_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN36"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>; 
</span>            <a href="parse_func.c.html#LN884"><span class='Ref_To_Local'>current_type</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN883"><span class='Ref_To_Local'>current_typeids</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>            <a href="../../include/utils/lsyscache.h.html#LN153"><span class='Ref_to_Proto'>get_type_category_preferred</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN884"><span class='Ref_To_Local'>current_type</span></a><span class='Delimiter'>, 
</span>                                        <span class='Operator'>&</span><a href="parse_func.c.html#LN892"><span class='Ref_To_Local'>current_category</span></a><span class='Delimiter'>, 
</span>                                        <span class='Operator'>&</span><a href="parse_func.c.html#LN893"><span class='Ref_To_Local'>current_is_preferred</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN891"><span class='Ref_To_Local'>slot_category</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN726"><span class='Ref_to_Const'>TYPCATEGORY_INVALID</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* first candidate */ 
</span>                <a href="parse_func.c.html#LN891"><span class='Ref_To_Local'>slot_category</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="parse_func.c.html#LN892"><span class='Ref_To_Local'>current_category</span></a><span class='Delimiter'>; 
</span>                <a href="parse_func.c.html#LN894"><span class='Ref_To_Local'>slot_has_preferred_type</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="parse_func.c.html#LN893"><span class='Ref_To_Local'>current_is_preferred</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN892"><span class='Ref_To_Local'>current_category</span></a> <span class='Operator'>== </span><a href="parse_func.c.html#LN891"><span class='Ref_To_Local'>slot_category</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* more candidates in same category */ 
</span>                <a href="parse_func.c.html#LN894"><span class='Ref_To_Local'>slot_has_preferred_type</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>|= </span><a href="parse_func.c.html#LN893"><span class='Ref_To_Local'>current_is_preferred</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* category conflict! */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN892"><span class='Ref_To_Local'>current_category</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN737"><span class='Ref_to_Const'>TYPCATEGORY_STRING</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* STRING always wins if available */ 
</span>                    <a href="parse_func.c.html#LN891"><span class='Ref_To_Local'>slot_category</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="parse_func.c.html#LN892"><span class='Ref_To_Local'>current_category</span></a><span class='Delimiter'>; 
</span>                    <a href="parse_func.c.html#LN894"><span class='Ref_To_Local'>slot_has_preferred_type</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="parse_func.c.html#LN893"><span class='Ref_To_Local'>current_is_preferred</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>else</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* 
                     * Remember conflict, but keep going (might find STRING) 
                     */ 
</span>                    <a href="parse_func.c.html#LN1056"><span class='Ref_To_Local'>have_conflict</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for current_candidate=can... &raquo; </span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1056"><span class='Ref_To_Local'>have_conflict</span></a> <span class='Operator'>&& </span><a href="parse_func.c.html#LN891"><span class='Ref_To_Local'>slot_category</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>!= </span><a href="../../include/catalog/pg_type.h.html#LN737"><span class='Ref_to_Const'>TYPCATEGORY_STRING</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Failed to resolve category conflict at this position */ 
</span>            <a href="parse_func.c.html#LN895"><span class='Ref_To_Local'>resolved_unknowns</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;nargs;i++ &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN895"><span class='Ref_To_Local'>resolved_unknowns</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Strip non-matching candidates */ 
</span>        <a href="parse_func.c.html#LN886"><span class='Ref_To_Local'>ncandidates</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="parse_func.c.html#LN881"><span class='Ref_To_Local'>first_candidate</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN878"><span class='Ref_to_Parameter'>candidates</span></a><span class='Delimiter'>; 
</span>        <a href="parse_func.c.html#LN882"><span class='Ref_To_Local'>last_candidate</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN880"><span class='Ref_To_Local'>current_candidate</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN878"><span class='Ref_to_Parameter'>candidates</span></a><span class='Delimiter'>; 
</span>             <a href="parse_func.c.html#LN880"><span class='Ref_To_Local'>current_candidate</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>             <a href="parse_func.c.html#LN880"><span class='Ref_To_Local'>current_candidate</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN880"><span class='Ref_To_Local'>current_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN29"><span class='Ref_to_Member'>next</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1120"></a>            <span class='Keyword'>bool</span>        <span class='Declare_Local'>keepit</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
            <a href="parse_func.c.html#LN883"><span class='Ref_To_Local'>current_typeids</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN880"><span class='Ref_To_Local'>current_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN36"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="parse_func.c.html#LN876"><span class='Ref_to_Parameter'>nargs</span></a><span class='Delimiter'>; </span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN890"><span class='Ref_To_Local'>input_base_typeids</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>!= </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN43"><span class='Ref_to_Const'>UNKNOWNOID</span></a><span class='Parentheses'>) 
</span>                    <span class='Control'>continue</span><span class='Delimiter'>; 
</span>                <a href="parse_func.c.html#LN884"><span class='Ref_To_Local'>current_type</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN883"><span class='Ref_To_Local'>current_typeids</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>                <a href="../../include/utils/lsyscache.h.html#LN153"><span class='Ref_to_Proto'>get_type_category_preferred</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN884"><span class='Ref_To_Local'>current_type</span></a><span class='Delimiter'>, 
</span>                                            <span class='Operator'>&</span><a href="parse_func.c.html#LN892"><span class='Ref_To_Local'>current_category</span></a><span class='Delimiter'>, 
</span>                                            <span class='Operator'>&</span><a href="parse_func.c.html#LN893"><span class='Ref_To_Local'>current_is_preferred</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN892"><span class='Ref_To_Local'>current_category</span></a> <span class='Operator'>!= </span><a href="parse_func.c.html#LN891"><span class='Ref_To_Local'>slot_category</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <a href="parse_func.c.html#LN1120"><span class='Ref_To_Local'>keepit</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN894"><span class='Ref_To_Local'>slot_has_preferred_type</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>&& !</span><a href="parse_func.c.html#LN893"><span class='Ref_To_Local'>current_is_preferred</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <a href="parse_func.c.html#LN1120"><span class='Ref_To_Local'>keepit</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1120"><span class='Ref_To_Local'>keepit</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* keep this candidate */ 
</span>                <a href="parse_func.c.html#LN882"><span class='Ref_To_Local'>last_candidate</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN880"><span class='Ref_To_Local'>current_candidate</span></a><span class='Delimiter'>; 
</span>                <a href="parse_func.c.html#LN886"><span class='Ref_To_Local'>ncandidates</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* forget this candidate */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN882"><span class='Ref_To_Local'>last_candidate</span></a><span class='Parentheses'>) 
</span>                    <a href="parse_func.c.html#LN882"><span class='Ref_To_Local'>last_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN29"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN880"><span class='Ref_To_Local'>current_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN29"><span class='Ref_to_Member'>next</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>else</span> 
                    <a href="parse_func.c.html#LN881"><span class='Ref_To_Local'>first_candidate</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN880"><span class='Ref_To_Local'>current_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN29"><span class='Ref_to_Member'>next</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for current_candidate=can... &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* if we found any matches, restrict our attention to those */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN882"><span class='Ref_To_Local'>last_candidate</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="parse_func.c.html#LN878"><span class='Ref_to_Parameter'>candidates</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN881"><span class='Ref_To_Local'>first_candidate</span></a><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* terminate rebuilt list */ 
</span>            <a href="parse_func.c.html#LN882"><span class='Ref_To_Local'>last_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN29"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN886"><span class='Ref_To_Local'>ncandidates</span></a> <span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <a href="parse_func.c.html#LN878"><span class='Ref_to_Parameter'>candidates</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if resolved_unknowns &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Last gasp: if there are both known- and unknown-type inputs, and all 
     * the known types are the same, assume the unknown inputs are also that 
     * type, and see if that gives us a unique match.  If so, use that match. 
     * 
     * NOTE: for a binary operator with one unknown and one non-unknown input, 
     * we already tried this heuristic in binary_oper_exact().  However, that 
     * code only finds exact matches, whereas here we will handle matches that 
     * involve coercion, polymorphic type resolution, etc. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN889"><span class='Ref_To_Local'>nunknowns</span></a> <span class='Operator'>&LT; </span><a href="parse_func.c.html#LN876"><span class='Ref_to_Parameter'>nargs</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1182"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>known_type</span> <span class='Operator'>= </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN43"><span class='Ref_to_Const'>UNKNOWNOID</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="parse_func.c.html#LN876"><span class='Ref_to_Parameter'>nargs</span></a><span class='Delimiter'>; </span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN890"><span class='Ref_To_Local'>input_base_typeids</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN43"><span class='Ref_to_Const'>UNKNOWNOID</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1182"><span class='Ref_To_Local'>known_type</span></a> <span class='Operator'>== </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN43"><span class='Ref_to_Const'>UNKNOWNOID</span></a><span class='Parentheses'>)</span>       <span class='Comment_Single_Line'>/* first known arg? */ 
</span>                <a href="parse_func.c.html#LN1182"><span class='Ref_To_Local'>known_type</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN890"><span class='Ref_To_Local'>input_base_typeids</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1182"><span class='Ref_To_Local'>known_type</span></a> <span class='Operator'>!= </span><a href="parse_func.c.html#LN890"><span class='Ref_To_Local'>input_base_typeids</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* oops, not all match */ 
</span>                <a href="parse_func.c.html#LN1182"><span class='Ref_To_Local'>known_type</span></a> <span class='Operator'>= </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN43"><span class='Ref_to_Const'>UNKNOWNOID</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1182"><span class='Ref_To_Local'>known_type</span></a> <span class='Operator'>!= </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN43"><span class='Ref_to_Const'>UNKNOWNOID</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* okay, just one known type, apply the heuristic */ 
</span>            <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="parse_func.c.html#LN876"><span class='Ref_to_Parameter'>nargs</span></a><span class='Delimiter'>; </span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>                <a href="parse_func.c.html#LN890"><span class='Ref_To_Local'>input_base_typeids</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN885"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="parse_func.c.html#LN1182"><span class='Ref_To_Local'>known_type</span></a><span class='Delimiter'>; 
</span>            <a href="parse_func.c.html#LN886"><span class='Ref_To_Local'>ncandidates</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <a href="parse_func.c.html#LN882"><span class='Ref_To_Local'>last_candidate</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>            <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN880"><span class='Ref_To_Local'>current_candidate</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN878"><span class='Ref_to_Parameter'>candidates</span></a><span class='Delimiter'>; 
</span>                 <a href="parse_func.c.html#LN880"><span class='Ref_To_Local'>current_candidate</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>                 <a href="parse_func.c.html#LN880"><span class='Ref_To_Local'>current_candidate</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN880"><span class='Ref_To_Local'>current_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN29"><span class='Ref_to_Member'>next</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="parse_func.c.html#LN883"><span class='Ref_To_Local'>current_typeids</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN880"><span class='Ref_To_Local'>current_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN36"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/parser/parse_coerce.h.html#LN43"><span class='Ref_to_Proto'>can_coerce_type</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN876"><span class='Ref_to_Parameter'>nargs</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN890"><span class='Ref_To_Local'>input_base_typeids</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN883"><span class='Ref_To_Local'>current_typeids</span></a><span class='Delimiter'>, 
</span>                                    <a href="../../include/nodes/primnodes.h.html#LN420"><span class='Ref_to_EnumConst'>COERCION_IMPLICIT</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>++</span><a href="parse_func.c.html#LN886"><span class='Ref_To_Local'>ncandidates</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>                        <span class='Control'>break</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* not unique, give up */ 
</span>                    <a href="parse_func.c.html#LN882"><span class='Ref_To_Local'>last_candidate</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN880"><span class='Ref_To_Local'>current_candidate</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN886"><span class='Ref_To_Local'>ncandidates</span></a> <span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* successfully identified a unique match */ 
</span>                <a href="parse_func.c.html#LN882"><span class='Ref_To_Local'>last_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN29"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <a href="parse_func.c.html#LN882"><span class='Ref_To_Local'>last_candidate</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if known_type!=UNKNOWNOI... &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if nunknowns&LT;nargs &raquo; </span> 
 
    <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>;</span>                <span class='Comment_Single_Line'>/* failed to select a best candidate */ 
</span><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end func_select_candidate &raquo; </span>   <span class='Comment_Single_Line'>/* func_select_candidate() */ 
</span> 
 
<span class='Comment_Multi_Line'>/* func_get_detail() 
 * 
 * Find the named function in the system catalogs. 
 * 
 * Attempt to find the named function in the system catalogs with 
 * arguments exactly as specified, so that the normal case (exact match) 
 * is as quick as possible. 
 * 
 * If an exact match isn't found: 
 *  1) check for possible interpretation as a type coercion request 
 *  2) apply the ambiguous-function resolution rules 
 * 
 * Return values *funcid through *true_typeids receive info about the function. 
 * If argdefaults isn't NULL, *argdefaults receives a list of any default 
 * argument expressions that need to be added to the given arguments. 
 * 
 * When processing a named- or mixed-notation call (ie, fargnames isn't NIL), 
 * the returned true_typeids and argdefaults are ordered according to the 
 * call's argument ordering: first any positional arguments, then the named 
 * arguments, then defaulted arguments (if needed and allowed by 
 * expand_defaults).  Some care is needed if this information is to be compared 
 * to the function's pg_proc entry, but in practice the caller can usually 
 * just work with the call's argument ordering. 
 * 
 * We rely primarily on fargnames/nargs/argtypes as the argument description. 
 * The actual expression node list is passed in fargs so that we can check 
 * for type coercion of a constant.  Some callers pass fargs == NIL indicating 
 * they don't need that check made.  Note also that when fargnames isn't NIL, 
 * the fargs list must be passed if the caller wants actual argument position 
 * information to be returned into the NamedArgExpr nodes. 
 */ 
</span><a href="../../include/parser/parse_func.h.html#LN21"><span class='Ref_to_Typedef'>FuncDetailCode</span></a> 
<a name="LN1263"></a><span class='Declare_Function'>func_get_detail</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>funcname</span><span class='Delimiter'>, 
</span><a name="LN1264"></a>                <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>fargs</span><span class='Delimiter'>, 
</span><a name="LN1265"></a>                <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>fargnames</span><span class='Delimiter'>, 
</span><a name="LN1266"></a>                <span class='Keyword'>int </span><span class='Declare_Parameter'>nargs</span><span class='Delimiter'>, 
</span><a name="LN1267"></a>                <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>argtypes</span><span class='Delimiter'>, 
</span><a name="LN1268"></a>                <span class='Keyword'>bool </span><span class='Declare_Parameter'>expand_variadic</span><span class='Delimiter'>, 
</span><a name="LN1269"></a>                <span class='Keyword'>bool </span><span class='Declare_Parameter'>expand_defaults</span><span class='Delimiter'>, 
</span><a name="LN1270"></a>                <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>funcid</span><span class='Delimiter'>,</span>    <span class='Comment_Single_Line'>/* return value */ 
</span><a name="LN1271"></a>                <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rettype</span><span class='Delimiter'>,</span>   <span class='Comment_Single_Line'>/* return value */ 
</span><a name="LN1272"></a>                <span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>retset</span><span class='Delimiter'>,</span>   <span class='Comment_Single_Line'>/* return value */ 
</span><a name="LN1273"></a>                <span class='Keyword'>int </span><span class='Operator'>*</span><span class='Declare_Parameter'>nvargs</span><span class='Delimiter'>,</span>    <span class='Comment_Single_Line'>/* return value */ 
</span><a name="LN1274"></a>                <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vatype</span><span class='Delimiter'>,</span>    <span class='Comment_Single_Line'>/* return value */ 
</span><a name="LN1275"></a>                <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>true_typeids</span><span class='Delimiter'>,</span>     <span class='Comment_Single_Line'>/* return value */ 
</span><a name="LN1276"></a>                <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>argdefaults</span><span class='Parentheses'>)</span>     <span class='Comment_Single_Line'>/* optional return value */ 
</span><span class='Delimiter'>{ 
</span><a name="LN1278"></a>    <a href="../../include/catalog/namespace.h.html#LN27"><span class='Ref_to_Typedef'>FuncCandidateList</span></a> <span class='Declare_Local'>raw_candidates</span><span class='Delimiter'>; 
</span><a name="LN1279"></a>    <a href="../../include/catalog/namespace.h.html#LN27"><span class='Ref_to_Typedef'>FuncCandidateList</span></a> <span class='Declare_Local'>best_candidate</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Passing NULL for argtypes is no longer allowed */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1267"><span class='Ref_to_Parameter'>argtypes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* initialize output arguments to silence compiler warnings */ 
</span>    <span class='Operator'>*</span><a href="parse_func.c.html#LN1270"><span class='Ref_to_Parameter'>funcid</span></a> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="parse_func.c.html#LN1271"><span class='Ref_to_Parameter'>rettype</span></a> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="parse_func.c.html#LN1272"><span class='Ref_to_Parameter'>retset</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="parse_func.c.html#LN1273"><span class='Ref_to_Parameter'>nvargs</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="parse_func.c.html#LN1274"><span class='Ref_to_Parameter'>vatype</span></a> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="parse_func.c.html#LN1275"><span class='Ref_to_Parameter'>true_typeids</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1276"><span class='Ref_to_Parameter'>argdefaults</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>*</span><a href="parse_func.c.html#LN1276"><span class='Ref_to_Parameter'>argdefaults</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Get list of possible candidates from namespace search */ 
</span>    <a href="parse_func.c.html#LN1278"><span class='Ref_To_Local'>raw_candidates</span></a> <span class='Operator'>= </span><a href="../../include/catalog/namespace.h.html#LN70"><span class='Ref_to_Proto'>FuncnameGetCandidates</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1263"><span class='Ref_to_Parameter'>funcname</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN1266"><span class='Ref_to_Parameter'>nargs</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN1265"><span class='Ref_to_Parameter'>fargnames</span></a><span class='Delimiter'>, 
</span>                                           <a href="parse_func.c.html#LN1268"><span class='Ref_to_Parameter'>expand_variadic</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN1269"><span class='Ref_to_Parameter'>expand_defaults</span></a><span class='Delimiter'>, 
</span>                                           <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Quickly check if there is an exact match to the input datatypes (there 
     * can be only one) 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1279"><span class='Ref_To_Local'>best_candidate</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN1278"><span class='Ref_To_Local'>raw_candidates</span></a><span class='Delimiter'>; 
</span>         <a href="parse_func.c.html#LN1279"><span class='Ref_To_Local'>best_candidate</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>         <a href="parse_func.c.html#LN1279"><span class='Ref_To_Local'>best_candidate</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN1279"><span class='Ref_To_Local'>best_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN29"><span class='Ref_to_Member'>next</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span>memcmp<span class='Parentheses'>(</span><a href="parse_func.c.html#LN1267"><span class='Ref_to_Parameter'>argtypes</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN1279"><span class='Ref_To_Local'>best_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN36"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN1266"><span class='Ref_to_Parameter'>nargs</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a><span class='Parentheses'>))</span> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1279"><span class='Ref_To_Local'>best_candidate</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * If we didn't find an exact match, next consider the possibility 
         * that this is really a type-coercion request: a single-argument 
         * function call where the function name is a type name.  If so, and 
         * if the coercion path is RELABELTYPE or COERCEVIAIO, then go ahead 
         * and treat the "function call" as a coercion. 
         * 
         * This interpretation needs to be given higher priority than 
         * interpretations involving a type coercion followed by a function 
         * call, otherwise we can produce surprising results. For example, we 
         * want "text(varchar)" to be interpreted as a simple coercion, not as 
         * "text(name(varchar))" which the code below this point is entirely 
         * capable of selecting. 
         * 
         * We also treat a coercion of a previously-unknown-type literal 
         * constant to a specific type this way. 
         * 
         * The reason we reject COERCION_PATH_FUNC here is that we expect the 
         * cast implementation function to be named after the target type. 
         * Thus the function will be found by normal lookup if appropriate. 
         * 
         * The reason we reject COERCION_PATH_ARRAYCOERCE is mainly that you 
         * can't write "foo[] (something)" as a function call.  In theory 
         * someone might want to invoke it as "_foo (something)" but we have 
         * never supported that historically, so we can insist that people 
         * write it as a normal cast instead. 
         * 
         * We also reject the specific case of COERCEVIAIO for a composite 
         * source type and a string-category target type.  This is a case that 
         * find_coercion_pathway() allows by default, but experience has shown 
         * that it's too commonly invoked by mistake.  So, again, insist that 
         * people use cast syntax if they want to do that. 
         * 
         * NB: it's important that this code does not exceed what coerce_type 
         * can do, because the caller will try to apply coerce_type if we 
         * return FUNCDETAIL_COERCION.  If we return that result for something 
         * coerce_type can't handle, we'll cause infinite recursion between 
         * this module and coerce_type! 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1266"><span class='Ref_to_Parameter'>nargs</span></a> <span class='Operator'>== </span><span class='Number'>1</span> <span class='Operator'>&& </span><a href="parse_func.c.html#LN1264"><span class='Ref_to_Parameter'>fargs</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>&& </span><a href="parse_func.c.html#LN1265"><span class='Ref_to_Parameter'>fargnames</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1354"></a>            <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>targetType</span> <span class='Operator'>= </span><a href="parse_func.c.html#LN40"><span class='Ref_to_Proto'>FuncNameAsType</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1263"><span class='Ref_to_Parameter'>funcname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1354"><span class='Ref_To_Local'>targetType</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span><a name="LN1358"></a>                <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>sourceType</span> <span class='Operator'>= </span><a href="parse_func.c.html#LN1267"><span class='Ref_to_Parameter'>argtypes</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]; 
</span><a name="LN1359"></a>                <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>arg1</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1264"><span class='Ref_to_Parameter'>fargs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1360"></a>                <span class='Keyword'>bool</span>        <span class='Declare_Local'>iscoercion</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1358"><span class='Ref_To_Local'>sourceType</span></a> <span class='Operator'>== </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN43"><span class='Ref_to_Const'>UNKNOWNOID</span></a> <span class='Operator'>&& </span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1359"><span class='Ref_To_Local'>arg1</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* always treat typename('literal') as coercion */ 
</span>                    <a href="parse_func.c.html#LN1360"><span class='Ref_To_Local'>iscoercion</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>else</span> 
                <span class='Delimiter'>{ 
</span><a name="LN1369"></a>                    <a href="../../include/parser/parse_coerce.h.html#LN23"><span class='Ref_to_Enum'>CoercionPathType</span></a> <span class='Declare_Local'>cpathtype</span><span class='Delimiter'>; 
</span><a name="LN1370"></a>                    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>cfuncid</span><span class='Delimiter'>; 
</span> 
                    <a href="parse_func.c.html#LN1369"><span class='Ref_To_Local'>cpathtype</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN86"><span class='Ref_to_Proto'>find_coercion_pathway</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1354"><span class='Ref_To_Local'>targetType</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN1358"><span class='Ref_To_Local'>sourceType</span></a><span class='Delimiter'>, 
</span>                                                      <a href="../../include/nodes/primnodes.h.html#LN422"><span class='Ref_to_EnumConst'>COERCION_EXPLICIT</span></a><span class='Delimiter'>, 
</span>                                                      <span class='Operator'>&</span><a href="parse_func.c.html#LN1370"><span class='Ref_To_Local'>cfuncid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1369"><span class='Ref_To_Local'>cpathtype</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Control'>case</span> <a href="../../include/parser/parse_coerce.h.html#LN27"><span class='Ref_to_EnumConst'>COERCION_PATH_RELABELTYPE</span></a><span class='Operator'>: 
</span>                            <a href="parse_func.c.html#LN1360"><span class='Ref_To_Local'>iscoercion</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Control'>case</span> <a href="../../include/parser/parse_coerce.h.html#LN29"><span class='Ref_to_EnumConst'>COERCION_PATH_COERCEVIAIO</span></a><span class='Operator'>: 
</span>                            <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="parse_func.c.html#LN1358"><span class='Ref_To_Local'>sourceType</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN679"><span class='Ref_to_Const'>RECORDOID</span></a> <span class='Operator'>|| 
</span>                                 <a href="../../include/parser/parse_type.h.html#LN52"><span class='Ref_to_Macro'>ISCOMPLEX</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1358"><span class='Ref_To_Local'>sourceType</span></a><span class='Parentheses'>))</span> <span class='Operator'>&& 
</span>                              <a href="../../include/parser/parse_coerce.h.html#LN35"><span class='Ref_to_Proto'>TypeCategory</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1354"><span class='Ref_To_Local'>targetType</span></a><span class='Parentheses'>)</span> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN737"><span class='Ref_to_Const'>TYPCATEGORY_STRING</span></a><span class='Parentheses'>)</span> 
                                <a href="parse_func.c.html#LN1360"><span class='Ref_To_Local'>iscoercion</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                            <span class='Control'>else</span> 
                                <a href="parse_func.c.html#LN1360"><span class='Ref_To_Local'>iscoercion</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Control'>default</span><span class='Operator'>: 
</span>                            <a href="parse_func.c.html#LN1360"><span class='Ref_To_Local'>iscoercion</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1360"><span class='Ref_To_Local'>iscoercion</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* Treat it as a type coercion */ 
</span>                    <span class='Operator'>*</span><a href="parse_func.c.html#LN1270"><span class='Ref_to_Parameter'>funcid</span></a> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>                    <span class='Operator'>*</span><a href="parse_func.c.html#LN1271"><span class='Ref_to_Parameter'>rettype</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN1354"><span class='Ref_To_Local'>targetType</span></a><span class='Delimiter'>; 
</span>                    <span class='Operator'>*</span><a href="parse_func.c.html#LN1272"><span class='Ref_to_Parameter'>retset</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                    <span class='Operator'>*</span><a href="parse_func.c.html#LN1273"><span class='Ref_to_Parameter'>nvargs</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>                    <span class='Operator'>*</span><a href="parse_func.c.html#LN1274"><span class='Ref_to_Parameter'>vatype</span></a> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>                    <span class='Operator'>*</span><a href="parse_func.c.html#LN1275"><span class='Ref_to_Parameter'>true_typeids</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN1267"><span class='Ref_to_Parameter'>argtypes</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>return</span> <a href="../../include/parser/parse_func.h.html#LN28"><span class='Ref_to_EnumConst'>FUNCDETAIL_COERCION</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if OidIsValid(targetType... &raquo; </span> 
        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if nargs==1&&fargs!=NIL&... &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* 
         * didn't find an exact match, so now try to match up candidates... 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1278"><span class='Ref_To_Local'>raw_candidates</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1413"></a>            <a href="../../include/catalog/namespace.h.html#LN27"><span class='Ref_to_Typedef'>FuncCandidateList</span></a> <span class='Declare_Local'>current_candidates</span><span class='Delimiter'>; 
</span><a name="LN1414"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>ncandidates</span><span class='Delimiter'>; 
</span> 
            <a href="parse_func.c.html#LN1414"><span class='Ref_To_Local'>ncandidates</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_func.h.html#LN43"><span class='Ref_to_Proto'>func_match_argtypes</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1266"><span class='Ref_to_Parameter'>nargs</span></a><span class='Delimiter'>, 
</span>                                              <a href="parse_func.c.html#LN1267"><span class='Ref_to_Parameter'>argtypes</span></a><span class='Delimiter'>, 
</span>                                              <a href="parse_func.c.html#LN1278"><span class='Ref_To_Local'>raw_candidates</span></a><span class='Delimiter'>, 
</span>                                              <span class='Operator'>&</span><a href="parse_func.c.html#LN1413"><span class='Ref_To_Local'>current_candidates</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* one match only? then run with it... */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1414"><span class='Ref_To_Local'>ncandidates</span></a> <span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>                <a href="parse_func.c.html#LN1279"><span class='Ref_To_Local'>best_candidate</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN1413"><span class='Ref_To_Local'>current_candidates</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * multiple candidates? then better decide or throw an error... 
             */ 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1414"><span class='Ref_To_Local'>ncandidates</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="parse_func.c.html#LN1279"><span class='Ref_To_Local'>best_candidate</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_func.h.html#LN48"><span class='Ref_to_Proto'>func_select_candidate</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1266"><span class='Ref_to_Parameter'>nargs</span></a><span class='Delimiter'>, 
</span>                                                       <a href="parse_func.c.html#LN1267"><span class='Ref_to_Parameter'>argtypes</span></a><span class='Delimiter'>, 
</span>                                                       <a href="parse_func.c.html#LN1413"><span class='Ref_To_Local'>current_candidates</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * If we were able to choose a best candidate, we're done. 
                 * Otherwise, ambiguous function call. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_func.c.html#LN1279"><span class='Ref_To_Local'>best_candidate</span></a><span class='Parentheses'>) 
</span>                    <span class='Control'>return</span> <a href="../../include/parser/parse_func.h.html#LN24"><span class='Ref_to_EnumConst'>FUNCDETAIL_MULTIPLE</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if raw_candidates!=NULL &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if best_candidate==NULL &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1279"><span class='Ref_To_Local'>best_candidate</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1446"></a>        <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>ftup</span><span class='Delimiter'>; 
</span><a name="LN1447"></a>        <a href="../../include/catalog/pg_proc.h.html#LN82"><span class='Ref_to_Typedef'>Form_pg_proc</span></a> <span class='Declare_Local'>pform</span><span class='Delimiter'>; 
</span><a name="LN1448"></a>        <a href="../../include/parser/parse_func.h.html#LN21"><span class='Ref_to_Typedef'>FuncDetailCode</span></a> <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If processing named args or expanding variadics or defaults, the 
         * "best candidate" might represent multiple equivalently good 
         * functions; treat this case as ambiguous. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1279"><span class='Ref_To_Local'>best_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN31"><span class='Ref_to_Member'>oid</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <a href="../../include/parser/parse_func.h.html#LN24"><span class='Ref_to_EnumConst'>FUNCDETAIL_MULTIPLE</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We disallow VARIADIC with named arguments unless the last argument 
         * (the one with VARIADIC attached) actually matched the variadic 
         * parameter.  This is mere pedantry, really, but some folks insisted. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1265"><span class='Ref_to_Parameter'>fargnames</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>&& !</span><a href="parse_func.c.html#LN1268"><span class='Ref_to_Parameter'>expand_variadic</span></a> <span class='Operator'>&& </span><a href="parse_func.c.html#LN1266"><span class='Ref_to_Parameter'>nargs</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span> <span class='Operator'>&& 
</span>            <a href="parse_func.c.html#LN1279"><span class='Ref_To_Local'>best_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN35"><span class='Ref_to_Member'>argnumbers</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN1266"><span class='Ref_to_Parameter'>nargs</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>!= </span><a href="parse_func.c.html#LN1266"><span class='Ref_to_Parameter'>nargs</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <a href="../../include/parser/parse_func.h.html#LN23"><span class='Ref_to_EnumConst'>FUNCDETAIL_NOTFOUND</span></a><span class='Delimiter'>; 
</span> 
        <span class='Operator'>*</span><a href="parse_func.c.html#LN1270"><span class='Ref_to_Parameter'>funcid</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN1279"><span class='Ref_To_Local'>best_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN31"><span class='Ref_to_Member'>oid</span></a><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="parse_func.c.html#LN1273"><span class='Ref_to_Parameter'>nvargs</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN1279"><span class='Ref_To_Local'>best_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN33"><span class='Ref_to_Member'>nvargs</span></a><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="parse_func.c.html#LN1275"><span class='Ref_to_Parameter'>true_typeids</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN1279"><span class='Ref_To_Local'>best_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN36"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If processing named args, return actual argument positions into 
         * NamedArgExpr nodes in the fargs list.  This is a bit ugly but not 
         * worth the extra notation needed to do it differently. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1279"><span class='Ref_To_Local'>best_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN35"><span class='Ref_to_Member'>argnumbers</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1478"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1479"></a>            <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
            <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1479"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN1264"><span class='Ref_to_Parameter'>fargs</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN1483"></a>                <a href="../../include/nodes/primnodes.h.html#LN473"><span class='Ref_to_Struct'>NamedArgExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>na</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN473"><span class='Ref_to_Struct'>NamedArgExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1479"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1483"><span class='Ref_To_Local'>na</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN473"><span class='Ref_to_Struct'>NamedArgExpr</span></a><span class='Parentheses'>))</span> 
                    <a href="parse_func.c.html#LN1483"><span class='Ref_To_Local'>na</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN478"><span class='Ref_to_Member'>argnumber</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN1279"><span class='Ref_To_Local'>best_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN35"><span class='Ref_to_Member'>argnumbers</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN1478"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>                <a href="parse_func.c.html#LN1478"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="parse_func.c.html#LN1446"><span class='Ref_To_Local'>ftup</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN155"><span class='Ref_to_Macro'>SearchSysCache1</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN76"><span class='Ref_to_EnumConst'>PROCOID</span></a><span class='Delimiter'>, 
</span>                               <a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1279"><span class='Ref_To_Local'>best_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN31"><span class='Ref_to_Member'>oid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1446"><span class='Ref_To_Local'>ftup</span></a><span class='Parentheses'>))</span>    <span class='Comment_Single_Line'>/* should not happen */ 
</span>            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for function %u"</span><span class='Delimiter'>, 
</span>                 <a href="parse_func.c.html#LN1279"><span class='Ref_To_Local'>best_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN31"><span class='Ref_to_Member'>oid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_func.c.html#LN1447"><span class='Ref_To_Local'>pform</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_proc.h.html#LN82"><span class='Ref_to_Typedef'>Form_pg_proc</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1446"><span class='Ref_To_Local'>ftup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="parse_func.c.html#LN1271"><span class='Ref_to_Parameter'>rettype</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN1447"><span class='Ref_To_Local'>pform</span></a><span class='Operator'>-&GT;</span>prorettype<span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="parse_func.c.html#LN1272"><span class='Ref_to_Parameter'>retset</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN1447"><span class='Ref_To_Local'>pform</span></a><span class='Operator'>-&GT;</span>proretset<span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="parse_func.c.html#LN1274"><span class='Ref_to_Parameter'>vatype</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN1447"><span class='Ref_To_Local'>pform</span></a><span class='Operator'>-&GT;</span>provariadic<span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* fetch default args if caller wants 'em */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1276"><span class='Ref_to_Parameter'>argdefaults</span></a> <span class='Operator'>&& </span><a href="parse_func.c.html#LN1279"><span class='Ref_To_Local'>best_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN34"><span class='Ref_to_Member'>ndargs</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1503"></a>            <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>proargdefaults</span><span class='Delimiter'>; 
</span><a name="LN1504"></a>            <span class='Keyword'>bool</span>        <span class='Declare_Local'>isnull</span><span class='Delimiter'>; 
</span><a name="LN1505"></a>            <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>str</span><span class='Delimiter'>; 
</span><a name="LN1506"></a>            <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>defaults</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* shouldn't happen, FuncnameGetCandidates messed up */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1279"><span class='Ref_To_Local'>best_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN34"><span class='Ref_to_Member'>ndargs</span></a> <span class='Operator'>&GT; </span><a href="parse_func.c.html#LN1447"><span class='Ref_To_Local'>pform</span></a><span class='Operator'>-&GT;</span>pronargdefaults<span class='Parentheses'>) 
</span>                <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"not enough default arguments"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="parse_func.c.html#LN1503"><span class='Ref_To_Local'>proargdefaults</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN133"><span class='Ref_to_Proto'>SysCacheGetAttr</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN76"><span class='Ref_to_EnumConst'>PROCOID</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN1446"><span class='Ref_To_Local'>ftup</span></a><span class='Delimiter'>, 
</span>                                             <a href="../../include/catalog/pg_proc.h.html#LN112"><span class='Ref_to_Const'>Anum_pg_proc_proargdefaults</span></a><span class='Delimiter'>, 
</span>                                             <span class='Operator'>&</span><a href="parse_func.c.html#LN1504"><span class='Ref_To_Local'>isnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_func.c.html#LN1504"><span class='Ref_To_Local'>isnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="parse_func.c.html#LN1505"><span class='Ref_To_Local'>str</span></a> <span class='Operator'>= </span><a href="../../include/utils/builtins.h.html#LN91"><span class='Ref_to_Macro'>TextDatumGetCString</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1503"><span class='Ref_To_Local'>proargdefaults</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="parse_func.c.html#LN1506"><span class='Ref_To_Local'>defaults</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN575"><span class='Ref_to_Macro'>castNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a><span class='Delimiter'>, </span><a href="../nodes/read.c.html#LN36"><span class='Ref_to_Func'>stringToNode</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1505"><span class='Ref_To_Local'>str</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1505"><span class='Ref_To_Local'>str</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Delete any unused defaults from the returned list */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1279"><span class='Ref_To_Local'>best_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN35"><span class='Ref_to_Member'>argnumbers</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * This is a bit tricky in named notation, since the supplied 
                 * arguments could replace any subset of the defaults.  We 
                 * work by making a bitmapset of the argnumbers of defaulted 
                 * arguments, then scanning the defaults list and selecting 
                 * the needed items.  (This assumes that defaulted arguments 
                 * should be supplied in their positional order.) 
                 */ 
</span><a name="LN1531"></a>                <a href="../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>defargnumbers</span><span class='Delimiter'>; 
</span><a name="LN1532"></a>                <span class='Keyword'>int</span>        <span class='Operator'>*</span><span class='Declare_Local'>firstdefarg</span><span class='Delimiter'>; 
</span><a name="LN1533"></a>                <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>newdefaults</span><span class='Delimiter'>; 
</span><a name="LN1534"></a>                <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span><a name="LN1535"></a>                <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
                <a href="parse_func.c.html#LN1531"><span class='Ref_To_Local'>defargnumbers</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>                <a href="parse_func.c.html#LN1532"><span class='Ref_To_Local'>firstdefarg</span></a> <span class='Operator'>= &</span><a href="parse_func.c.html#LN1279"><span class='Ref_To_Local'>best_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN35"><span class='Ref_to_Member'>argnumbers</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN1279"><span class='Ref_To_Local'>best_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN32"><span class='Ref_to_Member'>nargs</span></a> <span class='Operator'>- </span><a href="parse_func.c.html#LN1279"><span class='Ref_To_Local'>best_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN34"><span class='Ref_to_Member'>ndargs</span></a><span class='Delimiter'>]; 
</span>                <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1535"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="parse_func.c.html#LN1535"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="parse_func.c.html#LN1279"><span class='Ref_To_Local'>best_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN34"><span class='Ref_to_Member'>ndargs</span></a><span class='Delimiter'>; </span><a href="parse_func.c.html#LN1535"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>                    <a href="parse_func.c.html#LN1531"><span class='Ref_To_Local'>defargnumbers</span></a> <span class='Operator'>= </span><a href="../../include/nodes/bitmapset.h.html#LN89"><span class='Ref_to_Proto'>bms_add_member</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1531"><span class='Ref_To_Local'>defargnumbers</span></a><span class='Delimiter'>, 
</span>                                                   <a href="parse_func.c.html#LN1532"><span class='Ref_To_Local'>firstdefarg</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN1535"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="parse_func.c.html#LN1533"><span class='Ref_To_Local'>newdefaults</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>                <a href="parse_func.c.html#LN1535"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN1447"><span class='Ref_To_Local'>pform</span></a><span class='Operator'>-&GT;</span>pronargs <span class='Operator'>- </span><a href="parse_func.c.html#LN1447"><span class='Ref_To_Local'>pform</span></a><span class='Operator'>-&GT;</span>pronargdefaults<span class='Delimiter'>; 
</span>                <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1534"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN1506"><span class='Ref_To_Local'>defaults</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/bitmapset.h.html#LN75"><span class='Ref_to_Proto'>bms_is_member</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1535"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN1531"><span class='Ref_To_Local'>defargnumbers</span></a><span class='Parentheses'>))</span> 
                        <a href="parse_func.c.html#LN1533"><span class='Ref_To_Local'>newdefaults</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1533"><span class='Ref_To_Local'>newdefaults</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1534"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                    <a href="parse_func.c.html#LN1535"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1533"><span class='Ref_To_Local'>newdefaults</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="parse_func.c.html#LN1279"><span class='Ref_To_Local'>best_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN34"><span class='Ref_to_Member'>ndargs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../include/nodes/bitmapset.h.html#LN68"><span class='Ref_to_Proto'>bms_free</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1531"><span class='Ref_To_Local'>defargnumbers</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Operator'>*</span><a href="parse_func.c.html#LN1276"><span class='Ref_to_Parameter'>argdefaults</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN1533"><span class='Ref_To_Local'>newdefaults</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if best_candidate-&GT;argnu... &raquo; </span> 
            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * Defaults for positional notation are lots easier; just 
                 * remove any unwanted ones from the front. 
                 */ 
</span><a name="LN1560"></a>                <span class='Keyword'>int</span>         <span class='Declare_Local'>ndelete</span><span class='Delimiter'>; 
</span> 
                <a href="parse_func.c.html#LN1560"><span class='Ref_To_Local'>ndelete</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1506"><span class='Ref_To_Local'>defaults</span></a><span class='Parentheses'>) </span><span class='Operator'>- </span><a href="parse_func.c.html#LN1279"><span class='Ref_To_Local'>best_candidate</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN34"><span class='Ref_to_Member'>ndargs</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1560"><span class='Ref_To_Local'>ndelete</span></a><span class='Operator'>-- &GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                    <a href="parse_func.c.html#LN1506"><span class='Ref_To_Local'>defaults</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN237"><span class='Ref_to_Proto'>list_delete_first</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1506"><span class='Ref_To_Local'>defaults</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Operator'>*</span><a href="parse_func.c.html#LN1276"><span class='Ref_to_Parameter'>argdefaults</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN1506"><span class='Ref_To_Local'>defaults</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if argdefaults&&best_can... &raquo; </span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1447"><span class='Ref_To_Local'>pform</span></a><span class='Operator'>-&GT;</span>proisagg<span class='Parentheses'>) 
</span>            <a href="parse_func.c.html#LN1448"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_func.h.html#LN26"><span class='Ref_to_EnumConst'>FUNCDETAIL_AGGREGATE</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1447"><span class='Ref_To_Local'>pform</span></a><span class='Operator'>-&GT;</span>proiswindow<span class='Parentheses'>) 
</span>            <a href="parse_func.c.html#LN1448"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_func.h.html#LN27"><span class='Ref_to_EnumConst'>FUNCDETAIL_WINDOWFUNC</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="parse_func.c.html#LN1448"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_func.h.html#LN25"><span class='Ref_to_EnumConst'>FUNCDETAIL_NORMAL</span></a><span class='Delimiter'>; 
</span>        <a href="../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1446"><span class='Ref_To_Local'>ftup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <a href="parse_func.c.html#LN1448"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if best_candidate &raquo; </span> 
 
    <span class='Control'>return</span> <a href="../../include/parser/parse_func.h.html#LN23"><span class='Ref_to_EnumConst'>FUNCDETAIL_NOTFOUND</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end func_get_detail &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * unify_hypothetical_args() 
 * 
 * Ensure that each hypothetical direct argument of a hypothetical-set 
 * aggregate has the same type as the corresponding aggregated argument. 
 * Modify the expressions in the fargs list, if necessary, and update 
 * actual_arg_types[]. 
 * 
 * If the agg declared its args non-ANY (even ANYELEMENT), we need only a 
 * sanity check that the declared types match; make_fn_arguments will coerce 
 * the actual arguments to match the declared ones.  But if the declaration 
 * is ANY, nothing will happen in make_fn_arguments, so we need to fix any 
 * mismatch here.  We use the same type resolution logic as UNION etc. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1597"></a><span class='Declare_Function'>unify_hypothetical_args</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, 
</span><a name="LN1598"></a>                        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>fargs</span><span class='Delimiter'>, 
</span><a name="LN1599"></a>                        <span class='Keyword'>int </span><span class='Declare_Parameter'>numAggregatedArgs</span><span class='Delimiter'>, 
</span><a name="LN1600"></a>                        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>actual_arg_types</span><span class='Delimiter'>, 
</span><a name="LN1601"></a>                        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>declared_arg_types</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1603"></a>    <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>args</span><span class='Delimiter'>[</span><a href="../../include/pg_config_manual.h.html#LN36"><span class='Ref_to_Const'>FUNC_MAX_ARGS</span></a><span class='Delimiter'>]; 
</span><a name="LN1604"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numDirectArgs</span><span class='Delimiter'>, 
</span><a name="LN1605"></a>                <span class='Declare_Local'>numNonHypotheticalArgs</span><span class='Delimiter'>; 
</span><a name="LN1606"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN1607"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <a href="parse_func.c.html#LN1604"><span class='Ref_To_Local'>numDirectArgs</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1598"><span class='Ref_to_Parameter'>fargs</span></a><span class='Parentheses'>) </span><span class='Operator'>- </span><a href="parse_func.c.html#LN1599"><span class='Ref_to_Parameter'>numAggregatedArgs</span></a><span class='Delimiter'>; 
</span>    <a href="parse_func.c.html#LN1605"><span class='Ref_To_Local'>numNonHypotheticalArgs</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN1604"><span class='Ref_To_Local'>numDirectArgs</span></a> <span class='Operator'>- </span><a href="parse_func.c.html#LN1599"><span class='Ref_to_Parameter'>numAggregatedArgs</span></a><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* safety check (should only trigger with a misdeclared agg) */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1605"><span class='Ref_To_Local'>numNonHypotheticalArgs</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"incorrect number of arguments to hypothetical-set aggregate"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Deconstruct fargs into an array for ease of subscripting */ 
</span>    <a href="parse_func.c.html#LN1606"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1607"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN1598"><span class='Ref_to_Parameter'>fargs</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="parse_func.c.html#LN1603"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN1606"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1607"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Check each hypothetical arg and corresponding aggregated arg */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1606"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN1605"><span class='Ref_To_Local'>numNonHypotheticalArgs</span></a><span class='Delimiter'>; </span><a href="parse_func.c.html#LN1606"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="parse_func.c.html#LN1604"><span class='Ref_To_Local'>numDirectArgs</span></a><span class='Delimiter'>; </span><a href="parse_func.c.html#LN1606"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1625"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>aargpos</span> <span class='Operator'>= </span><a href="parse_func.c.html#LN1604"><span class='Ref_To_Local'>numDirectArgs</span></a> <span class='Operator'>+ </span><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1606"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>- </span><a href="parse_func.c.html#LN1605"><span class='Ref_To_Local'>numNonHypotheticalArgs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1626"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>commontype</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* A mismatch means AggregateCreate didn't check properly ... */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1601"><span class='Ref_to_Parameter'>declared_arg_types</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN1606"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>!= </span><a href="parse_func.c.html#LN1601"><span class='Ref_to_Parameter'>declared_arg_types</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN1625"><span class='Ref_To_Local'>aargpos</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"hypothetical-set aggregate has inconsistent declared argument types"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* No need to unify if make_fn_arguments will coerce */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1601"><span class='Ref_to_Parameter'>declared_arg_types</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN1606"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>!= </span><a href="../../include/catalog/pg_type.h.html#LN685"><span class='Ref_to_Const'>ANYOID</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Select common type, giving preference to the aggregated argument's 
         * type (we'd rather coerce the direct argument once than coerce all 
         * the aggregated values). 
         */ 
</span>        <a href="parse_func.c.html#LN1626"><span class='Ref_To_Local'>commontype</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN68"><span class='Ref_to_Proto'>select_common_type</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1597"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                        <a href="../../include/nodes/pg_list.h.html#LN139"><span class='Ref_to_Macro'>list_make2</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1603"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN1625"><span class='Ref_To_Local'>aargpos</span></a><span class='Delimiter'>], </span><a href="parse_func.c.html#LN1603"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN1606"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                        <span class='String'>"WITHIN GROUP"</span><span class='Delimiter'>, 
</span>                                        <span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Perform the coercions.  We don't need to worry about NamedArgExprs 
         * here because they aren't supported with aggregates. 
         */ 
</span>        <a href="parse_func.c.html#LN1603"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN1606"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN45"><span class='Ref_to_Proto'>coerce_type</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1597"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                              <a href="parse_func.c.html#LN1603"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN1606"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], 
</span>                              <a href="parse_func.c.html#LN1600"><span class='Ref_to_Parameter'>actual_arg_types</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN1606"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], 
</span>                              <a href="parse_func.c.html#LN1626"><span class='Ref_To_Local'>commontype</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                              <a href="../../include/nodes/primnodes.h.html#LN420"><span class='Ref_to_EnumConst'>COERCION_IMPLICIT</span></a><span class='Delimiter'>, 
</span>                              <a href="../../include/nodes/primnodes.h.html#LN438"><span class='Ref_to_EnumConst'>COERCE_IMPLICIT_CAST</span></a><span class='Delimiter'>, 
</span>                              <span class='Operator'>-</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_func.c.html#LN1600"><span class='Ref_to_Parameter'>actual_arg_types</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN1606"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="parse_func.c.html#LN1626"><span class='Ref_To_Local'>commontype</span></a><span class='Delimiter'>; 
</span>        <a href="parse_func.c.html#LN1603"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN1625"><span class='Ref_To_Local'>aargpos</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN45"><span class='Ref_to_Proto'>coerce_type</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1597"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                    <a href="parse_func.c.html#LN1603"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN1625"><span class='Ref_To_Local'>aargpos</span></a><span class='Delimiter'>], 
</span>                                    <a href="parse_func.c.html#LN1600"><span class='Ref_to_Parameter'>actual_arg_types</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN1625"><span class='Ref_To_Local'>aargpos</span></a><span class='Delimiter'>], 
</span>                                    <a href="parse_func.c.html#LN1626"><span class='Ref_To_Local'>commontype</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                                    <a href="../../include/nodes/primnodes.h.html#LN420"><span class='Ref_to_EnumConst'>COERCION_IMPLICIT</span></a><span class='Delimiter'>, 
</span>                                    <a href="../../include/nodes/primnodes.h.html#LN438"><span class='Ref_to_EnumConst'>COERCE_IMPLICIT_CAST</span></a><span class='Delimiter'>, 
</span>                                    <span class='Operator'>-</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_func.c.html#LN1600"><span class='Ref_to_Parameter'>actual_arg_types</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN1625"><span class='Ref_To_Local'>aargpos</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="parse_func.c.html#LN1626"><span class='Ref_To_Local'>commontype</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=numNonHypotheticalA... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Reconstruct fargs from array */ 
</span>    <a href="parse_func.c.html#LN1606"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1607"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN1598"><span class='Ref_to_Parameter'>fargs</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1607"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="parse_func.c.html#LN1603"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN1606"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Delimiter'>]; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end unify_hypothetical_args &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * make_fn_arguments() 
 * 
 * Given the actual argument expressions for a function, and the desired 
 * input types for the function, add any necessary typecasting to the 
 * expression tree.  Caller should already have verified that casting is 
 * allowed. 
 * 
 * Caution: given argument list is modified in-place. 
 * 
 * As with coerce_type, pstate may be NULL if no special unknown-Param 
 * processing is wanted. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1691"></a><span class='Declare_Function'>make_fn_arguments</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, 
</span><a name="LN1692"></a>                  <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>fargs</span><span class='Delimiter'>, 
</span><a name="LN1693"></a>                  <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>actual_arg_types</span><span class='Delimiter'>, 
</span><a name="LN1694"></a>                  <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>declared_arg_types</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1696"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>current_fargs</span><span class='Delimiter'>; 
</span><a name="LN1697"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1696"><span class='Ref_To_Local'>current_fargs</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN1692"><span class='Ref_to_Parameter'>fargs</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* types don't match? then force coercion using a function call... */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1693"><span class='Ref_to_Parameter'>actual_arg_types</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN1697"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>!= </span><a href="parse_func.c.html#LN1694"><span class='Ref_to_Parameter'>declared_arg_types</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN1697"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1704"></a>            <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>node</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1696"><span class='Ref_To_Local'>current_fargs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * If arg is a NamedArgExpr, coerce its input expr instead --- we 
             * want the NamedArgExpr to stay at the top level of the list. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1704"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN473"><span class='Ref_to_Struct'>NamedArgExpr</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span><a name="LN1712"></a>                <a href="../../include/nodes/primnodes.h.html#LN473"><span class='Ref_to_Struct'>NamedArgExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>na</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN473"><span class='Ref_to_Struct'>NamedArgExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_func.c.html#LN1704"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>; 
</span> 
                <a href="parse_func.c.html#LN1704"><span class='Ref_To_Local'>node</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN45"><span class='Ref_to_Proto'>coerce_type</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1691"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                   <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_func.c.html#LN1712"><span class='Ref_To_Local'>na</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN476"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>, 
</span>                                   <a href="parse_func.c.html#LN1693"><span class='Ref_to_Parameter'>actual_arg_types</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN1697"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], 
</span>                                   <a href="parse_func.c.html#LN1694"><span class='Ref_to_Parameter'>declared_arg_types</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN1697"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                                   <a href="../../include/nodes/primnodes.h.html#LN420"><span class='Ref_to_EnumConst'>COERCION_IMPLICIT</span></a><span class='Delimiter'>, 
</span>                                   <a href="../../include/nodes/primnodes.h.html#LN438"><span class='Ref_to_EnumConst'>COERCE_IMPLICIT_CAST</span></a><span class='Delimiter'>, 
</span>                                   <span class='Operator'>-</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="parse_func.c.html#LN1712"><span class='Ref_To_Local'>na</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN476"><span class='Ref_to_Member'>arg</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_func.c.html#LN1704"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <a href="parse_func.c.html#LN1704"><span class='Ref_To_Local'>node</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN45"><span class='Ref_to_Proto'>coerce_type</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1691"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                   <a href="parse_func.c.html#LN1704"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>, 
</span>                                   <a href="parse_func.c.html#LN1693"><span class='Ref_to_Parameter'>actual_arg_types</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN1697"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], 
</span>                                   <a href="parse_func.c.html#LN1694"><span class='Ref_to_Parameter'>declared_arg_types</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN1697"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                                   <a href="../../include/nodes/primnodes.h.html#LN420"><span class='Ref_to_EnumConst'>COERCION_IMPLICIT</span></a><span class='Delimiter'>, 
</span>                                   <a href="../../include/nodes/primnodes.h.html#LN438"><span class='Ref_to_EnumConst'>COERCE_IMPLICIT_CAST</span></a><span class='Delimiter'>, 
</span>                                   <span class='Operator'>-</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1696"><span class='Ref_To_Local'>current_fargs</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="parse_func.c.html#LN1704"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if actual_arg_types[i]!=... &raquo; </span> 
        <a href="parse_func.c.html#LN1697"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end make_fn_arguments &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * FuncNameAsType - 
 *    convenience routine to see if a function name matches a type name 
 * 
 * Returns the OID of the matching type, or InvalidOid if none.  We ignore 
 * shell types and complex types. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> 
<a name="LN1747"></a><span class='Declare_Function'>FuncNameAsType</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>funcname</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1749"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span><a name="LN1750"></a>    <a href="../../include/parser/parse_type.h.html#LN19"><span class='Ref_to_Typedef'>Type</span></a>        <span class='Declare_Local'>typtup</span><span class='Delimiter'>; 
</span> 
    <a href="parse_func.c.html#LN1750"><span class='Ref_To_Local'>typtup</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_type.h.html#LN21"><span class='Ref_to_Proto'>LookupTypeName</span></a><span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><a href="../../include/nodes/makefuncs.h.html#LN71"><span class='Ref_to_Proto'>makeTypeNameFromNameList</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1747"><span class='Ref_to_Parameter'>funcname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1750"><span class='Ref_To_Local'>typtup</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(((</span><a href="../../include/catalog/pg_type.h.html#LN232"><span class='Ref_to_Typedef'>Form_pg_type</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1750"><span class='Ref_To_Local'>typtup</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>typisdefined <span class='Operator'>&& 
</span>        <span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="../../include/parser/parse_type.h.html#LN43"><span class='Ref_to_Proto'>typeTypeRelid</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1750"><span class='Ref_To_Local'>typtup</span></a><span class='Parentheses'>)))</span> 
        <a href="parse_func.c.html#LN1749"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_type.h.html#LN39"><span class='Ref_to_Proto'>typeTypeId</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1750"><span class='Ref_To_Local'>typtup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="parse_func.c.html#LN1749"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1750"><span class='Ref_To_Local'>typtup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="parse_func.c.html#LN1749"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * ParseComplexProjection - 
 *    handles function calls with a single argument that is of complex type. 
 *    If the function call is actually a column projection, return a suitably 
 *    transformed expression tree.  If not, return NULL. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN1773"></a><span class='Declare_Function'>ParseComplexProjection</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Declare_Parameter'>funcname</span><span class='Delimiter'>, </span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>first_arg</span><span class='Delimiter'>, 
</span><a name="LN1774"></a>                       <span class='Keyword'>int </span><span class='Declare_Parameter'>location</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1776"></a>    <a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Local'>tupdesc</span><span class='Delimiter'>; 
</span><a name="LN1777"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Special case for whole-row Vars so that we can resolve (foo.*).bar even 
     * when foo is a reference to a subselect, join, or RECORD function. A 
     * bonus is that we avoid generating an unnecessary FieldSelect; our 
     * result can omit the whole-row Var and just be a Var for the selected 
     * field. 
     * 
     * This case could be handled by expandRecordVariable, but it's more 
     * efficient to do it this way when possible. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1773"><span class='Ref_to_Parameter'>first_arg</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>        <span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_func.c.html#LN1773"><span class='Ref_to_Parameter'>first_arg</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>varattno <span class='Operator'>== </span><a href="../../include/access/attnum.h.html#LN22"><span class='Ref_to_Const'>InvalidAttrNumber</span></a><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1792"></a>        <a href="../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span><span class='Delimiter'>; 
</span> 
        <a href="parse_func.c.html#LN1792"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_relation.h.html#LN50"><span class='Ref_to_Proto'>GetRTEByRangeTablePosn</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1773"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, 
</span>                                     <span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_func.c.html#LN1773"><span class='Ref_to_Parameter'>first_arg</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>varno<span class='Delimiter'>, 
</span>                                     <span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_func.c.html#LN1773"><span class='Ref_to_Parameter'>first_arg</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>varlevelsup<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Return a Var if funcname matches a column, else NULL */ 
</span>        <span class='Control'>return</span> <a href="../../include/parser/parse_relation.h.html#LN55"><span class='Ref_to_Proto'>scanRTEForColumn</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1773"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN1792"><span class='Ref_To_Local'>rte</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN1773"><span class='Ref_to_Parameter'>funcname</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN1774"><span class='Ref_to_Parameter'>location</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Else do it the hard way with get_expr_result_type(). 
     * 
     * If it's a Var of type RECORD, we have to work even harder: we have to 
     * find what the Var refers to, and pass that to get_expr_result_type. 
     * That task is handled by expandRecordVariable(). 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1773"><span class='Ref_to_Parameter'>first_arg</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>        <span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_func.c.html#LN1773"><span class='Ref_to_Parameter'>first_arg</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>vartype <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN679"><span class='Ref_to_Const'>RECORDOID</span></a><span class='Parentheses'>)</span> 
        <a href="parse_func.c.html#LN1776"><span class='Ref_To_Local'>tupdesc</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_target.h.html#LN40"><span class='Ref_to_Proto'>expandRecordVariable</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1773"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_func.c.html#LN1773"><span class='Ref_to_Parameter'>first_arg</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/funcapi.h.html#LN160"><span class='Ref_to_Proto'>get_expr_result_type</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1773"><span class='Ref_to_Parameter'>first_arg</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_func.c.html#LN1776"><span class='Ref_To_Local'>tupdesc</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="../../include/funcapi.h.html#LN152"><span class='Ref_to_EnumConst'>TYPEFUNC_COMPOSITE</span></a><span class='Parentheses'>)</span> 
        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* unresolvable RECORD type */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1776"><span class='Ref_To_Local'>tupdesc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1777"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="parse_func.c.html#LN1777"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="parse_func.c.html#LN1776"><span class='Ref_To_Local'>tupdesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tupdesc.h.html#LN72"><span class='Ref_to_Member'>natts</span></a><span class='Delimiter'>; </span><a href="parse_func.c.html#LN1777"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1817"></a>        <a href="../../include/catalog/pg_attribute.h.html#LN186"><span class='Ref_to_Typedef'>Form_pg_attribute</span></a> <span class='Declare_Local'>att</span> <span class='Operator'>= </span><a href="parse_func.c.html#LN1776"><span class='Ref_To_Local'>tupdesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tupdesc.h.html#LN73"><span class='Ref_to_Member'>attrs</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN1777"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="parse_func.c.html#LN1773"><span class='Ref_to_Parameter'>funcname</span></a><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN498"><span class='Ref_to_Macro'>NameStr</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1817"><span class='Ref_To_Local'>att</span></a><span class='Operator'>-&GT;</span>attname<span class='Parentheses'>))</span> <span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>&& 
</span>            <span class='Operator'>!</span><a href="parse_func.c.html#LN1817"><span class='Ref_To_Local'>att</span></a><span class='Operator'>-&GT;</span>attisdropped<span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Success, so generate a FieldSelect expression */ 
</span><a name="LN1823"></a>            <a href="../../include/nodes/primnodes.h.html#LN737"><span class='Ref_to_Struct'>FieldSelect</span></a> <span class='Operator'>*</span><span class='Declare_Local'>fselect</span> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN737"><span class='Ref_to_Struct'>FieldSelect</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="parse_func.c.html#LN1823"><span class='Ref_To_Local'>fselect</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN740"><span class='Ref_to_Member'>arg</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_func.c.html#LN1773"><span class='Ref_to_Parameter'>first_arg</span></a><span class='Delimiter'>; 
</span>            <a href="parse_func.c.html#LN1823"><span class='Ref_To_Local'>fselect</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN741"><span class='Ref_to_Member'>fieldnum</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN1777"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>            <a href="parse_func.c.html#LN1823"><span class='Ref_To_Local'>fselect</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN742"><span class='Ref_to_Member'>resulttype</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN1817"><span class='Ref_To_Local'>att</span></a><span class='Operator'>-&GT;</span>atttypid<span class='Delimiter'>; 
</span>            <a href="parse_func.c.html#LN1823"><span class='Ref_To_Local'>fselect</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN744"><span class='Ref_to_Member'>resulttypmod</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN1817"><span class='Ref_To_Local'>att</span></a><span class='Operator'>-&GT;</span>atttypmod<span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* save attribute's collation for parse_collate.c */ 
</span>            <a href="parse_func.c.html#LN1823"><span class='Ref_To_Local'>fselect</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN745"><span class='Ref_to_Member'>resultcollid</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN1817"><span class='Ref_To_Local'>att</span></a><span class='Operator'>-&GT;</span>attcollation<span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_func.c.html#LN1823"><span class='Ref_To_Local'>fselect</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>;</span>                <span class='Comment_Single_Line'>/* funcname does not match any column */ 
</span><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end ParseComplexProjection &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * funcname_signature_string 
 *      Build a string representing a function name, including arg types. 
 *      The result is something like "foo(integer)". 
 * 
 * If argnames isn't NIL, it is a list of C strings representing the actual 
 * arg names for the last N arguments.  This must be considered part of the 
 * function signature too, when dealing with named-notation function calls. 
 * 
 * This is typically used in the construction of function-not-found error 
 * messages. 
 */ 
</span><span class='Keyword'>const char </span><span class='Operator'>* 
</span><a name="LN1851"></a><span class='Declare_Function'>funcname_signature_string</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>funcname</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>nargs</span><span class='Delimiter'>, 
</span><a name="LN1852"></a>                          <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>argnames</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>argtypes</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1854"></a>    <a href="../../include/lib/stringinfo.h.html#LN34"><span class='Ref_to_Struct'>StringInfoData</span></a> <span class='Declare_Local'>argbuf</span><span class='Delimiter'>; 
</span><a name="LN1855"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numposargs</span><span class='Delimiter'>; 
</span><a name="LN1856"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span><a name="LN1857"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <a href="../lib/stringinfo.c.html#LN44"><span class='Ref_to_Func'>initStringInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="parse_func.c.html#LN1854"><span class='Ref_To_Local'>argbuf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../bin/pg_waldump/compat.c.html#LN69"><span class='Ref_to_Func'>appendStringInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="parse_func.c.html#LN1854"><span class='Ref_To_Local'>argbuf</span></a><span class='Delimiter'>, </span><span class='String'>"%s("</span><span class='Delimiter'>, </span><a href="parse_func.c.html#LN1851"><span class='Ref_to_Parameter'>funcname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="parse_func.c.html#LN1855"><span class='Ref_To_Local'>numposargs</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN1851"><span class='Ref_to_Parameter'>nargs</span></a> <span class='Operator'>- </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1852"><span class='Ref_to_Parameter'>argnames</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="parse_func.c.html#LN1856"><span class='Ref_To_Local'>lc</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1852"><span class='Ref_to_Parameter'>argnames</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1857"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="parse_func.c.html#LN1857"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="parse_func.c.html#LN1851"><span class='Ref_to_Parameter'>nargs</span></a><span class='Delimiter'>; </span><a href="parse_func.c.html#LN1857"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1857"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>) 
</span>            <a href="../../bin/pg_waldump/compat.c.html#LN79"><span class='Ref_to_Func'>appendStringInfoString</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="parse_func.c.html#LN1854"><span class='Ref_To_Local'>argbuf</span></a><span class='Delimiter'>, </span><span class='String'>", "</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1857"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&GT;= </span><a href="parse_func.c.html#LN1855"><span class='Ref_To_Local'>numposargs</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../bin/pg_waldump/compat.c.html#LN69"><span class='Ref_to_Func'>appendStringInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="parse_func.c.html#LN1854"><span class='Ref_To_Local'>argbuf</span></a><span class='Delimiter'>, </span><span class='String'>"%s =&GT; "</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1856"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="parse_func.c.html#LN1856"><span class='Ref_To_Local'>lc</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1856"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="../../bin/pg_waldump/compat.c.html#LN79"><span class='Ref_to_Func'>appendStringInfoString</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="parse_func.c.html#LN1854"><span class='Ref_To_Local'>argbuf</span></a><span class='Delimiter'>, </span><a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1852"><span class='Ref_to_Parameter'>argtypes</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN1857"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../replication/syncrep_scanner.l.html#LN76"><span class='Ref_to_Proto'>appendStringInfoChar</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="parse_func.c.html#LN1854"><span class='Ref_To_Local'>argbuf</span></a><span class='Delimiter'>, </span><span class='String'>')'</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="parse_func.c.html#LN1854"><span class='Ref_To_Local'>argbuf</span></a><span class='Operator'>.</span><a href="../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* return palloc'd string buffer */ 
</span><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end funcname_signature_string &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * func_signature_string 
 *      As above, but function name is passed as a qualified name list. 
 */ 
</span><span class='Keyword'>const char </span><span class='Operator'>* 
</span><a name="LN1888"></a><span class='Declare_Function'>func_signature_string</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>funcname</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>nargs</span><span class='Delimiter'>, 
</span><a name="LN1889"></a>                      <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>argnames</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>argtypes</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="../../include/parser/parse_func.h.html#LN57"><span class='Ref_to_Proto'>funcname_signature_string</span></a><span class='Parentheses'>(</span><a href="../../include/catalog/namespace.h.html#LN120"><span class='Ref_to_Proto'>NameListToString</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1888"><span class='Ref_to_Parameter'>funcname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                     <a href="parse_func.c.html#LN1888"><span class='Ref_to_Parameter'>nargs</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN1889"><span class='Ref_to_Parameter'>argnames</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN1889"><span class='Ref_to_Parameter'>argtypes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * LookupFuncName 
 * 
 * Given a possibly-qualified function name and optionally a set of argument 
 * types, look up the function.  Pass nargs == -1 to indicate that no argument 
 * types are specified. 
 * 
 * If the function name is not schema-qualified, it is sought in the current 
 * namespace search path. 
 * 
 * If the function is not found, we return InvalidOid if noError is true, 
 * else raise an error. 
 */ 
</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> 
<a name="LN1909"></a><span class='Declare_Function'>LookupFuncName</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>funcname</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>nargs</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>argtypes</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>noError</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1911"></a>    <a href="../../include/catalog/namespace.h.html#LN27"><span class='Ref_to_Typedef'>FuncCandidateList</span></a> <span class='Declare_Local'>clist</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Passing NULL for argtypes is no longer allowed */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1909"><span class='Ref_to_Parameter'>argtypes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="parse_func.c.html#LN1911"><span class='Ref_To_Local'>clist</span></a> <span class='Operator'>= </span><a href="../../include/catalog/namespace.h.html#LN70"><span class='Ref_to_Proto'>FuncnameGetCandidates</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1909"><span class='Ref_to_Parameter'>funcname</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN1909"><span class='Ref_to_Parameter'>nargs</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><a href="parse_func.c.html#LN1909"><span class='Ref_to_Parameter'>noError</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If no arguments were specified, the name must yield a unique candidate. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1909"><span class='Ref_to_Parameter'>nargs</span></a> <span class='Operator'>== -</span><span class='Number'>1</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1911"><span class='Ref_To_Local'>clist</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1911"><span class='Ref_To_Local'>clist</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN29"><span class='Ref_to_Member'>next</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_func.c.html#LN1909"><span class='Ref_to_Parameter'>noError</span></a><span class='Parentheses'>) 
</span>                    <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_AMBIGUOUS_FUNCTION<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"function name \"%s\" is not unique"</span><span class='Delimiter'>, 
</span>                                    <a href="../../include/catalog/namespace.h.html#LN120"><span class='Ref_to_Proto'>NameListToString</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1909"><span class='Ref_to_Parameter'>funcname</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                             <a href="../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"Specify the argument list to select the function unambiguously."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
                <span class='Control'>return</span> <a href="parse_func.c.html#LN1911"><span class='Ref_To_Local'>clist</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN31"><span class='Ref_to_Member'>oid</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_func.c.html#LN1909"><span class='Ref_to_Parameter'>noError</span></a><span class='Parentheses'>) 
</span>                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_UNDEFINED_FUNCTION<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not find a function named \"%s\""</span><span class='Delimiter'>, 
</span>                                <a href="../../include/catalog/namespace.h.html#LN120"><span class='Ref_to_Proto'>NameListToString</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1909"><span class='Ref_to_Parameter'>funcname</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if nargs==-1 &raquo; </span> 
 
    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1911"><span class='Ref_To_Local'>clist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span>memcmp<span class='Parentheses'>(</span><a href="parse_func.c.html#LN1909"><span class='Ref_to_Parameter'>argtypes</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN1911"><span class='Ref_To_Local'>clist</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN36"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN1909"><span class='Ref_to_Parameter'>nargs</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a><span class='Parentheses'>))</span> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <span class='Control'>return</span> <a href="parse_func.c.html#LN1911"><span class='Ref_To_Local'>clist</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN31"><span class='Ref_to_Member'>oid</span></a><span class='Delimiter'>; 
</span>        <a href="parse_func.c.html#LN1911"><span class='Ref_To_Local'>clist</span></a> <span class='Operator'>= </span><a href="parse_func.c.html#LN1911"><span class='Ref_To_Local'>clist</span></a><span class='Operator'>-&GT;</span><a href="../../include/catalog/namespace.h.html#LN29"><span class='Ref_to_Member'>next</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_func.c.html#LN1909"><span class='Ref_to_Parameter'>noError</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_UNDEFINED_FUNCTION<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"function %s does not exist"</span><span class='Delimiter'>, 
</span>                        <a href="../../include/parser/parse_func.h.html#LN59"><span class='Ref_to_Proto'>func_signature_string</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1909"><span class='Ref_to_Parameter'>funcname</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN1909"><span class='Ref_to_Parameter'>nargs</span></a><span class='Delimiter'>, 
</span>                                              <a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN1909"><span class='Ref_to_Parameter'>argtypes</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end LookupFuncName &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * LookupFuncWithArgs 
 *      Like LookupFuncName, but the argument types are specified by a 
 *      ObjectWithArgs node. 
 */ 
</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> 
<a name="LN1970"></a><span class='Declare_Function'>LookupFuncWithArgs</span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1848"><span class='Ref_to_Struct'>ObjectWithArgs</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>func</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>noError</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1972"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>argoids</span><span class='Delimiter'>[</span><a href="../../include/pg_config_manual.h.html#LN36"><span class='Ref_to_Const'>FUNC_MAX_ARGS</span></a><span class='Delimiter'>]; 
</span><a name="LN1973"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>argcount</span><span class='Delimiter'>; 
</span><a name="LN1974"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN1975"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>args_item</span><span class='Delimiter'>; 
</span> 
    <a href="parse_func.c.html#LN1973"><span class='Ref_To_Local'>argcount</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1970"><span class='Ref_to_Parameter'>func</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1852"><span class='Ref_to_Member'>objargs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1973"><span class='Ref_To_Local'>argcount</span></a> <span class='Operator'>&GT; </span><a href="../../include/pg_config_manual.h.html#LN36"><span class='Ref_to_Const'>FUNC_MAX_ARGS</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_TOO_MANY_ARGUMENTS<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN848"><span class='Ref_to_Func'>errmsg_plural</span></a><span class='Parentheses'>(</span><span class='String'>"functions cannot have more than %d argument"</span><span class='Delimiter'>, 
</span>                               <span class='String'>"functions cannot have more than %d arguments"</span><span class='Delimiter'>, 
</span>                               <a href="../../include/pg_config_manual.h.html#LN36"><span class='Ref_to_Const'>FUNC_MAX_ARGS</span></a><span class='Delimiter'>, 
</span>                               <a href="../../include/pg_config_manual.h.html#LN36"><span class='Ref_to_Const'>FUNC_MAX_ARGS</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <a href="parse_func.c.html#LN1975"><span class='Ref_To_Local'>args_item</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1970"><span class='Ref_to_Parameter'>func</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1852"><span class='Ref_to_Member'>objargs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN1974"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="parse_func.c.html#LN1974"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="parse_func.c.html#LN1973"><span class='Ref_To_Local'>argcount</span></a><span class='Delimiter'>; </span><a href="parse_func.c.html#LN1974"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1989"></a>        <a href="../../include/nodes/parsenodes.h.html#LN205"><span class='Ref_to_Struct'>TypeName</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>t</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN205"><span class='Ref_to_Struct'>TypeName</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1975"><span class='Ref_To_Local'>args_item</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="parse_func.c.html#LN1972"><span class='Ref_To_Local'>argoids</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN1974"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/parser/parse_type.h.html#LN23"><span class='Ref_to_Proto'>LookupTypeNameOid</span></a><span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><a href="parse_func.c.html#LN1989"><span class='Ref_To_Local'>t</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN1970"><span class='Ref_to_Parameter'>noError</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_func.c.html#LN1975"><span class='Ref_To_Local'>args_item</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1975"><span class='Ref_To_Local'>args_item</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="../../include/parser/parse_func.h.html#LN62"><span class='Ref_to_Proto'>LookupFuncName</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN1970"><span class='Ref_to_Parameter'>func</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1851"><span class='Ref_to_Member'>objname</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN1970"><span class='Ref_to_Parameter'>func</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1853"><span class='Ref_to_Member'>args_unspecified</span></a> <span class='Operator'>? -</span><span class='Number'>1</span> <span class='Operator'>: </span><a href="parse_func.c.html#LN1973"><span class='Ref_To_Local'>argcount</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN1972"><span class='Ref_To_Local'>argoids</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN1970"><span class='Ref_to_Parameter'>noError</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end LookupFuncWithArgs &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * LookupAggWithArgs 
 *      Find an aggregate function from a given ObjectWithArgs node. 
 * 
 * This is almost like LookupFuncWithArgs, but the error messages refer 
 * to aggregates rather than plain functions, and we verify that the found 
 * function really is an aggregate. 
 */ 
</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> 
<a name="LN2007"></a><span class='Declare_Function'>LookupAggWithArgs</span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1848"><span class='Ref_to_Struct'>ObjectWithArgs</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>agg</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>noError</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2009"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>argoids</span><span class='Delimiter'>[</span><a href="../../include/pg_config_manual.h.html#LN36"><span class='Ref_to_Const'>FUNC_MAX_ARGS</span></a><span class='Delimiter'>]; 
</span><a name="LN2010"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>argcount</span><span class='Delimiter'>; 
</span><a name="LN2011"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN2012"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span><a name="LN2013"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>oid</span><span class='Delimiter'>; 
</span><a name="LN2014"></a>    <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>ftup</span><span class='Delimiter'>; 
</span><a name="LN2015"></a>    <a href="../../include/catalog/pg_proc.h.html#LN82"><span class='Ref_to_Typedef'>Form_pg_proc</span></a> <span class='Declare_Local'>pform</span><span class='Delimiter'>; 
</span> 
    <a href="parse_func.c.html#LN2010"><span class='Ref_To_Local'>argcount</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN2007"><span class='Ref_to_Parameter'>agg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1852"><span class='Ref_to_Member'>objargs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN2010"><span class='Ref_To_Local'>argcount</span></a> <span class='Operator'>&GT; </span><a href="../../include/pg_config_manual.h.html#LN36"><span class='Ref_to_Const'>FUNC_MAX_ARGS</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_TOO_MANY_ARGUMENTS<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN848"><span class='Ref_to_Func'>errmsg_plural</span></a><span class='Parentheses'>(</span><span class='String'>"functions cannot have more than %d argument"</span><span class='Delimiter'>, 
</span>                               <span class='String'>"functions cannot have more than %d arguments"</span><span class='Delimiter'>, 
</span>                               <a href="../../include/pg_config_manual.h.html#LN36"><span class='Ref_to_Const'>FUNC_MAX_ARGS</span></a><span class='Delimiter'>, 
</span>                               <a href="../../include/pg_config_manual.h.html#LN36"><span class='Ref_to_Const'>FUNC_MAX_ARGS</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <a href="parse_func.c.html#LN2011"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN2012"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN2007"><span class='Ref_to_Parameter'>agg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1852"><span class='Ref_to_Member'>objargs</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2029"></a>        <a href="../../include/nodes/parsenodes.h.html#LN205"><span class='Ref_to_Struct'>TypeName</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>t</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN205"><span class='Ref_to_Struct'>TypeName</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN2012"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="parse_func.c.html#LN2009"><span class='Ref_To_Local'>argoids</span></a><span class='Delimiter'>[</span><a href="parse_func.c.html#LN2011"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/parser/parse_type.h.html#LN23"><span class='Ref_to_Proto'>LookupTypeNameOid</span></a><span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><a href="parse_func.c.html#LN2029"><span class='Ref_To_Local'>t</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN2007"><span class='Ref_to_Parameter'>noError</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_func.c.html#LN2011"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="parse_func.c.html#LN2013"><span class='Ref_To_Local'>oid</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_func.h.html#LN62"><span class='Ref_to_Proto'>LookupFuncName</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN2007"><span class='Ref_to_Parameter'>agg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1851"><span class='Ref_to_Member'>objname</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN2010"><span class='Ref_To_Local'>argcount</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN2009"><span class='Ref_To_Local'>argoids</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN2013"><span class='Ref_To_Local'>oid</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN2007"><span class='Ref_to_Parameter'>noError</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN2010"><span class='Ref_To_Local'>argcount</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_UNDEFINED_FUNCTION<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"aggregate %s(*) does not exist"</span><span class='Delimiter'>, 
</span>                            <a href="../../include/catalog/namespace.h.html#LN120"><span class='Ref_to_Proto'>NameListToString</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN2007"><span class='Ref_to_Parameter'>agg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1851"><span class='Ref_to_Member'>objname</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_UNDEFINED_FUNCTION<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"aggregate %s does not exist"</span><span class='Delimiter'>, 
</span>                            <a href="../../include/parser/parse_func.h.html#LN59"><span class='Ref_to_Proto'>func_signature_string</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN2007"><span class='Ref_to_Parameter'>agg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1851"><span class='Ref_to_Member'>objname</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN2010"><span class='Ref_To_Local'>argcount</span></a><span class='Delimiter'>, 
</span>                                                  <a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN2009"><span class='Ref_To_Local'>argoids</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Make sure it's an aggregate */ 
</span>    <a href="parse_func.c.html#LN2014"><span class='Ref_To_Local'>ftup</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN155"><span class='Ref_to_Macro'>SearchSysCache1</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN76"><span class='Ref_to_EnumConst'>PROCOID</span></a><span class='Delimiter'>, </span><a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN2013"><span class='Ref_To_Local'>oid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN2014"><span class='Ref_To_Local'>ftup</span></a><span class='Parentheses'>))</span>    <span class='Comment_Single_Line'>/* should not happen */ 
</span>        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for function %u"</span><span class='Delimiter'>, </span><a href="parse_func.c.html#LN2013"><span class='Ref_To_Local'>oid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="parse_func.c.html#LN2015"><span class='Ref_To_Local'>pform</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_proc.h.html#LN82"><span class='Ref_to_Typedef'>Form_pg_proc</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN2014"><span class='Ref_To_Local'>ftup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_func.c.html#LN2015"><span class='Ref_To_Local'>pform</span></a><span class='Operator'>-&GT;</span>proisagg<span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN2014"><span class='Ref_To_Local'>ftup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN2007"><span class='Ref_to_Parameter'>noError</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* we do not use the (*) notation for functions... */ 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_WRONG_OBJECT_TYPE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"function %s is not an aggregate"</span><span class='Delimiter'>, 
</span>                        <a href="../../include/parser/parse_func.h.html#LN59"><span class='Ref_to_Proto'>func_signature_string</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN2007"><span class='Ref_to_Parameter'>agg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1851"><span class='Ref_to_Member'>objname</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN2010"><span class='Ref_To_Local'>argcount</span></a><span class='Delimiter'>, 
</span>                                              <a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN2009"><span class='Ref_To_Local'>argoids</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN2014"><span class='Ref_To_Local'>ftup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="parse_func.c.html#LN2013"><span class='Ref_To_Local'>oid</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end LookupAggWithArgs &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * check_srf_call_placement 
 *      Verify that a set-returning function is called in a valid place, 
 *      and throw a nice error if not. 
 * 
 * A side-effect is to set pstate-&GT;p_hasTargetSRFs true if appropriate. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2087"></a><span class='Declare_Function'>check_srf_call_placement</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>location</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2089"></a>    <span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Local'>err</span><span class='Delimiter'>; 
</span><a name="LN2090"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>errkind</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Check to see if the set-returning function is in an invalid place 
     * within the query.  Basically, we don't allow SRFs anywhere except in 
     * the targetlist (which includes GROUP BY/ORDER BY expressions), VALUES, 
     * and functions in FROM. 
     * 
     * For brevity we support two schemes for reporting an error here: set 
     * "err" to a custom message, or set "errkind" true if the error context 
     * is sufficiently identified by what ParseExprKindName will return, *and* 
     * what it will return is just a SQL keyword.  (Otherwise, use a custom 
     * message to avoid creating translation problems.) 
     */ 
</span>    <a href="parse_func.c.html#LN2089"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="parse_func.c.html#LN2090"><span class='Ref_To_Local'>errkind</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN2087"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN182"><span class='Ref_to_Member'>p_expr_kind</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN34"><span class='Ref_to_EnumConst'>EXPR_KIND_NONE</span></a><span class='Operator'>: 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* can't happen */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN35"><span class='Ref_to_EnumConst'>EXPR_KIND_OTHER</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* Accept SRF here; caller must throw error if wanted */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN36"><span class='Ref_to_EnumConst'>EXPR_KIND_JOIN_ON</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN37"><span class='Ref_to_EnumConst'>EXPR_KIND_JOIN_USING</span></a><span class='Operator'>: 
</span>            <a href="parse_func.c.html#LN2089"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"set-returning functions are not allowed in JOIN conditions"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN38"><span class='Ref_to_EnumConst'>EXPR_KIND_FROM_SUBSELECT</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* can't get here, but just in case, throw an error */ 
</span>            <a href="parse_func.c.html#LN2090"><span class='Ref_To_Local'>errkind</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN39"><span class='Ref_to_EnumConst'>EXPR_KIND_FROM_FUNCTION</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* okay ... but we can't check nesting here */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN40"><span class='Ref_to_EnumConst'>EXPR_KIND_WHERE</span></a><span class='Operator'>: 
</span>            <a href="parse_func.c.html#LN2090"><span class='Ref_To_Local'>errkind</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN68"><span class='Ref_to_EnumConst'>EXPR_KIND_POLICY</span></a><span class='Operator'>: 
</span>            <a href="parse_func.c.html#LN2089"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"set-returning functions are not allowed in policy expressions"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN41"><span class='Ref_to_EnumConst'>EXPR_KIND_HAVING</span></a><span class='Operator'>: 
</span>            <a href="parse_func.c.html#LN2090"><span class='Ref_To_Local'>errkind</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN42"><span class='Ref_to_EnumConst'>EXPR_KIND_FILTER</span></a><span class='Operator'>: 
</span>            <a href="parse_func.c.html#LN2090"><span class='Ref_To_Local'>errkind</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN43"><span class='Ref_to_EnumConst'>EXPR_KIND_WINDOW_PARTITION</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN44"><span class='Ref_to_EnumConst'>EXPR_KIND_WINDOW_ORDER</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* okay, these are effectively GROUP BY/ORDER BY */ 
</span>            <a href="parse_func.c.html#LN2087"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN197"><span class='Ref_to_Member'>p_hasTargetSRFs</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN45"><span class='Ref_to_EnumConst'>EXPR_KIND_WINDOW_FRAME_RANGE</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN46"><span class='Ref_to_EnumConst'>EXPR_KIND_WINDOW_FRAME_ROWS</span></a><span class='Operator'>: 
</span>            <a href="parse_func.c.html#LN2089"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"set-returning functions are not allowed in window definitions"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN47"><span class='Ref_to_EnumConst'>EXPR_KIND_SELECT_TARGET</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN48"><span class='Ref_to_EnumConst'>EXPR_KIND_INSERT_TARGET</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* okay */ 
</span>            <a href="parse_func.c.html#LN2087"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN197"><span class='Ref_to_Member'>p_hasTargetSRFs</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN49"><span class='Ref_to_EnumConst'>EXPR_KIND_UPDATE_SOURCE</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN50"><span class='Ref_to_EnumConst'>EXPR_KIND_UPDATE_TARGET</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* disallowed because it would be ambiguous what to do */ 
</span>            <a href="parse_func.c.html#LN2090"><span class='Ref_To_Local'>errkind</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN51"><span class='Ref_to_EnumConst'>EXPR_KIND_GROUP_BY</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN52"><span class='Ref_to_EnumConst'>EXPR_KIND_ORDER_BY</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* okay */ 
</span>            <a href="parse_func.c.html#LN2087"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN197"><span class='Ref_to_Member'>p_hasTargetSRFs</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN53"><span class='Ref_to_EnumConst'>EXPR_KIND_DISTINCT_ON</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* okay */ 
</span>            <a href="parse_func.c.html#LN2087"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN197"><span class='Ref_to_Member'>p_hasTargetSRFs</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN54"><span class='Ref_to_EnumConst'>EXPR_KIND_LIMIT</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN55"><span class='Ref_to_EnumConst'>EXPR_KIND_OFFSET</span></a><span class='Operator'>: 
</span>            <a href="parse_func.c.html#LN2090"><span class='Ref_To_Local'>errkind</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN56"><span class='Ref_to_EnumConst'>EXPR_KIND_RETURNING</span></a><span class='Operator'>: 
</span>            <a href="parse_func.c.html#LN2090"><span class='Ref_To_Local'>errkind</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN57"><span class='Ref_to_EnumConst'>EXPR_KIND_VALUES</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* SRFs are presently not supported by nodeValuesscan.c */ 
</span>            <a href="parse_func.c.html#LN2090"><span class='Ref_To_Local'>errkind</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN58"><span class='Ref_to_EnumConst'>EXPR_KIND_VALUES_SINGLE</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* okay, since we process this like a SELECT tlist */ 
</span>            <a href="parse_func.c.html#LN2087"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN197"><span class='Ref_to_Member'>p_hasTargetSRFs</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN59"><span class='Ref_to_EnumConst'>EXPR_KIND_CHECK_CONSTRAINT</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN60"><span class='Ref_to_EnumConst'>EXPR_KIND_DOMAIN_CHECK</span></a><span class='Operator'>: 
</span>            <a href="parse_func.c.html#LN2089"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"set-returning functions are not allowed in check constraints"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN61"><span class='Ref_to_EnumConst'>EXPR_KIND_COLUMN_DEFAULT</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN62"><span class='Ref_to_EnumConst'>EXPR_KIND_FUNCTION_DEFAULT</span></a><span class='Operator'>: 
</span>            <a href="parse_func.c.html#LN2089"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"set-returning functions are not allowed in DEFAULT expressions"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN63"><span class='Ref_to_EnumConst'>EXPR_KIND_INDEX_EXPRESSION</span></a><span class='Operator'>: 
</span>            <a href="parse_func.c.html#LN2089"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"set-returning functions are not allowed in index expressions"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN64"><span class='Ref_to_EnumConst'>EXPR_KIND_INDEX_PREDICATE</span></a><span class='Operator'>: 
</span>            <a href="parse_func.c.html#LN2089"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"set-returning functions are not allowed in index predicates"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN65"><span class='Ref_to_EnumConst'>EXPR_KIND_ALTER_COL_TRANSFORM</span></a><span class='Operator'>: 
</span>            <a href="parse_func.c.html#LN2089"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"set-returning functions are not allowed in transform expressions"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN66"><span class='Ref_to_EnumConst'>EXPR_KIND_EXECUTE_PARAMETER</span></a><span class='Operator'>: 
</span>            <a href="parse_func.c.html#LN2089"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"set-returning functions are not allowed in EXECUTE parameters"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN67"><span class='Ref_to_EnumConst'>EXPR_KIND_TRIGGER_WHEN</span></a><span class='Operator'>: 
</span>            <a href="parse_func.c.html#LN2089"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"set-returning functions are not allowed in trigger WHEN conditions"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/parser/parse_node.h.html#LN69"><span class='Ref_to_EnumConst'>EXPR_KIND_PARTITION_EXPRESSION</span></a><span class='Operator'>: 
</span>            <a href="parse_func.c.html#LN2089"><span class='Ref_To_Local'>err</span></a> <span class='Operator'>= </span>_<span class='Parentheses'>(</span><span class='String'>"set-returning functions are not allowed in partition key expression"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * There is intentionally no default: case here, so that the 
             * compiler will warn if we add a new ParseExprKind without 
             * extending this switch.  If we do see an unrecognized value at 
             * runtime, the behavior will be the same as for EXPR_KIND_OTHER, 
             * which is sane anyway. 
             */ 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch pstate-&GT;p_expr_kind &raquo; </span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN2089"><span class='Ref_To_Local'>err</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN825"><span class='Ref_to_Func'>errmsg_internal</span></a><span class='Parentheses'>(</span><span class='String'>"%s"</span><span class='Delimiter'>, </span><a href="parse_func.c.html#LN2089"><span class='Ref_To_Local'>err</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN2087"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN2087"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_func.c.html#LN2090"><span class='Ref_To_Local'>errkind</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>        <span class='Comment_Multi_Line'>/* translator: %s is name of a SQL construct, eg GROUP BY */ 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"set-returning functions are not allowed in %s"</span><span class='Delimiter'>, 
</span>                        <a href="../../include/parser/parse_expr.h.html#LN23"><span class='Ref_to_Proto'>ParseExprKindName</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN2087"><span class='Ref_to_Parameter'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN182"><span class='Ref_to_Member'>p_expr_kind</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                 <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_func.c.html#LN2087"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_func.c.html#LN2087"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end check_srf_call_placement &raquo; </span> 
</pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>