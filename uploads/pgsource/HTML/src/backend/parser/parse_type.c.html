<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\parser\parse_type.c</title>
<LINK REL=StyleSheet HREF="../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\parser\parse_type.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:45 2017
</td></tr>
<tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * parse_type.c 
 *      handle type operations for parser 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * 
 * IDENTIFICATION 
 *    src/backend/parser/parse_type.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/htup_details.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/namespace.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_type.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"lib/stringinfo.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/makefuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parser.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_type.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/array.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/builtins.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/lsyscache.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/syscache.h"</span> 
 
 
<a name="LN29"></a><span class='Keyword'>static </span><a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a> <span class='Declare_Prototype'>typenameTypeMod</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="../../include/nodes/parsenodes.h.html#LN205"><span class='Ref_to_Struct'>TypeName</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>typeName</span><span class='Delimiter'>, 
</span><a name="LN30"></a>                <a href="../../include/parser/parse_type.h.html#LN19"><span class='Ref_to_Typedef'>Type</span></a> <span class='Declare_Parameter'>typ</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * LookupTypeName 
 *      Given a TypeName object, lookup the pg_type syscache entry of the type. 
 *      Returns NULL if no such type can be found.  If the type is found, 
 *      the typmod value represented in the TypeName struct is computed and 
 *      stored into *typmod_p. 
 * 
 * NB: on success, the caller must ReleaseSysCache the type tuple when done 
 * with it. 
 * 
 * NB: direct callers of this function MUST check typisdefined before assuming 
 * that the type is fully valid.  Most code should go through typenameType 
 * or typenameTypeId instead. 
 * 
 * typmod_p can be passed as NULL if the caller does not care to know the 
 * typmod value, but the typmod decoration (if any) will be validated anyway, 
 * except in the case where the type is not found.  Note that if the type is 
 * found but is a shell, and there is typmod decoration, an error will be 
 * thrown --- this is intentional. 
 * 
 * pstate is only used for error location info, and may be NULL. 
 */ 
</span><a href="../../include/parser/parse_type.h.html#LN19"><span class='Ref_to_Typedef'>Type</span></a> 
<a name="LN56"></a><span class='Declare_Function'>LookupTypeName</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="../../include/nodes/parsenodes.h.html#LN205"><span class='Ref_to_Struct'>TypeName</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>typeName</span><span class='Delimiter'>, 
</span><a name="LN57"></a>               <a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>typmod_p</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>missing_ok</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN59"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>typoid</span><span class='Delimiter'>; 
</span><a name="LN60"></a>    <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>tup</span><span class='Delimiter'>; 
</span><a name="LN61"></a>    <a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>typmod</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_type.c.html#LN56"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN208"><span class='Ref_to_Member'>names</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* We have the OID already if it's an internally generated TypeName */ 
</span>        <a href="parse_type.c.html#LN59"><span class='Ref_To_Local'>typoid</span></a> <span class='Operator'>= </span><a href="parse_type.c.html#LN56"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN209"><span class='Ref_to_Member'>typeOid</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_type.c.html#LN56"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN211"><span class='Ref_to_Member'>pct_type</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Handle %TYPE reference to type of an existing field */ 
</span><a name="LN71"></a>        <a href="../../include/nodes/primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>rel</span> <span class='Operator'>= </span><a href="../../include/nodes/makefuncs.h.html#LN68"><span class='Ref_to_Proto'>makeRangeVar</span></a><span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><a href="parse_type.c.html#LN56"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN215"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN72"></a>        <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>field</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN73"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>relid</span><span class='Delimiter'>; 
</span><a name="LN74"></a>        <a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a>  <span class='Declare_Local'>attnum</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* deconstruct the name list */ 
</span>        <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN56"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN208"><span class='Ref_to_Member'>names</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>case</span> <span class='Number'>1</span><span class='Operator'>: 
</span>                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_SYNTAX_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"improper %%TYPE reference (too few dotted names): %s"</span><span class='Delimiter'>, 
</span>                       <a href="../../include/catalog/namespace.h.html#LN120"><span class='Ref_to_Proto'>NameListToString</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN56"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN208"><span class='Ref_to_Member'>names</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                         <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN56"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN56"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN215"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <span class='Number'>2</span><span class='Operator'>: 
</span>                <a href="parse_type.c.html#LN71"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN67"><span class='Ref_to_Member'>relname</span></a> <span class='Operator'>= </span><a href="../../include/nodes/value.h.html#LN53"><span class='Ref_to_Macro'>strVal</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN56"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN208"><span class='Ref_to_Member'>names</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <a href="parse_type.c.html#LN72"><span class='Ref_To_Local'>field</span></a> <span class='Operator'>= </span><a href="../../include/nodes/value.h.html#LN53"><span class='Ref_to_Macro'>strVal</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN115"><span class='Ref_to_Macro'>lsecond</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN56"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN208"><span class='Ref_to_Member'>names</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <span class='Number'>3</span><span class='Operator'>: 
</span>                <a href="parse_type.c.html#LN71"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN66"><span class='Ref_to_Member'>schemaname</span></a> <span class='Operator'>= </span><a href="../../include/nodes/value.h.html#LN53"><span class='Ref_to_Macro'>strVal</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN56"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN208"><span class='Ref_to_Member'>names</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <a href="parse_type.c.html#LN71"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN67"><span class='Ref_to_Member'>relname</span></a> <span class='Operator'>= </span><a href="../../include/nodes/value.h.html#LN53"><span class='Ref_to_Macro'>strVal</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN115"><span class='Ref_to_Macro'>lsecond</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN56"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN208"><span class='Ref_to_Member'>names</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <a href="parse_type.c.html#LN72"><span class='Ref_To_Local'>field</span></a> <span class='Operator'>= </span><a href="../../include/nodes/value.h.html#LN53"><span class='Ref_to_Macro'>strVal</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN120"><span class='Ref_to_Macro'>lthird</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN56"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN208"><span class='Ref_to_Member'>names</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <span class='Number'>4</span><span class='Operator'>: 
</span>                <a href="parse_type.c.html#LN71"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN65"><span class='Ref_to_Member'>catalogname</span></a> <span class='Operator'>= </span><a href="../../include/nodes/value.h.html#LN53"><span class='Ref_to_Macro'>strVal</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN56"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN208"><span class='Ref_to_Member'>names</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <a href="parse_type.c.html#LN71"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN66"><span class='Ref_to_Member'>schemaname</span></a> <span class='Operator'>= </span><a href="../../include/nodes/value.h.html#LN53"><span class='Ref_to_Macro'>strVal</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN115"><span class='Ref_to_Macro'>lsecond</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN56"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN208"><span class='Ref_to_Member'>names</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <a href="parse_type.c.html#LN71"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN67"><span class='Ref_to_Member'>relname</span></a> <span class='Operator'>= </span><a href="../../include/nodes/value.h.html#LN53"><span class='Ref_to_Macro'>strVal</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN120"><span class='Ref_to_Macro'>lthird</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN56"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN208"><span class='Ref_to_Member'>names</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <a href="parse_type.c.html#LN72"><span class='Ref_To_Local'>field</span></a> <span class='Operator'>= </span><a href="../../include/nodes/value.h.html#LN53"><span class='Ref_to_Macro'>strVal</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN125"><span class='Ref_to_Macro'>lfourth</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN56"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN208"><span class='Ref_to_Member'>names</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>default</span><span class='Operator'>: 
</span>                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_SYNTAX_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"improper %%TYPE reference (too many dotted names): %s"</span><span class='Delimiter'>, 
</span>                                <a href="../../include/catalog/namespace.h.html#LN120"><span class='Ref_to_Proto'>NameListToString</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN56"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN208"><span class='Ref_to_Member'>names</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                         <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN56"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN56"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN215"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch list_length(typeName-... &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* 
         * Look up the field. 
         * 
         * XXX: As no lock is taken here, this might fail in the presence of 
         * concurrent DDL.  But taking a lock would carry a performance 
         * penalty and would also require a permissions check. 
         */ 
</span>        <a href="parse_type.c.html#LN73"><span class='Ref_To_Local'>relid</span></a> <span class='Operator'>= </span><a href="../../include/catalog/namespace.h.html#LN52"><span class='Ref_to_Macro'>RangeVarGetRelid</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN71"><span class='Ref_To_Local'>rel</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN33"><span class='Ref_to_Const'>NoLock</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN57"><span class='Ref_to_Parameter'>missing_ok</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_type.c.html#LN74"><span class='Ref_To_Local'>attnum</span></a> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN87"><span class='Ref_to_Proto'>get_attnum</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN73"><span class='Ref_To_Local'>relid</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN72"><span class='Ref_To_Local'>field</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_type.c.html#LN74"><span class='Ref_To_Local'>attnum</span></a> <span class='Operator'>== </span><a href="../../include/access/attnum.h.html#LN22"><span class='Ref_to_Const'>InvalidAttrNumber</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_type.c.html#LN57"><span class='Ref_to_Parameter'>missing_ok</span></a><span class='Parentheses'>) 
</span>                <a href="parse_type.c.html#LN59"><span class='Ref_To_Local'>typoid</span></a> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_UNDEFINED_COLUMN<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                    <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"column \"%s\" of relation \"%s\" does not exist"</span><span class='Delimiter'>, 
</span>                           <a href="parse_type.c.html#LN72"><span class='Ref_To_Local'>field</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN71"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN67"><span class='Ref_to_Member'>relname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN56"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN56"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN215"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="parse_type.c.html#LN59"><span class='Ref_To_Local'>typoid</span></a> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN89"><span class='Ref_to_Proto'>get_atttype</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN73"><span class='Ref_To_Local'>relid</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN74"><span class='Ref_To_Local'>attnum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* this construct should never have an array indicator */ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="parse_type.c.html#LN56"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN214"><span class='Ref_to_Member'>arrayBounds</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* emit nuisance notice (intentionally not errposition'd) */ 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN36"><span class='Ref_to_Const'>NOTICE</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"type reference %s converted to %s"</span><span class='Delimiter'>, 
</span>                            <a href="../../include/parser/parse_type.h.html#LN31"><span class='Ref_to_Proto'>TypeNameToString</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN56"><span class='Ref_to_Parameter'>typeName</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                            <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN59"><span class='Ref_To_Local'>typoid</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if typeName-&GT;pct_type &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Normal reference to a type name */ 
</span><a name="LN147"></a>        <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>schemaname</span><span class='Delimiter'>; 
</span><a name="LN148"></a>        <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>typname</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* deconstruct the name list */ 
</span>        <a href="../../include/catalog/namespace.h.html#LN109"><span class='Ref_to_Proto'>DeconstructQualifiedName</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN56"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN208"><span class='Ref_to_Member'>names</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_type.c.html#LN147"><span class='Ref_To_Local'>schemaname</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_type.c.html#LN148"><span class='Ref_To_Local'>typname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_type.c.html#LN147"><span class='Ref_To_Local'>schemaname</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Look in specific schema only */ 
</span><a name="LN156"></a>            <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>namespaceId</span><span class='Delimiter'>; 
</span><a name="LN157"></a>            <a href="../../include/parser/parse_node.h.html#LN249"><span class='Ref_to_Struct'>ParseCallbackState</span></a> <span class='Declare_Local'>pcbstate</span><span class='Delimiter'>; 
</span> 
            <a href="parse_node.c.html#LN143"><span class='Ref_to_Func'>setup_parser_errposition_callback</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="parse_type.c.html#LN157"><span class='Ref_To_Local'>pcbstate</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN56"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN56"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN215"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="parse_type.c.html#LN156"><span class='Ref_To_Local'>namespaceId</span></a> <span class='Operator'>= </span><a href="../../include/catalog/namespace.h.html#LN113"><span class='Ref_to_Proto'>LookupExplicitNamespace</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN147"><span class='Ref_To_Local'>schemaname</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN57"><span class='Ref_to_Parameter'>missing_ok</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN156"><span class='Ref_To_Local'>namespaceId</span></a><span class='Parentheses'>))</span> 
                <a href="parse_type.c.html#LN59"><span class='Ref_To_Local'>typoid</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN184"><span class='Ref_to_Macro'>GetSysCacheOid2</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN106"><span class='Ref_to_EnumConst'>TYPENAMENSP</span></a><span class='Delimiter'>, 
</span>                                         <a href="../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN148"><span class='Ref_To_Local'>typname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                         <a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN156"><span class='Ref_To_Local'>namespaceId</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="parse_type.c.html#LN59"><span class='Ref_To_Local'>typoid</span></a> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span> 
            <a href="parse_node.c.html#LN159"><span class='Ref_to_Func'>cancel_parser_errposition_callback</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="parse_type.c.html#LN157"><span class='Ref_To_Local'>pcbstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Unqualified type name, so search the search path */ 
</span>            <a href="parse_type.c.html#LN59"><span class='Ref_To_Local'>typoid</span></a> <span class='Operator'>= </span><a href="../../include/catalog/namespace.h.html#LN67"><span class='Ref_to_Proto'>TypenameGetTypid</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN148"><span class='Ref_To_Local'>typname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* If an array reference, return the array type instead */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_type.c.html#LN56"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN214"><span class='Ref_to_Member'>arrayBounds</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>            <a href="parse_type.c.html#LN59"><span class='Ref_To_Local'>typoid</span></a> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN158"><span class='Ref_to_Proto'>get_array_type</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN59"><span class='Ref_To_Local'>typoid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN59"><span class='Ref_To_Local'>typoid</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_type.c.html#LN57"><span class='Ref_to_Parameter'>typmod_p</span></a><span class='Parentheses'>) 
</span>            <span class='Operator'>*</span><a href="parse_type.c.html#LN57"><span class='Ref_to_Parameter'>typmod_p</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="parse_type.c.html#LN60"><span class='Ref_To_Local'>tup</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN155"><span class='Ref_to_Macro'>SearchSysCache1</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN107"><span class='Ref_to_EnumConst'>TYPEOID</span></a><span class='Delimiter'>, </span><a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN59"><span class='Ref_To_Local'>typoid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN60"><span class='Ref_To_Local'>tup</span></a><span class='Parentheses'>))</span> <span class='Comment_Single_Line'>/* should not happen */ 
</span>        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for type %u"</span><span class='Delimiter'>, </span><a href="parse_type.c.html#LN59"><span class='Ref_To_Local'>typoid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="parse_type.c.html#LN61"><span class='Ref_To_Local'>typmod</span></a> <span class='Operator'>= </span><a href="parse_type.c.html#LN29"><span class='Ref_to_Proto'>typenameTypeMod</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN56"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN56"><span class='Ref_to_Parameter'>typeName</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/parser/parse_type.h.html#LN19"><span class='Ref_to_Typedef'>Type</span></a><span class='Parentheses'>) </span><a href="parse_type.c.html#LN60"><span class='Ref_To_Local'>tup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_type.c.html#LN57"><span class='Ref_to_Parameter'>typmod_p</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>*</span><a href="parse_type.c.html#LN57"><span class='Ref_to_Parameter'>typmod_p</span></a> <span class='Operator'>= </span><a href="parse_type.c.html#LN61"><span class='Ref_To_Local'>typmod</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../include/parser/parse_type.h.html#LN19"><span class='Ref_to_Typedef'>Type</span></a><span class='Parentheses'>) </span><a href="parse_type.c.html#LN60"><span class='Ref_To_Local'>tup</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end LookupTypeName &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * LookupTypeNameOid 
 *      Given a TypeName object, lookup the pg_type syscache entry of the type. 
 *      Returns InvalidOid if no such type can be found.  If the type is found, 
 *      return its Oid. 
 * 
 * NB: direct callers of this function need to be aware that the type OID 
 * returned may correspond to a shell type.  Most code should go through 
 * typenameTypeId instead. 
 * 
 * pstate is only used for error location info, and may be NULL. 
 */ 
</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> 
<a name="LN214"></a><span class='Declare_Function'>LookupTypeNameOid</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="../../include/nodes/parsenodes.h.html#LN205"><span class='Ref_to_Struct'>TypeName</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>typeName</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>missing_ok</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN216"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>typoid</span><span class='Delimiter'>; 
</span><a name="LN217"></a>    <a href="../../include/parser/parse_type.h.html#LN19"><span class='Ref_to_Typedef'>Type</span></a>        <span class='Declare_Local'>tup</span><span class='Delimiter'>; 
</span> 
    <a href="parse_type.c.html#LN217"><span class='Ref_To_Local'>tup</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_type.h.html#LN21"><span class='Ref_to_Proto'>LookupTypeName</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN214"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN214"><span class='Ref_to_Parameter'>typeName</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><a href="parse_type.c.html#LN214"><span class='Ref_to_Parameter'>missing_ok</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_type.c.html#LN217"><span class='Ref_To_Local'>tup</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_type.c.html#LN214"><span class='Ref_to_Parameter'>missing_ok</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_UNDEFINED_OBJECT<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"type \"%s\" does not exist"</span><span class='Delimiter'>, 
</span>                            <a href="../../include/parser/parse_type.h.html#LN31"><span class='Ref_to_Proto'>TypeNameToString</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN214"><span class='Ref_to_Parameter'>typeName</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN214"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN214"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN215"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>return</span> <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="parse_type.c.html#LN216"><span class='Ref_To_Local'>typoid</span></a> <span class='Operator'>= </span><a href="../../include/access/htup_details.h.html#LN694"><span class='Ref_to_Macro'>HeapTupleGetOid</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN217"><span class='Ref_To_Local'>tup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN217"><span class='Ref_To_Local'>tup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="parse_type.c.html#LN216"><span class='Ref_To_Local'>typoid</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end LookupTypeNameOid &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * typenameType - given a TypeName, return a Type structure and typmod 
 * 
 * This is equivalent to LookupTypeName, except that this will report 
 * a suitable error message if the type cannot be found or is not defined. 
 * Callers of this can therefore assume the result is a fully valid type. 
 */ 
</span><a href="../../include/parser/parse_type.h.html#LN19"><span class='Ref_to_Typedef'>Type</span></a> 
<a name="LN246"></a><span class='Declare_Function'>typenameType</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="../../include/nodes/parsenodes.h.html#LN205"><span class='Ref_to_Struct'>TypeName</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>typeName</span><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>typmod_p</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN248"></a>    <a href="../../include/parser/parse_type.h.html#LN19"><span class='Ref_to_Typedef'>Type</span></a>        <span class='Declare_Local'>tup</span><span class='Delimiter'>; 
</span> 
    <a href="parse_type.c.html#LN248"><span class='Ref_To_Local'>tup</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_type.h.html#LN21"><span class='Ref_to_Proto'>LookupTypeName</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN246"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN246"><span class='Ref_to_Parameter'>typeName</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN246"><span class='Ref_to_Parameter'>typmod_p</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_type.c.html#LN248"><span class='Ref_To_Local'>tup</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_UNDEFINED_OBJECT<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"type \"%s\" does not exist"</span><span class='Delimiter'>, 
</span>                        <a href="../../include/parser/parse_type.h.html#LN31"><span class='Ref_to_Proto'>TypeNameToString</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN246"><span class='Ref_to_Parameter'>typeName</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                 <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN246"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN246"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN215"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>((</span><a href="../../include/catalog/pg_type.h.html#LN232"><span class='Ref_to_Typedef'>Form_pg_type</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN248"><span class='Ref_To_Local'>tup</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>typisdefined<span class='Parentheses'>)</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_UNDEFINED_OBJECT<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"type \"%s\" is only a shell"</span><span class='Delimiter'>, 
</span>                        <a href="../../include/parser/parse_type.h.html#LN31"><span class='Ref_to_Proto'>TypeNameToString</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN246"><span class='Ref_to_Parameter'>typeName</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                 <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN246"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN246"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN215"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="parse_type.c.html#LN248"><span class='Ref_To_Local'>tup</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end typenameType &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * typenameTypeId - given a TypeName, return the type's OID 
 * 
 * This is similar to typenameType, but we only hand back the type OID 
 * not the syscache entry. 
 */ 
</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> 
<a name="LN273"></a><span class='Declare_Function'>typenameTypeId</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="../../include/nodes/parsenodes.h.html#LN205"><span class='Ref_to_Struct'>TypeName</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>typeName</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN275"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>typoid</span><span class='Delimiter'>; 
</span><a name="LN276"></a>    <a href="../../include/parser/parse_type.h.html#LN19"><span class='Ref_to_Typedef'>Type</span></a>        <span class='Declare_Local'>tup</span><span class='Delimiter'>; 
</span> 
    <a href="parse_type.c.html#LN276"><span class='Ref_To_Local'>tup</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_type.h.html#LN25"><span class='Ref_to_Proto'>typenameType</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN273"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN273"><span class='Ref_to_Parameter'>typeName</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="parse_type.c.html#LN275"><span class='Ref_To_Local'>typoid</span></a> <span class='Operator'>= </span><a href="../../include/access/htup_details.h.html#LN694"><span class='Ref_to_Macro'>HeapTupleGetOid</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN276"><span class='Ref_To_Local'>tup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN276"><span class='Ref_To_Local'>tup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="parse_type.c.html#LN275"><span class='Ref_To_Local'>typoid</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * typenameTypeIdAndMod - given a TypeName, return the type's OID and typmod 
 * 
 * This is equivalent to typenameType, but we only hand back the type OID 
 * and typmod, not the syscache entry. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN292"></a><span class='Declare_Function'>typenameTypeIdAndMod</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="../../include/nodes/parsenodes.h.html#LN205"><span class='Ref_to_Struct'>TypeName</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>typeName</span><span class='Delimiter'>, 
</span><a name="LN293"></a>                     <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>typeid_p</span><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>typmod_p</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN295"></a>    <a href="../../include/parser/parse_type.h.html#LN19"><span class='Ref_to_Typedef'>Type</span></a>        <span class='Declare_Local'>tup</span><span class='Delimiter'>; 
</span> 
    <a href="parse_type.c.html#LN295"><span class='Ref_To_Local'>tup</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_type.h.html#LN25"><span class='Ref_to_Proto'>typenameType</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN292"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN292"><span class='Ref_to_Parameter'>typeName</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN293"><span class='Ref_to_Parameter'>typmod_p</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="parse_type.c.html#LN293"><span class='Ref_to_Parameter'>typeid_p</span></a> <span class='Operator'>= </span><a href="../../include/access/htup_details.h.html#LN694"><span class='Ref_to_Macro'>HeapTupleGetOid</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN295"><span class='Ref_To_Local'>tup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN295"><span class='Ref_To_Local'>tup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * typenameTypeMod - given a TypeName, return the internal typmod value 
 * 
 * This will throw an error if the TypeName includes type modifiers that are 
 * illegal for the data type. 
 * 
 * The actual type OID represented by the TypeName must already have been 
 * looked up, and is passed as "typ". 
 * 
 * pstate is only used for error location info, and may be NULL. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a> 
<a name="LN314"></a><span class='Declare_Function'>typenameTypeMod</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="../../include/nodes/parsenodes.h.html#LN205"><span class='Ref_to_Struct'>TypeName</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>typeName</span><span class='Delimiter'>, </span><a href="../../include/parser/parse_type.h.html#LN19"><span class='Ref_to_Typedef'>Type</span></a> <span class='Declare_Parameter'>typ</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN316"></a>    <a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span><a name="LN317"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>typmodin</span><span class='Delimiter'>; 
</span><a name="LN318"></a>    <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>datums</span><span class='Delimiter'>; 
</span><a name="LN319"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>n</span><span class='Delimiter'>; 
</span><a name="LN320"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span><a name="LN321"></a>    <a href="../../include/utils/array.h.html#LN75"><span class='Ref_to_Typedef'>ArrayType</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>arrtypmod</span><span class='Delimiter'>; 
</span><a name="LN322"></a>    <a href="../../include/parser/parse_node.h.html#LN249"><span class='Ref_to_Struct'>ParseCallbackState</span></a> <span class='Declare_Local'>pcbstate</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Return prespecified typmod if no typmod expressions */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_type.c.html#LN314"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN212"><span class='Ref_to_Member'>typmods</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="parse_type.c.html#LN314"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN213"><span class='Ref_to_Member'>typemod</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Else, type had better accept typmods.  We give a special error message 
     * for the shell-type case, since a shell couldn't possibly have a 
     * typmodin function. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>((</span><a href="../../include/catalog/pg_type.h.html#LN232"><span class='Ref_to_Typedef'>Form_pg_type</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN314"><span class='Ref_to_Parameter'>typ</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>typisdefined<span class='Parentheses'>)</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_SYNTAX_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>            <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"type modifier cannot be specified for shell type \"%s\""</span><span class='Delimiter'>, 
</span>                   <a href="../../include/parser/parse_type.h.html#LN31"><span class='Ref_to_Proto'>TypeNameToString</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN314"><span class='Ref_to_Parameter'>typeName</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                 <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN314"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN314"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN215"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <a href="parse_type.c.html#LN317"><span class='Ref_To_Local'>typmodin</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/catalog/pg_type.h.html#LN232"><span class='Ref_to_Typedef'>Form_pg_type</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN314"><span class='Ref_to_Parameter'>typ</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>typmodin<span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_type.c.html#LN317"><span class='Ref_To_Local'>typmodin</span></a> <span class='Operator'>== </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_SYNTAX_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"type modifier is not allowed for type \"%s\""</span><span class='Delimiter'>, 
</span>                        <a href="../../include/parser/parse_type.h.html#LN31"><span class='Ref_to_Proto'>TypeNameToString</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN314"><span class='Ref_to_Parameter'>typeName</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                 <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN314"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN314"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN215"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Convert the list of raw-grammar-output expressions to a cstring array. 
     * Currently, we allow simple numeric constants, string literals, and 
     * identifiers; possibly this list could be extended. 
     */ 
</span>    <a href="parse_type.c.html#LN318"><span class='Ref_To_Local'>datums</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN314"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN212"><span class='Ref_to_Member'>typmods</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="parse_type.c.html#LN319"><span class='Ref_To_Local'>n</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN320"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN314"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN212"><span class='Ref_to_Member'>typmods</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN358"></a>        <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>tm</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN320"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN359"></a>        <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>cstr</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN358"><span class='Ref_To_Local'>tm</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN284"><span class='Ref_to_Struct'>A_Const</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN363"></a>            <a href="../../include/nodes/parsenodes.h.html#LN284"><span class='Ref_to_Struct'>A_Const</span></a>    <span class='Operator'>*</span><span class='Declare_Local'>ac</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN284"><span class='Ref_to_Struct'>A_Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_type.c.html#LN358"><span class='Ref_To_Local'>tm</span></a><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="parse_type.c.html#LN363"><span class='Ref_To_Local'>ac</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN287"><span class='Ref_to_Member'>val</span></a><span class='Delimiter'>, </span>Integer<span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="parse_type.c.html#LN359"><span class='Ref_To_Local'>cstr</span></a> <span class='Operator'>= </span><a href="../../common/psprintf.c.html#LN44"><span class='Ref_to_Func'>psprintf</span></a><span class='Parentheses'>(</span><span class='String'>"%ld"</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>long</span><span class='Parentheses'>) </span><a href="parse_type.c.html#LN363"><span class='Ref_To_Local'>ac</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN287"><span class='Ref_to_Member'>val</span></a><span class='Operator'>.</span><a href="../../include/nodes/value.h.html#LN48"><span class='Ref_to_Member'>val</span></a><span class='Operator'>.</span>ival<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="parse_type.c.html#LN363"><span class='Ref_To_Local'>ac</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN287"><span class='Ref_to_Member'>val</span></a><span class='Delimiter'>, </span>Float<span class='Parentheses'>) </span><span class='Operator'>|| 
</span>                     <a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="parse_type.c.html#LN363"><span class='Ref_To_Local'>ac</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN287"><span class='Ref_to_Member'>val</span></a><span class='Delimiter'>, </span>String<span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* we can just use the str field directly. */ 
</span>                <a href="parse_type.c.html#LN359"><span class='Ref_To_Local'>cstr</span></a> <span class='Operator'>= </span><a href="parse_type.c.html#LN363"><span class='Ref_To_Local'>ac</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN287"><span class='Ref_to_Member'>val</span></a><span class='Operator'>.</span><a href="../../include/nodes/value.h.html#LN48"><span class='Ref_to_Member'>val</span></a><span class='Operator'>.</span>str<span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN358"><span class='Ref_To_Local'>tm</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN231"><span class='Ref_to_Struct'>ColumnRef</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN378"></a>            <a href="../../include/nodes/parsenodes.h.html#LN231"><span class='Ref_to_Struct'>ColumnRef</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>cr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN231"><span class='Ref_to_Struct'>ColumnRef</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_type.c.html#LN358"><span class='Ref_To_Local'>tm</span></a><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN378"><span class='Ref_To_Local'>cr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN234"><span class='Ref_to_Member'>fields</span></a><span class='Parentheses'>)</span> <span class='Operator'>== </span><span class='Number'>1</span> <span class='Operator'>&& 
</span>                <a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN378"><span class='Ref_To_Local'>cr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN234"><span class='Ref_to_Member'>fields</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span>String<span class='Parentheses'>))</span> 
                <a href="parse_type.c.html#LN359"><span class='Ref_To_Local'>cstr</span></a> <span class='Operator'>= </span><a href="../../include/nodes/value.h.html#LN53"><span class='Ref_to_Macro'>strVal</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN378"><span class='Ref_To_Local'>cr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN234"><span class='Ref_to_Member'>fields</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_type.c.html#LN359"><span class='Ref_To_Local'>cstr</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_SYNTAX_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>            <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"type modifiers must be simple constants or identifiers"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN314"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN314"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN215"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <a href="parse_type.c.html#LN318"><span class='Ref_To_Local'>datums</span></a><span class='Delimiter'>[</span><a href="parse_type.c.html#LN319"><span class='Ref_To_Local'>n</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/postgres.h.html#LN583"><span class='Ref_to_Macro'>CStringGetDatum</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN359"><span class='Ref_To_Local'>cstr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* hardwired knowledge about cstring's representation details here */ 
</span>    <a href="parse_type.c.html#LN321"><span class='Ref_To_Local'>arrtypmod</span></a> <span class='Operator'>= </span><a href="../../include/utils/array.h.html#LN369"><span class='Ref_to_Proto'>construct_array</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN318"><span class='Ref_To_Local'>datums</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN319"><span class='Ref_To_Local'>n</span></a><span class='Delimiter'>, </span><a href="../../include/catalog/pg_type.h.html#LN683"><span class='Ref_to_Const'>CSTRINGOID</span></a><span class='Delimiter'>, 
</span>                                <span class='Operator'>-</span><span class='Number'>2</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='String'>'c'</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* arrange to report location if type's typmodin function fails */ 
</span>    <a href="parse_node.c.html#LN143"><span class='Ref_to_Func'>setup_parser_errposition_callback</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="parse_type.c.html#LN322"><span class='Ref_To_Local'>pcbstate</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN314"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN314"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN215"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="parse_type.c.html#LN316"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/postgres.h.html#LN477"><span class='Ref_to_Macro'>DatumGetInt32</span></a><span class='Parentheses'>(</span><a href="../../include/fmgr.h.html#LN621"><span class='Ref_to_Macro'>OidFunctionCall1</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN317"><span class='Ref_To_Local'>typmodin</span></a><span class='Delimiter'>, 
</span>                                            <a href="../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN321"><span class='Ref_To_Local'>arrtypmod</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <a href="parse_node.c.html#LN159"><span class='Ref_to_Func'>cancel_parser_errposition_callback</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="parse_type.c.html#LN322"><span class='Ref_To_Local'>pcbstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN318"><span class='Ref_To_Local'>datums</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN321"><span class='Ref_To_Local'>arrtypmod</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="parse_type.c.html#LN316"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end typenameTypeMod &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * appendTypeNameToBuffer 
 *      Append a string representing the name of a TypeName to a StringInfo. 
 *      This is the shared guts of TypeNameToString and TypeNameListToString. 
 * 
 * NB: this must work on TypeNames that do not describe any actual type; 
 * it is mostly used for reporting lookup errors. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN419"></a><span class='Declare_Function'>appendTypeNameToBuffer</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../include/nodes/parsenodes.h.html#LN205"><span class='Ref_to_Struct'>TypeName</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>typeName</span><span class='Delimiter'>, </span><a href="../../include/lib/stringinfo.h.html#LN42"><span class='Ref_to_Typedef'>StringInfo</span></a> <span class='Declare_Parameter'>string</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_type.c.html#LN419"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN208"><span class='Ref_to_Member'>names</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Emit possibly-qualified name as-is */ 
</span><a name="LN424"></a>        <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN424"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN419"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN208"><span class='Ref_to_Member'>names</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_type.c.html#LN424"><span class='Ref_To_Local'>l</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN419"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN208"><span class='Ref_to_Member'>names</span></a><span class='Parentheses'>))</span> 
                <a href="../replication/syncrep_scanner.l.html#LN76"><span class='Ref_to_Proto'>appendStringInfoChar</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN419"><span class='Ref_to_Parameter'>string</span></a><span class='Delimiter'>, </span><span class='String'>'.'</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../bin/pg_waldump/compat.c.html#LN79"><span class='Ref_to_Func'>appendStringInfoString</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN419"><span class='Ref_to_Parameter'>string</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/value.h.html#LN53"><span class='Ref_to_Macro'>strVal</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN424"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Look up internally-specified type */ 
</span>        <a href="../../bin/pg_waldump/compat.c.html#LN79"><span class='Ref_to_Func'>appendStringInfoString</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN419"><span class='Ref_to_Parameter'>string</span></a><span class='Delimiter'>, </span><a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN419"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN209"><span class='Ref_to_Member'>typeOid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Add decoration as needed, but only for fields considered by 
     * LookupTypeName 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_type.c.html#LN419"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN211"><span class='Ref_to_Member'>pct_type</span></a><span class='Parentheses'>) 
</span>        <a href="../../bin/pg_waldump/compat.c.html#LN79"><span class='Ref_to_Func'>appendStringInfoString</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN419"><span class='Ref_to_Parameter'>string</span></a><span class='Delimiter'>, </span><span class='String'>"%TYPE"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_type.c.html#LN419"><span class='Ref_to_Parameter'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN214"><span class='Ref_to_Member'>arrayBounds</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <a href="../../bin/pg_waldump/compat.c.html#LN79"><span class='Ref_to_Func'>appendStringInfoString</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN419"><span class='Ref_to_Parameter'>string</span></a><span class='Delimiter'>, </span><span class='String'>"[]"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end appendTypeNameToBuffer &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * TypeNameToString 
 *      Produce a string representing the name of a TypeName. 
 * 
 * NB: this must work on TypeNames that do not describe any actual type; 
 * it is mostly used for reporting lookup errors. 
 */ 
</span><span class='Keyword'>char </span><span class='Operator'>* 
</span><a name="LN458"></a><span class='Declare_Function'>TypeNameToString</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../include/nodes/parsenodes.h.html#LN205"><span class='Ref_to_Struct'>TypeName</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>typeName</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN460"></a>    <a href="../../include/lib/stringinfo.h.html#LN34"><span class='Ref_to_Struct'>StringInfoData</span></a> <span class='Declare_Local'>string</span><span class='Delimiter'>; 
</span> 
    <a href="../lib/stringinfo.c.html#LN44"><span class='Ref_to_Func'>initStringInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="parse_type.c.html#LN460"><span class='Ref_To_Local'>string</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="parse_type.c.html#LN418"><span class='Ref_to_Func'>appendTypeNameToBuffer</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN458"><span class='Ref_to_Parameter'>typeName</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_type.c.html#LN460"><span class='Ref_To_Local'>string</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="parse_type.c.html#LN460"><span class='Ref_To_Local'>string</span></a><span class='Operator'>.</span><a href="../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * TypeNameListToString 
 *      Produce a string representing the name(s) of a List of TypeNames 
 */ 
</span><span class='Keyword'>char </span><span class='Operator'>* 
</span><a name="LN472"></a><span class='Declare_Function'>TypeNameListToString</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>typenames</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN474"></a>    <a href="../../include/lib/stringinfo.h.html#LN34"><span class='Ref_to_Struct'>StringInfoData</span></a> <span class='Declare_Local'>string</span><span class='Delimiter'>; 
</span><a name="LN475"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
    <a href="../lib/stringinfo.c.html#LN44"><span class='Ref_to_Func'>initStringInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="parse_type.c.html#LN474"><span class='Ref_To_Local'>string</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN475"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN472"><span class='Ref_to_Parameter'>typenames</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN480"></a>        <a href="../../include/nodes/parsenodes.h.html#LN205"><span class='Ref_to_Struct'>TypeName</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>typeName</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN108"><span class='Ref_to_Macro'>lfirst_node</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN205"><span class='Ref_to_Struct'>TypeName</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN475"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_type.c.html#LN475"><span class='Ref_To_Local'>l</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN472"><span class='Ref_to_Parameter'>typenames</span></a><span class='Parentheses'>))</span> 
            <a href="../replication/syncrep_scanner.l.html#LN76"><span class='Ref_to_Proto'>appendStringInfoChar</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="parse_type.c.html#LN474"><span class='Ref_To_Local'>string</span></a><span class='Delimiter'>, </span><span class='String'>','</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="parse_type.c.html#LN418"><span class='Ref_to_Func'>appendTypeNameToBuffer</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN480"><span class='Ref_To_Local'>typeName</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="parse_type.c.html#LN474"><span class='Ref_To_Local'>string</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <a href="parse_type.c.html#LN474"><span class='Ref_To_Local'>string</span></a><span class='Operator'>.</span><a href="../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * LookupCollation 
 * 
 * Look up collation by name, return OID, with support for error location. 
 */ 
</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> 
<a name="LN495"></a><span class='Declare_Function'>LookupCollation</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>collnames</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>location</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN497"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>colloid</span><span class='Delimiter'>; 
</span><a name="LN498"></a>    <a href="../../include/parser/parse_node.h.html#LN249"><span class='Ref_to_Struct'>ParseCallbackState</span></a> <span class='Declare_Local'>pcbstate</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_type.c.html#LN495"><span class='Ref_to_Parameter'>pstate</span></a><span class='Parentheses'>) 
</span>        <a href="parse_node.c.html#LN143"><span class='Ref_to_Func'>setup_parser_errposition_callback</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="parse_type.c.html#LN498"><span class='Ref_To_Local'>pcbstate</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN495"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN495"><span class='Ref_to_Parameter'>location</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="parse_type.c.html#LN497"><span class='Ref_To_Local'>colloid</span></a> <span class='Operator'>= </span><a href="../../include/catalog/namespace.h.html#LN142"><span class='Ref_to_Proto'>get_collation_oid</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN495"><span class='Ref_to_Parameter'>collnames</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_type.c.html#LN495"><span class='Ref_to_Parameter'>pstate</span></a><span class='Parentheses'>) 
</span>        <a href="parse_node.c.html#LN159"><span class='Ref_to_Func'>cancel_parser_errposition_callback</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="parse_type.c.html#LN498"><span class='Ref_To_Local'>pcbstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="parse_type.c.html#LN497"><span class='Ref_To_Local'>colloid</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * GetColumnDefCollation 
 * 
 * Get the collation to be used for a column being defined, given the 
 * ColumnDef node and the previously-determined column type OID. 
 * 
 * pstate is only used for error location purposes, and can be NULL. 
 */ 
</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> 
<a name="LN520"></a><span class='Declare_Function'>GetColumnDefCollation</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN636"><span class='Ref_to_Struct'>ColumnDef</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>coldef</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>typeOid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN522"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span><a name="LN523"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>typcollation</span> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN166"><span class='Ref_to_Proto'>get_typcollation</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN520"><span class='Ref_to_Parameter'>typeOid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN524"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>location</span> <span class='Operator'>= </span><a href="parse_type.c.html#LN520"><span class='Ref_to_Parameter'>coldef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN654"><span class='Ref_to_Member'>location</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_type.c.html#LN520"><span class='Ref_to_Parameter'>coldef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN650"><span class='Ref_to_Member'>collClause</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* We have a raw COLLATE clause, so look up the collation */ 
</span>        <a href="parse_type.c.html#LN524"><span class='Ref_To_Local'>location</span></a> <span class='Operator'>= </span><a href="parse_type.c.html#LN520"><span class='Ref_to_Parameter'>coldef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN650"><span class='Ref_to_Member'>collClause</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN310"><span class='Ref_to_Member'>location</span></a><span class='Delimiter'>; 
</span>        <a href="parse_type.c.html#LN522"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_type.h.html#LN34"><span class='Ref_to_Proto'>LookupCollation</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN520"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN520"><span class='Ref_to_Parameter'>coldef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN650"><span class='Ref_to_Member'>collClause</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN309"><span class='Ref_to_Member'>collname</span></a><span class='Delimiter'>, 
</span>                                 <a href="parse_type.c.html#LN524"><span class='Ref_To_Local'>location</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN520"><span class='Ref_to_Parameter'>coldef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN651"><span class='Ref_to_Member'>collOid</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Precooked collation spec, use that */ 
</span>        <a href="parse_type.c.html#LN522"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="parse_type.c.html#LN520"><span class='Ref_to_Parameter'>coldef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN651"><span class='Ref_to_Member'>collOid</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Use the type's default collation if any */ 
</span>        <a href="parse_type.c.html#LN522"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="parse_type.c.html#LN523"><span class='Ref_To_Local'>typcollation</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Complain if COLLATE is applied to an uncollatable type */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN522"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>) </span><span class='Operator'>&& !</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN523"><span class='Ref_To_Local'>typcollation</span></a><span class='Parentheses'>))</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_DATATYPE_MISMATCH<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"collations are not supported by type %s"</span><span class='Delimiter'>, 
</span>                        <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN520"><span class='Ref_to_Parameter'>typeOid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                 <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN520"><span class='Ref_to_Parameter'>pstate</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN524"><span class='Ref_To_Local'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="parse_type.c.html#LN522"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end GetColumnDefCollation &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* return a Type structure, given a type id */ 
/* NB: caller must ReleaseSysCache the type tuple when done with it */ 
</span><a href="../../include/parser/parse_type.h.html#LN19"><span class='Ref_to_Typedef'>Type</span></a> 
<a name="LN558"></a><span class='Declare_Function'>typeidType</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>id</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN560"></a>    <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>tup</span><span class='Delimiter'>; 
</span> 
    <a href="parse_type.c.html#LN560"><span class='Ref_To_Local'>tup</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN155"><span class='Ref_to_Macro'>SearchSysCache1</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN107"><span class='Ref_to_EnumConst'>TYPEOID</span></a><span class='Delimiter'>, </span><a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN558"><span class='Ref_to_Parameter'>id</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN560"><span class='Ref_To_Local'>tup</span></a><span class='Parentheses'>))</span> 
        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for type %u"</span><span class='Delimiter'>, </span><a href="parse_type.c.html#LN558"><span class='Ref_to_Parameter'>id</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../include/parser/parse_type.h.html#LN19"><span class='Ref_to_Typedef'>Type</span></a><span class='Parentheses'>) </span><a href="parse_type.c.html#LN560"><span class='Ref_To_Local'>tup</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* given type (as type struct), return the type OID */ 
</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> 
<a name="LN570"></a><span class='Declare_Function'>typeTypeId</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_type.h.html#LN19"><span class='Ref_to_Typedef'>Type</span></a> <span class='Declare_Parameter'>tp</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_type.c.html#LN570"><span class='Ref_to_Parameter'>tp</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span>             <span class='Comment_Single_Line'>/* probably useless */ 
</span>        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"typeTypeId() called with NULL type struct"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="../../include/access/htup_details.h.html#LN694"><span class='Ref_to_Macro'>HeapTupleGetOid</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN570"><span class='Ref_to_Parameter'>tp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* given type (as type struct), return the length of type */ 
</span><a href="../../include/c.h.html#LN254"><span class='Ref_to_Typedef'>int16</span></a> 
<a name="LN579"></a><span class='Declare_Function'>typeLen</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_type.h.html#LN19"><span class='Ref_to_Typedef'>Type</span></a> <span class='Declare_Parameter'>t</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN581"></a>    <a href="../../include/catalog/pg_type.h.html#LN232"><span class='Ref_to_Typedef'>Form_pg_type</span></a> <span class='Declare_Local'>typ</span><span class='Delimiter'>; 
</span> 
    <a href="parse_type.c.html#LN581"><span class='Ref_To_Local'>typ</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_type.h.html#LN232"><span class='Ref_to_Typedef'>Form_pg_type</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN579"><span class='Ref_to_Parameter'>t</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="parse_type.c.html#LN581"><span class='Ref_To_Local'>typ</span></a><span class='Operator'>-&GT;</span>typlen<span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* given type (as type struct), return its 'byval' attribute */ 
</span><span class='Keyword'>bool 
</span><a name="LN589"></a><span class='Declare_Function'>typeByVal</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_type.h.html#LN19"><span class='Ref_to_Typedef'>Type</span></a> <span class='Declare_Parameter'>t</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN591"></a>    <a href="../../include/catalog/pg_type.h.html#LN232"><span class='Ref_to_Typedef'>Form_pg_type</span></a> <span class='Declare_Local'>typ</span><span class='Delimiter'>; 
</span> 
    <a href="parse_type.c.html#LN591"><span class='Ref_To_Local'>typ</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_type.h.html#LN232"><span class='Ref_to_Typedef'>Form_pg_type</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN589"><span class='Ref_to_Parameter'>t</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="parse_type.c.html#LN591"><span class='Ref_To_Local'>typ</span></a><span class='Operator'>-&GT;</span>typbyval<span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* given type (as type struct), return the type's name */ 
</span><span class='Keyword'>char </span><span class='Operator'>* 
</span><a name="LN599"></a><span class='Declare_Function'>typeTypeName</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_type.h.html#LN19"><span class='Ref_to_Typedef'>Type</span></a> <span class='Declare_Parameter'>t</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN601"></a>    <a href="../../include/catalog/pg_type.h.html#LN232"><span class='Ref_to_Typedef'>Form_pg_type</span></a> <span class='Declare_Local'>typ</span><span class='Delimiter'>; 
</span> 
    <a href="parse_type.c.html#LN601"><span class='Ref_To_Local'>typ</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_type.h.html#LN232"><span class='Ref_to_Typedef'>Form_pg_type</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN599"><span class='Ref_to_Parameter'>t</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* pstrdup here because result may need to outlive the syscache entry */ 
</span>    <span class='Control'>return</span> <a href="../../include/common/fe_memutils.h.html#LN32"><span class='Ref_to_Proto'>pstrdup</span></a><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN498"><span class='Ref_to_Macro'>NameStr</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN601"><span class='Ref_To_Local'>typ</span></a><span class='Operator'>-&GT;</span>typname<span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* given type (as type struct), return its 'typrelid' attribute */ 
</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> 
<a name="LN610"></a><span class='Declare_Function'>typeTypeRelid</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_type.h.html#LN19"><span class='Ref_to_Typedef'>Type</span></a> <span class='Declare_Parameter'>typ</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN612"></a>    <a href="../../include/catalog/pg_type.h.html#LN232"><span class='Ref_to_Typedef'>Form_pg_type</span></a> <span class='Declare_Local'>typtup</span><span class='Delimiter'>; 
</span> 
    <a href="parse_type.c.html#LN612"><span class='Ref_To_Local'>typtup</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_type.h.html#LN232"><span class='Ref_to_Typedef'>Form_pg_type</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN610"><span class='Ref_to_Parameter'>typ</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="parse_type.c.html#LN612"><span class='Ref_To_Local'>typtup</span></a><span class='Operator'>-&GT;</span>typrelid<span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* given type (as type struct), return its 'typcollation' attribute */ 
</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> 
<a name="LN620"></a><span class='Declare_Function'>typeTypeCollation</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_type.h.html#LN19"><span class='Ref_to_Typedef'>Type</span></a> <span class='Declare_Parameter'>typ</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN622"></a>    <a href="../../include/catalog/pg_type.h.html#LN232"><span class='Ref_to_Typedef'>Form_pg_type</span></a> <span class='Declare_Local'>typtup</span><span class='Delimiter'>; 
</span> 
    <a href="parse_type.c.html#LN622"><span class='Ref_To_Local'>typtup</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_type.h.html#LN232"><span class='Ref_to_Typedef'>Form_pg_type</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN620"><span class='Ref_to_Parameter'>typ</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="parse_type.c.html#LN622"><span class='Ref_To_Local'>typtup</span></a><span class='Operator'>-&GT;</span>typcollation<span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Given a type structure and a string, returns the internal representation 
 * of that string.  The "string" can be NULL to perform conversion of a NULL 
 * (which might result in failure, if the input function rejects NULLs). 
 */ 
</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN634"></a><span class='Declare_Function'>stringTypeDatum</span><span class='Parentheses'>(</span><a href="../../include/parser/parse_type.h.html#LN19"><span class='Ref_to_Typedef'>Type</span></a> <span class='Declare_Parameter'>tp</span><span class='Delimiter'>, </span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Declare_Parameter'>string</span><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a> <span class='Declare_Parameter'>atttypmod</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN636"></a>    <a href="../../include/catalog/pg_type.h.html#LN232"><span class='Ref_to_Typedef'>Form_pg_type</span></a> <span class='Declare_Local'>typform</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_type.h.html#LN232"><span class='Ref_to_Typedef'>Form_pg_type</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN634"><span class='Ref_to_Parameter'>tp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN637"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>typinput</span> <span class='Operator'>= </span><a href="parse_type.c.html#LN636"><span class='Ref_To_Local'>typform</span></a><span class='Operator'>-&GT;</span>typinput<span class='Delimiter'>; 
</span><a name="LN638"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>typioparam</span> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN138"><span class='Ref_to_Proto'>getTypeIOParam</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN634"><span class='Ref_to_Parameter'>tp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="../../include/fmgr.h.html#LN644"><span class='Ref_to_Proto'>OidInputFunctionCall</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN637"><span class='Ref_To_Local'>typinput</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN634"><span class='Ref_to_Parameter'>string</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN638"><span class='Ref_To_Local'>typioparam</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN634"><span class='Ref_to_Parameter'>atttypmod</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* given a typeid, return the type's typrelid (associated relation, if any) */ 
</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> 
<a name="LN645"></a><span class='Declare_Function'>typeidTypeRelid</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>type_id</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN647"></a>    <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>typeTuple</span><span class='Delimiter'>; 
</span><a name="LN648"></a>    <a href="../../include/catalog/pg_type.h.html#LN232"><span class='Ref_to_Typedef'>Form_pg_type</span></a> <span class='Declare_Local'>type</span><span class='Delimiter'>; 
</span><a name="LN649"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span> 
    <a href="parse_type.c.html#LN647"><span class='Ref_To_Local'>typeTuple</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN155"><span class='Ref_to_Macro'>SearchSysCache1</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN107"><span class='Ref_to_EnumConst'>TYPEOID</span></a><span class='Delimiter'>, </span><a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN645"><span class='Ref_to_Parameter'>type_id</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN647"><span class='Ref_To_Local'>typeTuple</span></a><span class='Parentheses'>))</span> 
        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for type %u"</span><span class='Delimiter'>, </span><a href="parse_type.c.html#LN645"><span class='Ref_to_Parameter'>type_id</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="parse_type.c.html#LN648"><span class='Ref_To_Local'>type</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_type.h.html#LN232"><span class='Ref_to_Typedef'>Form_pg_type</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN647"><span class='Ref_To_Local'>typeTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="parse_type.c.html#LN649"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="parse_type.c.html#LN648"><span class='Ref_To_Local'>type</span></a><span class='Operator'>-&GT;</span>typrelid<span class='Delimiter'>; 
</span>    <a href="../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN647"><span class='Ref_To_Local'>typeTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="parse_type.c.html#LN649"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * error context callback for parse failure during parseTypeString() 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN665"></a><span class='Declare_Function'>pts_error_callback</span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>arg</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN667"></a>    <span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Local'>str</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_type.c.html#LN665"><span class='Ref_to_Parameter'>arg</span></a><span class='Delimiter'>; 
</span> 
    errcontext<span class='Parentheses'>(</span><span class='String'>"invalid type name \"%s\""</span><span class='Delimiter'>, </span><a href="parse_type.c.html#LN667"><span class='Ref_To_Local'>str</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Currently we just suppress any syntax error position report, rather 
     * than transforming to an "internal query" error.  It's unlikely that a 
     * type name is complex enough to need positioning. 
     */ 
</span>    <a href="../utils/error/elog.c.html#LN1123"><span class='Ref_to_Func'>errposition</span></a><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Given a string that is supposed to be a SQL-compatible type declaration, 
 * such as "int4" or "integer" or "character varying(32)", parse 
 * the string and return the result as a TypeName. 
 * If the string cannot be parsed as a type, an error is raised. 
 */ 
</span><a href="../../include/nodes/parsenodes.h.html#LN205"><span class='Ref_to_Struct'>TypeName</span></a> <span class='Operator'>* 
</span><a name="LN686"></a><span class='Declare_Function'>typeStringToTypeName</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>str</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN688"></a>    <a href="../../include/lib/stringinfo.h.html#LN34"><span class='Ref_to_Struct'>StringInfoData</span></a> <span class='Declare_Local'>buf</span><span class='Delimiter'>; 
</span><a name="LN689"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>raw_parsetree_list</span><span class='Delimiter'>; 
</span><a name="LN690"></a>    <a href="../../include/nodes/parsenodes.h.html#LN1478"><span class='Ref_to_Struct'>SelectStmt</span></a> <span class='Operator'>*</span><span class='Declare_Local'>stmt</span><span class='Delimiter'>; 
</span><a name="LN691"></a>    <a href="../../include/nodes/parsenodes.h.html#LN436"><span class='Ref_to_Struct'>ResTarget</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>restarget</span><span class='Delimiter'>; 
</span><a name="LN692"></a>    <a href="../../include/nodes/parsenodes.h.html#LN294"><span class='Ref_to_Struct'>TypeCast</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>typecast</span><span class='Delimiter'>; 
</span><a name="LN693"></a>    <a href="../../include/nodes/parsenodes.h.html#LN205"><span class='Ref_to_Struct'>TypeName</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>typeName</span><span class='Delimiter'>; 
</span><a name="LN694"></a>    ErrorContextCallback <span class='Declare_Local'>ptserrcontext</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* make sure we give useful error for empty input */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span>strspn<span class='Parentheses'>(</span><a href="parse_type.c.html#LN686"><span class='Ref_to_Parameter'>str</span></a><span class='Delimiter'>, </span><span class='String'>" \t\n\r\f"</span><span class='Parentheses'>) </span><span class='Operator'>== </span>strlen<span class='Parentheses'>(</span><a href="parse_type.c.html#LN686"><span class='Ref_to_Parameter'>str</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="parse_type.c.html#LN765"><span class='Ref_to_Label'>fail</span></a><span class='Delimiter'>; 
</span> 
    <a href="../lib/stringinfo.c.html#LN44"><span class='Ref_to_Func'>initStringInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="parse_type.c.html#LN688"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../bin/pg_waldump/compat.c.html#LN69"><span class='Ref_to_Func'>appendStringInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="parse_type.c.html#LN688"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='String'>"SELECT NULL::%s"</span><span class='Delimiter'>, </span><a href="parse_type.c.html#LN686"><span class='Ref_to_Parameter'>str</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Setup error traceback support in case of ereport() during parse 
     */ 
</span>    <a href="parse_type.c.html#LN694"><span class='Ref_To_Local'>ptserrcontext</span></a><span class='Operator'>.</span>callback <span class='Operator'>= </span><a href="parse_type.c.html#LN664"><span class='Ref_to_Func'>pts_error_callback</span></a><span class='Delimiter'>; 
</span>    <a href="parse_type.c.html#LN694"><span class='Ref_To_Local'>ptserrcontext</span></a><span class='Operator'>.</span>arg <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_type.c.html#LN686"><span class='Ref_to_Parameter'>str</span></a><span class='Delimiter'>; 
</span>    <a href="parse_type.c.html#LN694"><span class='Ref_To_Local'>ptserrcontext</span></a><span class='Operator'>.</span>previous <span class='Operator'>= </span><a href="../utils/error/elog.c.html#LN87"><span class='Ref_to_Global_Var'>error_context_stack</span></a><span class='Delimiter'>; 
</span>    <a href="../utils/error/elog.c.html#LN87"><span class='Ref_to_Global_Var'>error_context_stack</span></a> <span class='Operator'>= &</span><a href="parse_type.c.html#LN694"><span class='Ref_To_Local'>ptserrcontext</span></a><span class='Delimiter'>; 
</span> 
    <a href="parse_type.c.html#LN689"><span class='Ref_To_Local'>raw_parsetree_list</span></a> <span class='Operator'>= </span><a href="parser.c.html#LN34"><span class='Ref_to_Func'>raw_parser</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN688"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>.</span><a href="../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../utils/error/elog.c.html#LN87"><span class='Ref_to_Global_Var'>error_context_stack</span></a> <span class='Operator'>= </span><a href="parse_type.c.html#LN694"><span class='Ref_To_Local'>ptserrcontext</span></a><span class='Operator'>.</span>previous<span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Make sure we got back exactly what we expected and no more; paranoia is 
     * justified since the string might contain anything. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN689"><span class='Ref_To_Local'>raw_parsetree_list</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
        <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="parse_type.c.html#LN765"><span class='Ref_to_Label'>fail</span></a><span class='Delimiter'>; 
</span>    <a href="parse_type.c.html#LN690"><span class='Ref_To_Local'>stmt</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1478"><span class='Ref_to_Struct'>SelectStmt</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN113"><span class='Ref_to_Macro'>linitial_node</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1396"><span class='Ref_to_Struct'>RawStmt</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN689"><span class='Ref_To_Local'>raw_parsetree_list</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>stmt<span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_type.c.html#LN690"><span class='Ref_To_Local'>stmt</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| 
</span>        <span class='Operator'>!</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN690"><span class='Ref_To_Local'>stmt</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN1478"><span class='Ref_to_Struct'>SelectStmt</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <a href="parse_type.c.html#LN690"><span class='Ref_To_Local'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1485"><span class='Ref_to_Member'>distinctClause</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>|| 
</span>        <a href="parse_type.c.html#LN690"><span class='Ref_To_Local'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1487"><span class='Ref_to_Member'>intoClause</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL </span><span class='Operator'>|| 
</span>        <a href="parse_type.c.html#LN690"><span class='Ref_To_Local'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1489"><span class='Ref_to_Member'>fromClause</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>|| 
</span>        <a href="parse_type.c.html#LN690"><span class='Ref_To_Local'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1490"><span class='Ref_to_Member'>whereClause</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL </span><span class='Operator'>|| 
</span>        <a href="parse_type.c.html#LN690"><span class='Ref_To_Local'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1491"><span class='Ref_to_Member'>groupClause</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>|| 
</span>        <a href="parse_type.c.html#LN690"><span class='Ref_To_Local'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1492"><span class='Ref_to_Member'>havingClause</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL </span><span class='Operator'>|| 
</span>        <a href="parse_type.c.html#LN690"><span class='Ref_To_Local'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1493"><span class='Ref_to_Member'>windowClause</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>|| 
</span>        <a href="parse_type.c.html#LN690"><span class='Ref_To_Local'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1503"><span class='Ref_to_Member'>valuesLists</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>|| 
</span>        <a href="parse_type.c.html#LN690"><span class='Ref_To_Local'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1509"><span class='Ref_to_Member'>sortClause</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>|| 
</span>        <a href="parse_type.c.html#LN690"><span class='Ref_To_Local'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1510"><span class='Ref_to_Member'>limitOffset</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL </span><span class='Operator'>|| 
</span>        <a href="parse_type.c.html#LN690"><span class='Ref_To_Local'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1511"><span class='Ref_to_Member'>limitCount</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL </span><span class='Operator'>|| 
</span>        <a href="parse_type.c.html#LN690"><span class='Ref_To_Local'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1512"><span class='Ref_to_Member'>lockingClause</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>|| 
</span>        <a href="parse_type.c.html#LN690"><span class='Ref_To_Local'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1513"><span class='Ref_to_Member'>withClause</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL </span><span class='Operator'>|| 
</span>        <a href="parse_type.c.html#LN690"><span class='Ref_To_Local'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1518"><span class='Ref_to_Member'>op</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/parsenodes.h.html#LN1472"><span class='Ref_to_EnumConst'>SETOP_NONE</span></a><span class='Parentheses'>)</span> 
        <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="parse_type.c.html#LN765"><span class='Ref_to_Label'>fail</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN690"><span class='Ref_To_Local'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1488"><span class='Ref_to_Member'>targetList</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
        <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="parse_type.c.html#LN765"><span class='Ref_to_Label'>fail</span></a><span class='Delimiter'>; 
</span>    <a href="parse_type.c.html#LN691"><span class='Ref_To_Local'>restarget</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN436"><span class='Ref_to_Struct'>ResTarget</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN690"><span class='Ref_To_Local'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1488"><span class='Ref_to_Member'>targetList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_type.c.html#LN691"><span class='Ref_To_Local'>restarget</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| 
</span>        <span class='Operator'>!</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN691"><span class='Ref_To_Local'>restarget</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN436"><span class='Ref_to_Struct'>ResTarget</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <a href="parse_type.c.html#LN691"><span class='Ref_To_Local'>restarget</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN439"><span class='Ref_to_Member'>name</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL </span><span class='Operator'>|| 
</span>        <a href="parse_type.c.html#LN691"><span class='Ref_To_Local'>restarget</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN440"><span class='Ref_to_Member'>indirection</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span> 
        <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="parse_type.c.html#LN765"><span class='Ref_to_Label'>fail</span></a><span class='Delimiter'>; 
</span>    <a href="parse_type.c.html#LN692"><span class='Ref_To_Local'>typecast</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN294"><span class='Ref_to_Struct'>TypeCast</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="parse_type.c.html#LN691"><span class='Ref_To_Local'>restarget</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN441"><span class='Ref_to_Member'>val</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_type.c.html#LN692"><span class='Ref_To_Local'>typecast</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| 
</span>        <span class='Operator'>!</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN692"><span class='Ref_To_Local'>typecast</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN294"><span class='Ref_to_Struct'>TypeCast</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <a href="parse_type.c.html#LN692"><span class='Ref_To_Local'>typecast</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN297"><span class='Ref_to_Member'>arg</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| 
</span>        <span class='Operator'>!</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN692"><span class='Ref_To_Local'>typecast</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN297"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN284"><span class='Ref_to_Struct'>A_Const</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="parse_type.c.html#LN765"><span class='Ref_to_Label'>fail</span></a><span class='Delimiter'>; 
</span> 
    <a href="parse_type.c.html#LN693"><span class='Ref_To_Local'>typeName</span></a> <span class='Operator'>= </span><a href="parse_type.c.html#LN692"><span class='Ref_To_Local'>typecast</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN298"><span class='Ref_to_Member'>typeName</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_type.c.html#LN693"><span class='Ref_To_Local'>typeName</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| 
</span>        <span class='Operator'>!</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN693"><span class='Ref_To_Local'>typeName</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN205"><span class='Ref_to_Struct'>TypeName</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="parse_type.c.html#LN765"><span class='Ref_to_Label'>fail</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_type.c.html#LN693"><span class='Ref_To_Local'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN210"><span class='Ref_to_Member'>setof</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="parse_type.c.html#LN765"><span class='Ref_to_Label'>fail</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN688"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>.</span><a href="../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="parse_type.c.html#LN693"><span class='Ref_To_Local'>typeName</span></a><span class='Delimiter'>; 
</span> 
<a name="LN765"></a><span class='Label'>fail</span><span class='Operator'>: 
</span>    <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>            <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_SYNTAX_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>             <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"invalid type name \"%s\""</span><span class='Delimiter'>, </span><a href="parse_type.c.html#LN686"><span class='Ref_to_Parameter'>str</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>;</span>                <span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end typeStringToTypeName &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Given a string that is supposed to be a SQL-compatible type declaration, 
 * such as "int4" or "integer" or "character varying(32)", parse 
 * the string and convert it to a type OID and type modifier. 
 * If missing_ok is true, InvalidOid is returned rather than raising an error 
 * when the type name is not found. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN780"></a><span class='Declare_Function'>parseTypeString</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>str</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>typeid_p</span><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>typmod_p</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>missing_ok</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN782"></a>    <a href="../../include/nodes/parsenodes.h.html#LN205"><span class='Ref_to_Struct'>TypeName</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>typeName</span><span class='Delimiter'>; 
</span><a name="LN783"></a>    <a href="../../include/parser/parse_type.h.html#LN19"><span class='Ref_to_Typedef'>Type</span></a>        <span class='Declare_Local'>tup</span><span class='Delimiter'>; 
</span> 
    <a href="parse_type.c.html#LN782"><span class='Ref_To_Local'>typeName</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_type.h.html#LN49"><span class='Ref_to_Proto'>typeStringToTypeName</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN780"><span class='Ref_to_Parameter'>str</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="parse_type.c.html#LN783"><span class='Ref_To_Local'>tup</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_type.h.html#LN21"><span class='Ref_to_Proto'>LookupTypeName</span></a><span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><a href="parse_type.c.html#LN782"><span class='Ref_To_Local'>typeName</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN780"><span class='Ref_to_Parameter'>typmod_p</span></a><span class='Delimiter'>, </span><a href="parse_type.c.html#LN780"><span class='Ref_to_Parameter'>missing_ok</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="parse_type.c.html#LN783"><span class='Ref_To_Local'>tup</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="parse_type.c.html#LN780"><span class='Ref_to_Parameter'>missing_ok</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_UNDEFINED_OBJECT<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"type \"%s\" does not exist"</span><span class='Delimiter'>, 
</span>                            <a href="../../include/parser/parse_type.h.html#LN31"><span class='Ref_to_Proto'>TypeNameToString</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN782"><span class='Ref_To_Local'>typeName</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><a href="parse_type.c.html#LN782"><span class='Ref_To_Local'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN215"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="parse_type.c.html#LN780"><span class='Ref_to_Parameter'>typeid_p</span></a> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>((</span><a href="../../include/catalog/pg_type.h.html#LN232"><span class='Ref_to_Typedef'>Form_pg_type</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN783"><span class='Ref_To_Local'>tup</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>typisdefined<span class='Parentheses'>)</span> 
            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_UNDEFINED_OBJECT<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"type \"%s\" is only a shell"</span><span class='Delimiter'>, 
</span>                            <a href="../../include/parser/parse_type.h.html#LN31"><span class='Ref_to_Proto'>TypeNameToString</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN782"><span class='Ref_To_Local'>typeName</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                     <a href="../../pl/plpgsql/src/pl_gram.y.html#LN55"><span class='Ref_to_Macro'>parser_errposition</span></a><span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><a href="parse_type.c.html#LN782"><span class='Ref_To_Local'>typeName</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN215"><span class='Ref_to_Member'>location</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="parse_type.c.html#LN780"><span class='Ref_to_Parameter'>typeid_p</span></a> <span class='Operator'>= </span><a href="../../include/access/htup_details.h.html#LN694"><span class='Ref_to_Macro'>HeapTupleGetOid</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN783"><span class='Ref_To_Local'>tup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="parse_type.c.html#LN783"><span class='Ref_To_Local'>tup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end parseTypeString &raquo; </span> 
</pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>