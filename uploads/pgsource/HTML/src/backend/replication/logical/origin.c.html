<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\replication\logical\origin.c</title>
<LINK REL=StyleSheet HREF="../../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\replication\logical\origin.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:46 2017
</td></tr>
<tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
</span><span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * origin.c 
 *    Logical replication progress tracking support. 
 * 
 * Copyright (c) 2013-2017, PostgreSQL Global Development Group 
 * 
 * IDENTIFICATION 
 *    src/backend/replication/logical/origin.c 
 * 
 * NOTES 
 * 
 * This file provides the following: 
 * * An infrastructure to name nodes in a replication setup 
 * * A facility to efficiently store and persist replication progress in an 
 *   efficient and durable manner. 
 * 
 * Replication origin consist out of a descriptive, user defined, external 
 * name and a short, thus space efficient, internal 2 byte one. This split 
 * exists because replication origin have to be stored in WAL and shared 
 * memory and long descriptors would be inefficient.  For now only use 2 bytes 
 * for the internal id of a replication origin as it seems unlikely that there 
 * soon will be more than 65k nodes in one replication setup; and using only 
 * two bytes allow us to be more space efficient. 
 * 
 * Replication progress is tracked in a shared memory table 
 * (ReplicationState) that's dumped to disk every checkpoint. Entries 
 * ('slots') in this table are identified by the internal id. That's the case 
 * because it allows to increase replication progress during crash 
 * recovery. To allow doing so we store the original LSN (from the originating 
 * system) of a transaction in the commit record. That allows to recover the 
 * precise replayed state after crash recovery; without requiring synchronous 
 * commits. Allowing logical replication to use asynchronous commit is 
 * generally good for performance, but especially important as it allows a 
 * single threaded replay process to keep up with a source that has multiple 
 * backends generating changes concurrently.  For efficiency and simplicity 
 * reasons a backend can setup one replication origin that's from then used as 
 * the source of changes produced by the backend, until reset again. 
 * 
 * This infrastructure is intended to be used in cooperation with logical 
 * decoding. When replaying from a remote system the configured origin is 
 * provided to output plugins, allowing prevention of replication loops and 
 * other filtering. 
 * 
 * There are several levels of locking at work: 
 * 
 * * To create and drop replication origins an exclusive lock on 
 *   pg_replication_slot is required for the duration. That allows us to 
 *   safely and conflict free assign new origins using a dirty snapshot. 
 * 
 * * When creating an in-memory replication progress slot the ReplicationOrigin 
 *   LWLock has to be held exclusively; when iterating over the replication 
 *   progress a shared lock has to be held, the same when advancing the 
 *   replication progress of an individual backend that has not setup as the 
 *   session's replication origin. 
 * 
 * * When manipulating or looking at the remote_lsn and local_lsn fields of a 
 *   replication progress slot that slot's lwlock has to be held. That's 
 *   primarily because we do not assume 8 byte writes (the LSN) is atomic on 
 *   all our platforms, but it also simplifies memory ordering concerns 
 *   between the remote and local lsn. We use a lwlock instead of a spinlock 
 *   so it's less harmful to hold the lock over a WAL write 
 *   (c.f. AdvanceReplicationProgress). 
 * 
 * --------------------------------------------------------------------------- 
 */ 
</span> 
<span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>&LT;unistd.h&GT;</span> 
<span class='Keyword'>#include </span><span class='String'>&LT;sys/stat.h&GT;</span> 
 
<span class='Keyword'>#include </span><span class='String'>"funcapi.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"miscadmin.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/genam.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/heapam.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/htup_details.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/xact.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"catalog/indexing.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"nodes/execnodes.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"replication/origin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"replication/logical.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"storage/fd.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/ipc.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/lmgr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/copydir.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"utils/builtins.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/fmgroids.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/pg_lsn.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/rel.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/syscache.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/tqual.h"</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Replay progress of a single remote node. 
 */ 
</span><a name="LN102"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ReplicationState</span> 
<span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * Local identifier for the remote node. 
     */ 
</span><a name="LN107"></a>    <a href="../../../include/access/xlogdefs.h.html#LN50"><span class='Ref_to_Typedef'>RepOriginId</span></a> <span class='Declare_Member'>roident</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Location of the latest commit from the remote side. 
     */ 
</span><a name="LN112"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Member'>remote_lsn</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Remember the local lsn of the commit record so we can XLogFlush() to it 
     * during a checkpoint so we know the commit record actually is safe on 
     * disk. 
     */ 
</span><a name="LN119"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Member'>local_lsn</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * PID of backend that's acquired slot, or 0 if none. 
     */ 
</span><a name="LN124"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>acquired_by</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Lock protecting remote_lsn and local_lsn. 
     */ 
</span><a name="LN129"></a>    <a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a>      <span class='Declare_Member'>lock</span><span class='Delimiter'>; 
</span><a name="LN130"></a>}<span class='Auto_Annotations'> &laquo; end ReplicationState &raquo; </span> <span class='Declare_Typedef'>ReplicationState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * On disk version of ReplicationState. 
 */ 
</span><a name="LN135"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ReplicationStateOnDisk</span> 
<span class='Delimiter'>{ 
</span><a name="LN137"></a>    <a href="../../../include/access/xlogdefs.h.html#LN50"><span class='Ref_to_Typedef'>RepOriginId</span></a> <span class='Declare_Member'>roident</span><span class='Delimiter'>; 
</span><a name="LN138"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Member'>remote_lsn</span><span class='Delimiter'>; 
</span><a name="LN139"></a>} <span class='Declare_Typedef'>ReplicationStateOnDisk</span><span class='Delimiter'>; 
</span> 
 
<a name="LN142"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ReplicationStateCtl</span> 
<span class='Delimiter'>{ 
</span><a name="LN144"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>tranche_id</span><span class='Delimiter'>; 
</span><a name="LN145"></a>    <a href="origin.c.html#LN102"><span class='Ref_to_Struct'>ReplicationState</span></a> <span class='Declare_Member'>states</span><span class='Delimiter'>[</span>FLEXIBLE_ARRAY_MEMBER<span class='Delimiter'>]; 
</span><a name="LN146"></a>} <span class='Declare_Typedef'>ReplicationStateCtl</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* external variables */ 
</span><a name="LN149"></a><a href="../../../include/access/xlogdefs.h.html#LN50"><span class='Ref_to_Typedef'>RepOriginId</span></a> <span class='Declare_Var'>replorigin_session_origin</span> <span class='Operator'>= </span><a href="../../../include/replication/origin.h.html#LN33"><span class='Ref_to_Const'>InvalidRepOriginId</span></a><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* assumed identity */ 
</span><a name="LN150"></a><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Var'>replorigin_session_origin_lsn</span> <span class='Operator'>= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span><a name="LN151"></a><a href="../../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Var'>replorigin_session_origin_timestamp</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Base address into a shared memory array of replication states of size 
 * max_replication_slots. 
 * 
 * XXX: Should we use a separate variable to size this rather than 
 * max_replication_slots? 
 */ 
</span><a name="LN160"></a><span class='Keyword'>static </span><a href="origin.c.html#LN102"><span class='Ref_to_Struct'>ReplicationState</span></a> <span class='Operator'>*</span><span class='Declare_Var'>replication_states</span><span class='Delimiter'>; 
</span><a name="LN161"></a><span class='Keyword'>static </span><a href="origin.c.html#LN142"><span class='Ref_to_Struct'>ReplicationStateCtl</span></a> <span class='Operator'>*</span><span class='Declare_Var'>replication_states_ctl</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Backend-local, cached element from ReplicationState for use in a backend 
 * replaying remote commits, so we don't have to search ReplicationState for 
 * the backends current RepOriginId. 
 */ 
</span><a name="LN168"></a><span class='Keyword'>static </span><a href="origin.c.html#LN102"><span class='Ref_to_Struct'>ReplicationState</span></a> <span class='Operator'>*</span><span class='Declare_Var'>session_replication_state</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Magic for on disk files. */ 
</span><a name="LN171"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>REPLICATION_STATE_MAGIC</span> <span class='Parentheses'>((</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><span class='Number'>0x1257DADE</span><span class='Parentheses'>)</span> 
 
<span class='Keyword'>static void 
</span><a name="LN174"></a><span class='Declare_Function'>replorigin_check_prerequisites</span><span class='Parentheses'>(</span><span class='Keyword'>bool </span><span class='Declare_Parameter'>check_slots</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>recoveryOK</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../utils/misc/superuser.c.html#LN45"><span class='Ref_to_Func'>superuser</span></a><span class='Parentheses'>())</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INSUFFICIENT_PRIVILEGE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"only superusers can query or manipulate replication origins"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN174"><span class='Ref_to_Parameter'>check_slots</span></a> <span class='Operator'>&& </span><a href="../slot.c.html#LN98"><span class='Ref_to_Global_Var'>max_replication_slots</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"cannot query or manipulate replication origin when max_replication_slots = 0"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="origin.c.html#LN174"><span class='Ref_to_Parameter'>recoveryOK</span></a> <span class='Operator'>&& </span><a href="../../../include/access/xlog.h.html#LN242"><span class='Ref_to_Proto'>RecoveryInProgress</span></a><span class='Parentheses'>())</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_READ_ONLY_SQL_TRANSACTION<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>           <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"cannot manipulate replication origins during recovery"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
<span class='Delimiter'>} 
</span> 
 
<span class='Comment_Multi_Line'>/* --------------------------------------------------------------------------- 
 * Functions for working with replication origins themselves. 
 * --------------------------------------------------------------------------- 
 */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Check for a persistent replication origin identified by name. 
 * 
 * Returns InvalidOid if the node isn't known yet and missing_ok is true. 
 */ 
</span><a href="../../../include/access/xlogdefs.h.html#LN50"><span class='Ref_to_Typedef'>RepOriginId</span></a> 
<a name="LN205"></a><span class='Declare_Function'>replorigin_by_name</span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Declare_Parameter'>roname</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>missing_ok</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN207"></a>    <a href="../../../include/catalog/pg_replication_origin.h.html#LN54"><span class='Ref_to_Typedef'>Form_pg_replication_origin</span></a> <span class='Declare_Local'>ident</span><span class='Delimiter'>; 
</span><a name="LN208"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>roident</span> <span class='Operator'>= </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span><a name="LN209"></a>    <a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>tuple</span><span class='Delimiter'>; 
</span><a name="LN210"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>roname_d</span><span class='Delimiter'>; 
</span> 
    <a href="origin.c.html#LN210"><span class='Ref_To_Local'>roname_d</span></a> <span class='Operator'>= </span><a href="../../../include/utils/builtins.h.html#LN90"><span class='Ref_to_Macro'>CStringGetTextDatum</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN205"><span class='Ref_to_Parameter'>roname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="origin.c.html#LN209"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><a href="../../../include/utils/syscache.h.html#LN155"><span class='Ref_to_Macro'>SearchSysCache1</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/syscache.h.html#LN85"><span class='Ref_to_EnumConst'>REPLORIGNAME</span></a><span class='Delimiter'>, </span><a href="origin.c.html#LN210"><span class='Ref_To_Local'>roname_d</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN209"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="origin.c.html#LN207"><span class='Ref_To_Local'>ident</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_replication_origin.h.html#LN54"><span class='Ref_to_Typedef'>Form_pg_replication_origin</span></a><span class='Parentheses'>) </span><a href="../../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN209"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="origin.c.html#LN208"><span class='Ref_To_Local'>roident</span></a> <span class='Operator'>= </span><a href="origin.c.html#LN207"><span class='Ref_To_Local'>ident</span></a><span class='Operator'>-&GT;</span>roident<span class='Delimiter'>; 
</span>        <a href="../../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN209"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="origin.c.html#LN205"><span class='Ref_to_Parameter'>missing_ok</span></a><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for replication origin '%s'"</span><span class='Delimiter'>, 
</span>             <a href="origin.c.html#LN205"><span class='Ref_to_Parameter'>roname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="origin.c.html#LN208"><span class='Ref_To_Local'>roident</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end replorigin_by_name &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Create a replication origin. 
 * 
 * Needs to be called in a transaction. 
 */ 
</span><a href="../../../include/access/xlogdefs.h.html#LN50"><span class='Ref_to_Typedef'>RepOriginId</span></a> 
<a name="LN234"></a><span class='Declare_Function'>replorigin_create</span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Declare_Parameter'>roname</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN236"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>roident</span><span class='Delimiter'>; 
</span><a name="LN237"></a>    <a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>tuple</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN238"></a>    <a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>rel</span><span class='Delimiter'>; 
</span><a name="LN239"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>roname_d</span><span class='Delimiter'>; 
</span><a name="LN240"></a>    <a href="../../../include/utils/snapshot.h.html#LN51"><span class='Ref_to_Struct'>SnapshotData</span></a> <span class='Declare_Local'>SnapshotDirty</span><span class='Delimiter'>; 
</span><a name="LN241"></a>    <a href="../../../include/access/genam.h.html#LN86"><span class='Ref_to_Typedef'>SysScanDesc</span></a> <span class='Declare_Local'>scan</span><span class='Delimiter'>; 
</span><a name="LN242"></a>    <a href="../../../include/access/skey.h.html#LN63"><span class='Ref_to_Struct'>ScanKeyData</span></a> <span class='Declare_Local'>key</span><span class='Delimiter'>; 
</span> 
    <a href="origin.c.html#LN239"><span class='Ref_To_Local'>roname_d</span></a> <span class='Operator'>= </span><a href="../../../include/utils/builtins.h.html#LN90"><span class='Ref_to_Macro'>CStringGetTextDatum</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN234"><span class='Ref_to_Parameter'>roname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/xact.h.html#LN329"><span class='Ref_to_Proto'>IsTransactionState</span></a><span class='Parentheses'>())</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We need the numeric replication origin to be 16bit wide, so we cannot 
     * rely on the normal oid allocation. Instead we simply scan 
     * pg_replication_origin for the first unused id. That's not particularly 
     * efficient, but this should be a fairly infrequent operation - we can 
     * easily spend a bit more code on this when it turns out it needs to be 
     * faster. 
     * 
     * We handle concurrency by taking an exclusive lock (allowing reads!) 
     * over the table for the duration of the search. Because we use a "dirty 
     * snapshot" we can read rows that other in-progress sessions have 
     * written, even though they would be invisible with normal snapshots. Due 
     * to the exclusive lock there's no danger that new rows can appear while 
     * we're checking. 
     */ 
</span>    <a href="../../../include/utils/tqual.h.html#LN99"><span class='Ref_to_Macro'>InitDirtySnapshot</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN240"><span class='Ref_To_Local'>SnapshotDirty</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="origin.c.html#LN238"><span class='Ref_To_Local'>rel</span></a> <span class='Operator'>= </span><a href="../../../include/access/heapam.h.html#LN91"><span class='Ref_to_Proto'>heap_open</span></a><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_replication_origin.h.html#LN27"><span class='Ref_to_Const'>ReplicationOriginRelationId</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lockdefs.h.html#LN43"><span class='Ref_to_Const'>ExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN236"><span class='Ref_To_Local'>roident</span></a> <span class='Operator'>= </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="origin.c.html#LN236"><span class='Ref_To_Local'>roident</span></a> <span class='Operator'>&LT; </span><a href="../../../include/c.h.html#LN337"><span class='Ref_to_Const'>PG_UINT16_MAX</span></a><span class='Delimiter'>; </span><a href="origin.c.html#LN236"><span class='Ref_To_Local'>roident</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN269"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>nulls</span><span class='Delimiter'>[</span><a href="../../../include/catalog/pg_replication_origin.h.html#LN60"><span class='Ref_to_Const'>Natts_pg_replication_origin</span></a><span class='Delimiter'>]; 
</span><a name="LN270"></a>        <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>values</span><span class='Delimiter'>[</span><a href="../../../include/catalog/pg_replication_origin.h.html#LN60"><span class='Ref_to_Const'>Natts_pg_replication_origin</span></a><span class='Delimiter'>]; 
</span><a name="LN271"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>collides</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/miscadmin.h.html#LN99"><span class='Ref_to_Macro'>CHECK_FOR_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <a href="../../access/common/scankey.c.html#LN74"><span class='Ref_to_Func'>ScanKeyInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="origin.c.html#LN242"><span class='Ref_To_Local'>key</span></a><span class='Delimiter'>, 
</span>                    <a href="../../../include/catalog/pg_replication_origin.h.html#LN61"><span class='Ref_to_Const'>Anum_pg_replication_origin_roident</span></a><span class='Delimiter'>, 
</span>                    <a href="../../../include/access/stratnum.h.html#LN30"><span class='Ref_to_Const'>BTEqualStrategyNumber</span></a><span class='Delimiter'>, </span>F_OIDEQ<span class='Delimiter'>, 
</span>                    <a href="../../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN236"><span class='Ref_To_Local'>roident</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <a href="origin.c.html#LN241"><span class='Ref_To_Local'>scan</span></a> <span class='Operator'>= </span><a href="../../../include/access/genam.h.html#LN189"><span class='Ref_to_Proto'>systable_beginscan</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN238"><span class='Ref_To_Local'>rel</span></a><span class='Delimiter'>, </span><a href="../../../include/catalog/indexing.h.html#LN332"><span class='Ref_to_Const'>ReplicationOriginIdentIndex</span></a><span class='Delimiter'>, 
</span>                                  <span class='Boolean'>true </span><span class='Comment_Multi_Line'>/* indexOK */ </span><span class='Delimiter'>, 
</span>                                  <span class='Operator'>&</span><a href="origin.c.html#LN240"><span class='Ref_To_Local'>SnapshotDirty</span></a><span class='Delimiter'>, 
</span>                                  <span class='Number'>1</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="origin.c.html#LN242"><span class='Ref_To_Local'>key</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="origin.c.html#LN271"><span class='Ref_To_Local'>collides</span></a> <span class='Operator'>= </span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="../../../include/access/genam.h.html#LN194"><span class='Ref_to_Proto'>systable_getnext</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN241"><span class='Ref_To_Local'>scan</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/access/genam.h.html#LN196"><span class='Ref_to_Proto'>systable_endscan</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN241"><span class='Ref_To_Local'>scan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="origin.c.html#LN271"><span class='Ref_To_Local'>collides</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Ok, found an unused roident, insert the new row and do a CCI, 
             * so our callers can look it up if they want to. 
             */ 
</span>            memset<span class='Parentheses'>(</span><span class='Operator'>&</span><a href="origin.c.html#LN269"><span class='Ref_To_Local'>nulls</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="origin.c.html#LN269"><span class='Ref_To_Local'>nulls</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <a href="origin.c.html#LN270"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><a href="../../../include/catalog/pg_replication_origin.h.html#LN61"><span class='Ref_to_Const'>Anum_pg_replication_origin_roident</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN236"><span class='Ref_To_Local'>roident</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="origin.c.html#LN270"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><a href="../../../include/catalog/pg_replication_origin.h.html#LN62"><span class='Ref_to_Const'>Anum_pg_replication_origin_roname</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="origin.c.html#LN239"><span class='Ref_To_Local'>roname_d</span></a><span class='Delimiter'>; 
</span> 
            <a href="origin.c.html#LN237"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><a href="../../access/common/heaptuple.c.html#LN690"><span class='Ref_to_Func'>heap_form_tuple</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/rel.h.html#LN428"><span class='Ref_to_Macro'>RelationGetDescr</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN238"><span class='Ref_To_Local'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="origin.c.html#LN270"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>, </span><a href="origin.c.html#LN269"><span class='Ref_To_Local'>nulls</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/catalog/indexing.h.html#LN32"><span class='Ref_to_Proto'>CatalogTupleInsert</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN238"><span class='Ref_To_Local'>rel</span></a><span class='Delimiter'>, </span><a href="origin.c.html#LN237"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/access/xact.h.html#LN346"><span class='Ref_to_Proto'>CommandCounterIncrement</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for roident=InvalidOid+1;... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* now release lock again,  */ 
</span>    <a href="../../../include/access/heapam.h.html#LN96"><span class='Ref_to_Macro'>heap_close</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN238"><span class='Ref_To_Local'>rel</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lockdefs.h.html#LN43"><span class='Ref_to_Const'>ExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN237"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_PROGRAM_LIMIT_EXCEEDED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not find free replication origin OID"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/access/htup_details.h.html#LN815"><span class='Ref_to_Proto'>heap_freetuple</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN237"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="origin.c.html#LN236"><span class='Ref_To_Local'>roident</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end replorigin_create &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Drop replication origin. 
 * 
 * Needs to be called in a transaction. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN326"></a><span class='Declare_Function'>replorigin_drop</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN50"><span class='Ref_to_Typedef'>RepOriginId</span></a> <span class='Declare_Parameter'>roident</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN328"></a>    <a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>tuple</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN329"></a>    <a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>rel</span><span class='Delimiter'>; 
</span><a name="LN330"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/xact.h.html#LN329"><span class='Ref_to_Proto'>IsTransactionState</span></a><span class='Parentheses'>())</span><span class='Delimiter'>; 
</span> 
    <a href="origin.c.html#LN329"><span class='Ref_To_Local'>rel</span></a> <span class='Operator'>= </span><a href="../../../include/access/heapam.h.html#LN91"><span class='Ref_to_Proto'>heap_open</span></a><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_replication_origin.h.html#LN27"><span class='Ref_to_Const'>ReplicationOriginRelationId</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lockdefs.h.html#LN43"><span class='Ref_to_Const'>ExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* cleanup the slot state info */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ReplicationOriginLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN330"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="origin.c.html#LN330"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="../slot.c.html#LN98"><span class='Ref_to_Global_Var'>max_replication_slots</span></a><span class='Delimiter'>; </span><a href="origin.c.html#LN330"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN341"></a>        <a href="origin.c.html#LN102"><span class='Ref_to_Struct'>ReplicationState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>state</span> <span class='Operator'>= &</span><a href="origin.c.html#LN160"><span class='Ref_to_Global_Var'>replication_states</span></a><span class='Delimiter'>[</span><a href="origin.c.html#LN330"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Comment_Multi_Line'>/* found our slot */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN341"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN107"><span class='Ref_to_Member'>roident</span></a> <span class='Operator'>== </span><a href="origin.c.html#LN326"><span class='Ref_to_Parameter'>roident</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN341"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN124"><span class='Ref_to_Member'>acquired_by</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OBJECT_IN_USE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not drop replication origin with OID %d, in use by PID %d"</span><span class='Delimiter'>, 
</span>                                <a href="origin.c.html#LN341"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN107"><span class='Ref_to_Member'>roident</span></a><span class='Delimiter'>, 
</span>                                <a href="origin.c.html#LN341"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN124"><span class='Ref_to_Member'>acquired_by</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* first WAL log */ 
</span>            <span class='Delimiter'>{ 
</span><a name="LN357"></a>                <a href="../../../include/replication/origin.h.html#LN25"><span class='Ref_to_Struct'>xl_replorigin_drop</span></a> <span class='Declare_Local'>xlrec</span><span class='Delimiter'>; 
</span> 
                <a href="origin.c.html#LN357"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>.</span><a href="../../../include/replication/origin.h.html#LN27"><span class='Ref_to_Member'>node_id</span></a> <span class='Operator'>= </span><a href="origin.c.html#LN326"><span class='Ref_to_Parameter'>roident</span></a><span class='Delimiter'>; 
</span>                <a href="../../../include/access/xloginsert.h.html#LN41"><span class='Ref_to_Proto'>XLogBeginInsert</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>                <a href="../../../include/access/xloginsert.h.html#LN45"><span class='Ref_to_Proto'>XLogRegisterData</span></a><span class='Parentheses'>((</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) (</span><span class='Operator'>&</span><a href="origin.c.html#LN357"><span class='Ref_To_Local'>xlrec</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="origin.c.html#LN357"><span class='Ref_To_Local'>xlrec</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <a href="../../../include/access/xloginsert.h.html#LN43"><span class='Ref_to_Proto'>XLogInsert</span></a><span class='Parentheses'>(</span>RM_REPLORIGIN_ID<span class='Delimiter'>, </span><a href="../../../include/replication/origin.h.html#LN31"><span class='Ref_to_Const'>XLOG_REPLORIGIN_DROP</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* then reset the in-memory entry */ 
</span>            <a href="origin.c.html#LN341"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN107"><span class='Ref_to_Member'>roident</span></a> <span class='Operator'>= </span><a href="../../../include/replication/origin.h.html#LN33"><span class='Ref_to_Const'>InvalidRepOriginId</span></a><span class='Delimiter'>; 
</span>            <a href="origin.c.html#LN341"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN112"><span class='Ref_to_Member'>remote_lsn</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span>            <a href="origin.c.html#LN341"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN119"><span class='Ref_to_Member'>local_lsn</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if state-&GT;roident==roide... &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;max_replication... &raquo; </span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ReplicationOriginLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="origin.c.html#LN328"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><a href="../../../include/utils/syscache.h.html#LN155"><span class='Ref_to_Macro'>SearchSysCache1</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/syscache.h.html#LN84"><span class='Ref_to_EnumConst'>REPLORIGIDENT</span></a><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN326"><span class='Ref_to_Parameter'>roident</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN328"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>))</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for replication origin with oid %u"</span><span class='Delimiter'>, 
</span>             <a href="origin.c.html#LN326"><span class='Ref_to_Parameter'>roident</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/catalog/indexing.h.html#LN40"><span class='Ref_to_Proto'>CatalogTupleDelete</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN329"><span class='Ref_To_Local'>rel</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="origin.c.html#LN328"><span class='Ref_To_Local'>tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN64"><span class='Ref_to_Member'>t_self</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN328"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/access/xact.h.html#LN346"><span class='Ref_to_Proto'>CommandCounterIncrement</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* now release lock again,  */ 
</span>    <a href="../../../include/access/heapam.h.html#LN96"><span class='Ref_to_Macro'>heap_close</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN329"><span class='Ref_To_Local'>rel</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lockdefs.h.html#LN43"><span class='Ref_to_Const'>ExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end replorigin_drop &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Lookup replication origin via it's oid and return the name. 
 * 
 * The external name is palloc'd in the calling context. 
 * 
 * Returns true if the origin is known, false otherwise. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN397"></a><span class='Declare_Function'>replorigin_by_oid</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN50"><span class='Ref_to_Typedef'>RepOriginId</span></a> <span class='Declare_Parameter'>roident</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>missing_ok</span><span class='Delimiter'>, </span><span class='Keyword'>char </span><span class='Operator'>**</span><span class='Declare_Parameter'>roname</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN399"></a>    <a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>tuple</span><span class='Delimiter'>; 
</span><a name="LN400"></a>    <a href="../../../include/catalog/pg_replication_origin.h.html#LN54"><span class='Ref_to_Typedef'>Form_pg_replication_origin</span></a> <span class='Declare_Local'>ric</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>((</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a><span class='Parentheses'>) </span><a href="origin.c.html#LN397"><span class='Ref_to_Parameter'>roident</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="origin.c.html#LN397"><span class='Ref_to_Parameter'>roident</span></a> <span class='Operator'>!= </span><a href="../../../include/replication/origin.h.html#LN33"><span class='Ref_to_Const'>InvalidRepOriginId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="origin.c.html#LN397"><span class='Ref_to_Parameter'>roident</span></a> <span class='Operator'>!= </span><a href="../../../include/replication/origin.h.html#LN34"><span class='Ref_to_Const'>DoNotReplicateId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="origin.c.html#LN399"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><a href="../../../include/utils/syscache.h.html#LN155"><span class='Ref_to_Macro'>SearchSysCache1</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/syscache.h.html#LN84"><span class='Ref_to_EnumConst'>REPLORIGIDENT</span></a><span class='Delimiter'>, 
</span>                            <a href="../../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>((</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a><span class='Parentheses'>) </span><a href="origin.c.html#LN397"><span class='Ref_to_Parameter'>roident</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN399"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="origin.c.html#LN400"><span class='Ref_To_Local'>ric</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_replication_origin.h.html#LN54"><span class='Ref_to_Typedef'>Form_pg_replication_origin</span></a><span class='Parentheses'>) </span><a href="../../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN399"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="origin.c.html#LN397"><span class='Ref_to_Parameter'>roname</span></a> <span class='Operator'>= </span><a href="../../../include/utils/builtins.h.html#LN87"><span class='Ref_to_Proto'>text_to_cstring</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="origin.c.html#LN400"><span class='Ref_To_Local'>ric</span></a><span class='Operator'>-&GT;</span>roname<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN399"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Operator'>*</span><a href="origin.c.html#LN397"><span class='Ref_to_Parameter'>roname</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="origin.c.html#LN397"><span class='Ref_to_Parameter'>missing_ok</span></a><span class='Parentheses'>) 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for replication origin with oid %u"</span><span class='Delimiter'>, 
</span>                 <a href="origin.c.html#LN397"><span class='Ref_to_Parameter'>roident</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end replorigin_by_oid &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* --------------------------------------------------------------------------- 
 * Functions for handling replication progress. 
 * --------------------------------------------------------------------------- 
 */ 
</span> 
<a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a> 
<a name="LN436"></a><span class='Declare_Function'>ReplicationOriginShmemSize</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN438"></a>    <a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Local'>size</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * XXX: max_replication_slots is arguably the wrong thing to use, as here 
     * we keep the replay state of *remote* transactions. But for now it seems 
     * sufficient to reuse it, lest we introduce a separate GUC. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../slot.c.html#LN98"><span class='Ref_to_Global_Var'>max_replication_slots</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="origin.c.html#LN438"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>; 
</span> 
    <a href="origin.c.html#LN438"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN438"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN142"><span class='Ref_to_Struct'>ReplicationStateCtl</span></a><span class='Delimiter'>, </span>states<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="origin.c.html#LN438"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN438"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, 
</span>                  <a href="../../../include/storage/shmem.h.html#LN45"><span class='Ref_to_Proto'>mul_size</span></a><span class='Parentheses'>(</span><a href="../slot.c.html#LN98"><span class='Ref_to_Global_Var'>max_replication_slots</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="origin.c.html#LN102"><span class='Ref_to_Struct'>ReplicationState</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="origin.c.html#LN438"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>void 
</span><a name="LN456"></a><span class='Declare_Function'>ReplicationOriginShmemInit</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN458"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../slot.c.html#LN98"><span class='Ref_to_Global_Var'>max_replication_slots</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <a href="origin.c.html#LN161"><span class='Ref_to_Global_Var'>replication_states_ctl</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="origin.c.html#LN142"><span class='Ref_to_Struct'>ReplicationStateCtl</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/shmem.h.html#LN43"><span class='Ref_to_Proto'>ShmemInitStruct</span></a><span class='Parentheses'>(</span><span class='String'>"ReplicationOriginState"</span><span class='Delimiter'>, 
</span>                        <a href="../../../include/replication/origin.h.html#LN70"><span class='Ref_to_Proto'>ReplicationOriginShmemSize</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                        <span class='Operator'>&</span><a href="origin.c.html#LN458"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="origin.c.html#LN160"><span class='Ref_to_Global_Var'>replication_states</span></a> <span class='Operator'>= </span><a href="origin.c.html#LN161"><span class='Ref_to_Global_Var'>replication_states_ctl</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN145"><span class='Ref_to_Member'>states</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="origin.c.html#LN458"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN471"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
        <a href="origin.c.html#LN161"><span class='Ref_to_Global_Var'>replication_states_ctl</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN144"><span class='Ref_to_Member'>tranche_id</span></a> <span class='Operator'>= </span><a href="../../../include/storage/lwlock.h.html#LN207"><span class='Ref_to_EnumConst'>LWTRANCHE_REPLICATION_ORIGIN</span></a><span class='Delimiter'>; 
</span> 
        <a href="../../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN160"><span class='Ref_to_Global_Var'>replication_states</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><a href="../../../include/replication/origin.h.html#LN70"><span class='Ref_to_Proto'>ReplicationOriginShmemSize</span></a><span class='Parentheses'>())</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN471"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="origin.c.html#LN471"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="../slot.c.html#LN98"><span class='Ref_to_Global_Var'>max_replication_slots</span></a><span class='Delimiter'>; </span><a href="origin.c.html#LN471"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <a href="../../../include/storage/lwlock.h.html#LN187"><span class='Ref_to_Proto'>LWLockInitialize</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="origin.c.html#LN160"><span class='Ref_to_Global_Var'>replication_states</span></a><span class='Delimiter'>[</span><a href="origin.c.html#LN471"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="origin.c.html#LN129"><span class='Ref_to_Member'>lock</span></a><span class='Delimiter'>, 
</span>                             <a href="origin.c.html#LN161"><span class='Ref_to_Global_Var'>replication_states_ctl</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN144"><span class='Ref_to_Member'>tranche_id</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN186"><span class='Ref_to_Proto'>LWLockRegisterTranche</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN161"><span class='Ref_to_Global_Var'>replication_states_ctl</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN144"><span class='Ref_to_Member'>tranche_id</span></a><span class='Delimiter'>, 
</span>                          <span class='String'>"replication_origin"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ReplicationOriginShmemInit &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* --------------------------------------------------------------------------- 
 * Perform a checkpoint of each replication origin's progress with respect to 
 * the replayed remote_lsn. Make sure that all transactions we refer to in the 
 * checkpoint (local_lsn) are actually on-disk. This might not yet be the case 
 * if the transactions were originally committed asynchronously. 
 * 
 * We store checkpoints in the following format: 
 * +-------+------------------------+------------------+-----+--------+ 
 * | MAGIC | ReplicationStateOnDisk | struct Replic... | ... | CRC32C | EOF 
 * +-------+------------------------+------------------+-----+--------+ 
 * 
 * So its just the magic, followed by the statically sized 
 * ReplicationStateOnDisk structs. Note that the maximum number of 
 * ReplicationState is determined by max_replication_slots. 
 * --------------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN503"></a><span class='Declare_Function'>CheckPointReplicationOrigin</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN505"></a>    <span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Local'>tmppath</span> <span class='Operator'>= </span><span class='String'>"pg_logical/replorigin_checkpoint.tmp"</span><span class='Delimiter'>; 
</span><a name="LN506"></a>    <span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Local'>path</span> <span class='Operator'>= </span><span class='String'>"pg_logical/replorigin_checkpoint"</span><span class='Delimiter'>; 
</span><a name="LN507"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>tmpfd</span><span class='Delimiter'>; 
</span><a name="LN508"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN509"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>magic</span> <span class='Operator'>= </span><a href="origin.c.html#LN171"><span class='Ref_to_Const'>REPLICATION_STATE_MAGIC</span></a><span class='Delimiter'>; 
</span><a name="LN510"></a>    <a href="../../../include/port/pg_crc32c.h.html#LN37"><span class='Ref_to_Typedef'>pg_crc32c</span></a>   <span class='Declare_Local'>crc</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../slot.c.html#LN98"><span class='Ref_to_Global_Var'>max_replication_slots</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/port/pg_crc32c.h.html#LN40"><span class='Ref_to_Macro'>INIT_CRC32C</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN510"><span class='Ref_To_Local'>crc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* make sure no old temp file is remaining */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../timezone/private.h.html#LN59"><span class='Ref_to_Proto'>unlink</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN505"><span class='Ref_To_Local'>tmppath</span></a><span class='Parentheses'>) </span><span class='Operator'>&LT; </span><span class='Number'>0</span> <span class='Operator'>&& </span>errno <span class='Operator'>!= </span>ENOENT<span class='Parentheses'>)</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not remove file \"%s\": %m"</span><span class='Delimiter'>, 
</span>                        <a href="origin.c.html#LN505"><span class='Ref_To_Local'>tmppath</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * no other backend can perform this at the same time, we're protected by 
     * CheckpointLock. 
     */ 
</span>    <a href="origin.c.html#LN507"><span class='Ref_To_Local'>tmpfd</span></a> <span class='Operator'>= </span><a href="../../../include/storage/fd.h.html#LN96"><span class='Ref_to_Proto'>OpenTransientFile</span></a><span class='Parentheses'>((</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="origin.c.html#LN505"><span class='Ref_To_Local'>tmppath</span></a><span class='Delimiter'>, 
</span>                              O_CREAT <span class='Operator'>| </span>O_EXCL <span class='Operator'>| </span>O_WRONLY <span class='Operator'>| </span><a href="../../../include/c.h.html#LN1032"><span class='Ref_to_Const'>PG_BINARY</span></a><span class='Delimiter'>, 
</span>                              <a href="../../../include/port/win32.h.html#LN424"><span class='Ref_to_Const'>S_IRUSR</span></a> <span class='Operator'>| </span><a href="../../../include/port/win32.h.html#LN425"><span class='Ref_to_Const'>S_IWUSR</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN507"><span class='Ref_To_Local'>tmpfd</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not create file \"%s\": %m"</span><span class='Delimiter'>, 
</span>                        <a href="origin.c.html#LN505"><span class='Ref_To_Local'>tmppath</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* write magic */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="../../../interfaces/libpq/win32.h.html#LN13"><span class='Ref_to_Macro'>write</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN507"><span class='Ref_To_Local'>tmpfd</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="origin.c.html#LN509"><span class='Ref_To_Local'>magic</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="origin.c.html#LN509"><span class='Ref_To_Local'>magic</span></a><span class='Parentheses'>)))</span> <span class='Operator'>!= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="origin.c.html#LN509"><span class='Ref_To_Local'>magic</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/storage/fd.h.html#LN97"><span class='Ref_to_Proto'>CloseTransientFile</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN507"><span class='Ref_To_Local'>tmpfd</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not write to file \"%s\": %m"</span><span class='Delimiter'>, 
</span>                        <a href="origin.c.html#LN505"><span class='Ref_To_Local'>tmppath</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../../include/port/pg_crc32c.h.html#LN45"><span class='Ref_to_Macro'>COMP_CRC32C</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN510"><span class='Ref_To_Local'>crc</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="origin.c.html#LN509"><span class='Ref_To_Local'>magic</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="origin.c.html#LN509"><span class='Ref_To_Local'>magic</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* prevent concurrent creations/drops */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ReplicationOriginLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* write actual data */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN508"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="origin.c.html#LN508"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="../slot.c.html#LN98"><span class='Ref_to_Global_Var'>max_replication_slots</span></a><span class='Delimiter'>; </span><a href="origin.c.html#LN508"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN554"></a>        <a href="origin.c.html#LN135"><span class='Ref_to_Struct'>ReplicationStateOnDisk</span></a> <span class='Declare_Local'>disk_state</span><span class='Delimiter'>; 
</span><a name="LN555"></a>        <a href="origin.c.html#LN102"><span class='Ref_to_Struct'>ReplicationState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>curstate</span> <span class='Operator'>= &</span><a href="origin.c.html#LN160"><span class='Ref_to_Global_Var'>replication_states</span></a><span class='Delimiter'>[</span><a href="origin.c.html#LN508"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span><a name="LN556"></a>        <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>local_lsn</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN555"><span class='Ref_To_Local'>curstate</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN107"><span class='Ref_to_Member'>roident</span></a> <span class='Operator'>== </span><a href="../../../include/replication/origin.h.html#LN33"><span class='Ref_to_Const'>InvalidRepOriginId</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* zero, to avoid uninitialized padding bytes */ 
</span>        memset<span class='Parentheses'>(</span><span class='Operator'>&</span><a href="origin.c.html#LN554"><span class='Ref_To_Local'>disk_state</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="origin.c.html#LN554"><span class='Ref_To_Local'>disk_state</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="origin.c.html#LN555"><span class='Ref_To_Local'>curstate</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN129"><span class='Ref_to_Member'>lock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="origin.c.html#LN554"><span class='Ref_To_Local'>disk_state</span></a><span class='Operator'>.</span><a href="origin.c.html#LN137"><span class='Ref_to_Member'>roident</span></a> <span class='Operator'>= </span><a href="origin.c.html#LN555"><span class='Ref_To_Local'>curstate</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN107"><span class='Ref_to_Member'>roident</span></a><span class='Delimiter'>; 
</span> 
        <a href="origin.c.html#LN554"><span class='Ref_To_Local'>disk_state</span></a><span class='Operator'>.</span><a href="origin.c.html#LN138"><span class='Ref_to_Member'>remote_lsn</span></a> <span class='Operator'>= </span><a href="origin.c.html#LN555"><span class='Ref_To_Local'>curstate</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN112"><span class='Ref_to_Member'>remote_lsn</span></a><span class='Delimiter'>; 
</span>        <a href="origin.c.html#LN556"><span class='Ref_To_Local'>local_lsn</span></a> <span class='Operator'>= </span><a href="origin.c.html#LN555"><span class='Ref_To_Local'>curstate</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN119"><span class='Ref_to_Member'>local_lsn</span></a><span class='Delimiter'>; 
</span> 
        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="origin.c.html#LN555"><span class='Ref_To_Local'>curstate</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN129"><span class='Ref_to_Member'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* make sure we only write out a commit that's persistent */ 
</span>        <a href="../../../include/access/xlog.h.html#LN225"><span class='Ref_to_Proto'>XLogFlush</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN556"><span class='Ref_To_Local'>local_lsn</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="../../../interfaces/libpq/win32.h.html#LN13"><span class='Ref_to_Macro'>write</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN507"><span class='Ref_To_Local'>tmpfd</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="origin.c.html#LN554"><span class='Ref_To_Local'>disk_state</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="origin.c.html#LN554"><span class='Ref_To_Local'>disk_state</span></a><span class='Parentheses'>)))</span> <span class='Operator'>!= 
</span>            <span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="origin.c.html#LN554"><span class='Ref_To_Local'>disk_state</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../../include/storage/fd.h.html#LN97"><span class='Ref_to_Proto'>CloseTransientFile</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN507"><span class='Ref_To_Local'>tmpfd</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not write to file \"%s\": %m"</span><span class='Delimiter'>, 
</span>                            <a href="origin.c.html#LN505"><span class='Ref_To_Local'>tmppath</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="../../../include/port/pg_crc32c.h.html#LN45"><span class='Ref_to_Macro'>COMP_CRC32C</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN510"><span class='Ref_To_Local'>crc</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="origin.c.html#LN554"><span class='Ref_To_Local'>disk_state</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="origin.c.html#LN554"><span class='Ref_To_Local'>disk_state</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;max_replication... &raquo; </span> 
 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ReplicationOriginLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* write out the CRC */ 
</span>    <a href="../../../include/port/pg_crc32c.h.html#LN47"><span class='Ref_to_Macro'>FIN_CRC32C</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN510"><span class='Ref_To_Local'>crc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="../../../interfaces/libpq/win32.h.html#LN13"><span class='Ref_to_Macro'>write</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN507"><span class='Ref_To_Local'>tmpfd</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="origin.c.html#LN510"><span class='Ref_To_Local'>crc</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="origin.c.html#LN510"><span class='Ref_To_Local'>crc</span></a><span class='Parentheses'>)))</span> <span class='Operator'>!= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="origin.c.html#LN510"><span class='Ref_To_Local'>crc</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/storage/fd.h.html#LN97"><span class='Ref_to_Proto'>CloseTransientFile</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN507"><span class='Ref_To_Local'>tmpfd</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not write to file \"%s\": %m"</span><span class='Delimiter'>, 
</span>                        <a href="origin.c.html#LN505"><span class='Ref_To_Local'>tmppath</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/storage/fd.h.html#LN97"><span class='Ref_to_Proto'>CloseTransientFile</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN507"><span class='Ref_To_Local'>tmpfd</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* fsync, rename to permanent file, fsync file and directory */ 
</span>    <a href="../../../include/common/file_utils.h.html#LN22"><span class='Ref_to_Proto'>durable_rename</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN505"><span class='Ref_To_Local'>tmppath</span></a><span class='Delimiter'>, </span><a href="origin.c.html#LN506"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end CheckPointReplicationOrigin &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Recover replication replay status from checkpoint data saved earlier by 
 * CheckPointReplicationOrigin. 
 * 
 * This only needs to be called at startup and *not* during every checkpoint 
 * read during recovery (e.g. in HS or PITR from a base backup) afterwards. All 
 * state thereafter can be recovered by looking at commit records. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN617"></a><span class='Declare_Function'>StartupReplicationOrigin</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN619"></a>    <span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Local'>path</span> <span class='Operator'>= </span><span class='String'>"pg_logical/replorigin_checkpoint"</span><span class='Delimiter'>; 
</span><a name="LN620"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>fd</span><span class='Delimiter'>; 
</span><a name="LN621"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>readBytes</span><span class='Delimiter'>; 
</span><a name="LN622"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>magic</span> <span class='Operator'>= </span><a href="origin.c.html#LN171"><span class='Ref_to_Const'>REPLICATION_STATE_MAGIC</span></a><span class='Delimiter'>; 
</span><a name="LN623"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>last_state</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN624"></a>    <a href="../../../include/port/pg_crc32c.h.html#LN37"><span class='Ref_to_Typedef'>pg_crc32c</span></a>   <span class='Declare_Local'>file_crc</span><span class='Delimiter'>; 
</span><a name="LN625"></a>    <a href="../../../include/port/pg_crc32c.h.html#LN37"><span class='Ref_to_Typedef'>pg_crc32c</span></a>   <span class='Declare_Local'>crc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* don't want to overwrite already existing state */ 
</span><span class='Directive'>#ifdef</span> USE_ASSERT_CHECKING 
<a name="LN629"></a>    <span class='Keyword'>static bool </span><span class='Declare_Local'>already_started</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="origin.c.html#LN629"><span class='Ref_To_Local'>already_started</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="origin.c.html#LN629"><span class='Ref_To_Local'>already_started</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../slot.c.html#LN98"><span class='Ref_to_Global_Var'>max_replication_slots</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/port/pg_crc32c.h.html#LN40"><span class='Ref_to_Macro'>INIT_CRC32C</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN625"><span class='Ref_To_Local'>crc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, </span><span class='String'>"starting up replication origin progress state"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="origin.c.html#LN620"><span class='Ref_To_Local'>fd</span></a> <span class='Operator'>= </span><a href="../../../include/storage/fd.h.html#LN96"><span class='Ref_to_Proto'>OpenTransientFile</span></a><span class='Parentheses'>((</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="origin.c.html#LN619"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span>O_RDONLY <span class='Operator'>| </span><a href="../../../include/c.h.html#LN1032"><span class='Ref_to_Const'>PG_BINARY</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * might have had max_replication_slots == 0 last run, or we just brought 
     * up a standby. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN620"><span class='Ref_To_Local'>fd</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span> <span class='Operator'>&& </span>errno <span class='Operator'>== </span>ENOENT<span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN620"><span class='Ref_To_Local'>fd</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not open file \"%s\": %m"</span><span class='Delimiter'>, 
</span>                        <a href="origin.c.html#LN619"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* verify magic, that is written even if nothing was active */ 
</span>    <a href="origin.c.html#LN621"><span class='Ref_To_Local'>readBytes</span></a> <span class='Operator'>= </span><a href="../../../interfaces/libpq/win32.h.html#LN12"><span class='Ref_to_Macro'>read</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN620"><span class='Ref_To_Local'>fd</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="origin.c.html#LN622"><span class='Ref_To_Local'>magic</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="origin.c.html#LN622"><span class='Ref_To_Local'>magic</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN621"><span class='Ref_To_Local'>readBytes</span></a> <span class='Operator'>!= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="origin.c.html#LN622"><span class='Ref_To_Local'>magic</span></a><span class='Parentheses'>))</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not read file \"%s\": %m"</span><span class='Delimiter'>, 
</span>                        <a href="origin.c.html#LN619"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/port/pg_crc32c.h.html#LN45"><span class='Ref_to_Macro'>COMP_CRC32C</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN625"><span class='Ref_To_Local'>crc</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="origin.c.html#LN622"><span class='Ref_To_Local'>magic</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="origin.c.html#LN622"><span class='Ref_To_Local'>magic</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN622"><span class='Ref_To_Local'>magic</span></a> <span class='Operator'>!= </span><a href="origin.c.html#LN171"><span class='Ref_to_Const'>REPLICATION_STATE_MAGIC</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>           <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"replication checkpoint has wrong magic %u instead of %u"</span><span class='Delimiter'>, 
</span>                   <a href="origin.c.html#LN622"><span class='Ref_To_Local'>magic</span></a><span class='Delimiter'>, </span><a href="origin.c.html#LN171"><span class='Ref_to_Const'>REPLICATION_STATE_MAGIC</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* we can skip locking here, no other access is possible */ 
</span> 
    <span class='Comment_Multi_Line'>/* recover individual states, until there are no more to be found */ 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN674"></a>        <a href="origin.c.html#LN135"><span class='Ref_to_Struct'>ReplicationStateOnDisk</span></a> <span class='Declare_Local'>disk_state</span><span class='Delimiter'>; 
</span> 
        <a href="origin.c.html#LN621"><span class='Ref_To_Local'>readBytes</span></a> <span class='Operator'>= </span><a href="../../../interfaces/libpq/win32.h.html#LN12"><span class='Ref_to_Macro'>read</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN620"><span class='Ref_To_Local'>fd</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="origin.c.html#LN674"><span class='Ref_To_Local'>disk_state</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="origin.c.html#LN674"><span class='Ref_To_Local'>disk_state</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* no further data */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN621"><span class='Ref_To_Local'>readBytes</span></a> <span class='Operator'>== </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="origin.c.html#LN625"><span class='Ref_To_Local'>crc</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* not pretty, but simple ... */ 
</span>            <a href="origin.c.html#LN624"><span class='Ref_To_Local'>file_crc</span></a> <span class='Operator'>= *</span><span class='Parentheses'>(</span><a href="../../../include/port/pg_crc32c.h.html#LN37"><span class='Ref_to_Typedef'>pg_crc32c</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="origin.c.html#LN674"><span class='Ref_To_Local'>disk_state</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN621"><span class='Ref_To_Local'>readBytes</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not read file \"%s\": %m"</span><span class='Delimiter'>, 
</span>                            <a href="origin.c.html#LN619"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN621"><span class='Ref_To_Local'>readBytes</span></a> <span class='Operator'>!= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="origin.c.html#LN674"><span class='Ref_To_Local'>disk_state</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not read file \"%s\": read %d of %zu"</span><span class='Delimiter'>, 
</span>                            <a href="origin.c.html#LN619"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span><a href="origin.c.html#LN621"><span class='Ref_To_Local'>readBytes</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="origin.c.html#LN674"><span class='Ref_To_Local'>disk_state</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="../../../include/port/pg_crc32c.h.html#LN45"><span class='Ref_to_Macro'>COMP_CRC32C</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN625"><span class='Ref_To_Local'>crc</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="origin.c.html#LN674"><span class='Ref_To_Local'>disk_state</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="origin.c.html#LN674"><span class='Ref_To_Local'>disk_state</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN623"><span class='Ref_To_Local'>last_state</span></a> <span class='Operator'>== </span><a href="../slot.c.html#LN98"><span class='Ref_to_Global_Var'>max_replication_slots</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_CONFIGURATION_LIMIT_EXCEEDED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not find free replication state, increase max_replication_slots"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* copy data to shared memory */ 
</span>        <a href="origin.c.html#LN160"><span class='Ref_to_Global_Var'>replication_states</span></a><span class='Delimiter'>[</span><a href="origin.c.html#LN623"><span class='Ref_To_Local'>last_state</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="origin.c.html#LN107"><span class='Ref_to_Member'>roident</span></a> <span class='Operator'>= </span><a href="origin.c.html#LN674"><span class='Ref_To_Local'>disk_state</span></a><span class='Operator'>.</span><a href="origin.c.html#LN137"><span class='Ref_to_Member'>roident</span></a><span class='Delimiter'>; 
</span>        <a href="origin.c.html#LN160"><span class='Ref_to_Global_Var'>replication_states</span></a><span class='Delimiter'>[</span><a href="origin.c.html#LN623"><span class='Ref_To_Local'>last_state</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="origin.c.html#LN112"><span class='Ref_to_Member'>remote_lsn</span></a> <span class='Operator'>= </span><a href="origin.c.html#LN674"><span class='Ref_To_Local'>disk_state</span></a><span class='Operator'>.</span><a href="origin.c.html#LN138"><span class='Ref_to_Member'>remote_lsn</span></a><span class='Delimiter'>; 
</span>        <a href="origin.c.html#LN623"><span class='Ref_To_Local'>last_state</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, </span><span class='String'>"recovered replication state of node %u to %X/%X"</span><span class='Delimiter'>, 
</span>             <a href="origin.c.html#LN674"><span class='Ref_To_Local'>disk_state</span></a><span class='Operator'>.</span><a href="origin.c.html#LN137"><span class='Ref_to_Member'>roident</span></a><span class='Delimiter'>, 
</span>             <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="origin.c.html#LN674"><span class='Ref_To_Local'>disk_state</span></a><span class='Operator'>.</span><a href="origin.c.html#LN138"><span class='Ref_to_Member'>remote_lsn</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>             <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="origin.c.html#LN674"><span class='Ref_To_Local'>disk_state</span></a><span class='Operator'>.</span><a href="origin.c.html#LN138"><span class='Ref_to_Member'>remote_lsn</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while true &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* now check checksum */ 
</span>    <a href="../../../include/port/pg_crc32c.h.html#LN47"><span class='Ref_to_Macro'>FIN_CRC32C</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN625"><span class='Ref_To_Local'>crc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN624"><span class='Ref_To_Local'>file_crc</span></a> <span class='Operator'>!= </span><a href="origin.c.html#LN625"><span class='Ref_To_Local'>crc</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_CONFIGURATION_LIMIT_EXCEEDED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"replication slot checkpoint has wrong checksum %u, expected %u"</span><span class='Delimiter'>, 
</span>                        <a href="origin.c.html#LN625"><span class='Ref_To_Local'>crc</span></a><span class='Delimiter'>, </span><a href="origin.c.html#LN624"><span class='Ref_To_Local'>file_crc</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/fd.h.html#LN97"><span class='Ref_to_Proto'>CloseTransientFile</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN620"><span class='Ref_To_Local'>fd</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end StartupReplicationOrigin &raquo; </span> 
 
<span class='Keyword'>void 
</span><a name="LN732"></a><span class='Declare_Function'>replorigin_redo</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogreader.h.html#LN68"><span class='Ref_to_Struct'>XLogReaderState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>record</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN734"></a>    <a href="../../../include/c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a>       <span class='Declare_Local'>info</span> <span class='Operator'>= </span><a href="../../../include/access/xlogreader.h.html#LN215"><span class='Ref_to_Macro'>XLogRecGetInfo</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN732"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>) </span><span class='Operator'>& ~</span><a href="../../../include/access/xlogrecord.h.html#LN61"><span class='Ref_to_Const'>XLR_INFO_MASK</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN734"><span class='Ref_To_Local'>info</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../../include/replication/origin.h.html#LN30"><span class='Ref_to_Const'>XLOG_REPLORIGIN_SET</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span><a name="LN740"></a>                <a href="../../../include/replication/origin.h.html#LN18"><span class='Ref_to_Struct'>xl_replorigin_set</span></a> <span class='Operator'>*</span><span class='Declare_Local'>xlrec</span> <span class='Operator'>= 
</span>                <span class='Parentheses'>(</span><a href="../../../include/replication/origin.h.html#LN18"><span class='Ref_to_Struct'>xl_replorigin_set</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/access/xlogreader.h.html#LN219"><span class='Ref_to_Macro'>XLogRecGetData</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN732"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="../../../include/replication/origin.h.html#LN48"><span class='Ref_to_Proto'>replorigin_advance</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN740"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>-&GT;</span><a href="../../../include/replication/origin.h.html#LN21"><span class='Ref_to_Member'>node_id</span></a><span class='Delimiter'>, 
</span>                                   <a href="origin.c.html#LN740"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>-&GT;</span><a href="../../../include/replication/origin.h.html#LN20"><span class='Ref_to_Member'>remote_lsn</span></a><span class='Delimiter'>, </span><a href="origin.c.html#LN732"><span class='Ref_to_Parameter'>record</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogreader.h.html#LN114"><span class='Ref_to_Member'>EndRecPtr</span></a><span class='Delimiter'>, 
</span>                                   <a href="origin.c.html#LN740"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>-&GT;</span><a href="../../../include/replication/origin.h.html#LN22"><span class='Ref_to_Member'>force</span></a> <span class='Comment_Multi_Line'>/* backward */ </span><span class='Delimiter'>, 
</span>                                   <span class='Boolean'>false </span><span class='Comment_Multi_Line'>/* WAL log */ </span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Control'>case</span> <a href="../../../include/replication/origin.h.html#LN31"><span class='Ref_to_Const'>XLOG_REPLORIGIN_DROP</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span><a name="LN751"></a>                <a href="../../../include/replication/origin.h.html#LN25"><span class='Ref_to_Struct'>xl_replorigin_drop</span></a> <span class='Operator'>*</span><span class='Declare_Local'>xlrec</span><span class='Delimiter'>; 
</span><a name="LN752"></a>                <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
                <a href="origin.c.html#LN751"><span class='Ref_To_Local'>xlrec</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/replication/origin.h.html#LN25"><span class='Ref_to_Struct'>xl_replorigin_drop</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/access/xlogreader.h.html#LN219"><span class='Ref_to_Macro'>XLogRecGetData</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN732"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN752"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="origin.c.html#LN752"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="../slot.c.html#LN98"><span class='Ref_to_Global_Var'>max_replication_slots</span></a><span class='Delimiter'>; </span><a href="origin.c.html#LN752"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN758"></a>                    <a href="origin.c.html#LN102"><span class='Ref_to_Struct'>ReplicationState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>state</span> <span class='Operator'>= &</span><a href="origin.c.html#LN160"><span class='Ref_to_Global_Var'>replication_states</span></a><span class='Delimiter'>[</span><a href="origin.c.html#LN752"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
                    <span class='Comment_Multi_Line'>/* found our slot */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN758"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN107"><span class='Ref_to_Member'>roident</span></a> <span class='Operator'>== </span><a href="origin.c.html#LN751"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>-&GT;</span><a href="../../../include/replication/origin.h.html#LN27"><span class='Ref_to_Member'>node_id</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Comment_Multi_Line'>/* reset entry */ 
</span>                        <a href="origin.c.html#LN758"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN107"><span class='Ref_to_Member'>roident</span></a> <span class='Operator'>= </span><a href="../../../include/replication/origin.h.html#LN33"><span class='Ref_to_Const'>InvalidRepOriginId</span></a><span class='Delimiter'>; 
</span>                        <a href="origin.c.html#LN758"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN112"><span class='Ref_to_Member'>remote_lsn</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span>                        <a href="origin.c.html#LN758"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN119"><span class='Ref_to_Member'>local_lsn</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span>                        <span class='Control'>break</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Control'>default</span><span class='Operator'>: 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, </span><span class='String'>"replorigin_redo: unknown op code %u"</span><span class='Delimiter'>, </span><a href="origin.c.html#LN734"><span class='Ref_To_Local'>info</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch info &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end replorigin_redo &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Tell the replication origin progress machinery that a commit from 'node' 
 * that originated at the LSN remote_commit on the remote node was replayed 
 * successfully and that we don't need to do so again. In combination with 
 * setting up replorigin_session_origin_lsn and replorigin_session_origin 
 * that ensures we won't loose knowledge about that after a crash if the 
 * transaction had a persistent effect (think of asynchronous commits). 
 * 
 * local_commit needs to be a local LSN of the commit so that we can make sure 
 * upon a checkpoint that enough WAL has been persisted to disk. 
 * 
 * Needs to be called with a RowExclusiveLock on pg_replication_origin, 
 * unless running in recovery. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN793"></a><span class='Declare_Function'>replorigin_advance</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN50"><span class='Ref_to_Typedef'>RepOriginId</span></a> <span class='Declare_Parameter'>node</span><span class='Delimiter'>, 
</span><a name="LN794"></a>                   <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>remote_commit</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>local_commit</span><span class='Delimiter'>, 
</span><a name="LN795"></a>                   <span class='Keyword'>bool </span><span class='Declare_Parameter'>go_backward</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>wal_log</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN797"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN798"></a>    <a href="origin.c.html#LN102"><span class='Ref_to_Struct'>ReplicationState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>replication_state</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN799"></a>    <a href="origin.c.html#LN102"><span class='Ref_to_Struct'>ReplicationState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>free_state</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="origin.c.html#LN793"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>!= </span><a href="../../../include/replication/origin.h.html#LN33"><span class='Ref_to_Const'>InvalidRepOriginId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* we don't track DoNotReplicateId */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN793"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>== </span><a href="../../../include/replication/origin.h.html#LN34"><span class='Ref_to_Const'>DoNotReplicateId</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * XXX: For the case where this is called by WAL replay, it'd be more 
     * efficient to restore into a backend local hashtable and only dump into 
     * shmem after recovery is finished. Let's wait with implementing that 
     * till it's shown to be a measurable expense 
     */ 
</span> 
    <span class='Comment_Multi_Line'>/* Lock exclusively, as we may have to create a new table entry. */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ReplicationOriginLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Search for either an existing slot for the origin, or a free one we can 
     * use. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN797"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="origin.c.html#LN797"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="../slot.c.html#LN98"><span class='Ref_to_Global_Var'>max_replication_slots</span></a><span class='Delimiter'>; </span><a href="origin.c.html#LN797"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN823"></a>        <a href="origin.c.html#LN102"><span class='Ref_to_Struct'>ReplicationState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>curstate</span> <span class='Operator'>= &</span><a href="origin.c.html#LN160"><span class='Ref_to_Global_Var'>replication_states</span></a><span class='Delimiter'>[</span><a href="origin.c.html#LN797"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Comment_Multi_Line'>/* remember where to insert if necessary */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN823"><span class='Ref_To_Local'>curstate</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN107"><span class='Ref_to_Member'>roident</span></a> <span class='Operator'>== </span><a href="../../../include/replication/origin.h.html#LN33"><span class='Ref_to_Const'>InvalidRepOriginId</span></a> <span class='Operator'>&& 
</span>            <a href="origin.c.html#LN799"><span class='Ref_To_Local'>free_state</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="origin.c.html#LN799"><span class='Ref_To_Local'>free_state</span></a> <span class='Operator'>= </span><a href="origin.c.html#LN823"><span class='Ref_To_Local'>curstate</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* not our slot */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN823"><span class='Ref_To_Local'>curstate</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN107"><span class='Ref_to_Member'>roident</span></a> <span class='Operator'>!= </span><a href="origin.c.html#LN793"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* ok, found slot */ 
</span>        <a href="origin.c.html#LN798"><span class='Ref_To_Local'>replication_state</span></a> <span class='Operator'>= </span><a href="origin.c.html#LN823"><span class='Ref_To_Local'>curstate</span></a><span class='Delimiter'>; 
</span> 
        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="origin.c.html#LN798"><span class='Ref_To_Local'>replication_state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN129"><span class='Ref_to_Member'>lock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Make sure it's not used by somebody else */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN798"><span class='Ref_To_Local'>replication_state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN124"><span class='Ref_to_Member'>acquired_by</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OBJECT_IN_USE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"replication origin with OID %d is already active for PID %d"</span><span class='Delimiter'>, 
</span>                            <a href="origin.c.html#LN798"><span class='Ref_To_Local'>replication_state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN107"><span class='Ref_to_Member'>roident</span></a><span class='Delimiter'>, 
</span>                            <a href="origin.c.html#LN798"><span class='Ref_To_Local'>replication_state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN124"><span class='Ref_to_Member'>acquired_by</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;max_replication... &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN798"><span class='Ref_To_Local'>replication_state</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>&& </span><a href="origin.c.html#LN799"><span class='Ref_To_Local'>free_state</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_CONFIGURATION_LIMIT_EXCEEDED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not find free replication state slot for replication origin with OID %u"</span><span class='Delimiter'>, 
</span>                        <a href="origin.c.html#LN793"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"Increase max_replication_slots and try again."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN798"><span class='Ref_To_Local'>replication_state</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* initialize new slot */ 
</span>        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="origin.c.html#LN799"><span class='Ref_To_Local'>free_state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN129"><span class='Ref_to_Member'>lock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="origin.c.html#LN798"><span class='Ref_To_Local'>replication_state</span></a> <span class='Operator'>= </span><a href="origin.c.html#LN799"><span class='Ref_To_Local'>free_state</span></a><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="origin.c.html#LN798"><span class='Ref_To_Local'>replication_state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN112"><span class='Ref_to_Member'>remote_lsn</span></a> <span class='Operator'>== </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="origin.c.html#LN798"><span class='Ref_To_Local'>replication_state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN119"><span class='Ref_to_Member'>local_lsn</span></a> <span class='Operator'>== </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="origin.c.html#LN798"><span class='Ref_To_Local'>replication_state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN107"><span class='Ref_to_Member'>roident</span></a> <span class='Operator'>= </span><a href="origin.c.html#LN793"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="origin.c.html#LN798"><span class='Ref_To_Local'>replication_state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN107"><span class='Ref_to_Member'>roident</span></a> <span class='Operator'>!= </span><a href="../../../include/replication/origin.h.html#LN33"><span class='Ref_to_Const'>InvalidRepOriginId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If somebody "forcefully" sets this slot, WAL log it, so it's durable 
     * and the standby gets the message. Primarily this will be called during 
     * WAL replay (of commit records) where no WAL logging is necessary. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN795"><span class='Ref_to_Parameter'>wal_log</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN883"></a>        <a href="../../../include/replication/origin.h.html#LN18"><span class='Ref_to_Struct'>xl_replorigin_set</span></a> <span class='Declare_Local'>xlrec</span><span class='Delimiter'>; 
</span> 
        <a href="origin.c.html#LN883"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>.</span><a href="../../../include/replication/origin.h.html#LN20"><span class='Ref_to_Member'>remote_lsn</span></a> <span class='Operator'>= </span><a href="origin.c.html#LN794"><span class='Ref_to_Parameter'>remote_commit</span></a><span class='Delimiter'>; 
</span>        <a href="origin.c.html#LN883"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>.</span><a href="../../../include/replication/origin.h.html#LN21"><span class='Ref_to_Member'>node_id</span></a> <span class='Operator'>= </span><a href="origin.c.html#LN793"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span>        <a href="origin.c.html#LN883"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>.</span><a href="../../../include/replication/origin.h.html#LN22"><span class='Ref_to_Member'>force</span></a> <span class='Operator'>= </span><a href="origin.c.html#LN795"><span class='Ref_to_Parameter'>go_backward</span></a><span class='Delimiter'>; 
</span> 
        <a href="../../../include/access/xloginsert.h.html#LN41"><span class='Ref_to_Proto'>XLogBeginInsert</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <a href="../../../include/access/xloginsert.h.html#LN45"><span class='Ref_to_Proto'>XLogRegisterData</span></a><span class='Parentheses'>((</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) (</span><span class='Operator'>&</span><a href="origin.c.html#LN883"><span class='Ref_To_Local'>xlrec</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="origin.c.html#LN883"><span class='Ref_To_Local'>xlrec</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/access/xloginsert.h.html#LN43"><span class='Ref_to_Proto'>XLogInsert</span></a><span class='Parentheses'>(</span>RM_REPLORIGIN_ID<span class='Delimiter'>, </span><a href="../../../include/replication/origin.h.html#LN30"><span class='Ref_to_Const'>XLOG_REPLORIGIN_SET</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Due to - harmless - race conditions during a checkpoint we could see 
     * values here that are older than the ones we already have in memory. 
     * Don't overwrite those. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN795"><span class='Ref_to_Parameter'>go_backward</span></a> <span class='Operator'>|| </span><a href="origin.c.html#LN798"><span class='Ref_To_Local'>replication_state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN112"><span class='Ref_to_Member'>remote_lsn</span></a> <span class='Operator'>&LT; </span><a href="origin.c.html#LN794"><span class='Ref_to_Parameter'>remote_commit</span></a><span class='Parentheses'>) 
</span>        <a href="origin.c.html#LN798"><span class='Ref_To_Local'>replication_state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN112"><span class='Ref_to_Member'>remote_lsn</span></a> <span class='Operator'>= </span><a href="origin.c.html#LN794"><span class='Ref_to_Parameter'>remote_commit</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN794"><span class='Ref_to_Parameter'>local_commit</span></a> <span class='Operator'>!= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a> <span class='Operator'>&& 
</span>        <span class='Parentheses'>(</span><a href="origin.c.html#LN795"><span class='Ref_to_Parameter'>go_backward</span></a> <span class='Operator'>|| </span><a href="origin.c.html#LN798"><span class='Ref_To_Local'>replication_state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN119"><span class='Ref_to_Member'>local_lsn</span></a> <span class='Operator'>&LT; </span><a href="origin.c.html#LN794"><span class='Ref_to_Parameter'>local_commit</span></a><span class='Parentheses'>))</span> 
        <a href="origin.c.html#LN798"><span class='Ref_To_Local'>replication_state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN119"><span class='Ref_to_Member'>local_lsn</span></a> <span class='Operator'>= </span><a href="origin.c.html#LN794"><span class='Ref_to_Parameter'>local_commit</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="origin.c.html#LN798"><span class='Ref_To_Local'>replication_state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN129"><span class='Ref_to_Member'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Release *after* changing the LSNs, slot isn't acquired and thus could 
     * otherwise be dropped anytime. 
     */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ReplicationOriginLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end replorigin_advance &raquo; </span> 
 
 
<a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> 
<a name="LN916"></a><span class='Declare_Function'>replorigin_get_progress</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN50"><span class='Ref_to_Typedef'>RepOriginId</span></a> <span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>flush</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN918"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN919"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>local_lsn</span> <span class='Operator'>= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span><a name="LN920"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>remote_lsn</span> <span class='Operator'>= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* prevent slots from being concurrently dropped */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ReplicationOriginLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN918"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="origin.c.html#LN918"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="../slot.c.html#LN98"><span class='Ref_to_Global_Var'>max_replication_slots</span></a><span class='Delimiter'>; </span><a href="origin.c.html#LN918"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN927"></a>        <a href="origin.c.html#LN102"><span class='Ref_to_Struct'>ReplicationState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>state</span><span class='Delimiter'>; 
</span> 
        <a href="origin.c.html#LN927"><span class='Ref_To_Local'>state</span></a> <span class='Operator'>= &</span><a href="origin.c.html#LN160"><span class='Ref_to_Global_Var'>replication_states</span></a><span class='Delimiter'>[</span><a href="origin.c.html#LN918"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN927"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN107"><span class='Ref_to_Member'>roident</span></a> <span class='Operator'>== </span><a href="origin.c.html#LN916"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="origin.c.html#LN927"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN129"><span class='Ref_to_Member'>lock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="origin.c.html#LN920"><span class='Ref_To_Local'>remote_lsn</span></a> <span class='Operator'>= </span><a href="origin.c.html#LN927"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN112"><span class='Ref_to_Member'>remote_lsn</span></a><span class='Delimiter'>; 
</span>            <a href="origin.c.html#LN919"><span class='Ref_To_Local'>local_lsn</span></a> <span class='Operator'>= </span><a href="origin.c.html#LN927"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN119"><span class='Ref_to_Member'>local_lsn</span></a><span class='Delimiter'>; 
</span> 
            <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="origin.c.html#LN927"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN129"><span class='Ref_to_Member'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ReplicationOriginLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN916"><span class='Ref_to_Parameter'>flush</span></a> <span class='Operator'>&& </span><a href="origin.c.html#LN919"><span class='Ref_To_Local'>local_lsn</span></a> <span class='Operator'>!= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/access/xlog.h.html#LN225"><span class='Ref_to_Proto'>XLogFlush</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN919"><span class='Ref_To_Local'>local_lsn</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="origin.c.html#LN920"><span class='Ref_To_Local'>remote_lsn</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end replorigin_get_progress &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Tear down a (possibly) configured session replication origin during process 
 * exit. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN957"></a><span class='Declare_Function'>ReplicationOriginExitCleanup</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>code</span><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>arg</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ReplicationOriginLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN168"><span class='Ref_to_Global_Var'>session_replication_state</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL </span><span class='Operator'>&& 
</span>        <a href="origin.c.html#LN168"><span class='Ref_to_Global_Var'>session_replication_state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN124"><span class='Ref_to_Member'>acquired_by</span></a> <span class='Operator'>== </span><a href="../../utils/init/globals.c.html#LN38"><span class='Ref_to_Global_Var'>MyProcPid</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="origin.c.html#LN168"><span class='Ref_to_Global_Var'>session_replication_state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN124"><span class='Ref_to_Member'>acquired_by</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="origin.c.html#LN168"><span class='Ref_to_Global_Var'>session_replication_state</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ReplicationOriginLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Setup a replication origin in the shared memory struct if it doesn't 
 * already exists and cache access to the specific ReplicationSlot so the 
 * array doesn't have to be searched when calling 
 * replorigin_session_advance(). 
 * 
 * Obviously only one such cached origin can exist per process and the current 
 * cached value can only be set again after the previous value is torn down 
 * with replorigin_session_reset(). 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN982"></a><span class='Declare_Function'>replorigin_session_setup</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN50"><span class='Ref_to_Typedef'>RepOriginId</span></a> <span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN984"></a>    <span class='Keyword'>static bool </span><span class='Declare_Local'>registered_cleanup</span><span class='Delimiter'>; 
</span><a name="LN985"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN986"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>free_slot</span> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="origin.c.html#LN984"><span class='Ref_To_Local'>registered_cleanup</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/storage/ipc.h.html#LN69"><span class='Ref_to_Proto'>on_shmem_exit</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN956"><span class='Ref_to_Func'>ReplicationOriginExitCleanup</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="origin.c.html#LN984"><span class='Ref_To_Local'>registered_cleanup</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../slot.c.html#LN98"><span class='Ref_to_Global_Var'>max_replication_slots</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN168"><span class='Ref_to_Global_Var'>session_replication_state</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>        <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"cannot setup replication origin when one is already setup"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Lock exclusively, as we may have to create a new table entry. */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ReplicationOriginLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Search for either an existing slot for the origin, or a free one we can 
     * use. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN985"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="origin.c.html#LN985"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="../slot.c.html#LN98"><span class='Ref_to_Global_Var'>max_replication_slots</span></a><span class='Delimiter'>; </span><a href="origin.c.html#LN985"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1010"></a>        <a href="origin.c.html#LN102"><span class='Ref_to_Struct'>ReplicationState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>curstate</span> <span class='Operator'>= &</span><a href="origin.c.html#LN160"><span class='Ref_to_Global_Var'>replication_states</span></a><span class='Delimiter'>[</span><a href="origin.c.html#LN985"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Comment_Multi_Line'>/* remember where to insert if necessary */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN1010"><span class='Ref_To_Local'>curstate</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN107"><span class='Ref_to_Member'>roident</span></a> <span class='Operator'>== </span><a href="../../../include/replication/origin.h.html#LN33"><span class='Ref_to_Const'>InvalidRepOriginId</span></a> <span class='Operator'>&& 
</span>            <a href="origin.c.html#LN986"><span class='Ref_To_Local'>free_slot</span></a> <span class='Operator'>== -</span><span class='Number'>1</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="origin.c.html#LN986"><span class='Ref_To_Local'>free_slot</span></a> <span class='Operator'>= </span><a href="origin.c.html#LN985"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* not our slot */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN1010"><span class='Ref_To_Local'>curstate</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN107"><span class='Ref_to_Member'>roident</span></a> <span class='Operator'>!= </span><a href="origin.c.html#LN982"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN1010"><span class='Ref_To_Local'>curstate</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN124"><span class='Ref_to_Member'>acquired_by</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OBJECT_IN_USE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>             <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"replication identifier %d is already active for PID %d"</span><span class='Delimiter'>, 
</span>                    <a href="origin.c.html#LN1010"><span class='Ref_To_Local'>curstate</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN107"><span class='Ref_to_Member'>roident</span></a><span class='Delimiter'>, </span><a href="origin.c.html#LN1010"><span class='Ref_To_Local'>curstate</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN124"><span class='Ref_to_Member'>acquired_by</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* ok, found slot */ 
</span>        <a href="origin.c.html#LN168"><span class='Ref_to_Global_Var'>session_replication_state</span></a> <span class='Operator'>= </span><a href="origin.c.html#LN1010"><span class='Ref_To_Local'>curstate</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;max_replication... &raquo; </span> 
 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN168"><span class='Ref_to_Global_Var'>session_replication_state</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>&& </span><a href="origin.c.html#LN986"><span class='Ref_To_Local'>free_slot</span></a> <span class='Operator'>== -</span><span class='Number'>1</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_CONFIGURATION_LIMIT_EXCEEDED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not find free replication state slot for replication origin with OID %u"</span><span class='Delimiter'>, 
</span>                        <a href="origin.c.html#LN982"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"Increase max_replication_slots and try again."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN168"><span class='Ref_to_Global_Var'>session_replication_state</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* initialize new slot */ 
</span>        <a href="origin.c.html#LN168"><span class='Ref_to_Global_Var'>session_replication_state</span></a> <span class='Operator'>= &</span><a href="origin.c.html#LN160"><span class='Ref_to_Global_Var'>replication_states</span></a><span class='Delimiter'>[</span><a href="origin.c.html#LN986"><span class='Ref_To_Local'>free_slot</span></a><span class='Delimiter'>]; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="origin.c.html#LN168"><span class='Ref_to_Global_Var'>session_replication_state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN112"><span class='Ref_to_Member'>remote_lsn</span></a> <span class='Operator'>== </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="origin.c.html#LN168"><span class='Ref_to_Global_Var'>session_replication_state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN119"><span class='Ref_to_Member'>local_lsn</span></a> <span class='Operator'>== </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="origin.c.html#LN168"><span class='Ref_to_Global_Var'>session_replication_state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN107"><span class='Ref_to_Member'>roident</span></a> <span class='Operator'>= </span><a href="origin.c.html#LN982"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="origin.c.html#LN168"><span class='Ref_to_Global_Var'>session_replication_state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN107"><span class='Ref_to_Member'>roident</span></a> <span class='Operator'>!= </span><a href="../../../include/replication/origin.h.html#LN33"><span class='Ref_to_Const'>InvalidRepOriginId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="origin.c.html#LN168"><span class='Ref_to_Global_Var'>session_replication_state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN124"><span class='Ref_to_Member'>acquired_by</span></a> <span class='Operator'>= </span><a href="../../utils/init/globals.c.html#LN38"><span class='Ref_to_Global_Var'>MyProcPid</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ReplicationOriginLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end replorigin_session_setup &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Reset replay state previously setup in this session. 
 * 
 * This function may only be called if an origin was setup with 
 * replorigin_session_setup(). 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1067"></a><span class='Declare_Function'>replorigin_session_reset</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../slot.c.html#LN98"><span class='Ref_to_Global_Var'>max_replication_slots</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN168"><span class='Ref_to_Global_Var'>session_replication_state</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"no replication origin is configured"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ReplicationOriginLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="origin.c.html#LN168"><span class='Ref_to_Global_Var'>session_replication_state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN124"><span class='Ref_to_Member'>acquired_by</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="origin.c.html#LN168"><span class='Ref_to_Global_Var'>session_replication_state</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ReplicationOriginLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Do the same work replorigin_advance() does, just on the session's 
 * configured origin. 
 * 
 * This is noticeably cheaper than using replorigin_advance(). 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1091"></a><span class='Declare_Function'>replorigin_session_advance</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>remote_commit</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>local_commit</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="origin.c.html#LN168"><span class='Ref_to_Global_Var'>session_replication_state</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="origin.c.html#LN168"><span class='Ref_to_Global_Var'>session_replication_state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN107"><span class='Ref_to_Member'>roident</span></a> <span class='Operator'>!= </span><a href="../../../include/replication/origin.h.html#LN33"><span class='Ref_to_Const'>InvalidRepOriginId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="origin.c.html#LN168"><span class='Ref_to_Global_Var'>session_replication_state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN129"><span class='Ref_to_Member'>lock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN168"><span class='Ref_to_Global_Var'>session_replication_state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN119"><span class='Ref_to_Member'>local_lsn</span></a> <span class='Operator'>&LT; </span><a href="origin.c.html#LN1091"><span class='Ref_to_Parameter'>local_commit</span></a><span class='Parentheses'>) 
</span>        <a href="origin.c.html#LN168"><span class='Ref_to_Global_Var'>session_replication_state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN119"><span class='Ref_to_Member'>local_lsn</span></a> <span class='Operator'>= </span><a href="origin.c.html#LN1091"><span class='Ref_to_Parameter'>local_commit</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN168"><span class='Ref_to_Global_Var'>session_replication_state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN112"><span class='Ref_to_Member'>remote_lsn</span></a> <span class='Operator'>&LT; </span><a href="origin.c.html#LN1091"><span class='Ref_to_Parameter'>remote_commit</span></a><span class='Parentheses'>) 
</span>        <a href="origin.c.html#LN168"><span class='Ref_to_Global_Var'>session_replication_state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN112"><span class='Ref_to_Member'>remote_lsn</span></a> <span class='Operator'>= </span><a href="origin.c.html#LN1091"><span class='Ref_to_Parameter'>remote_commit</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="origin.c.html#LN168"><span class='Ref_to_Global_Var'>session_replication_state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN129"><span class='Ref_to_Member'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Ask the machinery about the point up to which we successfully replayed 
 * changes from an already setup replication origin. 
 */ 
</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> 
<a name="LN1109"></a><span class='Declare_Function'>replorigin_session_get_progress</span><span class='Parentheses'>(</span><span class='Keyword'>bool </span><span class='Declare_Parameter'>flush</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1111"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>remote_lsn</span><span class='Delimiter'>; 
</span><a name="LN1112"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>local_lsn</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="origin.c.html#LN168"><span class='Ref_to_Global_Var'>session_replication_state</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="origin.c.html#LN168"><span class='Ref_to_Global_Var'>session_replication_state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN129"><span class='Ref_to_Member'>lock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="origin.c.html#LN1111"><span class='Ref_To_Local'>remote_lsn</span></a> <span class='Operator'>= </span><a href="origin.c.html#LN168"><span class='Ref_to_Global_Var'>session_replication_state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN112"><span class='Ref_to_Member'>remote_lsn</span></a><span class='Delimiter'>; 
</span>    <a href="origin.c.html#LN1112"><span class='Ref_To_Local'>local_lsn</span></a> <span class='Operator'>= </span><a href="origin.c.html#LN168"><span class='Ref_to_Global_Var'>session_replication_state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN119"><span class='Ref_to_Member'>local_lsn</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="origin.c.html#LN168"><span class='Ref_to_Global_Var'>session_replication_state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN129"><span class='Ref_to_Member'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN1109"><span class='Ref_to_Parameter'>flush</span></a> <span class='Operator'>&& </span><a href="origin.c.html#LN1112"><span class='Ref_To_Local'>local_lsn</span></a> <span class='Operator'>!= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/access/xlog.h.html#LN225"><span class='Ref_to_Proto'>XLogFlush</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN1112"><span class='Ref_To_Local'>local_lsn</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="origin.c.html#LN1111"><span class='Ref_To_Local'>remote_lsn</span></a><span class='Delimiter'>; 
} 
</span> 
 
 
<span class='Comment_Multi_Line'>/* --------------------------------------------------------------------------- 
 * SQL functions for working with replication origin. 
 * 
 * These mostly should be fairly short wrappers around more generic functions. 
 * --------------------------------------------------------------------------- 
 */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Create replication origin for the passed in name, and return the assigned 
 * oid. 
 */ 
</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN1141"></a><span class='Declare_Function'>pg_replication_origin_create</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1143"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>name</span><span class='Delimiter'>; 
</span><a name="LN1144"></a>    <a href="../../../include/access/xlogdefs.h.html#LN50"><span class='Ref_to_Typedef'>RepOriginId</span></a> <span class='Declare_Local'>roident</span><span class='Delimiter'>; 
</span> 
    <a href="origin.c.html#LN173"><span class='Ref_to_Func'>replorigin_check_prerequisites</span></a><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="origin.c.html#LN1143"><span class='Ref_To_Local'>name</span></a> <span class='Operator'>= </span><a href="../../../include/utils/builtins.h.html#LN87"><span class='Ref_to_Proto'>text_to_cstring</span></a><span class='Parentheses'>((</span><a href="../../../../contrib/seg/segparse.y.html#LN46"><span class='Ref_to_Global_Var'>text</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> <a href="../../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN232"><span class='Ref_to_Macro'>PG_GETARG_DATUM</span></a><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <a href="origin.c.html#LN1144"><span class='Ref_To_Local'>roident</span></a> <span class='Operator'>= </span><a href="../../../include/replication/origin.h.html#LN42"><span class='Ref_to_Proto'>replorigin_create</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN1143"><span class='Ref_To_Local'>name</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN1143"><span class='Ref_To_Local'>name</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/fmgr.h.html#LN319"><span class='Ref_to_Macro'>PG_RETURN_OID</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN1144"><span class='Ref_To_Local'>roident</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Drop replication origin. 
 */ 
</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN1160"></a><span class='Declare_Function'>pg_replication_origin_drop</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1162"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>name</span><span class='Delimiter'>; 
</span><a name="LN1163"></a>    <a href="../../../include/access/xlogdefs.h.html#LN50"><span class='Ref_to_Typedef'>RepOriginId</span></a> <span class='Declare_Local'>roident</span><span class='Delimiter'>; 
</span> 
    <a href="origin.c.html#LN173"><span class='Ref_to_Func'>replorigin_check_prerequisites</span></a><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="origin.c.html#LN1162"><span class='Ref_To_Local'>name</span></a> <span class='Operator'>= </span><a href="../../../include/utils/builtins.h.html#LN87"><span class='Ref_to_Proto'>text_to_cstring</span></a><span class='Parentheses'>((</span><a href="../../../../contrib/seg/segparse.y.html#LN46"><span class='Ref_to_Global_Var'>text</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> <a href="../../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN232"><span class='Ref_to_Macro'>PG_GETARG_DATUM</span></a><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <a href="origin.c.html#LN1163"><span class='Ref_To_Local'>roident</span></a> <span class='Operator'>= </span><a href="../../../include/replication/origin.h.html#LN41"><span class='Ref_to_Proto'>replorigin_by_name</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN1162"><span class='Ref_To_Local'>name</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN1163"><span class='Ref_To_Local'>roident</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/replication/origin.h.html#LN43"><span class='Ref_to_Proto'>replorigin_drop</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN1163"><span class='Ref_To_Local'>roident</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN1162"><span class='Ref_To_Local'>name</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/fmgr.h.html#LN308"><span class='Ref_to_Macro'>PG_RETURN_VOID</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Return oid of a replication origin. 
 */ 
</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN1183"></a><span class='Declare_Function'>pg_replication_origin_oid</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1185"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>name</span><span class='Delimiter'>; 
</span><a name="LN1186"></a>    <a href="../../../include/access/xlogdefs.h.html#LN50"><span class='Ref_to_Typedef'>RepOriginId</span></a> <span class='Declare_Local'>roident</span><span class='Delimiter'>; 
</span> 
    <a href="origin.c.html#LN173"><span class='Ref_to_Func'>replorigin_check_prerequisites</span></a><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="origin.c.html#LN1185"><span class='Ref_To_Local'>name</span></a> <span class='Operator'>= </span><a href="../../../include/utils/builtins.h.html#LN87"><span class='Ref_to_Proto'>text_to_cstring</span></a><span class='Parentheses'>((</span><a href="../../../../contrib/seg/segparse.y.html#LN46"><span class='Ref_to_Global_Var'>text</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> <a href="../../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN232"><span class='Ref_to_Macro'>PG_GETARG_DATUM</span></a><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <a href="origin.c.html#LN1186"><span class='Ref_To_Local'>roident</span></a> <span class='Operator'>= </span><a href="../../../include/replication/origin.h.html#LN41"><span class='Ref_to_Proto'>replorigin_by_name</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN1185"><span class='Ref_To_Local'>name</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN1185"><span class='Ref_To_Local'>name</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN1186"><span class='Ref_To_Local'>roident</span></a><span class='Parentheses'>))</span> 
        <a href="../../../include/fmgr.h.html#LN319"><span class='Ref_to_Macro'>PG_RETURN_OID</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN1186"><span class='Ref_To_Local'>roident</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/fmgr.h.html#LN304"><span class='Ref_to_Macro'>PG_RETURN_NULL</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Setup a replication origin for this session. 
 */ 
</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN1204"></a><span class='Declare_Function'>pg_replication_origin_session_setup</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1206"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>name</span><span class='Delimiter'>; 
</span><a name="LN1207"></a>    <a href="../../../include/access/xlogdefs.h.html#LN50"><span class='Ref_to_Typedef'>RepOriginId</span></a> <span class='Declare_Local'>origin</span><span class='Delimiter'>; 
</span> 
    <a href="origin.c.html#LN173"><span class='Ref_to_Func'>replorigin_check_prerequisites</span></a><span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="origin.c.html#LN1206"><span class='Ref_To_Local'>name</span></a> <span class='Operator'>= </span><a href="../../../include/utils/builtins.h.html#LN87"><span class='Ref_to_Proto'>text_to_cstring</span></a><span class='Parentheses'>((</span><a href="../../../../contrib/seg/segparse.y.html#LN46"><span class='Ref_to_Global_Var'>text</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> <a href="../../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN232"><span class='Ref_to_Macro'>PG_GETARG_DATUM</span></a><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <a href="origin.c.html#LN1207"><span class='Ref_To_Local'>origin</span></a> <span class='Operator'>= </span><a href="../../../include/replication/origin.h.html#LN41"><span class='Ref_to_Proto'>replorigin_by_name</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN1206"><span class='Ref_To_Local'>name</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/replication/origin.h.html#LN56"><span class='Ref_to_Proto'>replorigin_session_setup</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN1207"><span class='Ref_To_Local'>origin</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="origin.c.html#LN149"><span class='Ref_to_Global_Var'>replorigin_session_origin</span></a> <span class='Operator'>= </span><a href="origin.c.html#LN1207"><span class='Ref_To_Local'>origin</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN1206"><span class='Ref_To_Local'>name</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/fmgr.h.html#LN308"><span class='Ref_to_Macro'>PG_RETURN_VOID</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Reset previously setup origin in this session 
 */ 
</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN1226"></a><span class='Declare_Function'>pg_replication_origin_session_reset</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="origin.c.html#LN173"><span class='Ref_to_Func'>replorigin_check_prerequisites</span></a><span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/replication/origin.h.html#LN57"><span class='Ref_to_Proto'>replorigin_session_reset</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <a href="origin.c.html#LN149"><span class='Ref_to_Global_Var'>replorigin_session_origin</span></a> <span class='Operator'>= </span><a href="../../../include/replication/origin.h.html#LN33"><span class='Ref_to_Const'>InvalidRepOriginId</span></a><span class='Delimiter'>; 
</span>    <a href="origin.c.html#LN150"><span class='Ref_to_Global_Var'>replorigin_session_origin_lsn</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span>    <a href="origin.c.html#LN151"><span class='Ref_to_Global_Var'>replorigin_session_origin_timestamp</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/fmgr.h.html#LN308"><span class='Ref_to_Macro'>PG_RETURN_VOID</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Has a replication origin been setup for this session. 
 */ 
</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN1243"></a><span class='Declare_Function'>pg_replication_origin_session_is_setup</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="origin.c.html#LN173"><span class='Ref_to_Func'>replorigin_check_prerequisites</span></a><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/fmgr.h.html#LN318"><span class='Ref_to_Macro'>PG_RETURN_BOOL</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN149"><span class='Ref_to_Global_Var'>replorigin_session_origin</span></a> <span class='Operator'>!= </span><a href="../../../include/replication/origin.h.html#LN33"><span class='Ref_to_Const'>InvalidRepOriginId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Return the replication progress for origin setup in the current session. 
 * 
 * If 'flush' is set to true it is ensured that the returned value corresponds 
 * to a local transaction that has been flushed. This is useful if asynchronous 
 * commits are used when replaying replicated transactions. 
 */ 
</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN1259"></a><span class='Declare_Function'>pg_replication_origin_session_progress</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1261"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>remote_lsn</span> <span class='Operator'>= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span><a name="LN1262"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>flush</span> <span class='Operator'>= </span><a href="../../../include/fmgr.h.html#LN238"><span class='Ref_to_Macro'>PG_GETARG_BOOL</span></a><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="origin.c.html#LN173"><span class='Ref_to_Func'>replorigin_check_prerequisites</span></a><span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN168"><span class='Ref_to_Global_Var'>session_replication_state</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"no replication origin is configured"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <a href="origin.c.html#LN1261"><span class='Ref_To_Local'>remote_lsn</span></a> <span class='Operator'>= </span><a href="../../../include/replication/origin.h.html#LN58"><span class='Ref_to_Proto'>replorigin_session_get_progress</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN1262"><span class='Ref_To_Local'>flush</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN1261"><span class='Ref_To_Local'>remote_lsn</span></a> <span class='Operator'>== </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/fmgr.h.html#LN304"><span class='Ref_to_Macro'>PG_RETURN_NULL</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/pg_lsn.h.html#LN24"><span class='Ref_to_Macro'>PG_RETURN_LSN</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN1261"><span class='Ref_To_Local'>remote_lsn</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end pg_replication_origin_session_progress &raquo; </span> 
 
<a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN1280"></a><span class='Declare_Function'>pg_replication_origin_xact_setup</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1282"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>location</span> <span class='Operator'>= </span><a href="../../../include/utils/pg_lsn.h.html#LN23"><span class='Ref_to_Macro'>PG_GETARG_LSN</span></a><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="origin.c.html#LN173"><span class='Ref_to_Func'>replorigin_check_prerequisites</span></a><span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN168"><span class='Ref_to_Global_Var'>session_replication_state</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"no replication origin is configured"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <a href="origin.c.html#LN150"><span class='Ref_to_Global_Var'>replorigin_session_origin_lsn</span></a> <span class='Operator'>= </span><a href="origin.c.html#LN1282"><span class='Ref_To_Local'>location</span></a><span class='Delimiter'>; 
</span>    <a href="origin.c.html#LN151"><span class='Ref_to_Global_Var'>replorigin_session_origin_timestamp</span></a> <span class='Operator'>= </span><a href="../../../include/utils/timestamp.h.html#LN35"><span class='Ref_to_Macro'>PG_GETARG_TIMESTAMPTZ</span></a><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/fmgr.h.html#LN308"><span class='Ref_to_Macro'>PG_RETURN_VOID</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
} 
</span> 
<a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN1298"></a><span class='Declare_Function'>pg_replication_origin_xact_reset</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="origin.c.html#LN173"><span class='Ref_to_Func'>replorigin_check_prerequisites</span></a><span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="origin.c.html#LN150"><span class='Ref_to_Global_Var'>replorigin_session_origin_lsn</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span>    <a href="origin.c.html#LN151"><span class='Ref_to_Global_Var'>replorigin_session_origin_timestamp</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/fmgr.h.html#LN308"><span class='Ref_to_Macro'>PG_RETURN_VOID</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
} 
</span> 
 
<a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN1310"></a><span class='Declare_Function'>pg_replication_origin_advance</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1312"></a>    <a href="../../../../contrib/seg/segparse.y.html#LN46"><span class='Ref_to_Global_Var'>text</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>name</span> <span class='Operator'>= </span><a href="../../../include/fmgr.h.html#LN272"><span class='Ref_to_Macro'>PG_GETARG_TEXT_PP</span></a><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1313"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>remote_commit</span> <span class='Operator'>= </span><a href="../../../include/utils/pg_lsn.h.html#LN23"><span class='Ref_to_Macro'>PG_GETARG_LSN</span></a><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1314"></a>    <a href="../../../include/access/xlogdefs.h.html#LN50"><span class='Ref_to_Typedef'>RepOriginId</span></a> <span class='Declare_Local'>node</span><span class='Delimiter'>; 
</span> 
    <a href="origin.c.html#LN173"><span class='Ref_to_Func'>replorigin_check_prerequisites</span></a><span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* lock to prevent the replication origin from vanishing */ 
</span>    <a href="../../../include/storage/lmgr.h.html#LN39"><span class='Ref_to_Proto'>LockRelationOid</span></a><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_replication_origin.h.html#LN27"><span class='Ref_to_Const'>ReplicationOriginRelationId</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lockdefs.h.html#LN37"><span class='Ref_to_Const'>RowExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="origin.c.html#LN1314"><span class='Ref_To_Local'>node</span></a> <span class='Operator'>= </span><a href="../../../include/replication/origin.h.html#LN41"><span class='Ref_to_Proto'>replorigin_by_name</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/builtins.h.html#LN87"><span class='Ref_to_Proto'>text_to_cstring</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN1312"><span class='Ref_To_Local'>name</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Can't sensibly pass a local commit to be flushed at checkpoint - this 
     * xact hasn't committed yet. This is why this function should be used to 
     * set up the initial replication state, but not for replay. 
     */ 
</span>    <a href="../../../include/replication/origin.h.html#LN48"><span class='Ref_to_Proto'>replorigin_advance</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN1314"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>, </span><a href="origin.c.html#LN1313"><span class='Ref_To_Local'>remote_commit</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>, 
</span>                       <span class='Boolean'>true </span><span class='Comment_Multi_Line'>/* go backward */ </span><span class='Delimiter'>, </span><span class='Boolean'>true </span><span class='Comment_Multi_Line'>/* WAL log */ </span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lmgr.h.html#LN42"><span class='Ref_to_Proto'>UnlockRelationOid</span></a><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_replication_origin.h.html#LN27"><span class='Ref_to_Const'>ReplicationOriginRelationId</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lockdefs.h.html#LN37"><span class='Ref_to_Const'>RowExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/fmgr.h.html#LN308"><span class='Ref_to_Macro'>PG_RETURN_VOID</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end pg_replication_origin_advance &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Return the replication progress for an individual replication origin. 
 * 
 * If 'flush' is set to true it is ensured that the returned value corresponds 
 * to a local transaction that has been flushed. This is useful if asynchronous 
 * commits are used when replaying replicated transactions. 
 */ 
</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN1345"></a><span class='Declare_Function'>pg_replication_origin_progress</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1347"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>name</span><span class='Delimiter'>; 
</span><a name="LN1348"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>flush</span><span class='Delimiter'>; 
</span><a name="LN1349"></a>    <a href="../../../include/access/xlogdefs.h.html#LN50"><span class='Ref_to_Typedef'>RepOriginId</span></a> <span class='Declare_Local'>roident</span><span class='Delimiter'>; 
</span><a name="LN1350"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>remote_lsn</span> <span class='Operator'>= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span> 
    <a href="origin.c.html#LN173"><span class='Ref_to_Func'>replorigin_check_prerequisites</span></a><span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="origin.c.html#LN1347"><span class='Ref_To_Local'>name</span></a> <span class='Operator'>= </span><a href="../../../include/utils/builtins.h.html#LN87"><span class='Ref_to_Proto'>text_to_cstring</span></a><span class='Parentheses'>((</span><a href="../../../../contrib/seg/segparse.y.html#LN46"><span class='Ref_to_Global_Var'>text</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> <a href="../../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN232"><span class='Ref_to_Macro'>PG_GETARG_DATUM</span></a><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <a href="origin.c.html#LN1348"><span class='Ref_To_Local'>flush</span></a> <span class='Operator'>= </span><a href="../../../include/fmgr.h.html#LN238"><span class='Ref_to_Macro'>PG_GETARG_BOOL</span></a><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="origin.c.html#LN1349"><span class='Ref_To_Local'>roident</span></a> <span class='Operator'>= </span><a href="../../../include/replication/origin.h.html#LN41"><span class='Ref_to_Proto'>replorigin_by_name</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN1347"><span class='Ref_To_Local'>name</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN1349"><span class='Ref_To_Local'>roident</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="origin.c.html#LN1350"><span class='Ref_To_Local'>remote_lsn</span></a> <span class='Operator'>= </span><a href="../../../include/replication/origin.h.html#LN52"><span class='Ref_to_Proto'>replorigin_get_progress</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN1349"><span class='Ref_To_Local'>roident</span></a><span class='Delimiter'>, </span><a href="origin.c.html#LN1348"><span class='Ref_To_Local'>flush</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN1350"><span class='Ref_To_Local'>remote_lsn</span></a> <span class='Operator'>== </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/fmgr.h.html#LN304"><span class='Ref_to_Macro'>PG_RETURN_NULL</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/pg_lsn.h.html#LN24"><span class='Ref_to_Macro'>PG_RETURN_LSN</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN1350"><span class='Ref_To_Local'>remote_lsn</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end pg_replication_origin_progress &raquo; </span> 
 
 
<a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN1370"></a><span class='Declare_Function'>pg_show_replication_origin_status</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1372"></a>    <a href="../../../include/nodes/execnodes.h.html#LN261"><span class='Ref_to_Struct'>ReturnSetInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rsinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/execnodes.h.html#LN261"><span class='Ref_to_Struct'>ReturnSetInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span>fcinfo<span class='Operator'>-&GT;</span>resultinfo<span class='Delimiter'>; 
</span><a name="LN1373"></a>    <a href="../../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Local'>tupdesc</span><span class='Delimiter'>; 
</span><a name="LN1374"></a>    <a href="../../utils/sort/tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tupstore</span><span class='Delimiter'>; 
</span><a name="LN1375"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>per_query_ctx</span><span class='Delimiter'>; 
</span><a name="LN1376"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span><span class='Delimiter'>; 
</span><a name="LN1377"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN1378"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>REPLICATION_ORIGIN_PROGRESS_COLS</span> <span class='Number'>4</span> 
 
    <span class='Comment_Multi_Line'>/* we we want to return 0 rows if slot is set to zero */ 
</span>    <a href="origin.c.html#LN173"><span class='Ref_to_Func'>replorigin_check_prerequisites</span></a><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN1372"><span class='Ref_To_Local'>rsinfo</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| !</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN1372"><span class='Ref_To_Local'>rsinfo</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/execnodes.h.html#LN261"><span class='Ref_to_Struct'>ReturnSetInfo</span></a><span class='Parentheses'>))</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"set-valued function called in context that cannot accept a set"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="origin.c.html#LN1372"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/execnodes.h.html#LN267"><span class='Ref_to_Member'>allowedModes</span></a> <span class='Operator'>& </span><a href="../../../include/nodes/execnodes.h.html#LN250"><span class='Ref_to_EnumConst'>SFRM_Materialize</span></a><span class='Parentheses'>))</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"materialize mode required, but it is not allowed in this context"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/funcapi.h.html#LN157"><span class='Ref_to_Proto'>get_call_result_type</span></a><span class='Parentheses'>(</span>fcinfo<span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="origin.c.html#LN1373"><span class='Ref_To_Local'>tupdesc</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="../../../include/funcapi.h.html#LN152"><span class='Ref_to_EnumConst'>TYPEFUNC_COMPOSITE</span></a><span class='Parentheses'>)</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"return type must be a row type"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN1373"><span class='Ref_To_Local'>tupdesc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/tupdesc.h.html#LN72"><span class='Ref_to_Member'>natts</span></a> <span class='Operator'>!= </span><a href="origin.c.html#LN1378"><span class='Ref_to_Const'>REPLICATION_ORIGIN_PROGRESS_COLS</span></a><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"wrong function definition"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="origin.c.html#LN1375"><span class='Ref_To_Local'>per_query_ctx</span></a> <span class='Operator'>= </span><a href="origin.c.html#LN1372"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/execnodes.h.html#LN265"><span class='Ref_to_Member'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/execnodes.h.html#LN201"><span class='Ref_to_Member'>ecxt_per_query_memory</span></a><span class='Delimiter'>; 
</span>    <a href="origin.c.html#LN1376"><span class='Ref_To_Local'>oldcontext</span></a> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN1375"><span class='Ref_To_Local'>per_query_ctx</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="origin.c.html#LN1374"><span class='Ref_To_Local'>tupstore</span></a> <span class='Operator'>= </span><a href="../../../include/utils/tuplestore.h.html#LN46"><span class='Ref_to_Proto'>tuplestore_begin_heap</span></a><span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><a href="../../utils/init/globals.c.html#LN112"><span class='Ref_to_Global_Var'>work_mem</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="origin.c.html#LN1372"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/execnodes.h.html#LN269"><span class='Ref_to_Member'>returnMode</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/execnodes.h.html#LN250"><span class='Ref_to_EnumConst'>SFRM_Materialize</span></a><span class='Delimiter'>; 
</span>    <a href="origin.c.html#LN1372"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/execnodes.h.html#LN272"><span class='Ref_to_Member'>setResult</span></a> <span class='Operator'>= </span><a href="origin.c.html#LN1374"><span class='Ref_To_Local'>tupstore</span></a><span class='Delimiter'>; 
</span>    <a href="origin.c.html#LN1372"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/execnodes.h.html#LN273"><span class='Ref_to_Member'>setDesc</span></a> <span class='Operator'>= </span><a href="origin.c.html#LN1373"><span class='Ref_To_Local'>tupdesc</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN1376"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
    <span class='Comment_Multi_Line'>/* prevent slots from being concurrently dropped */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ReplicationOriginLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Iterate through all possible replication_states, display if they are 
     * filled. Note that we do not take any locks, so slightly corrupted/out 
     * of date values are a possibility. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN1377"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="origin.c.html#LN1377"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="../slot.c.html#LN98"><span class='Ref_to_Global_Var'>max_replication_slots</span></a><span class='Delimiter'>; </span><a href="origin.c.html#LN1377"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1418"></a>        <a href="origin.c.html#LN102"><span class='Ref_to_Struct'>ReplicationState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>state</span><span class='Delimiter'>; 
</span><a name="LN1419"></a>        <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>values</span><span class='Delimiter'>[</span><a href="origin.c.html#LN1378"><span class='Ref_to_Const'>REPLICATION_ORIGIN_PROGRESS_COLS</span></a><span class='Delimiter'>]; 
</span><a name="LN1420"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>nulls</span><span class='Delimiter'>[</span><a href="origin.c.html#LN1378"><span class='Ref_to_Const'>REPLICATION_ORIGIN_PROGRESS_COLS</span></a><span class='Delimiter'>]; 
</span><a name="LN1421"></a>        <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>roname</span><span class='Delimiter'>; 
</span> 
        <a href="origin.c.html#LN1418"><span class='Ref_To_Local'>state</span></a> <span class='Operator'>= &</span><a href="origin.c.html#LN160"><span class='Ref_to_Global_Var'>replication_states</span></a><span class='Delimiter'>[</span><a href="origin.c.html#LN1377"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Comment_Multi_Line'>/* unused slot, nothing to display */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="origin.c.html#LN1418"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN107"><span class='Ref_to_Member'>roident</span></a> <span class='Operator'>== </span><a href="../../../include/replication/origin.h.html#LN33"><span class='Ref_to_Const'>InvalidRepOriginId</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        memset<span class='Parentheses'>(</span><a href="origin.c.html#LN1419"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="origin.c.html#LN1419"><span class='Ref_To_Local'>values</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        memset<span class='Parentheses'>(</span><a href="origin.c.html#LN1420"><span class='Ref_To_Local'>nulls</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="origin.c.html#LN1420"><span class='Ref_To_Local'>nulls</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <a href="origin.c.html#LN1419"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN1418"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN107"><span class='Ref_to_Member'>roident</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="origin.c.html#LN1420"><span class='Ref_To_Local'>nulls</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We're not preventing the origin to be dropped concurrently, so 
         * silently accept that it might be gone. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/replication/origin.h.html#LN44"><span class='Ref_to_Proto'>replorigin_by_oid</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN1418"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN107"><span class='Ref_to_Member'>roident</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, 
</span>                              <span class='Operator'>&</span><a href="origin.c.html#LN1421"><span class='Ref_To_Local'>roname</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="origin.c.html#LN1419"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../../include/utils/builtins.h.html#LN90"><span class='Ref_to_Macro'>CStringGetTextDatum</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN1421"><span class='Ref_To_Local'>roname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="origin.c.html#LN1420"><span class='Ref_To_Local'>nulls</span></a><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="origin.c.html#LN1418"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN129"><span class='Ref_to_Member'>lock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="origin.c.html#LN1419"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><span class='Number'>2</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../../include/utils/pg_lsn.h.html#LN21"><span class='Ref_to_Macro'>LSNGetDatum</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN1418"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN112"><span class='Ref_to_Member'>remote_lsn</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="origin.c.html#LN1420"><span class='Ref_To_Local'>nulls</span></a><span class='Delimiter'>[</span><span class='Number'>2</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
        <a href="origin.c.html#LN1419"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><span class='Number'>3</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../../include/utils/pg_lsn.h.html#LN21"><span class='Ref_to_Macro'>LSNGetDatum</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN1418"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN119"><span class='Ref_to_Member'>local_lsn</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="origin.c.html#LN1420"><span class='Ref_To_Local'>nulls</span></a><span class='Delimiter'>[</span><span class='Number'>3</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="origin.c.html#LN1418"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="origin.c.html#LN129"><span class='Ref_to_Member'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/utils/tuplestore.h.html#LN55"><span class='Ref_to_Proto'>tuplestore_putvalues</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN1374"><span class='Ref_To_Local'>tupstore</span></a><span class='Delimiter'>, </span><a href="origin.c.html#LN1373"><span class='Ref_To_Local'>tupdesc</span></a><span class='Delimiter'>, </span><a href="origin.c.html#LN1419"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>, </span><a href="origin.c.html#LN1420"><span class='Ref_To_Local'>nulls</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;max_replication... &raquo; </span> 
 
    <a href="../../../include/utils/tuplestore.h.html#LN59"><span class='Ref_to_Macro'>tuplestore_donestoring</span></a><span class='Parentheses'>(</span><a href="origin.c.html#LN1374"><span class='Ref_To_Local'>tupstore</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ReplicationOriginLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Keyword'>#undef </span><a href="origin.c.html#LN1378"><span class='Ref_to_Const'>REPLICATION_ORIGIN_PROGRESS_COLS</span></a> 
 
    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end pg_show_replication_origin_status &raquo; </span> 
</pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>