<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\replication\walsender.c</title>
<LINK REL=StyleSheet HREF="../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\replication\walsender.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:46 2017
</td></tr>
<tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * walsender.c 
 * 
 * The WAL sender process (walsender) is new as of Postgres 9.0. It takes 
 * care of sending XLOG from the primary server to a single recipient. 
 * (Note that there can be more than one walsender process concurrently.) 
 * It is started by the postmaster when the walreceiver of a standby server 
 * connects to the primary server and requests XLOG streaming replication. 
 * 
 * A walsender is similar to a regular backend, ie. there is a one-to-one 
 * relationship between a connection and a walsender process, but instead 
 * of processing SQL queries, it understands a small set of special 
 * replication-mode commands. The START_REPLICATION command begins streaming 
 * WAL to the client. While streaming, the walsender keeps reading XLOG 
 * records from the disk and sends them to the standby server over the 
 * COPY protocol, until either side ends the replication by exiting COPY 
 * mode (or until the connection is closed). 
 * 
 * Normal termination is by SIGTERM, which instructs the walsender to 
 * close the connection and exit(0) at the next convenient moment. Emergency 
 * termination is by SIGQUIT; like any backend, the walsender will simply 
 * abort and exit on SIGQUIT. A close of the connection and a FATAL error 
 * are treated as not a crash but approximately normal termination; 
 * the walsender will exit quickly without sending any more XLOG records. 
 * 
 * If the server is shut down, checkpointer sends us 
 * PROCSIG_WALSND_INIT_STOPPING after all regular backends have exited.  If 
 * the backend is idle or runs an SQL query this causes the backend to 
 * shutdown, if logical replication is in progress all existing WAL records 
 * are processed followed by a shutdown.  Otherwise this causes the walsender 
 * to switch to the "stopping" state. In this state, the walsender will reject 
 * any further replication commands. The checkpointer begins the shutdown 
 * checkpoint once all walsenders are confirmed as stopping. When the shutdown 
 * checkpoint finishes, the postmaster sends us SIGUSR2. This instructs 
 * walsender to send any outstanding WAL, including the shutdown checkpoint 
 * record, wait for it to be replicated to the standby, and then exit. 
 * 
 * 
 * Portions Copyright (c) 2010-2017, PostgreSQL Global Development Group 
 * 
 * IDENTIFICATION 
 *    src/backend/replication/walsender.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>&LT;signal.h&GT;</span> 
<span class='Keyword'>#include </span><span class='String'>&LT;unistd.h&GT;</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/printtup.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/timeline.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/transam.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/xact.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/xlog_internal.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/xlogutils.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_type.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"commands/dbcommands.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"commands/defrem.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"funcapi.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"libpq/libpq.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"libpq/pqformat.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"miscadmin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/replnodes.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"pgstat.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"replication/basebackup.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"replication/decode.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"replication/logical.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"replication/logicalfuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"replication/slot.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"replication/snapbuild.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"replication/syncrep.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"replication/walreceiver.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"replication/walsender.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"replication/walsender_private.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/condition_variable.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/fd.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/ipc.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/pmsignal.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/proc.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/procarray.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"tcop/dest.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"tcop/tcopprot.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/builtins.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/guc.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/memutils.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/pg_lsn.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/portal.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/ps_status.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/resowner.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/timeout.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/timestamp.h"</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Maximum data payload in a WAL data message.  Must be &GT;= XLOG_BLCKSZ. 
 * 
 * We don't have a good idea of what a good value would be; there's some 
 * overhead per message in both walsender and walreceiver, but on the other 
 * hand sending large batches makes walsender less responsive to signals 
 * because signals are checked only between messages.  128kB (with 
 * default 8k blocks) seems like a reasonable guess for now. 
 */ 
</span><a name="LN104"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>MAX_SEND_SIZE</span> <span class='Parentheses'>(</span>XLOG_BLCKSZ <span class='Operator'>* </span><span class='Number'>16</span><span class='Parentheses'>) 
</span> 
<span class='Comment_Multi_Line'>/* Array of WalSnds in shared memory */ 
</span><a name="LN107"></a><a href="../../include/replication/walsender_private.h.html#LN75"><span class='Ref_to_Typedef'>WalSndCtlData</span></a> <span class='Operator'>*</span><span class='Declare_Var'>WalSndCtl</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* My slot in the shared memory array */ 
</span><a name="LN110"></a><a href="../../include/replication/walsender_private.h.html#LN33"><span class='Ref_to_Struct'>WalSnd</span></a>     <span class='Operator'>*</span><span class='Declare_Var'>MyWalSnd</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Global state */ 
</span><a name="LN113"></a><span class='Keyword'>bool</span>        <span class='Declare_Var'>am_walsender</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* Am I a walsender process? */ 
</span><a name="LN114"></a><span class='Keyword'>bool</span>        <span class='Declare_Var'>am_cascading_walsender</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>;</span>     <span class='Comment_Multi_Line'>/* Am I cascading WAL to 
                                                 * another standby? */ 
</span><a name="LN116"></a><span class='Keyword'>bool</span>        <span class='Declare_Var'>am_db_walsender</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* Connected to a database? */ 
</span> 
<span class='Comment_Multi_Line'>/* User-settable parameters for walsender */ 
</span><a name="LN119"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>max_wal_senders</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* the maximum number of concurrent walsenders */ 
</span><a name="LN120"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>wal_sender_timeout</span> <span class='Operator'>= </span><span class='Number'>60</span> <span class='Operator'>* </span><span class='Number'>1000</span><span class='Delimiter'>;</span>     <span class='Comment_Multi_Line'>/* maximum time to send one 
                                                 * WAL data message */ 
</span><a name="LN122"></a><span class='Keyword'>bool</span>        <span class='Declare_Var'>log_replication_commands</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * State for WalSndWakeupRequest 
 */ 
</span><a name="LN127"></a><span class='Keyword'>bool</span>        <span class='Declare_Var'>wake_wal_senders</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * These variables are used similarly to openLogFile/SegNo/Off, 
 * but for walsender to read the XLOG. 
 */ 
</span><a name="LN133"></a><span class='Keyword'>static int</span>  <span class='Declare_Var'>sendFile</span> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span><a name="LN134"></a><span class='Keyword'>static </span><a href="../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a> <span class='Declare_Var'>sendSegNo</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN135"></a><span class='Keyword'>static </span><a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Var'>sendOff</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Timeline ID of the currently open file */ 
</span><a name="LN138"></a><span class='Keyword'>static </span><a href="../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a> <span class='Declare_Var'>curFileTimeLine</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * These variables keep track of the state of the timeline we're currently 
 * sending. sendTimeLine identifies the timeline. If sendTimeLineIsHistoric, 
 * the timeline is not the latest timeline on this server, and the server's 
 * history forked off from that timeline at sendTimeLineValidUpto. 
 */ 
</span><a name="LN146"></a><span class='Keyword'>static </span><a href="../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a> <span class='Declare_Var'>sendTimeLine</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN147"></a><span class='Keyword'>static </span><a href="../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a> <span class='Declare_Var'>sendTimeLineNextTLI</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN148"></a><span class='Keyword'>static bool </span><span class='Declare_Var'>sendTimeLineIsHistoric</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN149"></a><span class='Keyword'>static </span><a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Var'>sendTimeLineValidUpto</span> <span class='Operator'>= </span><a href="../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * How far have we sent WAL already? This is also advertised in 
 * MyWalSnd-&GT;sentPtr.  (Actually, this is the next WAL location to send.) 
 */ 
</span><a name="LN155"></a><span class='Keyword'>static </span><a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Var'>sentPtr</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Buffers for constructing outgoing messages and processing reply messages. */ 
</span><a name="LN158"></a><span class='Keyword'>static </span><a href="../../include/lib/stringinfo.h.html#LN34"><span class='Ref_to_Struct'>StringInfoData</span></a> <span class='Declare_Var'>output_message</span><span class='Delimiter'>; 
</span><a name="LN159"></a><span class='Keyword'>static </span><a href="../../include/lib/stringinfo.h.html#LN34"><span class='Ref_to_Struct'>StringInfoData</span></a> <span class='Declare_Var'>reply_message</span><span class='Delimiter'>; 
</span><a name="LN160"></a><span class='Keyword'>static </span><a href="../../include/lib/stringinfo.h.html#LN34"><span class='Ref_to_Struct'>StringInfoData</span></a> <span class='Declare_Var'>tmpbuf</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Timestamp of the last receipt of the reply from the standby. Set to 0 if 
 * wal_sender_timeout doesn't need to be active. 
 */ 
</span><a name="LN166"></a><span class='Keyword'>static </span><a href="../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Var'>last_reply_timestamp</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Have we sent a heartbeat message asking for reply, since last reply? */ 
</span><a name="LN169"></a><span class='Keyword'>static bool </span><span class='Declare_Var'>waiting_for_ping_response</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * While streaming WAL in Copy mode, streamingDoneSending is set to true 
 * after we have sent CopyDone. We should not send any more CopyData messages 
 * after that. streamingDoneReceiving is set to true when we receive CopyDone 
 * from the other end. When both become true, it's time to exit Copy mode. 
 */ 
</span><a name="LN177"></a><span class='Keyword'>static bool </span><span class='Declare_Var'>streamingDoneSending</span><span class='Delimiter'>; 
</span><a name="LN178"></a><span class='Keyword'>static bool </span><span class='Declare_Var'>streamingDoneReceiving</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Are we there yet? */ 
</span><a name="LN181"></a><span class='Keyword'>static bool </span><span class='Declare_Var'>WalSndCaughtUp</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Flags set by signal handlers for later service in main loop */ 
</span><a name="LN184"></a><span class='Keyword'>static volatile </span>sig_atomic_t <span class='Declare_Var'>got_SIGUSR2</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN185"></a><span class='Keyword'>static volatile </span>sig_atomic_t <span class='Declare_Var'>got_STOPPING</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * This is set while we are streaming. When not set 
 * PROCSIG_WALSND_INIT_STOPPING signal will be handled like SIGTERM. When set, 
 * the main loop is responsible for checking got_STOPPING and terminating when 
 * it's set (after streaming any remaining WAL). 
 */ 
</span><a name="LN193"></a><span class='Keyword'>static volatile </span>sig_atomic_t <span class='Declare_Var'>replication_active</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
<a name="LN195"></a><span class='Keyword'>static </span><a href="../../include/replication/logical.h.html#LN34"><span class='Ref_to_Struct'>LogicalDecodingContext</span></a> <span class='Operator'>*</span><span class='Declare_Var'>logical_decoding_ctx</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN196"></a><span class='Keyword'>static </span><a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Var'>logical_startptr</span> <span class='Operator'>= </span><a href="../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* A sample associating a WAL location with the time it was written. */ 
</span><span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN201"></a>    <a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Member'>lsn</span><span class='Delimiter'>; 
</span><a name="LN202"></a>    <a href="../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Member'>time</span><span class='Delimiter'>; 
</span><a name="LN203"></a>} <span class='Declare_Typedef'>WalTimeSample</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* The size of our buffer of time samples. */ 
</span><a name="LN206"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>LAG_TRACKER_BUFFER_SIZE</span> <span class='Number'>8192</span> 
 
<span class='Comment_Multi_Line'>/* A mechanism for tracking replication lag. */ 
</span><span class='Keyword'>static </span><span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN211"></a>    <a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Member'>last_lsn</span><span class='Delimiter'>; 
</span><a name="LN212"></a>    <a href="walsender.c.html#LN199"><span class='Ref_to_Typedef'>WalTimeSample</span></a> <span class='Declare_Member'>buffer</span><span class='Delimiter'>[</span><a href="walsender.c.html#LN206"><span class='Ref_to_Const'>LAG_TRACKER_BUFFER_SIZE</span></a><span class='Delimiter'>]; 
</span><a name="LN213"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>write_head</span><span class='Delimiter'>; 
</span><a name="LN214"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>read_heads</span><span class='Delimiter'>[</span><a href="../../include/replication/syncrep.h.html#LN27"><span class='Ref_to_Const'>NUM_SYNC_REP_WAIT_MODE</span></a><span class='Delimiter'>]; 
</span><a name="LN215"></a>    <a href="walsender.c.html#LN199"><span class='Ref_to_Typedef'>WalTimeSample</span></a> <span class='Declare_Member'>last_read</span><span class='Delimiter'>[</span><a href="../../include/replication/syncrep.h.html#LN27"><span class='Ref_to_Const'>NUM_SYNC_REP_WAIT_MODE</span></a><span class='Delimiter'>]; 
</span><a name="LN216"></a>}   <span class='Declare_Var'>LagTracker</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Signal handlers */ 
</span><a name="LN219"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>WalSndLastCycleHandler</span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN1078"><span class='Ref_to_Const'>SIGNAL_ARGS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Prototypes for private functions */ 
</span><a name="LN222"></a><span class='Control'>typedef</span> <span class='Keyword'>void </span><span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Declare_Typedef'>WalSndSendDataCallback</span><span class='Parentheses'>) (</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN223"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>WalSndLoop</span><span class='Parentheses'>(</span><a href="walsender.c.html#LN222"><span class='Ref_to_Typedef'>WalSndSendDataCallback</span></a> <span class='Declare_Parameter'>send_data</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN224"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>InitWalSenderSlot</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN225"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>WalSndKill</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>code</span><span class='Delimiter'>, </span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>arg</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN226"></a><span class='Keyword'>static void </span><span class='Declare_Function'>WalSndShutdown</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="logical/tablesync.c.html#LN118"><span class='Ref_to_Func'>pg_attribute_noreturn</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span><span class='Keyword'>static void </span><a href="walsender.c.html#LN2467"><span class='Ref_to_Func'>XLogSendPhysical</span></a><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Keyword'>static void </span><a href="walsender.c.html#LN2730"><span class='Ref_to_Func'>XLogSendLogical</span></a><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Keyword'>static void </span><a href="walsender.c.html#LN2800"><span class='Ref_to_Func'>WalSndDone</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN222"><span class='Ref_to_Typedef'>WalSndSendDataCallback</span></a> send_data<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Keyword'>static </span><a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <a href="walsender.c.html#LN2840"><span class='Ref_to_Func'>GetStandbyFlushRecPtr</span></a><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Keyword'>static void </span><a href="walsender.c.html#LN335"><span class='Ref_to_Func'>IdentifySystem</span></a><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Keyword'>static void </span><a href="../../bin/pg_basebackup/streamutil.h.html#LN33"><span class='Ref_to_Proto'>CreateReplicationSlot</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/replnodes.h.html#LN51"><span class='Ref_to_Struct'>CreateReplicationSlotCmd</span></a> <span class='Operator'>*</span>cmd<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Keyword'>static void </span><a href="../../bin/pg_basebackup/streamutil.h.html#LN36"><span class='Ref_to_Proto'>DropReplicationSlot</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/replnodes.h.html#LN66"><span class='Ref_to_Struct'>DropReplicationSlotCmd</span></a> <span class='Operator'>*</span>cmd<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Keyword'>static void </span><a href="walsender.c.html#LN520"><span class='Ref_to_Func'>StartReplication</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/replnodes.h.html#LN77"><span class='Ref_to_Struct'>StartReplicationCmd</span></a> <span class='Operator'>*</span>cmd<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Keyword'>static void </span><a href="walsender.c.html#LN1042"><span class='Ref_to_Func'>StartLogicalReplication</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/replnodes.h.html#LN77"><span class='Ref_to_Struct'>StartReplicationCmd</span></a> <span class='Operator'>*</span>cmd<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Keyword'>static void </span><a href="walsender.c.html#LN1667"><span class='Ref_to_Func'>ProcessStandbyMessage</span></a><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Keyword'>static void </span><a href="walsender.c.html#LN1730"><span class='Ref_to_Func'>ProcessStandbyReplyMessage</span></a><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Keyword'>static void </span><a href="walsender.c.html#LN1899"><span class='Ref_to_Func'>ProcessStandbyHSFeedbackMessage</span></a><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Keyword'>static void </span><a href="walsender.c.html#LN1565"><span class='Ref_to_Func'>ProcessRepliesIfAny</span></a><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Keyword'>static void </span><a href="walsender.c.html#LN3305"><span class='Ref_to_Func'>WalSndKeepalive</span></a><span class='Parentheses'>(</span><span class='Keyword'>bool </span>requestReply<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Keyword'>static void </span><a href="walsender.c.html#LN3324"><span class='Ref_to_Func'>WalSndKeepaliveIfNecessary</span></a><span class='Parentheses'>(</span><a href="../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <a href="../utils/adt/timestamp.c.html#LN1532"><span class='Ref_to_Func'>now</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Keyword'>static void </span><a href="walsender.c.html#LN2040"><span class='Ref_to_Func'>WalSndCheckTimeOut</span></a><span class='Parentheses'>(</span><a href="../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <a href="../utils/adt/timestamp.c.html#LN1532"><span class='Ref_to_Func'>now</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Keyword'>static long </span><a href="walsender.c.html#LN1998"><span class='Ref_to_Func'>WalSndComputeSleeptime</span></a><span class='Parentheses'>(</span><a href="../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <a href="../utils/adt/timestamp.c.html#LN1532"><span class='Ref_to_Func'>now</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Keyword'>static void </span><a href="walsender.c.html#LN1130"><span class='Ref_to_Func'>WalSndPrepareWrite</span></a><span class='Parentheses'>(</span><a href="../../include/replication/logical.h.html#LN34"><span class='Ref_to_Struct'>LogicalDecodingContext</span></a> <span class='Operator'>*</span>ctx<span class='Delimiter'>, </span><a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> lsn<span class='Delimiter'>, </span><a href="../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> xid<span class='Delimiter'>, </span><span class='Keyword'>bool </span>last_write<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Keyword'>static void </span><a href="walsender.c.html#LN1157"><span class='Ref_to_Func'>WalSndWriteData</span></a><span class='Parentheses'>(</span><a href="../../include/replication/logical.h.html#LN34"><span class='Ref_to_Struct'>LogicalDecodingContext</span></a> <span class='Operator'>*</span>ctx<span class='Delimiter'>, </span><a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> lsn<span class='Delimiter'>, </span><a href="../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> xid<span class='Delimiter'>, </span><span class='Keyword'>bool </span>last_write<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Keyword'>static void </span><a href="walsender.c.html#LN1247"><span class='Ref_to_Func'>WalSndUpdateProgress</span></a><span class='Parentheses'>(</span><a href="../../include/replication/logical.h.html#LN34"><span class='Ref_to_Struct'>LogicalDecodingContext</span></a> <span class='Operator'>*</span>ctx<span class='Delimiter'>, </span><a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> lsn<span class='Delimiter'>, </span><a href="../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> xid<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Keyword'>static </span><a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <a href="walsender.c.html#LN1269"><span class='Ref_to_Func'>WalSndWaitForWal</span></a><span class='Parentheses'>(</span><a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> loc<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Keyword'>static void </span><a href="walsender.c.html#LN3363"><span class='Ref_to_Func'>LagTrackerWrite</span></a><span class='Parentheses'>(</span><a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> lsn<span class='Delimiter'>, </span><a href="../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> local_flush_time<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Keyword'>static </span><a href="../../include/datatype/timestamp.h.html#LN39"><span class='Ref_to_Typedef'>TimeOffset</span></a> <a href="walsender.c.html#LN3428"><span class='Ref_to_Func'>LagTrackerRead</span></a><span class='Parentheses'>(</span><span class='Keyword'>int </span>head<span class='Delimiter'>, </span><a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> lsn<span class='Delimiter'>, </span><a href="../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <a href="../utils/adt/timestamp.c.html#LN1532"><span class='Ref_to_Func'>now</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Keyword'>static bool </span><a href="../utils/adt/txid.c.html#LN109"><span class='Ref_to_Func'>TransactionIdInRecentPast</span></a><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> xid<span class='Delimiter'>, </span><a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <a href="../../port/gettimeofday.c.html#LN33"><span class='Ref_to_Global_Var'>epoch</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Keyword'>static void </span><a href="../access/transam/xlogutils.c.html#LN655"><span class='Ref_to_Func'>XLogRead</span></a><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><a href="../../bin/pg_test_fsync/pg_test_fsync.c.html#LN66"><span class='Ref_to_Global_Var'>buf</span></a><span class='Delimiter'>, </span><a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> startptr<span class='Delimiter'>, </span><a href="../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a> count<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* Initialize walsender process before entering the main command loop */ 
</span><span class='Keyword'>void 
</span><a href="../../include/replication/walsender.h.html#LN39"><span class='Ref_to_Proto'>InitWalSender</span></a><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="walsender.c.html#LN114"><span class='Ref_to_Global_Var'>am_cascading_walsender</span></a> <span class='Operator'>= </span><a href="../../include/access/xlog.h.html#LN242"><span class='Ref_to_Proto'>RecoveryInProgress</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Create a per-walsender data structure in shared memory */ 
</span>    <a href="walsender.c.html#LN224"><span class='Ref_to_Proto'>InitWalSenderSlot</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Set up resource owner */ 
</span>    <a href="../utils/resowner/resowner.c.html#LN137"><span class='Ref_to_Global_Var'>CurrentResourceOwner</span></a> <span class='Operator'>= </span><a href="../../include/utils/resowner.h.html#LN66"><span class='Ref_to_Proto'>ResourceOwnerCreate</span></a><span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='String'>"walsender top-level resource owner"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Let postmaster know that we're a WAL sender. Once we've declared us as 
     * a WAL sender process, postmaster will let us outlive the bgwriter and 
     * kill us last in the shutdown sequence, so we get a chance to stream all 
     * remaining WAL at shutdown, including the shutdown checkpoint. Note that 
     * there's no going back, and we mustn't write any WAL records after this. 
     */ 
</span>    <a href="../../include/storage/pmsignal.h.html#LN52"><span class='Ref_to_Proto'>MarkPostmasterChildWalSender</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="../../include/storage/pmsignal.h.html#LN45"><span class='Ref_to_Proto'>SendPostmasterSignal</span></a><span class='Parentheses'>(</span><a href="../../include/storage/pmsignal.h.html#LN32"><span class='Ref_to_EnumConst'>PMSIGNAL_ADVANCE_STATE_MACHINE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Initialize empty timestamp buffer for lag tracking. */ 
</span>    memset<span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN216"><span class='Ref_to_Global_Var'>LagTracker</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="walsender.c.html#LN216"><span class='Ref_to_Global_Var'>LagTracker</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end WalSndShutdown &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Clean up after an error. 
 * 
 * WAL sender processes don't use transactions like regular backends do. 
 * This function does any cleanup required after an error in a WAL sender 
 * process, similar to what transaction abort does in a regular backend. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN289"></a><span class='Declare_Function'>WalSndErrorCleanup</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../include/storage/lwlock.h.html#LN150"><span class='Ref_to_Proto'>LWLockReleaseAll</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="../../include/storage/condition_variable.h.html#LN45"><span class='Ref_to_Proto'>ConditionVariableCancelSleep</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="../../include/pgstat.h.html#LN1230"><span class='Ref_to_Func'>pgstat_report_wait_end</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="basebackup.c.html#LN55"><span class='Ref_to_Proto'>sendFile</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../interfaces/libpq/win32.h.html#LN11"><span class='Ref_to_Macro'>close</span></a><span class='Parentheses'>(</span><a href="basebackup.c.html#LN55"><span class='Ref_to_Proto'>sendFile</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="basebackup.c.html#LN55"><span class='Ref_to_Proto'>sendFile</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="slot.c.html#LN95"><span class='Ref_to_Global_Var'>MyReplicationSlot</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../include/replication/slot.h.html#LN167"><span class='Ref_to_Proto'>ReplicationSlotRelease</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/replication/slot.h.html#LN168"><span class='Ref_to_Proto'>ReplicationSlotCleanup</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <a href="walsender.c.html#LN193"><span class='Ref_to_Global_Var'>replication_active</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN185"><span class='Ref_to_Global_Var'>got_STOPPING</span></a> <span class='Operator'>|| </span><a href="../postmaster/autovacuum.c.html#LN140"><span class='Ref_to_Global_Var'>got_SIGUSR2</span></a><span class='Parentheses'>) 
</span>        <a href="../storage/ipc/ipc.c.html#LN97"><span class='Ref_to_Func'>proc_exit</span></a><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Revert back to startup state */ 
</span>    <a href="../../include/replication/walsender_private.h.html#LN102"><span class='Ref_to_Proto'>WalSndSetState</span></a><span class='Parentheses'>(</span><a href="../../include/replication/walsender_private.h.html#LN23"><span class='Ref_to_EnumConst'>WALSNDSTATE_STARTUP</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end WalSndErrorCleanup &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Handle a client's connection abort in an orderly manner. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN319"></a><span class='Declare_Function'>WalSndShutdown</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * Reset whereToSendOutput to prevent ereport from attempting to send any 
     * more messages to the standby. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../tcop/postgres.c.html#LN87"><span class='Ref_to_Global_Var'>whereToSendOutput</span></a> <span class='Operator'>== </span><a href="../../include/tcop/dest.h.html#LN89"><span class='Ref_to_EnumConst'>DestRemote</span></a><span class='Parentheses'>) 
</span>        <a href="../tcop/postgres.c.html#LN87"><span class='Ref_to_Global_Var'>whereToSendOutput</span></a> <span class='Operator'>= </span><a href="../../include/tcop/dest.h.html#LN87"><span class='Ref_to_EnumConst'>DestNone</span></a><span class='Delimiter'>; 
</span> 
    <a href="../storage/ipc/ipc.c.html#LN97"><span class='Ref_to_Func'>proc_exit</span></a><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    abort<span class='Parentheses'>()</span><span class='Delimiter'>;</span>                    <span class='Comment_Single_Line'>/* keep the compiler quiet */ 
</span><span class='Delimiter'>} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Handle the IDENTIFY_SYSTEM command. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN336"></a><span class='Declare_Function'>IdentifySystem</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN338"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>sysid</span><span class='Delimiter'>[</span><span class='Number'>32</span><span class='Delimiter'>]; 
</span><a name="LN339"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>xloc</span><span class='Delimiter'>[</span><a href="../../include/access/xlog_internal.h.html#LN137"><span class='Ref_to_Const'>MAXFNAMELEN</span></a><span class='Delimiter'>]; 
</span><a name="LN340"></a>    <a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>logptr</span><span class='Delimiter'>; 
</span><a name="LN341"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>dbname</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN342"></a>    <a href="../../include/tcop/dest.h.html#LN112"><span class='Ref_to_Typedef'>DestReceiver</span></a> <span class='Operator'>*</span><span class='Declare_Local'>dest</span><span class='Delimiter'>; 
</span><a name="LN343"></a>    <a href="../../include/executor/executor.h.html#LN411"><span class='Ref_to_Struct'>TupOutputState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tstate</span><span class='Delimiter'>; 
</span><a name="LN344"></a>    <a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Local'>tupdesc</span><span class='Delimiter'>; 
</span><a name="LN345"></a>    <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>values</span><span class='Delimiter'>[</span><span class='Number'>4</span><span class='Delimiter'>]; 
</span><a name="LN346"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>nulls</span><span class='Delimiter'>[</span><span class='Number'>4</span><span class='Delimiter'>]; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Reply with a result set with one row, four columns. First col is system 
     * ID, second is timeline ID, third is current xlog location and the 
     * fourth contains the database name if we are connected to one. 
     */ 
</span> 
    <a href="../../pl/plperl/plperl.h.html#LN60"><span class='Ref_to_Macro'>snprintf</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN338"><span class='Ref_To_Local'>sysid</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="walsender.c.html#LN338"><span class='Ref_To_Local'>sysid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN315"><span class='Ref_to_Const'>UINT64_FORMAT</span></a><span class='Delimiter'>, 
</span>             <a href="../../include/access/xlog.h.html#LN257"><span class='Ref_to_Proto'>GetSystemIdentifier</span></a><span class='Parentheses'>())</span><span class='Delimiter'>; 
</span> 
    <a href="walsender.c.html#LN114"><span class='Ref_to_Global_Var'>am_cascading_walsender</span></a> <span class='Operator'>= </span><a href="../../include/access/xlog.h.html#LN242"><span class='Ref_to_Proto'>RecoveryInProgress</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN114"><span class='Ref_to_Global_Var'>am_cascading_walsender</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* this also updates ThisTimeLineID */ 
</span>        <a href="walsender.c.html#LN340"><span class='Ref_To_Local'>logptr</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN2840"><span class='Ref_to_Func'>GetStandbyFlushRecPtr</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
        <a href="walsender.c.html#LN340"><span class='Ref_To_Local'>logptr</span></a> <span class='Operator'>= </span><a href="../../include/access/xlog.h.html#LN275"><span class='Ref_to_Proto'>GetFlushRecPtr</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <a href="../../pl/plperl/plperl.h.html#LN60"><span class='Ref_to_Macro'>snprintf</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN339"><span class='Ref_To_Local'>xloc</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="walsender.c.html#LN339"><span class='Ref_To_Local'>xloc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='String'>"%X/%X"</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="walsender.c.html#LN340"><span class='Ref_To_Local'>logptr</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="walsender.c.html#LN340"><span class='Ref_To_Local'>logptr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN76"><span class='Ref_to_Global_Var'>MyDatabaseId</span></a> <span class='Operator'>!= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN370"></a>        <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>cur</span> <span class='Operator'>= </span><a href="../utils/mmgr/mcxt.c.html#LN36"><span class='Ref_to_Global_Var'>CurrentMemoryContext</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* syscache access needs a transaction env. */ 
</span>        <a href="../../include/access/xact.h.html#LN348"><span class='Ref_to_Proto'>StartTransactionCommand</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* make dbname live outside TX context */ 
</span>        <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN370"><span class='Ref_To_Local'>cur</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN341"><span class='Ref_To_Local'>dbname</span></a> <span class='Operator'>= </span><a href="../../include/commands/dbcommands.h.html#LN29"><span class='Ref_to_Proto'>get_database_name</span></a><span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN76"><span class='Ref_to_Global_Var'>MyDatabaseId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/access/xact.h.html#LN349"><span class='Ref_to_Proto'>CommitTransactionCommand</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* CommitTransactionCommand switches to TopMemoryContext */ 
</span>        <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN370"><span class='Ref_To_Local'>cur</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="walsender.c.html#LN342"><span class='Ref_To_Local'>dest</span></a> <span class='Operator'>= </span><a href="../tcop/dest.c.html#LN107"><span class='Ref_to_Func'>CreateDestReceiver</span></a><span class='Parentheses'>(</span><a href="../../include/tcop/dest.h.html#LN91"><span class='Ref_to_EnumConst'>DestRemoteSimple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN346"><span class='Ref_To_Local'>nulls</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="walsender.c.html#LN346"><span class='Ref_To_Local'>nulls</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* need a tuple descriptor representing four columns */ 
</span>    <a href="walsender.c.html#LN344"><span class='Ref_To_Local'>tupdesc</span></a> <span class='Operator'>= </span><a href="../access/common/tupdesc.c.html#LN39"><span class='Ref_to_Func'>CreateTemplateTupleDesc</span></a><span class='Parentheses'>(</span><span class='Number'>4</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/access/tupdesc.h.html#LN121"><span class='Ref_to_Proto'>TupleDescInitBuiltinEntry</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN344"><span class='Ref_To_Local'>tupdesc</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a><span class='Parentheses'>) </span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='String'>"systemid"</span><span class='Delimiter'>, 
</span>                              <a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN26"><span class='Ref_to_Const'>TEXTOID</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/access/tupdesc.h.html#LN121"><span class='Ref_to_Proto'>TupleDescInitBuiltinEntry</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN344"><span class='Ref_To_Local'>tupdesc</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a><span class='Parentheses'>) </span><span class='Number'>2</span><span class='Delimiter'>, </span><span class='String'>"timeline"</span><span class='Delimiter'>, 
</span>                              <a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN24"><span class='Ref_to_Const'>INT4OID</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/access/tupdesc.h.html#LN121"><span class='Ref_to_Proto'>TupleDescInitBuiltinEntry</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN344"><span class='Ref_To_Local'>tupdesc</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a><span class='Parentheses'>) </span><span class='Number'>3</span><span class='Delimiter'>, </span><span class='String'>"xlogpos"</span><span class='Delimiter'>, 
</span>                              <a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN26"><span class='Ref_to_Const'>TEXTOID</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/access/tupdesc.h.html#LN121"><span class='Ref_to_Proto'>TupleDescInitBuiltinEntry</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN344"><span class='Ref_To_Local'>tupdesc</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a><span class='Parentheses'>) </span><span class='Number'>4</span><span class='Delimiter'>, </span><span class='String'>"dbname"</span><span class='Delimiter'>, 
</span>                              <a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN26"><span class='Ref_to_Const'>TEXTOID</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* prepare for projection of tuples */ 
</span>    <a href="walsender.c.html#LN343"><span class='Ref_To_Local'>tstate</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN417"><span class='Ref_to_Proto'>begin_tup_output_tupdesc</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN342"><span class='Ref_To_Local'>dest</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN344"><span class='Ref_To_Local'>tupdesc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* column 1: system identifier */ 
</span>    <a href="walsender.c.html#LN345"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/utils/builtins.h.html#LN90"><span class='Ref_to_Macro'>CStringGetTextDatum</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN338"><span class='Ref_To_Local'>sysid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* column 2: timeline */ 
</span>    <a href="walsender.c.html#LN345"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/postgres.h.html#LN484"><span class='Ref_to_Macro'>Int32GetDatum</span></a><span class='Parentheses'>(</span><a href="../access/transam/xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* column 3: wal location */ 
</span>    <a href="walsender.c.html#LN345"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><span class='Number'>2</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/utils/builtins.h.html#LN90"><span class='Ref_to_Macro'>CStringGetTextDatum</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN339"><span class='Ref_To_Local'>xloc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* column 4: database name, or NULL if none */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN341"><span class='Ref_To_Local'>dbname</span></a><span class='Parentheses'>) 
</span>        <a href="walsender.c.html#LN345"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><span class='Number'>3</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/utils/builtins.h.html#LN90"><span class='Ref_to_Macro'>CStringGetTextDatum</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN341"><span class='Ref_To_Local'>dbname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="walsender.c.html#LN346"><span class='Ref_To_Local'>nulls</span></a><span class='Delimiter'>[</span><span class='Number'>3</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* send it to dest */ 
</span>    <a href="../../include/executor/executor.h.html#LN419"><span class='Ref_to_Proto'>do_tup_output</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN343"><span class='Ref_To_Local'>tstate</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN345"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN346"><span class='Ref_To_Local'>nulls</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/executor/executor.h.html#LN421"><span class='Ref_to_Proto'>end_tup_output</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN343"><span class='Ref_To_Local'>tstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end IdentifySystem &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Handle TIMELINE_HISTORY command. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN425"></a><span class='Declare_Function'>SendTimeLineHistory</span><span class='Parentheses'>(</span><a href="../../include/nodes/replnodes.h.html#LN92"><span class='Ref_to_Struct'>TimeLineHistoryCmd</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>cmd</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN427"></a>    <a href="../../include/lib/stringinfo.h.html#LN34"><span class='Ref_to_Struct'>StringInfoData</span></a> <span class='Declare_Local'>buf</span><span class='Delimiter'>; 
</span><a name="LN428"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>histfname</span><span class='Delimiter'>[</span><a href="../../include/access/xlog_internal.h.html#LN137"><span class='Ref_to_Const'>MAXFNAMELEN</span></a><span class='Delimiter'>]; 
</span><a name="LN429"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>path</span><span class='Delimiter'>[</span><a href="../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a><span class='Delimiter'>]; 
</span><a name="LN430"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>fd</span><span class='Delimiter'>; 
</span><a name="LN431"></a>    off_t       <span class='Declare_Local'>histfilelen</span><span class='Delimiter'>; 
</span><a name="LN432"></a>    off_t       <span class='Declare_Local'>bytesleft</span><span class='Delimiter'>; 
</span><a name="LN433"></a>    <a href="../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Local'>len</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Reply with a result set with one row, and two columns. The first col is 
     * the name of the history file, 2nd is the contents. 
     */ 
</span> 
    <a href="../../include/access/xlog_internal.h.html#LN177"><span class='Ref_to_Macro'>TLHistoryFileName</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN428"><span class='Ref_To_Local'>histfname</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN425"><span class='Ref_to_Parameter'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN95"><span class='Ref_to_Member'>timeline</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/access/xlog_internal.h.html#LN185"><span class='Ref_to_Macro'>TLHistoryFilePath</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN429"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN425"><span class='Ref_to_Parameter'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN95"><span class='Ref_to_Member'>timeline</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Send a RowDescription message */ 
</span>    <a href="../../include/libpq/pqformat.h.html#LN17"><span class='Ref_to_Proto'>pq_beginmessage</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN427"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='String'>'T'</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/libpq/pqformat.h.html#LN25"><span class='Ref_to_Proto'>pq_sendint</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN427"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='Number'>2</span><span class='Delimiter'>, </span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* 2 fields */ 
</span> 
    <span class='Comment_Multi_Line'>/* first field */ 
</span>    <a href="../../include/libpq/pqformat.h.html#LN23"><span class='Ref_to_Proto'>pq_sendstring</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN427"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='String'>"filename"</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* col name */ 
</span>    <a href="../../include/libpq/pqformat.h.html#LN25"><span class='Ref_to_Proto'>pq_sendint</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN427"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Number'>4</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* table oid */ 
</span>    <a href="../../include/libpq/pqformat.h.html#LN25"><span class='Ref_to_Proto'>pq_sendint</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN427"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* attnum */ 
</span>    <a href="../../include/libpq/pqformat.h.html#LN25"><span class='Ref_to_Proto'>pq_sendint</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN427"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN26"><span class='Ref_to_Const'>TEXTOID</span></a><span class='Delimiter'>, </span><span class='Number'>4</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* type oid */ 
</span>    <a href="../../include/libpq/pqformat.h.html#LN25"><span class='Ref_to_Proto'>pq_sendint</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN427"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* typlen */ 
</span>    <a href="../../include/libpq/pqformat.h.html#LN25"><span class='Ref_to_Proto'>pq_sendint</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN427"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Number'>4</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* typmod */ 
</span>    <a href="../../include/libpq/pqformat.h.html#LN25"><span class='Ref_to_Proto'>pq_sendint</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN427"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* format code */ 
</span> 
    <span class='Comment_Multi_Line'>/* second field */ 
</span>    <a href="../../include/libpq/pqformat.h.html#LN23"><span class='Ref_to_Proto'>pq_sendstring</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN427"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='String'>"content"</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* col name */ 
</span>    <a href="../../include/libpq/pqformat.h.html#LN25"><span class='Ref_to_Proto'>pq_sendint</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN427"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Number'>4</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* table oid */ 
</span>    <a href="../../include/libpq/pqformat.h.html#LN25"><span class='Ref_to_Proto'>pq_sendint</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN427"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* attnum */ 
</span>    <a href="../../include/libpq/pqformat.h.html#LN25"><span class='Ref_to_Proto'>pq_sendint</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN427"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN18"><span class='Ref_to_Const'>BYTEAOID</span></a><span class='Delimiter'>, </span><span class='Number'>4</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* type oid */ 
</span>    <a href="../../include/libpq/pqformat.h.html#LN25"><span class='Ref_to_Proto'>pq_sendint</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN427"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* typlen */ 
</span>    <a href="../../include/libpq/pqformat.h.html#LN25"><span class='Ref_to_Proto'>pq_sendint</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN427"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Number'>4</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* typmod */ 
</span>    <a href="../../include/libpq/pqformat.h.html#LN25"><span class='Ref_to_Proto'>pq_sendint</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN427"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* format code */ 
</span>    <a href="../../include/libpq/pqformat.h.html#LN29"><span class='Ref_to_Proto'>pq_endmessage</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN427"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Send a DataRow message */ 
</span>    <a href="../../include/libpq/pqformat.h.html#LN17"><span class='Ref_to_Proto'>pq_beginmessage</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN427"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='String'>'D'</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/libpq/pqformat.h.html#LN25"><span class='Ref_to_Proto'>pq_sendint</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN427"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='Number'>2</span><span class='Delimiter'>, </span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* # of columns */ 
</span>    <a href="walsender.c.html#LN433"><span class='Ref_To_Local'>len</span></a> <span class='Operator'>= </span>strlen<span class='Parentheses'>(</span><a href="walsender.c.html#LN428"><span class='Ref_To_Local'>histfname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/libpq/pqformat.h.html#LN25"><span class='Ref_to_Proto'>pq_sendint</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN427"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN433"><span class='Ref_To_Local'>len</span></a><span class='Delimiter'>, </span><span class='Number'>4</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* col1 len */ 
</span>    <a href="../../include/libpq/pqformat.h.html#LN19"><span class='Ref_to_Proto'>pq_sendbytes</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN427"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN428"><span class='Ref_To_Local'>histfname</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN433"><span class='Ref_To_Local'>len</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="walsender.c.html#LN430"><span class='Ref_To_Local'>fd</span></a> <span class='Operator'>= </span><a href="../../include/storage/fd.h.html#LN96"><span class='Ref_to_Proto'>OpenTransientFile</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN429"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span>O_RDONLY <span class='Operator'>| </span><a href="../../include/c.h.html#LN1032"><span class='Ref_to_Const'>PG_BINARY</span></a><span class='Delimiter'>, </span><span class='Number'>0666</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN430"><span class='Ref_To_Local'>fd</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not open file \"%s\": %m"</span><span class='Delimiter'>, </span><a href="walsender.c.html#LN429"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Determine file length and send it to client */ 
</span>    <a href="walsender.c.html#LN431"><span class='Ref_To_Local'>histfilelen</span></a> <span class='Operator'>= </span>lseek<span class='Parentheses'>(</span><a href="walsender.c.html#LN430"><span class='Ref_To_Local'>fd</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span>SEEK_END<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN431"><span class='Ref_To_Local'>histfilelen</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not seek to end of file \"%s\": %m"</span><span class='Delimiter'>, </span><a href="walsender.c.html#LN429"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span>lseek<span class='Parentheses'>(</span><a href="walsender.c.html#LN430"><span class='Ref_To_Local'>fd</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span>SEEK_SET<span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>            <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not seek to beginning of file \"%s\": %m"</span><span class='Delimiter'>, </span><a href="walsender.c.html#LN429"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/libpq/pqformat.h.html#LN25"><span class='Ref_to_Proto'>pq_sendint</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN427"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN431"><span class='Ref_To_Local'>histfilelen</span></a><span class='Delimiter'>, </span><span class='Number'>4</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* col2 len */ 
</span> 
    <a href="walsender.c.html#LN432"><span class='Ref_To_Local'>bytesleft</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN431"><span class='Ref_To_Local'>histfilelen</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN432"><span class='Ref_To_Local'>bytesleft</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN495"></a>        <span class='Keyword'>char</span>        <span class='Declare_Local'>rbuf</span><span class='Delimiter'>[</span>BLCKSZ<span class='Delimiter'>]; 
</span><a name="LN496"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>nread</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/pgstat.h.html#LN1206"><span class='Ref_to_Func'>pgstat_report_wait_start</span></a><span class='Parentheses'>(</span><a href="../../include/pgstat.h.html#LN894"><span class='Ref_to_EnumConst'>WAIT_EVENT_WALSENDER_TIMELINE_HISTORY_READ</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN496"><span class='Ref_To_Local'>nread</span></a> <span class='Operator'>= </span><a href="../../interfaces/libpq/win32.h.html#LN12"><span class='Ref_to_Macro'>read</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN430"><span class='Ref_To_Local'>fd</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN495"><span class='Ref_To_Local'>rbuf</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="walsender.c.html#LN495"><span class='Ref_To_Local'>rbuf</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="../../include/pgstat.h.html#LN1230"><span class='Ref_to_Func'>pgstat_report_wait_end</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN496"><span class='Ref_To_Local'>nread</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not read file \"%s\": %m"</span><span class='Delimiter'>, 
</span>                            <a href="walsender.c.html#LN429"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <a href="../../include/libpq/pqformat.h.html#LN19"><span class='Ref_to_Proto'>pq_sendbytes</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN427"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN495"><span class='Ref_To_Local'>rbuf</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN496"><span class='Ref_To_Local'>nread</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN432"><span class='Ref_To_Local'>bytesleft</span></a> <span class='Operator'>-= </span><a href="walsender.c.html#LN496"><span class='Ref_To_Local'>nread</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../include/storage/fd.h.html#LN97"><span class='Ref_to_Proto'>CloseTransientFile</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN430"><span class='Ref_To_Local'>fd</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/libpq/pqformat.h.html#LN29"><span class='Ref_to_Proto'>pq_endmessage</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN427"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end SendTimeLineHistory &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Handle START_REPLICATION command. 
 * 
 * At the moment, this never returns, but an ereport(ERROR) will take us back 
 * to the main loop. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN521"></a><span class='Declare_Function'>StartReplication</span><span class='Parentheses'>(</span><a href="../../include/nodes/replnodes.h.html#LN77"><span class='Ref_to_Struct'>StartReplicationCmd</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>cmd</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN523"></a>    <a href="../../include/lib/stringinfo.h.html#LN34"><span class='Ref_to_Struct'>StringInfoData</span></a> <span class='Declare_Local'>buf</span><span class='Delimiter'>; 
</span><a name="LN524"></a>    <a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>FlushPtr</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../access/transam/xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>        <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"IDENTIFY_SYSTEM has not been run before START_REPLICATION"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We assume here that we're logging enough information in the WAL for 
     * log-shipping, since this is checked in PostmasterMain(). 
     * 
     * NOTE: wal_level can only change at shutdown, so in most cases it is 
     * difficult for there to be WAL data that we can still see that was 
     * written at wal_level='minimal'. 
     */ 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN521"><span class='Ref_to_Parameter'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN81"><span class='Ref_to_Member'>slotname</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../include/replication/slot.h.html#LN166"><span class='Ref_to_Proto'>ReplicationSlotAcquire</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN521"><span class='Ref_to_Parameter'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN81"><span class='Ref_to_Member'>slotname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/replication/slot.h.html#LN133"><span class='Ref_to_Macro'>SlotIsLogical</span></a><span class='Parentheses'>(</span><a href="slot.c.html#LN95"><span class='Ref_to_Global_Var'>MyReplicationSlot</span></a><span class='Parentheses'>))</span> 
            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <span class='Parentheses'>(</span><a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"cannot use a logical replication slot for physical replication"</span><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Select the timeline. If it was given explicitly by the client, use 
     * that. Otherwise use the timeline of the last replayed record, which is 
     * kept in ThisTimeLineID. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN114"><span class='Ref_to_Global_Var'>am_cascading_walsender</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* this also updates ThisTimeLineID */ 
</span>        <a href="walsender.c.html#LN524"><span class='Ref_To_Local'>FlushPtr</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN2840"><span class='Ref_to_Func'>GetStandbyFlushRecPtr</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
        <a href="walsender.c.html#LN524"><span class='Ref_To_Local'>FlushPtr</span></a> <span class='Operator'>= </span><a href="../../include/access/xlog.h.html#LN275"><span class='Ref_to_Proto'>GetFlushRecPtr</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN521"><span class='Ref_to_Parameter'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN82"><span class='Ref_to_Member'>timeline</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN564"></a>        <a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>switchpoint</span><span class='Delimiter'>; 
</span> 
        <a href="walsender.c.html#LN146"><span class='Ref_to_Global_Var'>sendTimeLine</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN521"><span class='Ref_to_Parameter'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN82"><span class='Ref_to_Member'>timeline</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN146"><span class='Ref_to_Global_Var'>sendTimeLine</span></a> <span class='Operator'>== </span><a href="../access/transam/xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="walsender.c.html#LN148"><span class='Ref_to_Global_Var'>sendTimeLineIsHistoric</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="walsender.c.html#LN149"><span class='Ref_to_Global_Var'>sendTimeLineValidUpto</span></a> <span class='Operator'>= </span><a href="../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span><a name="LN574"></a>            <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>timeLineHistory</span><span class='Delimiter'>; 
</span> 
            <a href="walsender.c.html#LN148"><span class='Ref_to_Global_Var'>sendTimeLineIsHistoric</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Check that the timeline the client requested exists, and the 
             * requested start location is on that timeline. 
             */ 
</span>            <a href="walsender.c.html#LN574"><span class='Ref_To_Local'>timeLineHistory</span></a> <span class='Operator'>= </span><a href="../../include/access/timeline.h.html#LN31"><span class='Ref_to_Proto'>readTimeLineHistory</span></a><span class='Parentheses'>(</span><a href="../access/transam/xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="walsender.c.html#LN564"><span class='Ref_To_Local'>switchpoint</span></a> <span class='Operator'>= </span><a href="../../include/access/timeline.h.html#LN40"><span class='Ref_to_Proto'>tliSwitchPoint</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN521"><span class='Ref_to_Parameter'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN82"><span class='Ref_to_Member'>timeline</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN574"><span class='Ref_To_Local'>timeLineHistory</span></a><span class='Delimiter'>, 
</span>                                         <span class='Operator'>&</span><a href="walsender.c.html#LN147"><span class='Ref_to_Global_Var'>sendTimeLineNextTLI</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../include/nodes/pg_list.h.html#LN266"><span class='Ref_to_Proto'>list_free_deep</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN574"><span class='Ref_To_Local'>timeLineHistory</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Found the requested timeline in the history. Check that 
             * requested startpoint is on that timeline in our history. 
             * 
             * This is quite loose on purpose. We only check that we didn't 
             * fork off the requested timeline before the switchpoint. We 
             * don't check that we switched *to* it before the requested 
             * starting point. This is because the client can legitimately 
             * request to start replication from the beginning of the WAL 
             * segment that contains switchpoint, but on the new timeline, so 
             * that it doesn't end up with a partial segment. If you ask for 
             * too old a starting point, you'll get an error later when we 
             * fail to find the requested WAL segment in pg_wal. 
             * 
             * XXX: we could be more strict here and only allow a startpoint 
             * that's older than the switchpoint, if it's still in the same 
             * WAL segment. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/xlogdefs.h.html#LN28"><span class='Ref_to_Macro'>XLogRecPtrIsInvalid</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN564"><span class='Ref_To_Local'>switchpoint</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                <a href="walsender.c.html#LN564"><span class='Ref_To_Local'>switchpoint</span></a> <span class='Operator'>&LT; </span><a href="walsender.c.html#LN521"><span class='Ref_to_Parameter'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN83"><span class='Ref_to_Member'>startpoint</span></a><span class='Parentheses'>)</span> 
            <span class='Delimiter'>{ 
</span>                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"requested starting point %X/%X on timeline %u is not in this server's history"</span><span class='Delimiter'>, 
</span>                                <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="walsender.c.html#LN521"><span class='Ref_to_Parameter'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN83"><span class='Ref_to_Member'>startpoint</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="walsender.c.html#LN521"><span class='Ref_to_Parameter'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN83"><span class='Ref_to_Member'>startpoint</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                <a href="walsender.c.html#LN521"><span class='Ref_to_Parameter'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN82"><span class='Ref_to_Member'>timeline</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"This server's history forked from timeline %u at %X/%X."</span><span class='Delimiter'>, 
</span>                                   <a href="walsender.c.html#LN521"><span class='Ref_to_Parameter'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN82"><span class='Ref_to_Member'>timeline</span></a><span class='Delimiter'>, 
</span>                                   <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="walsender.c.html#LN564"><span class='Ref_To_Local'>switchpoint</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                   <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="walsender.c.html#LN564"><span class='Ref_To_Local'>switchpoint</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <a href="walsender.c.html#LN149"><span class='Ref_to_Global_Var'>sendTimeLineValidUpto</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN564"><span class='Ref_To_Local'>switchpoint</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if cmd-&GT;timeline!=0 &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="walsender.c.html#LN146"><span class='Ref_to_Global_Var'>sendTimeLine</span></a> <span class='Operator'>= </span><a href="../access/transam/xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN149"><span class='Ref_to_Global_Var'>sendTimeLineValidUpto</span></a> <span class='Operator'>= </span><a href="../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN148"><span class='Ref_to_Global_Var'>sendTimeLineIsHistoric</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="walsender.c.html#LN177"><span class='Ref_to_Global_Var'>streamingDoneSending</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN178"><span class='Ref_to_Global_Var'>streamingDoneReceiving</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If there is nothing to stream, don't even enter COPY mode */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="walsender.c.html#LN148"><span class='Ref_to_Global_Var'>sendTimeLineIsHistoric</span></a> <span class='Operator'>|| </span><a href="walsender.c.html#LN521"><span class='Ref_to_Parameter'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN83"><span class='Ref_to_Member'>startpoint</span></a> <span class='Operator'>&LT; </span><a href="walsender.c.html#LN149"><span class='Ref_to_Global_Var'>sendTimeLineValidUpto</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * When we first start replication the standby will be behind the 
         * primary. For some applications, for example synchronous 
         * replication, it is important to have a clear state for this initial 
         * catchup mode, so we can trigger actions when we change streaming 
         * state later. We may stay in this state for a long time, which is 
         * exactly why we want to be able to monitor whether or not we are 
         * still here. 
         */ 
</span>        <a href="../../include/replication/walsender_private.h.html#LN102"><span class='Ref_to_Proto'>WalSndSetState</span></a><span class='Parentheses'>(</span><a href="../../include/replication/walsender_private.h.html#LN25"><span class='Ref_to_EnumConst'>WALSNDSTATE_CATCHUP</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Send a CopyBothResponse message, and start streaming */ 
</span>        <a href="../../include/libpq/pqformat.h.html#LN17"><span class='Ref_to_Proto'>pq_beginmessage</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN523"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='String'>'W'</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/libpq/pqformat.h.html#LN18"><span class='Ref_to_Proto'>pq_sendbyte</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN523"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/libpq/pqformat.h.html#LN25"><span class='Ref_to_Proto'>pq_sendint</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN523"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/libpq/pqformat.h.html#LN29"><span class='Ref_to_Proto'>pq_endmessage</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN523"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/libpq/libpq.h.html#LN38"><span class='Ref_to_Macro'>pq_flush</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Don't allow a request to stream from a future point in WAL that 
         * hasn't been flushed to disk in this server yet. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN524"><span class='Ref_To_Local'>FlushPtr</span></a> <span class='Operator'>&LT; </span><a href="walsender.c.html#LN521"><span class='Ref_to_Parameter'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN83"><span class='Ref_to_Member'>startpoint</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"requested starting point %X/%X is ahead of the WAL flush position of this server %X/%X"</span><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="walsender.c.html#LN521"><span class='Ref_to_Parameter'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN83"><span class='Ref_to_Member'>startpoint</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="walsender.c.html#LN521"><span class='Ref_to_Parameter'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN83"><span class='Ref_to_Member'>startpoint</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="walsender.c.html#LN524"><span class='Ref_To_Local'>FlushPtr</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="walsender.c.html#LN524"><span class='Ref_To_Local'>FlushPtr</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Start streaming from the requested point */ 
</span>        <a href="walsender.c.html#LN155"><span class='Ref_to_Global_Var'>sentPtr</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN521"><span class='Ref_to_Parameter'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN83"><span class='Ref_to_Member'>startpoint</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Initialize shared memory status, too */ 
</span>        <span class='Delimiter'>{ 
</span><a name="LN670"></a>            <a href="../../include/replication/walsender_private.h.html#LN33"><span class='Ref_to_Struct'>WalSnd</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>walsnd</span> <span class='Operator'>= </span><a href="walsender.c.html#LN110"><span class='Ref_to_Global_Var'>MyWalSnd</span></a><span class='Delimiter'>; 
</span> 
            <a href="../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN670"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN56"><span class='Ref_to_Member'>mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="walsender.c.html#LN670"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN37"><span class='Ref_to_Member'>sentPtr</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN155"><span class='Ref_to_Global_Var'>sentPtr</span></a><span class='Delimiter'>; 
</span>            <a href="../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN670"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN56"><span class='Ref_to_Member'>mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="../../include/replication/syncrep.h.html#LN72"><span class='Ref_to_Proto'>SyncRepInitConfig</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Main loop of walsender */ 
</span>        <a href="walsender.c.html#LN193"><span class='Ref_to_Global_Var'>replication_active</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
        <a href="walsender.c.html#LN223"><span class='Ref_to_Proto'>WalSndLoop</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN2467"><span class='Ref_to_Func'>XLogSendPhysical</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="walsender.c.html#LN193"><span class='Ref_to_Global_Var'>replication_active</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN185"><span class='Ref_to_Global_Var'>got_STOPPING</span></a><span class='Parentheses'>) 
</span>            <a href="../storage/ipc/ipc.c.html#LN97"><span class='Ref_to_Func'>proc_exit</span></a><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/replication/walsender_private.h.html#LN102"><span class='Ref_to_Proto'>WalSndSetState</span></a><span class='Parentheses'>(</span><a href="../../include/replication/walsender_private.h.html#LN23"><span class='Ref_to_EnumConst'>WALSNDSTATE_STARTUP</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="walsender.c.html#LN177"><span class='Ref_to_Global_Var'>streamingDoneSending</span></a> <span class='Operator'>&& </span><a href="walsender.c.html#LN178"><span class='Ref_to_Global_Var'>streamingDoneReceiving</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !sendTimeLineIsHistor... &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN521"><span class='Ref_to_Parameter'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN81"><span class='Ref_to_Member'>slotname</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/replication/slot.h.html#LN167"><span class='Ref_to_Proto'>ReplicationSlotRelease</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Copy is finished now. Send a single-row result set indicating the next 
     * timeline. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN148"><span class='Ref_to_Global_Var'>sendTimeLineIsHistoric</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN701"></a>        <span class='Keyword'>char</span>        <span class='Declare_Local'>startpos_str</span><span class='Delimiter'>[</span><span class='Number'>8</span> <span class='Operator'>+ </span><span class='Number'>1</span> <span class='Operator'>+ </span><span class='Number'>8</span> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span><a name="LN702"></a>        <a href="../../include/tcop/dest.h.html#LN112"><span class='Ref_to_Typedef'>DestReceiver</span></a> <span class='Operator'>*</span><span class='Declare_Local'>dest</span><span class='Delimiter'>; 
</span><a name="LN703"></a>        <a href="../../include/executor/executor.h.html#LN411"><span class='Ref_to_Struct'>TupOutputState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tstate</span><span class='Delimiter'>; 
</span><a name="LN704"></a>        <a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Local'>tupdesc</span><span class='Delimiter'>; 
</span><a name="LN705"></a>        <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>values</span><span class='Delimiter'>[</span><span class='Number'>2</span><span class='Delimiter'>]; 
</span><a name="LN706"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>nulls</span><span class='Delimiter'>[</span><span class='Number'>2</span><span class='Delimiter'>]; 
</span> 
        <a href="../../pl/plperl/plperl.h.html#LN60"><span class='Ref_to_Macro'>snprintf</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN701"><span class='Ref_To_Local'>startpos_str</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="walsender.c.html#LN701"><span class='Ref_To_Local'>startpos_str</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='String'>"%X/%X"</span><span class='Delimiter'>, 
</span>                 <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="walsender.c.html#LN149"><span class='Ref_to_Global_Var'>sendTimeLineValidUpto</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="walsender.c.html#LN149"><span class='Ref_to_Global_Var'>sendTimeLineValidUpto</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="walsender.c.html#LN702"><span class='Ref_To_Local'>dest</span></a> <span class='Operator'>= </span><a href="../tcop/dest.c.html#LN107"><span class='Ref_to_Func'>CreateDestReceiver</span></a><span class='Parentheses'>(</span><a href="../../include/tcop/dest.h.html#LN91"><span class='Ref_to_EnumConst'>DestRemoteSimple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN706"><span class='Ref_To_Local'>nulls</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="walsender.c.html#LN706"><span class='Ref_To_Local'>nulls</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Need a tuple descriptor representing two columns. int8 may seem 
         * like a surprising data type for this, but in theory int4 would not 
         * be wide enough for this, as TimeLineID is unsigned. 
         */ 
</span>        <a href="walsender.c.html#LN704"><span class='Ref_To_Local'>tupdesc</span></a> <span class='Operator'>= </span><a href="../access/common/tupdesc.c.html#LN39"><span class='Ref_to_Func'>CreateTemplateTupleDesc</span></a><span class='Parentheses'>(</span><span class='Number'>2</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/access/tupdesc.h.html#LN121"><span class='Ref_to_Proto'>TupleDescInitBuiltinEntry</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN704"><span class='Ref_To_Local'>tupdesc</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a><span class='Parentheses'>) </span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='String'>"next_tli"</span><span class='Delimiter'>, 
</span>                                  <a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN21"><span class='Ref_to_Const'>INT8OID</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/access/tupdesc.h.html#LN121"><span class='Ref_to_Proto'>TupleDescInitBuiltinEntry</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN704"><span class='Ref_To_Local'>tupdesc</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a><span class='Parentheses'>) </span><span class='Number'>2</span><span class='Delimiter'>, </span><span class='String'>"next_tli_startpos"</span><span class='Delimiter'>, 
</span>                                  <a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN26"><span class='Ref_to_Const'>TEXTOID</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* prepare for projection of tuple */ 
</span>        <a href="walsender.c.html#LN703"><span class='Ref_To_Local'>tstate</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN417"><span class='Ref_to_Proto'>begin_tup_output_tupdesc</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN702"><span class='Ref_To_Local'>dest</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN704"><span class='Ref_To_Local'>tupdesc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="walsender.c.html#LN705"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/postgres.h.html#LN624"><span class='Ref_to_Macro'>Int64GetDatum</span></a><span class='Parentheses'>((</span><a href="../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a><span class='Parentheses'>) </span><a href="walsender.c.html#LN147"><span class='Ref_to_Global_Var'>sendTimeLineNextTLI</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN705"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/utils/builtins.h.html#LN90"><span class='Ref_to_Macro'>CStringGetTextDatum</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN701"><span class='Ref_To_Local'>startpos_str</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* send it to dest */ 
</span>        <a href="../../include/executor/executor.h.html#LN419"><span class='Ref_to_Proto'>do_tup_output</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN703"><span class='Ref_To_Local'>tstate</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN705"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN706"><span class='Ref_To_Local'>nulls</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/executor/executor.h.html#LN421"><span class='Ref_to_Proto'>end_tup_output</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN703"><span class='Ref_To_Local'>tstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if sendTimeLineIsHistori... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Send CommandComplete message */ 
</span>    <a href="../../include/libpq/pqformat.h.html#LN34"><span class='Ref_to_Proto'>pq_puttextmessage</span></a><span class='Parentheses'>(</span><span class='String'>'C'</span><span class='Delimiter'>, </span><span class='String'>"START_STREAMING"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end StartReplication &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * read_page callback for logical decoding contexts, as a walsender process. 
 * 
 * Inside the walsender we can do better than logical_read_local_xlog_page, 
 * which has to do a plain sleep/busy loop, because the walsender's latch gets 
 * set every time WAL is flushed. 
 */ 
</span><span class='Keyword'>static int 
</span><a name="LN750"></a><span class='Declare_Function'>logical_read_xlog_page</span><span class='Parentheses'>(</span><a href="../../include/access/xlogreader.h.html#LN68"><span class='Ref_to_Struct'>XLogReaderState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>targetPagePtr</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>reqLen</span><span class='Delimiter'>, 
</span><a name="LN751"></a>                <a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>targetRecPtr</span><span class='Delimiter'>, </span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Declare_Parameter'>cur_page</span><span class='Delimiter'>, </span><a href="../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pageTLI</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN753"></a>    <a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>flushptr</span><span class='Delimiter'>; 
</span><a name="LN754"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>count</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/access/xlogutils.h.html#LN54"><span class='Ref_to_Proto'>XLogReadDetermineTimeline</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN750"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN750"><span class='Ref_to_Parameter'>targetPagePtr</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN750"><span class='Ref_to_Parameter'>reqLen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN148"><span class='Ref_to_Global_Var'>sendTimeLineIsHistoric</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="walsender.c.html#LN750"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/xlogreader.h.html#LN164"><span class='Ref_to_Member'>currTLI</span></a> <span class='Operator'>!= </span><a href="../access/transam/xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN146"><span class='Ref_to_Global_Var'>sendTimeLine</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN750"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/xlogreader.h.html#LN164"><span class='Ref_to_Member'>currTLI</span></a><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN149"><span class='Ref_to_Global_Var'>sendTimeLineValidUpto</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN750"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/xlogreader.h.html#LN174"><span class='Ref_to_Member'>currTLIValidUntil</span></a><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN147"><span class='Ref_to_Global_Var'>sendTimeLineNextTLI</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN750"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/xlogreader.h.html#LN180"><span class='Ref_to_Member'>nextTLI</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* make sure we have enough WAL available */ 
</span>    <a href="walsender.c.html#LN753"><span class='Ref_To_Local'>flushptr</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN1269"><span class='Ref_to_Func'>WalSndWaitForWal</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN750"><span class='Ref_to_Parameter'>targetPagePtr</span></a> <span class='Operator'>+ </span><a href="walsender.c.html#LN750"><span class='Ref_to_Parameter'>reqLen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* more than one block available */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN750"><span class='Ref_to_Parameter'>targetPagePtr</span></a> <span class='Operator'>+ </span>XLOG_BLCKSZ <span class='Operator'>&LT;= </span><a href="walsender.c.html#LN753"><span class='Ref_To_Local'>flushptr</span></a><span class='Parentheses'>) 
</span>        <a href="walsender.c.html#LN754"><span class='Ref_To_Local'>count</span></a> <span class='Operator'>= </span>XLOG_BLCKSZ<span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* not enough WAL synced, that can happen during shutdown */ 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN750"><span class='Ref_to_Parameter'>targetPagePtr</span></a> <span class='Operator'>+ </span><a href="walsender.c.html#LN750"><span class='Ref_to_Parameter'>reqLen</span></a> <span class='Operator'>&GT; </span><a href="walsender.c.html#LN753"><span class='Ref_To_Local'>flushptr</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* part of the page available */ 
</span>    <span class='Control'>else</span> 
        <a href="walsender.c.html#LN754"><span class='Ref_To_Local'>count</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN753"><span class='Ref_To_Local'>flushptr</span></a> <span class='Operator'>- </span><a href="walsender.c.html#LN750"><span class='Ref_to_Parameter'>targetPagePtr</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* now actually read the data, we know it's there */ 
</span>    <a href="../access/transam/xlogutils.c.html#LN655"><span class='Ref_to_Func'>XLogRead</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN751"><span class='Ref_to_Parameter'>cur_page</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN750"><span class='Ref_to_Parameter'>targetPagePtr</span></a><span class='Delimiter'>, </span>XLOG_BLCKSZ<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="walsender.c.html#LN754"><span class='Ref_To_Local'>count</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end logical_read_xlog_page &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Process extra options given to CREATE_REPLICATION_SLOT. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN785"></a><span class='Declare_Function'>parseCreateReplSlotOptions</span><span class='Parentheses'>(</span><a href="../../include/nodes/replnodes.h.html#LN51"><span class='Ref_to_Struct'>CreateReplicationSlotCmd</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>cmd</span><span class='Delimiter'>, 
</span><a name="LN786"></a>                           <span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>reserve_wal</span><span class='Delimiter'>, 
</span><a name="LN787"></a>                           <a href="../../include/replication/walsender.h.html#LN21"><span class='Ref_to_Typedef'>CRSSnapshotAction</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>snapshot_action</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN789"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span><a name="LN790"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>snapshot_action_given</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN791"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>reserve_wal_given</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Parse options */ 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN789"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN785"><span class='Ref_to_Parameter'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN58"><span class='Ref_to_Member'>options</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN796"></a>        <a href="../../include/nodes/parsenodes.h.html#LN715"><span class='Ref_to_Struct'>DefElem</span></a>    <span class='Operator'>*</span><span class='Declare_Local'>defel</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN715"><span class='Ref_to_Struct'>DefElem</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN789"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="walsender.c.html#LN796"><span class='Ref_To_Local'>defel</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN719"><span class='Ref_to_Member'>defname</span></a><span class='Delimiter'>, </span><span class='String'>"export_snapshot"</span><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN790"><span class='Ref_To_Local'>snapshot_action_given</span></a> <span class='Operator'>|| </span><a href="walsender.c.html#LN785"><span class='Ref_to_Parameter'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN55"><span class='Ref_to_Member'>kind</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/replnodes.h.html#LN22"><span class='Ref_to_EnumConst'>REPLICATION_KIND_LOGICAL</span></a><span class='Parentheses'>) 
</span>                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_SYNTAX_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"conflicting or redundant options"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
            <a href="walsender.c.html#LN790"><span class='Ref_To_Local'>snapshot_action_given</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Operator'>*</span><a href="walsender.c.html#LN787"><span class='Ref_to_Parameter'>snapshot_action</span></a> <span class='Operator'>= </span><a href="../commands/define.c.html#LN109"><span class='Ref_to_Func'>defGetBoolean</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN796"><span class='Ref_To_Local'>defel</span></a><span class='Parentheses'>) </span><span class='Operator'>? </span><a href="../../include/replication/walsender.h.html#LN23"><span class='Ref_to_EnumConst'>CRS_EXPORT_SNAPSHOT</span></a> <span class='Operator'>: 
</span>                <a href="../../include/replication/walsender.h.html#LN24"><span class='Ref_to_EnumConst'>CRS_NOEXPORT_SNAPSHOT</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="walsender.c.html#LN796"><span class='Ref_To_Local'>defel</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN719"><span class='Ref_to_Member'>defname</span></a><span class='Delimiter'>, </span><span class='String'>"use_snapshot"</span><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN790"><span class='Ref_To_Local'>snapshot_action_given</span></a> <span class='Operator'>|| </span><a href="walsender.c.html#LN785"><span class='Ref_to_Parameter'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN55"><span class='Ref_to_Member'>kind</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/replnodes.h.html#LN22"><span class='Ref_to_EnumConst'>REPLICATION_KIND_LOGICAL</span></a><span class='Parentheses'>) 
</span>                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_SYNTAX_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"conflicting or redundant options"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
            <a href="walsender.c.html#LN790"><span class='Ref_To_Local'>snapshot_action_given</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Operator'>*</span><a href="walsender.c.html#LN787"><span class='Ref_to_Parameter'>snapshot_action</span></a> <span class='Operator'>= </span><a href="../../include/replication/walsender.h.html#LN25"><span class='Ref_to_EnumConst'>CRS_USE_SNAPSHOT</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="walsender.c.html#LN796"><span class='Ref_To_Local'>defel</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN719"><span class='Ref_to_Member'>defname</span></a><span class='Delimiter'>, </span><span class='String'>"reserve_wal"</span><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN791"><span class='Ref_To_Local'>reserve_wal_given</span></a> <span class='Operator'>|| </span><a href="walsender.c.html#LN785"><span class='Ref_to_Parameter'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN55"><span class='Ref_to_Member'>kind</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/replnodes.h.html#LN21"><span class='Ref_to_EnumConst'>REPLICATION_KIND_PHYSICAL</span></a><span class='Parentheses'>) 
</span>                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_SYNTAX_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"conflicting or redundant options"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
            <a href="walsender.c.html#LN791"><span class='Ref_To_Local'>reserve_wal_given</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Operator'>*</span><a href="walsender.c.html#LN786"><span class='Ref_to_Parameter'>reserve_wal</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized option: %s"</span><span class='Delimiter'>, </span><a href="walsender.c.html#LN796"><span class='Ref_To_Local'>defel</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN719"><span class='Ref_to_Member'>defname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end parseCreateReplSlotOptions &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Create a new replication slot. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN838"></a><span class='Declare_Function'>CreateReplicationSlot</span><span class='Parentheses'>(</span><a href="../../include/nodes/replnodes.h.html#LN51"><span class='Ref_to_Struct'>CreateReplicationSlotCmd</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>cmd</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN840"></a>    <span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Local'>snapshot_name</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN841"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>xloc</span><span class='Delimiter'>[</span><a href="../../include/access/xlog_internal.h.html#LN137"><span class='Ref_to_Const'>MAXFNAMELEN</span></a><span class='Delimiter'>]; 
</span><a name="LN842"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>slot_name</span><span class='Delimiter'>; 
</span><a name="LN843"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>reserve_wal</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN844"></a>    <a href="../../include/replication/walsender.h.html#LN21"><span class='Ref_to_Typedef'>CRSSnapshotAction</span></a> <span class='Declare_Local'>snapshot_action</span> <span class='Operator'>= </span><a href="../../include/replication/walsender.h.html#LN23"><span class='Ref_to_EnumConst'>CRS_EXPORT_SNAPSHOT</span></a><span class='Delimiter'>; 
</span><a name="LN845"></a>    <a href="../../include/tcop/dest.h.html#LN112"><span class='Ref_to_Typedef'>DestReceiver</span></a> <span class='Operator'>*</span><span class='Declare_Local'>dest</span><span class='Delimiter'>; 
</span><a name="LN846"></a>    <a href="../../include/executor/executor.h.html#LN411"><span class='Ref_to_Struct'>TupOutputState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tstate</span><span class='Delimiter'>; 
</span><a name="LN847"></a>    <a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Local'>tupdesc</span><span class='Delimiter'>; 
</span><a name="LN848"></a>    <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>values</span><span class='Delimiter'>[</span><span class='Number'>4</span><span class='Delimiter'>]; 
</span><a name="LN849"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>nulls</span><span class='Delimiter'>[</span><span class='Number'>4</span><span class='Delimiter'>]; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="slot.c.html#LN95"><span class='Ref_to_Global_Var'>MyReplicationSlot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="walsender.c.html#LN784"><span class='Ref_to_Func'>parseCreateReplSlotOptions</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN838"><span class='Ref_to_Parameter'>cmd</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="walsender.c.html#LN843"><span class='Ref_To_Local'>reserve_wal</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="walsender.c.html#LN844"><span class='Ref_To_Local'>snapshot_action</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* setup state for XLogReadPage */ 
</span>    <a href="walsender.c.html#LN148"><span class='Ref_to_Global_Var'>sendTimeLineIsHistoric</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN146"><span class='Ref_to_Global_Var'>sendTimeLine</span></a> <span class='Operator'>= </span><a href="../access/transam/xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN838"><span class='Ref_to_Parameter'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN55"><span class='Ref_to_Member'>kind</span></a> <span class='Operator'>== </span><a href="../../include/nodes/replnodes.h.html#LN21"><span class='Ref_to_EnumConst'>REPLICATION_KIND_PHYSICAL</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../include/replication/slot.h.html#LN161"><span class='Ref_to_Proto'>ReplicationSlotCreate</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN838"><span class='Ref_to_Parameter'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN54"><span class='Ref_to_Member'>slotname</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                              <a href="walsender.c.html#LN838"><span class='Ref_to_Parameter'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN57"><span class='Ref_to_Member'>temporary</span></a> <span class='Operator'>? </span><a href="../../include/replication/slot.h.html#LN31"><span class='Ref_to_EnumConst'>RS_TEMPORARY</span></a> <span class='Operator'>: </span><a href="../../include/replication/slot.h.html#LN29"><span class='Ref_to_EnumConst'>RS_PERSISTENT</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="logical/logical.c.html#LN74"><span class='Ref_to_Func'>CheckLogicalDecodingRequirements</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Initially create persistent slot as ephemeral - that allows us to 
         * nicely handle errors during initialization because it'll get 
         * dropped if this transaction fails. We'll make it persistent at the 
         * end. Temporary slots can be created as temporary from beginning as 
         * they get dropped on error as well. 
         */ 
</span>        <a href="../../include/replication/slot.h.html#LN161"><span class='Ref_to_Proto'>ReplicationSlotCreate</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN838"><span class='Ref_to_Parameter'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN54"><span class='Ref_to_Member'>slotname</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, 
</span>                              <a href="walsender.c.html#LN838"><span class='Ref_to_Parameter'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN57"><span class='Ref_to_Member'>temporary</span></a> <span class='Operator'>? </span><a href="../../include/replication/slot.h.html#LN31"><span class='Ref_to_EnumConst'>RS_TEMPORARY</span></a> <span class='Operator'>: </span><a href="../../include/replication/slot.h.html#LN30"><span class='Ref_to_EnumConst'>RS_EPHEMERAL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN838"><span class='Ref_to_Parameter'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN55"><span class='Ref_to_Member'>kind</span></a> <span class='Operator'>== </span><a href="../../include/nodes/replnodes.h.html#LN22"><span class='Ref_to_EnumConst'>REPLICATION_KIND_LOGICAL</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN881"></a>        <a href="../../include/replication/logical.h.html#LN34"><span class='Ref_to_Struct'>LogicalDecodingContext</span></a> <span class='Operator'>*</span><span class='Declare_Local'>ctx</span><span class='Delimiter'>; 
</span><a name="LN882"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>need_full_snapshot</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Do options check early so that we can bail before calling the 
         * DecodingContextFindStartpoint which can take long time. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN844"><span class='Ref_To_Local'>snapshot_action</span></a> <span class='Operator'>== </span><a href="../../include/replication/walsender.h.html#LN23"><span class='Ref_to_EnumConst'>CRS_EXPORT_SNAPSHOT</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/xact.h.html#LN366"><span class='Ref_to_Proto'>IsTransactionBlock</span></a><span class='Parentheses'>())</span> 
                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"CREATE_REPLICATION_SLOT ... EXPORT_SNAPSHOT "</span> 
                                <span class='String'>"must not be called inside a transaction"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
            <a href="walsender.c.html#LN882"><span class='Ref_To_Local'>need_full_snapshot</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN844"><span class='Ref_To_Local'>snapshot_action</span></a> <span class='Operator'>== </span><a href="../../include/replication/walsender.h.html#LN25"><span class='Ref_to_EnumConst'>CRS_USE_SNAPSHOT</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/xact.h.html#LN366"><span class='Ref_to_Proto'>IsTransactionBlock</span></a><span class='Parentheses'>())</span> 
                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"CREATE_REPLICATION_SLOT ... USE_SNAPSHOT "</span> 
                                <span class='String'>"must be called inside a transaction"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../access/transam/xact.c.html#LN73"><span class='Ref_to_Global_Var'>XactIsoLevel</span></a> <span class='Operator'>!= </span><a href="../../include/access/xact.h.html#LN29"><span class='Ref_to_Const'>XACT_REPEATABLE_READ</span></a><span class='Parentheses'>) 
</span>                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"CREATE_REPLICATION_SLOT ... USE_SNAPSHOT "</span> 
                                <span class='String'>"must be called in REPEATABLE READ isolation mode transaction"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../utils/time/snapmgr.c.html#LN202"><span class='Ref_to_Global_Var'>FirstSnapshotSet</span></a><span class='Parentheses'>) 
</span>                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"CREATE_REPLICATION_SLOT ... USE_SNAPSHOT "</span> 
                                <span class='String'>"must be called before any query"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/xact.h.html#LN361"><span class='Ref_to_Proto'>IsSubTransaction</span></a><span class='Parentheses'>())</span> 
                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"CREATE_REPLICATION_SLOT ... USE_SNAPSHOT "</span> 
                                <span class='String'>"must not be called in a subtransaction"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
            <a href="walsender.c.html#LN882"><span class='Ref_To_Local'>need_full_snapshot</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if snapshot_action==CRS_... &raquo; </span> 
 
        <a href="walsender.c.html#LN881"><span class='Ref_To_Local'>ctx</span></a> <span class='Operator'>= </span><a href="../../include/replication/logical.h.html#LN89"><span class='Ref_to_Proto'>CreateInitDecodingContext</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN838"><span class='Ref_to_Parameter'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN56"><span class='Ref_to_Member'>plugin</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN882"><span class='Ref_To_Local'>need_full_snapshot</span></a><span class='Delimiter'>, 
</span>                                        <a href="walsender.c.html#LN749"><span class='Ref_to_Func'>logical_read_xlog_page</span></a><span class='Delimiter'>, 
</span>                                        <a href="walsender.c.html#LN1130"><span class='Ref_to_Func'>WalSndPrepareWrite</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN1157"><span class='Ref_to_Func'>WalSndWriteData</span></a><span class='Delimiter'>, 
</span>                                        <a href="walsender.c.html#LN1247"><span class='Ref_to_Func'>WalSndUpdateProgress</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Signal that we don't need the timeout mechanism. We're just 
         * creating the replication slot and don't yet accept feedback 
         * messages or send keepalives. As we possibly need to wait for 
         * further WAL the walsender would otherwise possibly be killed too 
         * soon. 
         */ 
</span>        <a href="walsender.c.html#LN166"><span class='Ref_to_Global_Var'>last_reply_timestamp</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* build initial snapshot, might take a while */ 
</span>        <a href="../../include/replication/logical.h.html#LN103"><span class='Ref_to_Proto'>DecodingContextFindStartpoint</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN881"><span class='Ref_To_Local'>ctx</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Export or use the snapshot if we've been asked to do so. 
         * 
         * NB. We will convert the snapbuild.c kind of snapshot to normal 
         * snapshot when doing this. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN844"><span class='Ref_To_Local'>snapshot_action</span></a> <span class='Operator'>== </span><a href="../../include/replication/walsender.h.html#LN23"><span class='Ref_to_EnumConst'>CRS_EXPORT_SNAPSHOT</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="walsender.c.html#LN840"><span class='Ref_To_Local'>snapshot_name</span></a> <span class='Operator'>= </span><a href="../../include/replication/snapbuild.h.html#LN69"><span class='Ref_to_Proto'>SnapBuildExportSnapshot</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN881"><span class='Ref_To_Local'>ctx</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/logical.h.html#LN45"><span class='Ref_to_Member'>snapshot_builder</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN844"><span class='Ref_To_Local'>snapshot_action</span></a> <span class='Operator'>== </span><a href="../../include/replication/walsender.h.html#LN25"><span class='Ref_to_EnumConst'>CRS_USE_SNAPSHOT</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN951"></a>            <a href="../../include/utils/snapshot.h.html#LN22"><span class='Ref_to_Typedef'>Snapshot</span></a>    <span class='Declare_Local'>snap</span><span class='Delimiter'>; 
</span> 
            <a href="walsender.c.html#LN951"><span class='Ref_To_Local'>snap</span></a> <span class='Operator'>= </span><a href="../../include/replication/snapbuild.h.html#LN68"><span class='Ref_to_Proto'>SnapBuildInitialSnapshot</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN881"><span class='Ref_To_Local'>ctx</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/logical.h.html#LN45"><span class='Ref_to_Member'>snapshot_builder</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../include/utils/snapmgr.h.html#LN110"><span class='Ref_to_Proto'>RestoreTransactionSnapshot</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN951"><span class='Ref_To_Local'>snap</span></a><span class='Delimiter'>, </span><a href="../storage/lmgr/proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* don't need the decoding context anymore */ 
</span>        <a href="../../include/replication/logical.h.html#LN105"><span class='Ref_to_Proto'>FreeDecodingContext</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN881"><span class='Ref_To_Local'>ctx</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="walsender.c.html#LN838"><span class='Ref_to_Parameter'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN57"><span class='Ref_to_Member'>temporary</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/replication/slot.h.html#LN163"><span class='Ref_to_Proto'>ReplicationSlotPersist</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if cmd-&GT;kind==REPLICATIO... &raquo; </span> 
    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN838"><span class='Ref_to_Parameter'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN55"><span class='Ref_to_Member'>kind</span></a> <span class='Operator'>== </span><a href="../../include/nodes/replnodes.h.html#LN21"><span class='Ref_to_EnumConst'>REPLICATION_KIND_PHYSICAL</span></a> <span class='Operator'>&& </span><a href="walsender.c.html#LN843"><span class='Ref_To_Local'>reserve_wal</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../include/replication/slot.h.html#LN174"><span class='Ref_to_Proto'>ReplicationSlotReserveWal</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/replication/slot.h.html#LN170"><span class='Ref_to_Proto'>ReplicationSlotMarkDirty</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Write this slot to disk if it's a permanent one. */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="walsender.c.html#LN838"><span class='Ref_to_Parameter'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN57"><span class='Ref_to_Member'>temporary</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/replication/slot.h.html#LN169"><span class='Ref_to_Proto'>ReplicationSlotSave</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../pl/plperl/plperl.h.html#LN60"><span class='Ref_to_Macro'>snprintf</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN841"><span class='Ref_To_Local'>xloc</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="walsender.c.html#LN841"><span class='Ref_To_Local'>xloc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='String'>"%X/%X"</span><span class='Delimiter'>, 
</span>             <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="slot.c.html#LN95"><span class='Ref_to_Global_Var'>MyReplicationSlot</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/slot.h.html#LN114"><span class='Ref_to_Member'>data</span></a><span class='Operator'>.</span><a href="../../include/replication/slot.h.html#LN75"><span class='Ref_to_Member'>confirmed_flush</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>             <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="slot.c.html#LN95"><span class='Ref_to_Global_Var'>MyReplicationSlot</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/slot.h.html#LN114"><span class='Ref_to_Member'>data</span></a><span class='Operator'>.</span><a href="../../include/replication/slot.h.html#LN75"><span class='Ref_to_Member'>confirmed_flush</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="walsender.c.html#LN845"><span class='Ref_To_Local'>dest</span></a> <span class='Operator'>= </span><a href="../tcop/dest.c.html#LN107"><span class='Ref_to_Func'>CreateDestReceiver</span></a><span class='Parentheses'>(</span><a href="../../include/tcop/dest.h.html#LN91"><span class='Ref_to_EnumConst'>DestRemoteSimple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN849"><span class='Ref_To_Local'>nulls</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="walsender.c.html#LN849"><span class='Ref_To_Local'>nulls</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/*---------- 
     * Need a tuple descriptor representing four columns: 
     * - first field: the slot name 
     * - second field: LSN at which we became consistent 
     * - third field: exported snapshot's name 
     * - fourth field: output plugin 
     *---------- 
     */ 
</span>    <a href="walsender.c.html#LN847"><span class='Ref_To_Local'>tupdesc</span></a> <span class='Operator'>= </span><a href="../access/common/tupdesc.c.html#LN39"><span class='Ref_to_Func'>CreateTemplateTupleDesc</span></a><span class='Parentheses'>(</span><span class='Number'>4</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/access/tupdesc.h.html#LN121"><span class='Ref_to_Proto'>TupleDescInitBuiltinEntry</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN847"><span class='Ref_To_Local'>tupdesc</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a><span class='Parentheses'>) </span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='String'>"slot_name"</span><span class='Delimiter'>, 
</span>                              <a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN26"><span class='Ref_to_Const'>TEXTOID</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/access/tupdesc.h.html#LN121"><span class='Ref_to_Proto'>TupleDescInitBuiltinEntry</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN847"><span class='Ref_To_Local'>tupdesc</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a><span class='Parentheses'>) </span><span class='Number'>2</span><span class='Delimiter'>, </span><span class='String'>"consistent_point"</span><span class='Delimiter'>, 
</span>                              <a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN26"><span class='Ref_to_Const'>TEXTOID</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/access/tupdesc.h.html#LN121"><span class='Ref_to_Proto'>TupleDescInitBuiltinEntry</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN847"><span class='Ref_To_Local'>tupdesc</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a><span class='Parentheses'>) </span><span class='Number'>3</span><span class='Delimiter'>, </span><span class='String'>"snapshot_name"</span><span class='Delimiter'>, 
</span>                              <a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN26"><span class='Ref_to_Const'>TEXTOID</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/access/tupdesc.h.html#LN121"><span class='Ref_to_Proto'>TupleDescInitBuiltinEntry</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN847"><span class='Ref_To_Local'>tupdesc</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a><span class='Parentheses'>) </span><span class='Number'>4</span><span class='Delimiter'>, </span><span class='String'>"output_plugin"</span><span class='Delimiter'>, 
</span>                              <a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN26"><span class='Ref_to_Const'>TEXTOID</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* prepare for projection of tuples */ 
</span>    <a href="walsender.c.html#LN846"><span class='Ref_To_Local'>tstate</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN417"><span class='Ref_to_Proto'>begin_tup_output_tupdesc</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN845"><span class='Ref_To_Local'>dest</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN847"><span class='Ref_To_Local'>tupdesc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* slot_name */ 
</span>    <a href="walsender.c.html#LN842"><span class='Ref_To_Local'>slot_name</span></a> <span class='Operator'>= </span><a href="../../include/c.h.html#LN498"><span class='Ref_to_Macro'>NameStr</span></a><span class='Parentheses'>(</span><a href="slot.c.html#LN95"><span class='Ref_to_Global_Var'>MyReplicationSlot</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/slot.h.html#LN114"><span class='Ref_to_Member'>data</span></a><span class='Operator'>.</span><a href="../../include/replication/slot.h.html#LN40"><span class='Ref_to_Member'>name</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN848"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/utils/builtins.h.html#LN90"><span class='Ref_to_Macro'>CStringGetTextDatum</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN842"><span class='Ref_To_Local'>slot_name</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* consistent wal location */ 
</span>    <a href="walsender.c.html#LN848"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/utils/builtins.h.html#LN90"><span class='Ref_to_Macro'>CStringGetTextDatum</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN841"><span class='Ref_To_Local'>xloc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* snapshot name, or NULL if none */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN840"><span class='Ref_To_Local'>snapshot_name</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="walsender.c.html#LN848"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><span class='Number'>2</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/utils/builtins.h.html#LN90"><span class='Ref_to_Macro'>CStringGetTextDatum</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN840"><span class='Ref_To_Local'>snapshot_name</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="walsender.c.html#LN849"><span class='Ref_To_Local'>nulls</span></a><span class='Delimiter'>[</span><span class='Number'>2</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* plugin, or NULL if none */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN838"><span class='Ref_to_Parameter'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN56"><span class='Ref_to_Member'>plugin</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="walsender.c.html#LN848"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><span class='Number'>3</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/utils/builtins.h.html#LN90"><span class='Ref_to_Macro'>CStringGetTextDatum</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN838"><span class='Ref_to_Parameter'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN56"><span class='Ref_to_Member'>plugin</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="walsender.c.html#LN849"><span class='Ref_To_Local'>nulls</span></a><span class='Delimiter'>[</span><span class='Number'>3</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* send it to dest */ 
</span>    <a href="../../include/executor/executor.h.html#LN419"><span class='Ref_to_Proto'>do_tup_output</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN846"><span class='Ref_To_Local'>tstate</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN848"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN849"><span class='Ref_To_Local'>nulls</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/executor/executor.h.html#LN421"><span class='Ref_to_Proto'>end_tup_output</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN846"><span class='Ref_To_Local'>tstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/replication/slot.h.html#LN167"><span class='Ref_to_Proto'>ReplicationSlotRelease</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end CreateReplicationSlot &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Get rid of a replication slot that is no longer wanted. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1032"></a><span class='Declare_Function'>DropReplicationSlot</span><span class='Parentheses'>(</span><a href="../../include/nodes/replnodes.h.html#LN66"><span class='Ref_to_Struct'>DropReplicationSlotCmd</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>cmd</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../include/replication/slot.h.html#LN164"><span class='Ref_to_Proto'>ReplicationSlotDrop</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1032"><span class='Ref_to_Parameter'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN69"><span class='Ref_to_Member'>slotname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/tcop/dest.h.html#LN137"><span class='Ref_to_Proto'>EndCommand</span></a><span class='Parentheses'>(</span><span class='String'>"DROP_REPLICATION_SLOT"</span><span class='Delimiter'>, </span><a href="../../include/tcop/dest.h.html#LN89"><span class='Ref_to_EnumConst'>DestRemote</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Load previously initiated logical slot and prepare for sending data (via 
 * WalSndLoop). 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1043"></a><span class='Declare_Function'>StartLogicalReplication</span><span class='Parentheses'>(</span><a href="../../include/nodes/replnodes.h.html#LN77"><span class='Ref_to_Struct'>StartReplicationCmd</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>cmd</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1045"></a>    <a href="../../include/lib/stringinfo.h.html#LN34"><span class='Ref_to_Struct'>StringInfoData</span></a> <span class='Declare_Local'>buf</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* make sure that our requirements are still fulfilled */ 
</span>    <a href="logical/logical.c.html#LN74"><span class='Ref_to_Func'>CheckLogicalDecodingRequirements</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="slot.c.html#LN95"><span class='Ref_to_Global_Var'>MyReplicationSlot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/replication/slot.h.html#LN166"><span class='Ref_to_Proto'>ReplicationSlotAcquire</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1043"><span class='Ref_to_Parameter'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN81"><span class='Ref_to_Member'>slotname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Force a disconnect, so that the decoding code doesn't need to care 
     * about an eventual switch from running in recovery, to running in a 
     * normal environment. Client code is expected to handle reconnects. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN114"><span class='Ref_to_Global_Var'>am_cascading_walsender</span></a> <span class='Operator'>&& !</span><a href="../../include/access/xlog.h.html#LN242"><span class='Ref_to_Proto'>RecoveryInProgress</span></a><span class='Parentheses'>())</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"terminating walsender process after promotion"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN185"><span class='Ref_to_Global_Var'>got_STOPPING</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../include/replication/walsender_private.h.html#LN102"><span class='Ref_to_Proto'>WalSndSetState</span></a><span class='Parentheses'>(</span><a href="../../include/replication/walsender_private.h.html#LN25"><span class='Ref_to_EnumConst'>WALSNDSTATE_CATCHUP</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Send a CopyBothResponse message, and start streaming */ 
</span>    <a href="../../include/libpq/pqformat.h.html#LN17"><span class='Ref_to_Proto'>pq_beginmessage</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN1045"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='String'>'W'</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/libpq/pqformat.h.html#LN18"><span class='Ref_to_Proto'>pq_sendbyte</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN1045"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/libpq/pqformat.h.html#LN25"><span class='Ref_to_Proto'>pq_sendint</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN1045"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/libpq/pqformat.h.html#LN29"><span class='Ref_to_Proto'>pq_endmessage</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN1045"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/libpq/libpq.h.html#LN38"><span class='Ref_to_Macro'>pq_flush</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Initialize position to the last ack'ed one, then the xlog records begin 
     * to be shipped from that position. 
     */ 
</span>    <a href="walsender.c.html#LN195"><span class='Ref_to_Global_Var'>logical_decoding_ctx</span></a> <span class='Operator'>= </span><a href="../../include/replication/logical.h.html#LN96"><span class='Ref_to_Proto'>CreateDecodingContext</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1043"><span class='Ref_to_Parameter'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN83"><span class='Ref_to_Member'>startpoint</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN1043"><span class='Ref_to_Parameter'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN84"><span class='Ref_to_Member'>options</span></a><span class='Delimiter'>, 
</span>                                                 <a href="walsender.c.html#LN749"><span class='Ref_to_Func'>logical_read_xlog_page</span></a><span class='Delimiter'>, 
</span>                                                 <a href="walsender.c.html#LN1130"><span class='Ref_to_Func'>WalSndPrepareWrite</span></a><span class='Delimiter'>, 
</span>                                                 <a href="walsender.c.html#LN1157"><span class='Ref_to_Func'>WalSndWriteData</span></a><span class='Delimiter'>, 
</span>                                                 <a href="walsender.c.html#LN1247"><span class='Ref_to_Func'>WalSndUpdateProgress</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Start reading WAL from the oldest required WAL. */ 
</span>    <a href="walsender.c.html#LN196"><span class='Ref_to_Global_Var'>logical_startptr</span></a> <span class='Operator'>= </span><a href="slot.c.html#LN95"><span class='Ref_to_Global_Var'>MyReplicationSlot</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/slot.h.html#LN114"><span class='Ref_to_Member'>data</span></a><span class='Operator'>.</span><a href="../../include/replication/slot.h.html#LN67"><span class='Ref_to_Member'>restart_lsn</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Report the location after which we'll send out further commits as the 
     * current sentPtr. 
     */ 
</span>    <a href="walsender.c.html#LN155"><span class='Ref_to_Global_Var'>sentPtr</span></a> <span class='Operator'>= </span><a href="slot.c.html#LN95"><span class='Ref_to_Global_Var'>MyReplicationSlot</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/slot.h.html#LN114"><span class='Ref_to_Member'>data</span></a><span class='Operator'>.</span><a href="../../include/replication/slot.h.html#LN75"><span class='Ref_to_Member'>confirmed_flush</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Also update the sent position status in shared memory */ 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1096"></a>        <a href="../../include/replication/walsender_private.h.html#LN33"><span class='Ref_to_Struct'>WalSnd</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>walsnd</span> <span class='Operator'>= </span><a href="walsender.c.html#LN110"><span class='Ref_to_Global_Var'>MyWalSnd</span></a><span class='Delimiter'>; 
</span> 
        <a href="../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN1096"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN56"><span class='Ref_to_Member'>mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN1096"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN37"><span class='Ref_to_Member'>sentPtr</span></a> <span class='Operator'>= </span><a href="slot.c.html#LN95"><span class='Ref_to_Global_Var'>MyReplicationSlot</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/slot.h.html#LN114"><span class='Ref_to_Member'>data</span></a><span class='Operator'>.</span><a href="../../include/replication/slot.h.html#LN67"><span class='Ref_to_Member'>restart_lsn</span></a><span class='Delimiter'>; 
</span>        <a href="../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN1096"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN56"><span class='Ref_to_Member'>mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="walsender.c.html#LN193"><span class='Ref_to_Global_Var'>replication_active</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/replication/syncrep.h.html#LN72"><span class='Ref_to_Proto'>SyncRepInitConfig</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Main loop of walsender */ 
</span>    <a href="walsender.c.html#LN223"><span class='Ref_to_Proto'>WalSndLoop</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN2730"><span class='Ref_to_Func'>XLogSendLogical</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/replication/logical.h.html#LN105"><span class='Ref_to_Proto'>FreeDecodingContext</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN195"><span class='Ref_to_Global_Var'>logical_decoding_ctx</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/replication/slot.h.html#LN167"><span class='Ref_to_Proto'>ReplicationSlotRelease</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <a href="walsender.c.html#LN193"><span class='Ref_to_Global_Var'>replication_active</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN185"><span class='Ref_to_Global_Var'>got_STOPPING</span></a><span class='Parentheses'>) 
</span>        <a href="../storage/ipc/ipc.c.html#LN97"><span class='Ref_to_Func'>proc_exit</span></a><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/replication/walsender_private.h.html#LN102"><span class='Ref_to_Proto'>WalSndSetState</span></a><span class='Parentheses'>(</span><a href="../../include/replication/walsender_private.h.html#LN23"><span class='Ref_to_EnumConst'>WALSNDSTATE_STARTUP</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Get out of COPY mode (CommandComplete). */ 
</span>    <a href="../../include/tcop/dest.h.html#LN137"><span class='Ref_to_Proto'>EndCommand</span></a><span class='Parentheses'>(</span><span class='String'>"COPY 0"</span><span class='Delimiter'>, </span><a href="../../include/tcop/dest.h.html#LN89"><span class='Ref_to_EnumConst'>DestRemote</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end StartLogicalReplication &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * LogicalDecodingContext 'prepare_write' callback. 
 * 
 * Prepare a write into a StringInfo. 
 * 
 * Don't do anything lasting in here, it's quite possible that nothing will be done 
 * with the data. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1131"></a><span class='Declare_Function'>WalSndPrepareWrite</span><span class='Parentheses'>(</span><a href="../../include/replication/logical.h.html#LN34"><span class='Ref_to_Struct'>LogicalDecodingContext</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>ctx</span><span class='Delimiter'>, </span><a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>lsn</span><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xid</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>last_write</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* can't have sync rep confused by sending the same LSN several times */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="walsender.c.html#LN1131"><span class='Ref_to_Parameter'>last_write</span></a><span class='Parentheses'>) 
</span>        <a href="walsender.c.html#LN1131"><span class='Ref_to_Parameter'>lsn</span></a> <span class='Operator'>= </span><a href="../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span> 
    <a href="../lib/stringinfo.c.html#LN60"><span class='Ref_to_Func'>resetStringInfo</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1131"><span class='Ref_to_Parameter'>ctx</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/logical.h.html#LN65"><span class='Ref_to_Member'>out</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/libpq/pqformat.h.html#LN18"><span class='Ref_to_Proto'>pq_sendbyte</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1131"><span class='Ref_to_Parameter'>ctx</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/logical.h.html#LN65"><span class='Ref_to_Member'>out</span></a><span class='Delimiter'>, </span><span class='String'>'w'</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/libpq/pqformat.h.html#LN26"><span class='Ref_to_Proto'>pq_sendint64</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1131"><span class='Ref_to_Parameter'>ctx</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/logical.h.html#LN65"><span class='Ref_to_Member'>out</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN1131"><span class='Ref_to_Parameter'>lsn</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* dataStart */ 
</span>    <a href="../../include/libpq/pqformat.h.html#LN26"><span class='Ref_to_Proto'>pq_sendint64</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1131"><span class='Ref_to_Parameter'>ctx</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/logical.h.html#LN65"><span class='Ref_to_Member'>out</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN1131"><span class='Ref_to_Parameter'>lsn</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* walEnd */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Fill out the sendtime later, just as it's done in XLogSendPhysical, but 
     * reserve space here. 
     */ 
</span>    <a href="../../include/libpq/pqformat.h.html#LN26"><span class='Ref_to_Proto'>pq_sendint64</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1131"><span class='Ref_to_Parameter'>ctx</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/logical.h.html#LN65"><span class='Ref_to_Member'>out</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* sendtime */ 
</span><span class='Delimiter'>} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * LogicalDecodingContext 'write' callback. 
 * 
 * Actually write out data previously prepared by WalSndPrepareWrite out to 
 * the network. Take as long as needed, but process replies from the other 
 * side and check timeouts during that. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1158"></a><span class='Declare_Function'>WalSndWriteData</span><span class='Parentheses'>(</span><a href="../../include/replication/logical.h.html#LN34"><span class='Ref_to_Struct'>LogicalDecodingContext</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>ctx</span><span class='Delimiter'>, </span><a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>lsn</span><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xid</span><span class='Delimiter'>, 
</span><a name="LN1159"></a>                <span class='Keyword'>bool </span><span class='Declare_Parameter'>last_write</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* output previously gathered data in a CopyData packet */ 
</span>    <a href="../../include/libpq/libpq.h.html#LN43"><span class='Ref_to_Macro'>pq_putmessage_noblock</span></a><span class='Parentheses'>(</span><span class='String'>'d'</span><span class='Delimiter'>, </span><a href="walsender.c.html#LN1158"><span class='Ref_to_Parameter'>ctx</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/logical.h.html#LN65"><span class='Ref_to_Member'>out</span></a><span class='Operator'>-&GT;</span><a href="../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN1158"><span class='Ref_to_Parameter'>ctx</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/logical.h.html#LN65"><span class='Ref_to_Member'>out</span></a><span class='Operator'>-&GT;</span><a href="../../include/lib/stringinfo.h.html#LN37"><span class='Ref_to_Member'>len</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Fill the send timestamp last, so that it is taken as late as possible. 
     * This is somewhat ugly, but the protocol is set as it's already used for 
     * several releases by streaming physical replication. 
     */ 
</span>    <a href="../lib/stringinfo.c.html#LN60"><span class='Ref_to_Func'>resetStringInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN160"><span class='Ref_to_Global_Var'>tmpbuf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/libpq/pqformat.h.html#LN26"><span class='Ref_to_Proto'>pq_sendint64</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN160"><span class='Ref_to_Global_Var'>tmpbuf</span></a><span class='Delimiter'>, </span><a href="../../include/utils/timestamp.h.html#LN69"><span class='Ref_to_Proto'>GetCurrentTimestamp</span></a><span class='Parentheses'>())</span><span class='Delimiter'>; 
</span>    memcpy<span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN1158"><span class='Ref_to_Parameter'>ctx</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/logical.h.html#LN65"><span class='Ref_to_Member'>out</span></a><span class='Operator'>-&GT;</span><a href="../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Delimiter'>[</span><span class='Number'>1</span> <span class='Operator'>+ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a><span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a><span class='Parentheses'>)</span><span class='Delimiter'>], 
</span>           <a href="walsender.c.html#LN160"><span class='Ref_to_Global_Var'>tmpbuf</span></a><span class='Operator'>.</span><a href="../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* fast path */ 
</span>    <span class='Comment_Multi_Line'>/* Try to flush pending output to the client */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/libpq/libpq.h.html#LN39"><span class='Ref_to_Macro'>pq_flush_if_writable</span></a><span class='Parentheses'>() </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <a href="walsender.c.html#LN226"><span class='Ref_to_Func'>WalSndShutdown</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/libpq/libpq.h.html#LN40"><span class='Ref_to_Macro'>pq_is_send_pending</span></a><span class='Parentheses'>())</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1184"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>wakeEvents</span><span class='Delimiter'>; 
</span><a name="LN1185"></a>        <span class='Keyword'>long</span>        <span class='Declare_Local'>sleeptime</span><span class='Delimiter'>; 
</span><a name="LN1186"></a>        <a href="../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Local'>now</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Emergency bailout if postmaster has died.  This is to avoid the 
         * necessity for manual cleanup of all postmaster children. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/storage/pmsignal.h.html#LN53"><span class='Ref_to_Proto'>PostmasterIsAlive</span></a><span class='Parentheses'>())</span> 
            <a href="../../test/isolation/specscanner.l.html#LN91"><span class='Ref_to_Proto'>exit</span></a><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Clear any already-pending wakeups */ 
</span>        <a href="../../include/storage/latch.h.html#LN152"><span class='Ref_to_Proto'>ResetLatch</span></a><span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN51"><span class='Ref_to_Global_Var'>MyLatch</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/miscadmin.h.html#LN99"><span class='Ref_to_Macro'>CHECK_FOR_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Process any requests or signals received recently */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN33"><span class='Ref_to_Global_Var'>ConfigReloadPending</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../utils/init/globals.c.html#LN33"><span class='Ref_to_Global_Var'>ConfigReloadPending</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="../utils/misc/guc-file.l.html#LN107"><span class='Ref_to_Func'>ProcessConfigFile</span></a><span class='Parentheses'>(</span><a href="../../include/utils/guc.h.html#LN71"><span class='Ref_to_EnumConst'>PGC_SIGHUP</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../include/replication/syncrep.h.html#LN72"><span class='Ref_to_Proto'>SyncRepInitConfig</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Check for input from the client */ 
</span>        <a href="walsender.c.html#LN1565"><span class='Ref_to_Func'>ProcessRepliesIfAny</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Try to flush pending output to the client */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/libpq/libpq.h.html#LN39"><span class='Ref_to_Macro'>pq_flush_if_writable</span></a><span class='Parentheses'>() </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <a href="walsender.c.html#LN226"><span class='Ref_to_Func'>WalSndShutdown</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* If we finished clearing the buffered data, we're done here. */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/libpq/libpq.h.html#LN40"><span class='Ref_to_Macro'>pq_is_send_pending</span></a><span class='Parentheses'>())</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <a href="walsender.c.html#LN1186"><span class='Ref_To_Local'>now</span></a> <span class='Operator'>= </span><a href="../../include/utils/timestamp.h.html#LN69"><span class='Ref_to_Proto'>GetCurrentTimestamp</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* die if timeout was reached */ 
</span>        <a href="walsender.c.html#LN2040"><span class='Ref_to_Func'>WalSndCheckTimeOut</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1186"><span class='Ref_To_Local'>now</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Send keepalive if the time has come */ 
</span>        <a href="walsender.c.html#LN3324"><span class='Ref_to_Func'>WalSndKeepaliveIfNecessary</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1186"><span class='Ref_To_Local'>now</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="walsender.c.html#LN1185"><span class='Ref_To_Local'>sleeptime</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN1998"><span class='Ref_to_Func'>WalSndComputeSleeptime</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1186"><span class='Ref_To_Local'>now</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="walsender.c.html#LN1184"><span class='Ref_To_Local'>wakeEvents</span></a> <span class='Operator'>= </span><a href="../../include/storage/latch.h.html#LN123"><span class='Ref_to_Const'>WL_LATCH_SET</span></a> <span class='Operator'>| </span><a href="../../include/storage/latch.h.html#LN127"><span class='Ref_to_Const'>WL_POSTMASTER_DEATH</span></a> <span class='Operator'>| 
</span>            <a href="../../include/storage/latch.h.html#LN125"><span class='Ref_to_Const'>WL_SOCKET_WRITEABLE</span></a> <span class='Operator'>| </span><a href="../../include/storage/latch.h.html#LN124"><span class='Ref_to_Const'>WL_SOCKET_READABLE</span></a> <span class='Operator'>| </span><a href="../../include/storage/latch.h.html#LN126"><span class='Ref_to_Const'>WL_TIMEOUT</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Sleep until something happens or we time out */ 
</span>        <a href="../../include/storage/latch.h.html#LN165"><span class='Ref_to_Proto'>WaitLatchOrSocket</span></a><span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN51"><span class='Ref_to_Global_Var'>MyLatch</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN1184"><span class='Ref_To_Local'>wakeEvents</span></a><span class='Delimiter'>, 
</span>                          <a href="../utils/init/globals.c.html#LN40"><span class='Ref_to_Global_Var'>MyProcPort</span></a><span class='Operator'>-&GT;</span><a href="../../include/libpq/libpq-be.h.html#LN117"><span class='Ref_to_Member'>sock</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN1185"><span class='Ref_To_Local'>sleeptime</span></a><span class='Delimiter'>, 
</span>                          <a href="../../include/pgstat.h.html#LN788"><span class='Ref_to_EnumConst'>WAIT_EVENT_WAL_SENDER_WRITE_DATA</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for ;; &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* reactivate latch so WalSndLoop knows to continue */ 
</span>    <a href="../../include/storage/latch.h.html#LN151"><span class='Ref_to_Proto'>SetLatch</span></a><span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN51"><span class='Ref_to_Global_Var'>MyLatch</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end WalSndWriteData &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * LogicalDecodingContext 'progress_update' callback. 
 * 
 * Write the current position to the log tracker (see XLogSendPhysical). 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1248"></a><span class='Declare_Function'>WalSndUpdateProgress</span><span class='Parentheses'>(</span><a href="../../include/replication/logical.h.html#LN34"><span class='Ref_to_Struct'>LogicalDecodingContext</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>ctx</span><span class='Delimiter'>, </span><a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>lsn</span><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1250"></a>    <span class='Keyword'>static </span><a href="../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Local'>sendTime</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1251"></a>    <a href="../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Local'>now</span> <span class='Operator'>= </span><a href="../../include/utils/timestamp.h.html#LN69"><span class='Ref_to_Proto'>GetCurrentTimestamp</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Track lag no more than once per WALSND_LOGICAL_LAG_TRACK_INTERVAL_MS to 
     * avoid flooding the lag tracker when we commit frequently. 
     */ 
</span><a name="LN1257"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>WALSND_LOGICAL_LAG_TRACK_INTERVAL_MS</span>    <span class='Number'>1000</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/utils/timestamp.h.html#LN74"><span class='Ref_to_Proto'>TimestampDifferenceExceeds</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1250"><span class='Ref_To_Local'>sendTime</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN1251"><span class='Ref_To_Local'>now</span></a><span class='Delimiter'>, 
</span>                                    <a href="walsender.c.html#LN1257"><span class='Ref_to_Const'>WALSND_LOGICAL_LAG_TRACK_INTERVAL_MS</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <a href="walsender.c.html#LN3363"><span class='Ref_to_Func'>LagTrackerWrite</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1248"><span class='Ref_to_Parameter'>lsn</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN1251"><span class='Ref_To_Local'>now</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN1250"><span class='Ref_To_Local'>sendTime</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN1251"><span class='Ref_To_Local'>now</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Wait till WAL &LT; loc is flushed to disk so it can be safely read. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> 
<a name="LN1270"></a><span class='Declare_Function'>WalSndWaitForWal</span><span class='Parentheses'>(</span><a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>loc</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1272"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>wakeEvents</span><span class='Delimiter'>; 
</span><a name="LN1273"></a>    <span class='Keyword'>static </span><a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Local'>RecentFlushPtr</span> <span class='Operator'>= </span><a href="../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Fast path to avoid acquiring the spinlock in case we already know we 
     * have enough WAL available. This is particularly interesting if we're 
     * far behind. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN1273"><span class='Ref_To_Local'>RecentFlushPtr</span></a> <span class='Operator'>!= </span><a href="../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a> <span class='Operator'>&& 
</span>        <a href="walsender.c.html#LN1270"><span class='Ref_to_Parameter'>loc</span></a> <span class='Operator'>&LT;= </span><a href="walsender.c.html#LN1273"><span class='Ref_To_Local'>RecentFlushPtr</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="walsender.c.html#LN1273"><span class='Ref_To_Local'>RecentFlushPtr</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Get a more recent flush pointer. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/xlog.h.html#LN242"><span class='Ref_to_Proto'>RecoveryInProgress</span></a><span class='Parentheses'>())</span> 
        <a href="walsender.c.html#LN1273"><span class='Ref_To_Local'>RecentFlushPtr</span></a> <span class='Operator'>= </span><a href="../../include/access/xlog.h.html#LN275"><span class='Ref_to_Proto'>GetFlushRecPtr</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="walsender.c.html#LN1273"><span class='Ref_To_Local'>RecentFlushPtr</span></a> <span class='Operator'>= </span><a href="../../include/access/xlog.h.html#LN247"><span class='Ref_to_Proto'>GetXLogReplayRecPtr</span></a><span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1293"></a>        <span class='Keyword'>long</span>        <span class='Declare_Local'>sleeptime</span><span class='Delimiter'>; 
</span><a name="LN1294"></a>        <a href="../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Local'>now</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Emergency bailout if postmaster has died.  This is to avoid the 
         * necessity for manual cleanup of all postmaster children. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/storage/pmsignal.h.html#LN53"><span class='Ref_to_Proto'>PostmasterIsAlive</span></a><span class='Parentheses'>())</span> 
            <a href="../../test/isolation/specscanner.l.html#LN91"><span class='Ref_to_Proto'>exit</span></a><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Clear any already-pending wakeups */ 
</span>        <a href="../../include/storage/latch.h.html#LN152"><span class='Ref_to_Proto'>ResetLatch</span></a><span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN51"><span class='Ref_to_Global_Var'>MyLatch</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/miscadmin.h.html#LN99"><span class='Ref_to_Macro'>CHECK_FOR_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Process any requests or signals received recently */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN33"><span class='Ref_to_Global_Var'>ConfigReloadPending</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../utils/init/globals.c.html#LN33"><span class='Ref_to_Global_Var'>ConfigReloadPending</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="../utils/misc/guc-file.l.html#LN107"><span class='Ref_to_Func'>ProcessConfigFile</span></a><span class='Parentheses'>(</span><a href="../../include/utils/guc.h.html#LN71"><span class='Ref_to_EnumConst'>PGC_SIGHUP</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../include/replication/syncrep.h.html#LN72"><span class='Ref_to_Proto'>SyncRepInitConfig</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Check for input from the client */ 
</span>        <a href="walsender.c.html#LN1565"><span class='Ref_to_Func'>ProcessRepliesIfAny</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If we're shutting down, trigger pending WAL to be written out, 
         * otherwise we'd possibly end up waiting for WAL that never gets 
         * written, because walwriter has shut down already. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN185"><span class='Ref_to_Global_Var'>got_STOPPING</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/access/xlog.h.html#LN226"><span class='Ref_to_Proto'>XLogBackgroundFlush</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Update our idea of the currently flushed position. */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/xlog.h.html#LN242"><span class='Ref_to_Proto'>RecoveryInProgress</span></a><span class='Parentheses'>())</span> 
            <a href="walsender.c.html#LN1273"><span class='Ref_To_Local'>RecentFlushPtr</span></a> <span class='Operator'>= </span><a href="../../include/access/xlog.h.html#LN275"><span class='Ref_to_Proto'>GetFlushRecPtr</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="walsender.c.html#LN1273"><span class='Ref_To_Local'>RecentFlushPtr</span></a> <span class='Operator'>= </span><a href="../../include/access/xlog.h.html#LN247"><span class='Ref_to_Proto'>GetXLogReplayRecPtr</span></a><span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If postmaster asked us to stop, don't wait here anymore. This will 
         * cause the xlogreader to return without reading a full record, which 
         * is the fastest way to reach the mainloop which then can quit. 
         * 
         * It's important to do this check after the recomputation of 
         * RecentFlushPtr, so we can send all remaining data before shutting 
         * down. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN185"><span class='Ref_to_Global_Var'>got_STOPPING</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We only send regular messages to the client for full decoded 
         * transactions, but a synchronous replication and walsender shutdown 
         * possibly are waiting for a later location. So we send pings 
         * containing the flush location every now and then. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN110"><span class='Ref_to_Global_Var'>MyWalSnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN47"><span class='Ref_to_Member'>flush</span></a> <span class='Operator'>&LT; </span><a href="walsender.c.html#LN155"><span class='Ref_to_Global_Var'>sentPtr</span></a> <span class='Operator'>&& 
</span>            <a href="walsender.c.html#LN110"><span class='Ref_to_Global_Var'>MyWalSnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN46"><span class='Ref_to_Member'>write</span></a> <span class='Operator'>&LT; </span><a href="walsender.c.html#LN155"><span class='Ref_to_Global_Var'>sentPtr</span></a> <span class='Operator'>&& 
</span>            <span class='Operator'>!</span><a href="walsender.c.html#LN169"><span class='Ref_to_Global_Var'>waiting_for_ping_response</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="walsender.c.html#LN3305"><span class='Ref_to_Func'>WalSndKeepalive</span></a><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="walsender.c.html#LN169"><span class='Ref_to_Global_Var'>waiting_for_ping_response</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* check whether we're done */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN1270"><span class='Ref_to_Parameter'>loc</span></a> <span class='Operator'>&LT;= </span><a href="walsender.c.html#LN1273"><span class='Ref_To_Local'>RecentFlushPtr</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Waiting for new WAL. Since we need to wait, we're now caught up. */ 
</span>        <a href="walsender.c.html#LN181"><span class='Ref_to_Global_Var'>WalSndCaughtUp</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Try to flush pending output to the client. Also wait for the socket 
         * becoming writable, if there's still pending output after an attempt 
         * to flush. Otherwise we might just sit on output data while waiting 
         * for new WAL being generated. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/libpq/libpq.h.html#LN39"><span class='Ref_to_Macro'>pq_flush_if_writable</span></a><span class='Parentheses'>() </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <a href="walsender.c.html#LN226"><span class='Ref_to_Func'>WalSndShutdown</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <a href="walsender.c.html#LN1294"><span class='Ref_To_Local'>now</span></a> <span class='Operator'>= </span><a href="../../include/utils/timestamp.h.html#LN69"><span class='Ref_to_Proto'>GetCurrentTimestamp</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* die if timeout was reached */ 
</span>        <a href="walsender.c.html#LN2040"><span class='Ref_to_Func'>WalSndCheckTimeOut</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1294"><span class='Ref_To_Local'>now</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Send keepalive if the time has come */ 
</span>        <a href="walsender.c.html#LN3324"><span class='Ref_to_Func'>WalSndKeepaliveIfNecessary</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1294"><span class='Ref_To_Local'>now</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="walsender.c.html#LN1293"><span class='Ref_To_Local'>sleeptime</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN1998"><span class='Ref_to_Func'>WalSndComputeSleeptime</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1294"><span class='Ref_To_Local'>now</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="walsender.c.html#LN1272"><span class='Ref_To_Local'>wakeEvents</span></a> <span class='Operator'>= </span><a href="../../include/storage/latch.h.html#LN123"><span class='Ref_to_Const'>WL_LATCH_SET</span></a> <span class='Operator'>| </span><a href="../../include/storage/latch.h.html#LN127"><span class='Ref_to_Const'>WL_POSTMASTER_DEATH</span></a> <span class='Operator'>| 
</span>            <a href="../../include/storage/latch.h.html#LN124"><span class='Ref_to_Const'>WL_SOCKET_READABLE</span></a> <span class='Operator'>| </span><a href="../../include/storage/latch.h.html#LN126"><span class='Ref_to_Const'>WL_TIMEOUT</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/libpq/libpq.h.html#LN40"><span class='Ref_to_Macro'>pq_is_send_pending</span></a><span class='Parentheses'>())</span> 
            <a href="walsender.c.html#LN1272"><span class='Ref_To_Local'>wakeEvents</span></a> <span class='Operator'>|= </span><a href="../../include/storage/latch.h.html#LN125"><span class='Ref_to_Const'>WL_SOCKET_WRITEABLE</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Sleep until something happens or we time out */ 
</span>        <a href="../../include/storage/latch.h.html#LN165"><span class='Ref_to_Proto'>WaitLatchOrSocket</span></a><span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN51"><span class='Ref_to_Global_Var'>MyLatch</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN1272"><span class='Ref_To_Local'>wakeEvents</span></a><span class='Delimiter'>, 
</span>                          <a href="../utils/init/globals.c.html#LN40"><span class='Ref_to_Global_Var'>MyProcPort</span></a><span class='Operator'>-&GT;</span><a href="../../include/libpq/libpq-be.h.html#LN117"><span class='Ref_to_Member'>sock</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN1293"><span class='Ref_To_Local'>sleeptime</span></a><span class='Delimiter'>, 
</span>                          <a href="../../include/pgstat.h.html#LN787"><span class='Ref_to_EnumConst'>WAIT_EVENT_WAL_SENDER_WAIT_WAL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for ;; &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* reactivate latch so WalSndLoop knows to continue */ 
</span>    <a href="../../include/storage/latch.h.html#LN151"><span class='Ref_to_Proto'>SetLatch</span></a><span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN51"><span class='Ref_to_Global_Var'>MyLatch</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="walsender.c.html#LN1273"><span class='Ref_To_Local'>RecentFlushPtr</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end WalSndWaitForWal &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Execute an incoming replication command. 
 * 
 * Returns true if the cmd_string was recognized as WalSender command, false 
 * if not. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN1409"></a><span class='Declare_Function'>exec_replication_command</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>cmd_string</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1411"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>parse_rc</span><span class='Delimiter'>; 
</span><a name="LN1412"></a>    <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>cmd_node</span><span class='Delimiter'>; 
</span><a name="LN1413"></a>    <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>cmd_context</span><span class='Delimiter'>; 
</span><a name="LN1414"></a>    <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>old_context</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If WAL sender has been told that shutdown is getting close, switch its 
     * status accordingly to handle the next replication commands correctly. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN185"><span class='Ref_to_Global_Var'>got_STOPPING</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/replication/walsender_private.h.html#LN102"><span class='Ref_to_Proto'>WalSndSetState</span></a><span class='Parentheses'>(</span><a href="../../include/replication/walsender_private.h.html#LN27"><span class='Ref_to_EnumConst'>WALSNDSTATE_STOPPING</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Throw error if in stopping mode.  We need prevent commands that could 
     * generate WAL while the shutdown checkpoint is being written.  To be 
     * safe, we just prohibit all new commands. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN110"><span class='Ref_to_Global_Var'>MyWalSnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN36"><span class='Ref_to_Member'>state</span></a> <span class='Operator'>== </span><a href="../../include/replication/walsender_private.h.html#LN27"><span class='Ref_to_EnumConst'>WALSNDSTATE_STOPPING</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"cannot execute new commands while WAL sender is in stopping mode"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * CREATE_REPLICATION_SLOT ... LOGICAL exports a snapshot until the next 
     * command arrives. Clean up the old stuff if there's anything. 
     */ 
</span>    <a href="../../include/replication/snapbuild.h.html#LN70"><span class='Ref_to_Proto'>SnapBuildClearExportedSnapshot</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/miscadmin.h.html#LN99"><span class='Ref_to_Macro'>CHECK_FOR_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <a href="walsender.c.html#LN1413"><span class='Ref_To_Local'>cmd_context</span></a> <span class='Operator'>= </span><a href="../../include/utils/memutils.h.html#LN145"><span class='Ref_to_Proto'>AllocSetContextCreate</span></a><span class='Parentheses'>(</span><a href="../utils/mmgr/mcxt.c.html#LN36"><span class='Ref_to_Global_Var'>CurrentMemoryContext</span></a><span class='Delimiter'>, 
</span>                                        <span class='String'>"Replication command context"</span><span class='Delimiter'>, 
</span>                                        <a href="../../include/utils/memutils.h.html#LN164"><span class='Ref_to_Const'>ALLOCSET_DEFAULT_SIZES</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN1414"><span class='Ref_To_Local'>old_context</span></a> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1413"><span class='Ref_To_Local'>cmd_context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/replication/walsender_private.h.html#LN111"><span class='Ref_to_Proto'>replication_scanner_init</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1409"><span class='Ref_to_Parameter'>cmd_string</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN1411"><span class='Ref_To_Local'>parse_rc</span></a> <span class='Operator'>= </span><a href="../../include/replication/walsender_private.h.html#LN108"><span class='Ref_to_Proto'>replication_yyparse</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN1411"><span class='Ref_To_Local'>parse_rc</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_SYNTAX_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <span class='Parentheses'>(</span><a href="../utils/error/elog.c.html#LN825"><span class='Ref_to_Func'>errmsg_internal</span></a><span class='Parentheses'>(</span><span class='String'>"replication command parser returned %d"</span><span class='Delimiter'>, 
</span>                                  <a href="walsender.c.html#LN1411"><span class='Ref_To_Local'>parse_rc</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span> 
    <a href="walsender.c.html#LN1412"><span class='Ref_To_Local'>cmd_node</span></a> <span class='Operator'>= </span><a href="repl_gram.y.html#LN25"><span class='Ref_to_Global_Var'>replication_parse_result</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Log replication command if log_replication_commands is enabled. Even 
     * when it's disabled, log the command with DEBUG1 level for backward 
     * compatibility. Note that SQL commands are not logged here, and will be 
     * logged later if log_statement is enabled. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN1412"><span class='Ref_To_Local'>cmd_node</span></a><span class='Operator'>-&GT;</span><a href="../../../contrib/ltree/ltxtquery_io.c.html#LN28"><span class='Ref_to_Member'>type</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/nodes.h.html#LN480"><span class='Ref_to_EnumConst'>T_SQLCmd</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN122"><span class='Ref_to_Global_Var'>log_replication_commands</span></a> <span class='Operator'>? </span><a href="../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a> <span class='Operator'>: </span><a href="../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"received replication command: %s"</span><span class='Delimiter'>, </span><a href="walsender.c.html#LN1409"><span class='Ref_to_Parameter'>cmd_string</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * CREATE_REPLICATION_SLOT ... LOGICAL exports a snapshot. If it was 
     * called outside of transaction the snapshot should be cleared here. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/xact.h.html#LN366"><span class='Ref_to_Proto'>IsTransactionBlock</span></a><span class='Parentheses'>())</span> 
        <a href="../../include/replication/snapbuild.h.html#LN70"><span class='Ref_to_Proto'>SnapBuildClearExportedSnapshot</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * For aborted transactions, don't allow anything except pure SQL, the 
     * exec_simple_query() will handle it correctly. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/xact.h.html#LN330"><span class='Ref_to_Proto'>IsAbortedTransactionBlockState</span></a><span class='Parentheses'>() </span><span class='Operator'>&& !</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1412"><span class='Ref_To_Local'>cmd_node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/replnodes.h.html#LN102"><span class='Ref_to_Struct'>SQLCmd</span></a><span class='Parentheses'>))</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_IN_FAILED_SQL_TRANSACTION<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"current transaction is aborted, "</span> 
                        <span class='String'>"commands ignored until end of transaction block"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/miscadmin.h.html#LN99"><span class='Ref_to_Macro'>CHECK_FOR_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Allocate buffers that will be used for each outgoing and incoming 
     * message.  We do this just once per command to reduce palloc overhead. 
     */ 
</span>    <a href="../lib/stringinfo.c.html#LN44"><span class='Ref_to_Func'>initStringInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN158"><span class='Ref_to_Global_Var'>output_message</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../lib/stringinfo.c.html#LN44"><span class='Ref_to_Func'>initStringInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walreceiver.c.html#LN110"><span class='Ref_to_Global_Var'>reply_message</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../lib/stringinfo.c.html#LN44"><span class='Ref_to_Func'>initStringInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN160"><span class='Ref_to_Global_Var'>tmpbuf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN1412"><span class='Ref_To_Local'>cmd_node</span></a><span class='Operator'>-&GT;</span><a href="../../../contrib/ltree/ltxtquery_io.c.html#LN28"><span class='Ref_to_Member'>type</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN474"><span class='Ref_to_EnumConst'>T_IdentifySystemCmd</span></a><span class='Operator'>: 
</span>            <a href="walsender.c.html#LN335"><span class='Ref_to_Func'>IdentifySystem</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN475"><span class='Ref_to_EnumConst'>T_BaseBackupCmd</span></a><span class='Operator'>: 
</span>            <a href="../../include/access/xact.h.html#LN370"><span class='Ref_to_Proto'>PreventTransactionChain</span></a><span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='String'>"BASE_BACKUP"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../include/replication/basebackup.h.html#LN31"><span class='Ref_to_Proto'>SendBaseBackup</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/replnodes.h.html#LN40"><span class='Ref_to_Struct'>BaseBackupCmd</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="walsender.c.html#LN1412"><span class='Ref_To_Local'>cmd_node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN476"><span class='Ref_to_EnumConst'>T_CreateReplicationSlotCmd</span></a><span class='Operator'>: 
</span>            <a href="../../bin/pg_basebackup/streamutil.h.html#LN33"><span class='Ref_to_Proto'>CreateReplicationSlot</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/replnodes.h.html#LN51"><span class='Ref_to_Struct'>CreateReplicationSlotCmd</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="walsender.c.html#LN1412"><span class='Ref_To_Local'>cmd_node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN477"><span class='Ref_to_EnumConst'>T_DropReplicationSlotCmd</span></a><span class='Operator'>: 
</span>            <a href="../../bin/pg_basebackup/streamutil.h.html#LN36"><span class='Ref_to_Proto'>DropReplicationSlot</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/replnodes.h.html#LN66"><span class='Ref_to_Struct'>DropReplicationSlotCmd</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="walsender.c.html#LN1412"><span class='Ref_To_Local'>cmd_node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN478"><span class='Ref_to_EnumConst'>T_StartReplicationCmd</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span><a name="LN1513"></a>                <a href="../../include/nodes/replnodes.h.html#LN77"><span class='Ref_to_Struct'>StartReplicationCmd</span></a> <span class='Operator'>*</span><span class='Declare_Local'>cmd</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/replnodes.h.html#LN77"><span class='Ref_to_Struct'>StartReplicationCmd</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="walsender.c.html#LN1412"><span class='Ref_To_Local'>cmd_node</span></a><span class='Delimiter'>; 
</span> 
                <a href="../../include/access/xact.h.html#LN370"><span class='Ref_to_Proto'>PreventTransactionChain</span></a><span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='String'>"START_REPLICATION"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN1513"><span class='Ref_To_Local'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/replnodes.h.html#LN80"><span class='Ref_to_Member'>kind</span></a> <span class='Operator'>== </span><a href="../../include/nodes/replnodes.h.html#LN21"><span class='Ref_to_EnumConst'>REPLICATION_KIND_PHYSICAL</span></a><span class='Parentheses'>) 
</span>                    <a href="walsender.c.html#LN520"><span class='Ref_to_Func'>StartReplication</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1513"><span class='Ref_To_Local'>cmd</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>else</span> 
                    <a href="walsender.c.html#LN1042"><span class='Ref_to_Func'>StartLogicalReplication</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1513"><span class='Ref_To_Local'>cmd</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN479"><span class='Ref_to_EnumConst'>T_TimeLineHistoryCmd</span></a><span class='Operator'>: 
</span>            <a href="../../include/access/xact.h.html#LN370"><span class='Ref_to_Proto'>PreventTransactionChain</span></a><span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='String'>"TIMELINE_HISTORY"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="walsender.c.html#LN424"><span class='Ref_to_Func'>SendTimeLineHistory</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/replnodes.h.html#LN92"><span class='Ref_to_Struct'>TimeLineHistoryCmd</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="walsender.c.html#LN1412"><span class='Ref_To_Local'>cmd_node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN346"><span class='Ref_to_EnumConst'>T_VariableShowStmt</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span><a name="LN1531"></a>                <a href="../../include/tcop/dest.h.html#LN112"><span class='Ref_to_Typedef'>DestReceiver</span></a> <span class='Operator'>*</span><span class='Declare_Local'>dest</span> <span class='Operator'>= </span><a href="../tcop/dest.c.html#LN107"><span class='Ref_to_Func'>CreateDestReceiver</span></a><span class='Parentheses'>(</span><a href="../../include/tcop/dest.h.html#LN91"><span class='Ref_to_EnumConst'>DestRemoteSimple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1532"></a>                <a href="../../include/nodes/parsenodes.h.html#LN1955"><span class='Ref_to_Struct'>VariableShowStmt</span></a> <span class='Operator'>*</span><span class='Declare_Local'>n</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1955"><span class='Ref_to_Struct'>VariableShowStmt</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="walsender.c.html#LN1412"><span class='Ref_To_Local'>cmd_node</span></a><span class='Delimiter'>; 
</span> 
                <a href="../../include/utils/guc.h.html#LN372"><span class='Ref_to_Proto'>GetPGVariable</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1532"><span class='Ref_To_Local'>n</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1958"><span class='Ref_to_Member'>name</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN1531"><span class='Ref_To_Local'>dest</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN480"><span class='Ref_to_EnumConst'>T_SQLCmd</span></a><span class='Operator'>: 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN76"><span class='Ref_to_Global_Var'>MyDatabaseId</span></a> <span class='Operator'>== </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>) 
</span>                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"not connected to database"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Tell the caller that this wasn't a WalSender command. */ 
</span>            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>default</span><span class='Operator'>: 
</span>            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized replication command node tag: %u"</span><span class='Delimiter'>, 
</span>                 <a href="walsender.c.html#LN1412"><span class='Ref_To_Local'>cmd_node</span></a><span class='Operator'>-&GT;</span><a href="../../../contrib/ltree/ltxtquery_io.c.html#LN28"><span class='Ref_to_Member'>type</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch cmd_node-&GT;type &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* done */ 
</span>    <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1414"><span class='Ref_To_Local'>old_context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/utils/memutils.h.html#LN74"><span class='Ref_to_Proto'>MemoryContextDelete</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1413"><span class='Ref_To_Local'>cmd_context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Send CommandComplete message */ 
</span>    <a href="../../include/tcop/dest.h.html#LN137"><span class='Ref_to_Proto'>EndCommand</span></a><span class='Parentheses'>(</span><span class='String'>"SELECT"</span><span class='Delimiter'>, </span><a href="../../include/tcop/dest.h.html#LN89"><span class='Ref_to_EnumConst'>DestRemote</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end exec_replication_command &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Process any incoming messages while streaming. Also checks if the remote 
 * end has closed the connection. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1566"></a><span class='Declare_Function'>ProcessRepliesIfAny</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1568"></a>    <span class='Keyword'>unsigned char </span><span class='Declare_Local'>firstchar</span><span class='Delimiter'>; 
</span><a name="LN1569"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>r</span><span class='Delimiter'>; 
</span><a name="LN1570"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>received</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../include/libpq/libpq.h.html#LN65"><span class='Ref_to_Proto'>pq_startmsgread</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN1569"><span class='Ref_To_Local'>r</span></a> <span class='Operator'>= </span><a href="../../include/libpq/libpq.h.html#LN71"><span class='Ref_to_Proto'>pq_getbyte_if_available</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN1568"><span class='Ref_To_Local'>firstchar</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN1569"><span class='Ref_To_Local'>r</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* unexpected error or EOF */ 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN29"><span class='Ref_to_Const'>COMMERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_PROTOCOL_VIOLATION<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"unexpected EOF on standby connection"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <a href="../storage/ipc/ipc.c.html#LN97"><span class='Ref_to_Func'>proc_exit</span></a><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN1569"><span class='Ref_To_Local'>r</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* no data available without blocking */ 
</span>            <a href="../../include/libpq/libpq.h.html#LN66"><span class='Ref_to_Proto'>pq_endmsgread</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Read the message contents */ 
</span>        <a href="../lib/stringinfo.c.html#LN60"><span class='Ref_to_Func'>resetStringInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walreceiver.c.html#LN110"><span class='Ref_to_Global_Var'>reply_message</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/libpq/libpq.h.html#LN68"><span class='Ref_to_Proto'>pq_getmessage</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walreceiver.c.html#LN110"><span class='Ref_to_Global_Var'>reply_message</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN29"><span class='Ref_to_Const'>COMMERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_PROTOCOL_VIOLATION<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"unexpected EOF on standby connection"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <a href="../storage/ipc/ipc.c.html#LN97"><span class='Ref_to_Func'>proc_exit</span></a><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If we already received a CopyDone from the frontend, the frontend 
         * should not send us anything until we've closed our end of the COPY. 
         * XXX: In theory, the frontend could already send the next command 
         * before receiving the CopyDone, but libpq doesn't currently allow 
         * that. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN178"><span class='Ref_to_Global_Var'>streamingDoneReceiving</span></a> <span class='Operator'>&& </span><a href="walsender.c.html#LN1568"><span class='Ref_To_Local'>firstchar</span></a> <span class='Operator'>!= </span><span class='String'>'X'</span><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_PROTOCOL_VIOLATION<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"unexpected standby message type \"%c\", after receiving CopyDone"</span><span class='Delimiter'>, 
</span>                            <a href="walsender.c.html#LN1568"><span class='Ref_To_Local'>firstchar</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Handle the very limited subset of commands expected in this phase */ 
</span>        <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN1568"><span class='Ref_To_Local'>firstchar</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * 'd' means a standby reply wrapped in a CopyData packet. 
                 */ 
</span>            <span class='Control'>case</span> <span class='String'>'d'</span><span class='Operator'>: 
</span>                <a href="walsender.c.html#LN1667"><span class='Ref_to_Func'>ProcessStandbyMessage</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>                <a href="walsender.c.html#LN1570"><span class='Ref_To_Local'>received</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * CopyDone means the standby requested to finish streaming. 
                 * Reply with CopyDone, if we had not sent that already. 
                 */ 
</span>            <span class='Control'>case</span> <span class='String'>'c'</span><span class='Operator'>: 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="walsender.c.html#LN177"><span class='Ref_to_Global_Var'>streamingDoneSending</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <a href="../../include/libpq/libpq.h.html#LN43"><span class='Ref_to_Macro'>pq_putmessage_noblock</span></a><span class='Parentheses'>(</span><span class='String'>'c'</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="walsender.c.html#LN177"><span class='Ref_to_Global_Var'>streamingDoneSending</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
                <a href="walsender.c.html#LN178"><span class='Ref_to_Global_Var'>streamingDoneReceiving</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <a href="walsender.c.html#LN1570"><span class='Ref_To_Local'>received</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * 'X' means that the standby is closing down the socket. 
                 */ 
</span>            <span class='Control'>case</span> <span class='String'>'X'</span><span class='Operator'>: 
</span>                <a href="../storage/ipc/ipc.c.html#LN97"><span class='Ref_to_Func'>proc_exit</span></a><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>default</span><span class='Operator'>: 
</span>                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_PROTOCOL_VIOLATION<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"invalid standby message type \"%c\""</span><span class='Delimiter'>, 
</span>                                <a href="walsender.c.html#LN1568"><span class='Ref_To_Local'>firstchar</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch firstchar &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for ;; &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Save the last reply timestamp if we've received at least one reply. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN1570"><span class='Ref_To_Local'>received</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="walsender.c.html#LN166"><span class='Ref_to_Global_Var'>last_reply_timestamp</span></a> <span class='Operator'>= </span><a href="../../include/utils/timestamp.h.html#LN69"><span class='Ref_to_Proto'>GetCurrentTimestamp</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN169"><span class='Ref_to_Global_Var'>waiting_for_ping_response</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end ProcessRepliesIfAny &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Process a status update message received from standby. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1668"></a><span class='Declare_Function'>ProcessStandbyMessage</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1670"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>msgtype</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Check message type from the first byte. 
     */ 
</span>    <a href="walsender.c.html#LN1670"><span class='Ref_To_Local'>msgtype</span></a> <span class='Operator'>= </span><a href="../../include/libpq/pqformat.h.html#LN37"><span class='Ref_to_Proto'>pq_getmsgbyte</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walreceiver.c.html#LN110"><span class='Ref_to_Global_Var'>reply_message</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN1670"><span class='Ref_To_Local'>msgtype</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <span class='String'>'r'</span><span class='Operator'>: 
</span>            <a href="walsender.c.html#LN1730"><span class='Ref_to_Func'>ProcessStandbyReplyMessage</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <span class='String'>'h'</span><span class='Operator'>: 
</span>            <a href="walsender.c.html#LN1899"><span class='Ref_to_Func'>ProcessStandbyHSFeedbackMessage</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>default</span><span class='Operator'>: 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN29"><span class='Ref_to_Const'>COMMERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_PROTOCOL_VIOLATION<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"unexpected message type \"%c\""</span><span class='Delimiter'>, </span><a href="walsender.c.html#LN1670"><span class='Ref_To_Local'>msgtype</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <a href="../storage/ipc/ipc.c.html#LN97"><span class='Ref_to_Func'>proc_exit</span></a><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end ProcessStandbyMessage &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Remember that a walreceiver just confirmed receipt of lsn `lsn`. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1699"></a><span class='Declare_Function'>PhysicalConfirmReceivedLocation</span><span class='Parentheses'>(</span><a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>lsn</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1701"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>changed</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN1702"></a>    <a href="../../include/replication/slot.h.html#LN84"><span class='Ref_to_Struct'>ReplicationSlot</span></a> <span class='Operator'>*</span><span class='Declare_Local'>slot</span> <span class='Operator'>= </span><a href="slot.c.html#LN95"><span class='Ref_to_Global_Var'>MyReplicationSlot</span></a><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="walsender.c.html#LN1699"><span class='Ref_to_Parameter'>lsn</span></a> <span class='Operator'>!= </span><a href="../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN1702"><span class='Ref_To_Local'>slot</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/slot.h.html#LN87"><span class='Ref_to_Member'>mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN1702"><span class='Ref_To_Local'>slot</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/slot.h.html#LN114"><span class='Ref_to_Member'>data</span></a><span class='Operator'>.</span><a href="../../include/replication/slot.h.html#LN67"><span class='Ref_to_Member'>restart_lsn</span></a> <span class='Operator'>!= </span><a href="walsender.c.html#LN1699"><span class='Ref_to_Parameter'>lsn</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="walsender.c.html#LN1701"><span class='Ref_To_Local'>changed</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN1702"><span class='Ref_To_Local'>slot</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/slot.h.html#LN114"><span class='Ref_to_Member'>data</span></a><span class='Operator'>.</span><a href="../../include/replication/slot.h.html#LN67"><span class='Ref_to_Member'>restart_lsn</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN1699"><span class='Ref_to_Parameter'>lsn</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN1702"><span class='Ref_To_Local'>slot</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/slot.h.html#LN87"><span class='Ref_to_Member'>mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN1701"><span class='Ref_To_Local'>changed</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../include/replication/slot.h.html#LN170"><span class='Ref_to_Proto'>ReplicationSlotMarkDirty</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <a href="../../include/replication/slot.h.html#LN176"><span class='Ref_to_Proto'>ReplicationSlotsComputeRequiredLSN</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * One could argue that the slot should be saved to disk now, but that'd 
     * be energy wasted - the worst lost information can do here is give us 
     * wrong information in a statistics view - we'll just potentially be more 
     * conservative in removing files. 
     */ 
</span><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end PhysicalConfirmReceivedLocation &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Regular reply from standby advising of WAL locations on standby server. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1731"></a><span class='Declare_Function'>ProcessStandbyReplyMessage</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1733"></a>    <a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>writePtr</span><span class='Delimiter'>, 
</span><a name="LN1734"></a>                <span class='Declare_Local'>flushPtr</span><span class='Delimiter'>, 
</span><a name="LN1735"></a>                <span class='Declare_Local'>applyPtr</span><span class='Delimiter'>; 
</span><a name="LN1736"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>replyRequested</span><span class='Delimiter'>; 
</span><a name="LN1737"></a>    <a href="../../include/datatype/timestamp.h.html#LN39"><span class='Ref_to_Typedef'>TimeOffset</span></a>  <span class='Declare_Local'>writeLag</span><span class='Delimiter'>, 
</span><a name="LN1738"></a>                <span class='Declare_Local'>flushLag</span><span class='Delimiter'>, 
</span><a name="LN1739"></a>                <span class='Declare_Local'>applyLag</span><span class='Delimiter'>; 
</span><a name="LN1740"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>clearLagTimes</span><span class='Delimiter'>; 
</span><a name="LN1741"></a>    <a href="../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Local'>now</span><span class='Delimiter'>; 
</span> 
<a name="LN1743"></a>    <span class='Keyword'>static bool </span><span class='Declare_Local'>fullyAppliedLastTime</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* the caller already consumed the msgtype byte */ 
</span>    <a href="walsender.c.html#LN1733"><span class='Ref_To_Local'>writePtr</span></a> <span class='Operator'>= </span><a href="../../include/libpq/pqformat.h.html#LN39"><span class='Ref_to_Proto'>pq_getmsgint64</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walreceiver.c.html#LN110"><span class='Ref_to_Global_Var'>reply_message</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN1734"><span class='Ref_To_Local'>flushPtr</span></a> <span class='Operator'>= </span><a href="../../include/libpq/pqformat.h.html#LN39"><span class='Ref_to_Proto'>pq_getmsgint64</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walreceiver.c.html#LN110"><span class='Ref_to_Global_Var'>reply_message</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN1735"><span class='Ref_To_Local'>applyPtr</span></a> <span class='Operator'>= </span><a href="../../include/libpq/pqformat.h.html#LN39"><span class='Ref_to_Proto'>pq_getmsgint64</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walreceiver.c.html#LN110"><span class='Ref_to_Global_Var'>reply_message</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="../../include/libpq/pqformat.h.html#LN39"><span class='Ref_to_Proto'>pq_getmsgint64</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walreceiver.c.html#LN110"><span class='Ref_to_Global_Var'>reply_message</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* sendTime; not used ATM */ 
</span>    <a href="walsender.c.html#LN1736"><span class='Ref_To_Local'>replyRequested</span></a> <span class='Operator'>= </span><a href="../../include/libpq/pqformat.h.html#LN37"><span class='Ref_to_Proto'>pq_getmsgbyte</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walreceiver.c.html#LN110"><span class='Ref_to_Global_Var'>reply_message</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, </span><span class='String'>"write %X/%X flush %X/%X apply %X/%X%s"</span><span class='Delimiter'>, 
</span>         <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="walsender.c.html#LN1733"><span class='Ref_To_Local'>writePtr</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="walsender.c.html#LN1733"><span class='Ref_To_Local'>writePtr</span></a><span class='Delimiter'>, 
</span>         <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="walsender.c.html#LN1734"><span class='Ref_To_Local'>flushPtr</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="walsender.c.html#LN1734"><span class='Ref_To_Local'>flushPtr</span></a><span class='Delimiter'>, 
</span>         <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="walsender.c.html#LN1735"><span class='Ref_To_Local'>applyPtr</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="walsender.c.html#LN1735"><span class='Ref_To_Local'>applyPtr</span></a><span class='Delimiter'>, 
</span>         <a href="walsender.c.html#LN1736"><span class='Ref_To_Local'>replyRequested</span></a> <span class='Operator'>? </span><span class='String'>" (reply requested)"</span> <span class='Operator'>: </span><span class='String'>""</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* See if we can compute the round-trip lag for these positions. */ 
</span>    <a href="walsender.c.html#LN1741"><span class='Ref_To_Local'>now</span></a> <span class='Operator'>= </span><a href="../../include/utils/timestamp.h.html#LN69"><span class='Ref_to_Proto'>GetCurrentTimestamp</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN1737"><span class='Ref_To_Local'>writeLag</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN3428"><span class='Ref_to_Func'>LagTrackerRead</span></a><span class='Parentheses'>(</span><a href="../../include/replication/syncrep.h.html#LN23"><span class='Ref_to_Const'>SYNC_REP_WAIT_WRITE</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN1733"><span class='Ref_To_Local'>writePtr</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN1741"><span class='Ref_To_Local'>now</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN1738"><span class='Ref_To_Local'>flushLag</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN3428"><span class='Ref_to_Func'>LagTrackerRead</span></a><span class='Parentheses'>(</span><a href="../../include/replication/syncrep.h.html#LN24"><span class='Ref_to_Const'>SYNC_REP_WAIT_FLUSH</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN1734"><span class='Ref_To_Local'>flushPtr</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN1741"><span class='Ref_To_Local'>now</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN1739"><span class='Ref_To_Local'>applyLag</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN3428"><span class='Ref_to_Func'>LagTrackerRead</span></a><span class='Parentheses'>(</span><a href="../../include/replication/syncrep.h.html#LN25"><span class='Ref_to_Const'>SYNC_REP_WAIT_APPLY</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN1735"><span class='Ref_To_Local'>applyPtr</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN1741"><span class='Ref_To_Local'>now</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the standby reports that it has fully replayed the WAL in two 
     * consecutive reply messages, then the second such message must result 
     * from wal_receiver_status_interval expiring on the standby.  This is a 
     * convenient time to forget the lag times measured when it last 
     * wrote/flushed/applied a WAL record, to avoid displaying stale lag data 
     * until more WAL traffic arrives. 
     */ 
</span>    <a href="walsender.c.html#LN1740"><span class='Ref_To_Local'>clearLagTimes</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN1735"><span class='Ref_To_Local'>applyPtr</span></a> <span class='Operator'>== </span><a href="walsender.c.html#LN155"><span class='Ref_to_Global_Var'>sentPtr</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN1743"><span class='Ref_To_Local'>fullyAppliedLastTime</span></a><span class='Parentheses'>) 
</span>            <a href="walsender.c.html#LN1740"><span class='Ref_To_Local'>clearLagTimes</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN1743"><span class='Ref_To_Local'>fullyAppliedLastTime</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
        <a href="walsender.c.html#LN1743"><span class='Ref_To_Local'>fullyAppliedLastTime</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Send a reply if the standby requested one. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN1736"><span class='Ref_To_Local'>replyRequested</span></a><span class='Parentheses'>) 
</span>        <a href="walsender.c.html#LN3305"><span class='Ref_to_Func'>WalSndKeepalive</span></a><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Update shared state for this WalSender process based on reply data from 
     * standby. 
     */ 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1791"></a>        <a href="../../include/replication/walsender_private.h.html#LN33"><span class='Ref_to_Struct'>WalSnd</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>walsnd</span> <span class='Operator'>= </span><a href="walsender.c.html#LN110"><span class='Ref_to_Global_Var'>MyWalSnd</span></a><span class='Delimiter'>; 
</span> 
        <a href="../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN1791"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN56"><span class='Ref_to_Member'>mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN1791"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN46"><span class='Ref_to_Member'>write</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN1733"><span class='Ref_To_Local'>writePtr</span></a><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN1791"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN47"><span class='Ref_to_Member'>flush</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN1734"><span class='Ref_To_Local'>flushPtr</span></a><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN1791"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN48"><span class='Ref_to_Member'>apply</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN1735"><span class='Ref_To_Local'>applyPtr</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN1737"><span class='Ref_To_Local'>writeLag</span></a> <span class='Operator'>!= -</span><span class='Number'>1</span> <span class='Operator'>|| </span><a href="walsender.c.html#LN1740"><span class='Ref_To_Local'>clearLagTimes</span></a><span class='Parentheses'>) 
</span>            <a href="walsender.c.html#LN1791"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN51"><span class='Ref_to_Member'>writeLag</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN1737"><span class='Ref_To_Local'>writeLag</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN1738"><span class='Ref_To_Local'>flushLag</span></a> <span class='Operator'>!= -</span><span class='Number'>1</span> <span class='Operator'>|| </span><a href="walsender.c.html#LN1740"><span class='Ref_To_Local'>clearLagTimes</span></a><span class='Parentheses'>) 
</span>            <a href="walsender.c.html#LN1791"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN52"><span class='Ref_to_Member'>flushLag</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN1738"><span class='Ref_To_Local'>flushLag</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN1739"><span class='Ref_To_Local'>applyLag</span></a> <span class='Operator'>!= -</span><span class='Number'>1</span> <span class='Operator'>|| </span><a href="walsender.c.html#LN1740"><span class='Ref_To_Local'>clearLagTimes</span></a><span class='Parentheses'>) 
</span>            <a href="walsender.c.html#LN1791"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN53"><span class='Ref_to_Member'>applyLag</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN1739"><span class='Ref_To_Local'>applyLag</span></a><span class='Delimiter'>; 
</span>        <a href="../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN1791"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN56"><span class='Ref_to_Member'>mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="walsender.c.html#LN114"><span class='Ref_to_Global_Var'>am_cascading_walsender</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/replication/syncrep.h.html#LN73"><span class='Ref_to_Proto'>SyncRepReleaseWaiters</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Advance our local xmin horizon when the client confirmed a flush. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="slot.c.html#LN95"><span class='Ref_to_Global_Var'>MyReplicationSlot</span></a> <span class='Operator'>&& </span><a href="walsender.c.html#LN1734"><span class='Ref_To_Local'>flushPtr</span></a> <span class='Operator'>!= </span><a href="../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/replication/slot.h.html#LN133"><span class='Ref_to_Macro'>SlotIsLogical</span></a><span class='Parentheses'>(</span><a href="slot.c.html#LN95"><span class='Ref_to_Global_Var'>MyReplicationSlot</span></a><span class='Parentheses'>))</span> 
            <a href="../../include/replication/logical.h.html#LN110"><span class='Ref_to_Proto'>LogicalConfirmReceivedLocation</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1734"><span class='Ref_To_Local'>flushPtr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="walsender.c.html#LN1698"><span class='Ref_to_Func'>PhysicalConfirmReceivedLocation</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1734"><span class='Ref_To_Local'>flushPtr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end ProcessStandbyReplyMessage &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* compute new replication slot xmin horizon if needed */ 
</span><span class='Keyword'>static void 
</span><a name="LN1823"></a><span class='Declare_Function'>PhysicalReplicationSlotNewXmin</span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>feedbackXmin</span><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>feedbackCatalogXmin</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1825"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>changed</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN1826"></a>    <a href="../../include/replication/slot.h.html#LN84"><span class='Ref_to_Struct'>ReplicationSlot</span></a> <span class='Operator'>*</span><span class='Declare_Local'>slot</span> <span class='Operator'>= </span><a href="slot.c.html#LN95"><span class='Ref_to_Global_Var'>MyReplicationSlot</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN1826"><span class='Ref_To_Local'>slot</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/slot.h.html#LN87"><span class='Ref_to_Member'>mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../storage/lmgr/proc.c.html#LN67"><span class='Ref_to_Global_Var'>MyPgXact</span></a><span class='Operator'>-&GT;</span><a href="../../include/storage/proc.h.html#LN212"><span class='Ref_to_Member'>xmin</span></a> <span class='Operator'>= </span><a href="../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * For physical replication we don't need the interlock provided by xmin 
     * and effective_xmin since the consequences of a missed increase are 
     * limited to query cancellations, so set both at once. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1826"><span class='Ref_To_Local'>slot</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/slot.h.html#LN114"><span class='Ref_to_Member'>data</span></a><span class='Operator'>.</span><a href="../../include/replication/slot.h.html#LN56"><span class='Ref_to_Member'>xmin</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <span class='Operator'>!</span><a href="../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1823"><span class='Ref_to_Parameter'>feedbackXmin</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <a href="../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1826"><span class='Ref_To_Local'>slot</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/slot.h.html#LN114"><span class='Ref_to_Member'>data</span></a><span class='Operator'>.</span><a href="../../include/replication/slot.h.html#LN56"><span class='Ref_to_Member'>xmin</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN1823"><span class='Ref_to_Parameter'>feedbackXmin</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="walsender.c.html#LN1825"><span class='Ref_To_Local'>changed</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN1826"><span class='Ref_To_Local'>slot</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/slot.h.html#LN114"><span class='Ref_to_Member'>data</span></a><span class='Operator'>.</span><a href="../../include/replication/slot.h.html#LN56"><span class='Ref_to_Member'>xmin</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN1823"><span class='Ref_to_Parameter'>feedbackXmin</span></a><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN1826"><span class='Ref_To_Local'>slot</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/slot.h.html#LN110"><span class='Ref_to_Member'>effective_xmin</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN1823"><span class='Ref_to_Parameter'>feedbackXmin</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1826"><span class='Ref_To_Local'>slot</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/slot.h.html#LN114"><span class='Ref_to_Member'>data</span></a><span class='Operator'>.</span><a href="../../include/replication/slot.h.html#LN64"><span class='Ref_to_Member'>catalog_xmin</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <span class='Operator'>!</span><a href="../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1823"><span class='Ref_to_Parameter'>feedbackCatalogXmin</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <a href="../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1826"><span class='Ref_To_Local'>slot</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/slot.h.html#LN114"><span class='Ref_to_Member'>data</span></a><span class='Operator'>.</span><a href="../../include/replication/slot.h.html#LN64"><span class='Ref_to_Member'>catalog_xmin</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN1823"><span class='Ref_to_Parameter'>feedbackCatalogXmin</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="walsender.c.html#LN1825"><span class='Ref_To_Local'>changed</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN1826"><span class='Ref_To_Local'>slot</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/slot.h.html#LN114"><span class='Ref_to_Member'>data</span></a><span class='Operator'>.</span><a href="../../include/replication/slot.h.html#LN64"><span class='Ref_to_Member'>catalog_xmin</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN1823"><span class='Ref_to_Parameter'>feedbackCatalogXmin</span></a><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN1826"><span class='Ref_To_Local'>slot</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/slot.h.html#LN111"><span class='Ref_to_Member'>effective_catalog_xmin</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN1823"><span class='Ref_to_Parameter'>feedbackCatalogXmin</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN1826"><span class='Ref_To_Local'>slot</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/slot.h.html#LN87"><span class='Ref_to_Member'>mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN1825"><span class='Ref_To_Local'>changed</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../include/replication/slot.h.html#LN170"><span class='Ref_to_Proto'>ReplicationSlotMarkDirty</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <a href="../../include/replication/slot.h.html#LN175"><span class='Ref_to_Proto'>ReplicationSlotsComputeRequiredXmin</span></a><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end PhysicalReplicationSlotNewXmin &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Check that the provided xmin/epoch are sane, that is, not in the future 
 * and not so far back as to be already wrapped around. 
 * 
 * Epoch of nextXid should be same as standby, or if the counter has 
 * wrapped, then one greater than standby. 
 * 
 * This check doesn't care about whether clog exists for these xids 
 * at all. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN1872"></a><span class='Declare_Function'>TransactionIdInRecentPast</span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xid</span><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Parameter'>epoch</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1874"></a>    <a href="../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>nextXid</span><span class='Delimiter'>; 
</span><a name="LN1875"></a>    <a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>nextEpoch</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/access/xlog.h.html#LN277"><span class='Ref_to_Proto'>GetNextXidAndEpoch</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN1874"><span class='Ref_To_Local'>nextXid</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="walsender.c.html#LN1875"><span class='Ref_To_Local'>nextEpoch</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN1872"><span class='Ref_to_Parameter'>xid</span></a> <span class='Operator'>&LT;= </span><a href="walsender.c.html#LN1874"><span class='Ref_To_Local'>nextXid</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN1872"><span class='Ref_to_Parameter'>epoch</span></a> <span class='Operator'>!= </span><a href="walsender.c.html#LN1875"><span class='Ref_To_Local'>nextEpoch</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN1872"><span class='Ref_to_Parameter'>epoch</span></a> <span class='Operator'>+ </span><span class='Number'>1</span> <span class='Operator'>!= </span><a href="walsender.c.html#LN1875"><span class='Ref_To_Local'>nextEpoch</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/transam.h.html#LN169"><span class='Ref_to_Proto'>TransactionIdPrecedesOrEquals</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1872"><span class='Ref_to_Parameter'>xid</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN1874"><span class='Ref_To_Local'>nextXid</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* epoch OK, but it's wrapped around */ 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end TransactionIdInRecentPast &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Hot Standby feedback 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1900"></a><span class='Declare_Function'>ProcessStandbyHSFeedbackMessage</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1902"></a>    <a href="../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>feedbackXmin</span><span class='Delimiter'>; 
</span><a name="LN1903"></a>    <a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>feedbackEpoch</span><span class='Delimiter'>; 
</span><a name="LN1904"></a>    <a href="../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>feedbackCatalogXmin</span><span class='Delimiter'>; 
</span><a name="LN1905"></a>    <a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>feedbackCatalogEpoch</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Decipher the reply message. The caller already consumed the msgtype 
     * byte. See XLogWalRcvSendHSFeedback() in walreceiver.c for the creation 
     * of this message. 
     */ 
</span>    <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="../../include/libpq/pqformat.h.html#LN39"><span class='Ref_to_Proto'>pq_getmsgint64</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walreceiver.c.html#LN110"><span class='Ref_to_Global_Var'>reply_message</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* sendTime; not used ATM */ 
</span>    <a href="walsender.c.html#LN1902"><span class='Ref_To_Local'>feedbackXmin</span></a> <span class='Operator'>= </span><a href="../../include/libpq/pqformat.h.html#LN38"><span class='Ref_to_Proto'>pq_getmsgint</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walreceiver.c.html#LN110"><span class='Ref_to_Global_Var'>reply_message</span></a><span class='Delimiter'>, </span><span class='Number'>4</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN1903"><span class='Ref_To_Local'>feedbackEpoch</span></a> <span class='Operator'>= </span><a href="../../include/libpq/pqformat.h.html#LN38"><span class='Ref_to_Proto'>pq_getmsgint</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walreceiver.c.html#LN110"><span class='Ref_to_Global_Var'>reply_message</span></a><span class='Delimiter'>, </span><span class='Number'>4</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN1904"><span class='Ref_To_Local'>feedbackCatalogXmin</span></a> <span class='Operator'>= </span><a href="../../include/libpq/pqformat.h.html#LN38"><span class='Ref_to_Proto'>pq_getmsgint</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walreceiver.c.html#LN110"><span class='Ref_to_Global_Var'>reply_message</span></a><span class='Delimiter'>, </span><span class='Number'>4</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN1905"><span class='Ref_To_Local'>feedbackCatalogEpoch</span></a> <span class='Operator'>= </span><a href="../../include/libpq/pqformat.h.html#LN38"><span class='Ref_to_Proto'>pq_getmsgint</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walreceiver.c.html#LN110"><span class='Ref_to_Global_Var'>reply_message</span></a><span class='Delimiter'>, </span><span class='Number'>4</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, </span><span class='String'>"hot standby feedback xmin %u epoch %u, catalog_xmin %u epoch %u"</span><span class='Delimiter'>, 
</span>         <a href="walsender.c.html#LN1902"><span class='Ref_To_Local'>feedbackXmin</span></a><span class='Delimiter'>, 
</span>         <a href="walsender.c.html#LN1903"><span class='Ref_To_Local'>feedbackEpoch</span></a><span class='Delimiter'>, 
</span>         <a href="walsender.c.html#LN1904"><span class='Ref_To_Local'>feedbackCatalogXmin</span></a><span class='Delimiter'>, 
</span>         <a href="walsender.c.html#LN1905"><span class='Ref_To_Local'>feedbackCatalogEpoch</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Unset WalSender's xmins if the feedback message values are invalid. 
     * This happens when the downstream turned hot_standby_feedback off. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1902"><span class='Ref_To_Local'>feedbackXmin</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>&& !</span><a href="../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1904"><span class='Ref_To_Local'>feedbackCatalogXmin</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../storage/lmgr/proc.c.html#LN67"><span class='Ref_to_Global_Var'>MyPgXact</span></a><span class='Operator'>-&GT;</span><a href="../../include/storage/proc.h.html#LN212"><span class='Ref_to_Member'>xmin</span></a> <span class='Operator'>= </span><a href="../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="slot.c.html#LN95"><span class='Ref_to_Global_Var'>MyReplicationSlot</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <a href="walsender.c.html#LN1822"><span class='Ref_to_Func'>PhysicalReplicationSlotNewXmin</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1902"><span class='Ref_To_Local'>feedbackXmin</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN1904"><span class='Ref_To_Local'>feedbackCatalogXmin</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Check that the provided xmin/epoch are sane, that is, not in the future 
     * and not so far back as to be already wrapped around.  Ignore if not. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1902"><span class='Ref_To_Local'>feedbackXmin</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>        <span class='Operator'>!</span><a href="../utils/adt/txid.c.html#LN109"><span class='Ref_to_Func'>TransactionIdInRecentPast</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1902"><span class='Ref_To_Local'>feedbackXmin</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN1903"><span class='Ref_To_Local'>feedbackEpoch</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1904"><span class='Ref_To_Local'>feedbackCatalogXmin</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>        <span class='Operator'>!</span><a href="../utils/adt/txid.c.html#LN109"><span class='Ref_to_Func'>TransactionIdInRecentPast</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1904"><span class='Ref_To_Local'>feedbackCatalogXmin</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN1905"><span class='Ref_To_Local'>feedbackCatalogEpoch</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Set the WalSender's xmin equal to the standby's requested xmin, so that 
     * the xmin will be taken into account by GetOldestXmin.  This will hold 
     * back the removal of dead rows and thereby prevent the generation of 
     * cleanup conflicts on the standby server. 
     * 
     * There is a small window for a race condition here: although we just 
     * checked that feedbackXmin precedes nextXid, the nextXid could have 
     * gotten advanced between our fetching it and applying the xmin below, 
     * perhaps far enough to make feedbackXmin wrap around.  In that case the 
     * xmin we set here would be "in the future" and have no effect.  No point 
     * in worrying about this since it's too late to save the desired data 
     * anyway.  Assuming that the standby sends us an increasing sequence of 
     * xmins, this could only happen during the first reply cycle, else our 
     * own xmin would prevent nextXid from advancing so far. 
     * 
     * We don't bother taking the ProcArrayLock here.  Setting the xmin field 
     * is assumed atomic, and there's no real need to prevent a concurrent 
     * GetOldestXmin.  (If we're moving our xmin forward, this is obviously 
     * safe, and if we're moving it backwards, well, the data is at risk 
     * already since a VACUUM could have just finished calling GetOldestXmin.) 
     * 
     * If we're using a replication slot we reserve the xmin via that, 
     * otherwise via the walsender's PGXACT entry. We can only track the 
     * catalog xmin separately when using a slot, so we store the least of the 
     * two provided when not using a slot. 
     * 
     * XXX: It might make sense to generalize the ephemeral slot concept and 
     * always use the slot mechanism to handle the feedback xmin. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="slot.c.html#LN95"><span class='Ref_to_Global_Var'>MyReplicationSlot</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span>      <span class='Comment_Single_Line'>/* XXX: persistency configurable? */ 
</span>        <a href="walsender.c.html#LN1822"><span class='Ref_to_Func'>PhysicalReplicationSlotNewXmin</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1902"><span class='Ref_To_Local'>feedbackXmin</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN1904"><span class='Ref_To_Local'>feedbackCatalogXmin</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1904"><span class='Ref_To_Local'>feedbackCatalogXmin</span></a><span class='Parentheses'>) 
</span>            <span class='Operator'>&& </span><a href="../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1904"><span class='Ref_To_Local'>feedbackCatalogXmin</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN1902"><span class='Ref_To_Local'>feedbackXmin</span></a><span class='Parentheses'>))</span> 
            <a href="../storage/lmgr/proc.c.html#LN67"><span class='Ref_to_Global_Var'>MyPgXact</span></a><span class='Operator'>-&GT;</span><a href="../../include/storage/proc.h.html#LN212"><span class='Ref_to_Member'>xmin</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN1904"><span class='Ref_To_Local'>feedbackCatalogXmin</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="../storage/lmgr/proc.c.html#LN67"><span class='Ref_to_Global_Var'>MyPgXact</span></a><span class='Operator'>-&GT;</span><a href="../../include/storage/proc.h.html#LN212"><span class='Ref_to_Member'>xmin</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN1902"><span class='Ref_To_Local'>feedbackXmin</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end ProcessStandbyHSFeedbackMessage &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Compute how long send/receive loops should sleep. 
 * 
 * If wal_sender_timeout is enabled we want to wake up in time to send 
 * keepalives and to abort the connection if wal_sender_timeout has been 
 * reached. 
 */ 
</span><span class='Keyword'>static long 
</span><a name="LN1999"></a><span class='Declare_Function'>WalSndComputeSleeptime</span><span class='Parentheses'>(</span><a href="../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Parameter'>now</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2001"></a>    <span class='Keyword'>long</span>        <span class='Declare_Local'>sleeptime</span> <span class='Operator'>= </span><span class='Number'>10000</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* 10 s */ 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN120"><span class='Ref_to_Global_Var'>wal_sender_timeout</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="walsender.c.html#LN166"><span class='Ref_to_Global_Var'>last_reply_timestamp</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2005"></a>        <a href="../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Local'>wakeup_time</span><span class='Delimiter'>; 
</span><a name="LN2006"></a>        <span class='Keyword'>long</span>        <span class='Declare_Local'>sec_to_timeout</span><span class='Delimiter'>; 
</span><a name="LN2007"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>microsec_to_timeout</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * At the latest stop sleeping once wal_sender_timeout has been 
         * reached. 
         */ 
</span>        <a href="walsender.c.html#LN2005"><span class='Ref_To_Local'>wakeup_time</span></a> <span class='Operator'>= </span><a href="../../include/utils/timestamp.h.html#LN55"><span class='Ref_to_Macro'>TimestampTzPlusMilliseconds</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN166"><span class='Ref_to_Global_Var'>last_reply_timestamp</span></a><span class='Delimiter'>, 
</span>                                                  <a href="walsender.c.html#LN120"><span class='Ref_to_Global_Var'>wal_sender_timeout</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If no ping has been sent yet, wakeup when it's time to do so. 
         * WalSndKeepaliveIfNecessary() wants to send a keepalive once half of 
         * the timeout passed without a response. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="walsender.c.html#LN169"><span class='Ref_to_Global_Var'>waiting_for_ping_response</span></a><span class='Parentheses'>) 
</span>            <a href="walsender.c.html#LN2005"><span class='Ref_To_Local'>wakeup_time</span></a> <span class='Operator'>= </span><a href="../../include/utils/timestamp.h.html#LN55"><span class='Ref_to_Macro'>TimestampTzPlusMilliseconds</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN166"><span class='Ref_to_Global_Var'>last_reply_timestamp</span></a><span class='Delimiter'>, 
</span>                                                      <a href="walsender.c.html#LN120"><span class='Ref_to_Global_Var'>wal_sender_timeout</span></a> <span class='Operator'>/ </span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Compute relative time until wakeup. */ 
</span>        <a href="../../include/utils/timestamp.h.html#LN72"><span class='Ref_to_Proto'>TimestampDifference</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN1999"><span class='Ref_to_Parameter'>now</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN2005"><span class='Ref_To_Local'>wakeup_time</span></a><span class='Delimiter'>, 
</span>                            <span class='Operator'>&</span><a href="walsender.c.html#LN2006"><span class='Ref_To_Local'>sec_to_timeout</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="walsender.c.html#LN2007"><span class='Ref_To_Local'>microsec_to_timeout</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="walsender.c.html#LN2001"><span class='Ref_To_Local'>sleeptime</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN2006"><span class='Ref_To_Local'>sec_to_timeout</span></a> <span class='Operator'>* </span><span class='Number'>1000</span> <span class='Operator'>+ 
</span>            <a href="walsender.c.html#LN2007"><span class='Ref_To_Local'>microsec_to_timeout</span></a> <span class='Operator'>/ </span><span class='Number'>1000</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if wal_sender_timeout&GT;0&... &raquo; </span> 
 
    <span class='Control'>return</span> <a href="walsender.c.html#LN2001"><span class='Ref_To_Local'>sleeptime</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end WalSndComputeSleeptime &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Check whether there have been responses by the client within 
 * wal_sender_timeout and shutdown if not. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2041"></a><span class='Declare_Function'>WalSndCheckTimeOut</span><span class='Parentheses'>(</span><a href="../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Parameter'>now</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2043"></a>    <a href="../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Local'>timeout</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* don't bail out if we're doing something that doesn't require timeouts */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN166"><span class='Ref_to_Global_Var'>last_reply_timestamp</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <a href="walsender.c.html#LN2043"><span class='Ref_To_Local'>timeout</span></a> <span class='Operator'>= </span><a href="../../include/utils/timestamp.h.html#LN55"><span class='Ref_to_Macro'>TimestampTzPlusMilliseconds</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN166"><span class='Ref_to_Global_Var'>last_reply_timestamp</span></a><span class='Delimiter'>, 
</span>                                          <a href="walsender.c.html#LN120"><span class='Ref_to_Global_Var'>wal_sender_timeout</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN120"><span class='Ref_to_Global_Var'>wal_sender_timeout</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="walsender.c.html#LN2041"><span class='Ref_to_Parameter'>now</span></a> <span class='Operator'>&GT;= </span><a href="walsender.c.html#LN2043"><span class='Ref_To_Local'>timeout</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Since typically expiration of replication timeout means 
         * communication problem, we don't send the error message to the 
         * standby. 
         */ 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN29"><span class='Ref_to_Const'>COMMERROR</span></a><span class='Delimiter'>, 
</span>        <span class='Parentheses'>(</span><a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"terminating walsender process due to replication timeout"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <a href="walsender.c.html#LN226"><span class='Ref_to_Func'>WalSndShutdown</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end WalSndCheckTimeOut &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* Main loop of walsender process that streams the WAL over Copy messages. */ 
</span><span class='Keyword'>static void 
</span><a name="LN2068"></a><span class='Declare_Function'>WalSndLoop</span><span class='Parentheses'>(</span><a href="walsender.c.html#LN222"><span class='Ref_to_Typedef'>WalSndSendDataCallback</span></a> <span class='Declare_Parameter'>send_data</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * Initialize the last reply timestamp. That enables timeout processing 
     * from hereon. 
     */ 
</span>    <a href="walsender.c.html#LN166"><span class='Ref_to_Global_Var'>last_reply_timestamp</span></a> <span class='Operator'>= </span><a href="../../include/utils/timestamp.h.html#LN69"><span class='Ref_to_Proto'>GetCurrentTimestamp</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN169"><span class='Ref_to_Global_Var'>waiting_for_ping_response</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Report to pgstat that this process is running */ 
</span>    <a href="../../include/pgstat.h.html#LN1168"><span class='Ref_to_Proto'>pgstat_report_activity</span></a><span class='Parentheses'>(</span><a href="../../include/pgstat.h.html#LN724"><span class='Ref_to_EnumConst'>STATE_RUNNING</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Loop until we reach the end of this timeline or the client requests to 
     * stop streaming. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2086"></a>        <a href="../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Local'>now</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Emergency bailout if postmaster has died.  This is to avoid the 
         * necessity for manual cleanup of all postmaster children. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/storage/pmsignal.h.html#LN53"><span class='Ref_to_Proto'>PostmasterIsAlive</span></a><span class='Parentheses'>())</span> 
            <a href="../../test/isolation/specscanner.l.html#LN91"><span class='Ref_to_Proto'>exit</span></a><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Clear any already-pending wakeups */ 
</span>        <a href="../../include/storage/latch.h.html#LN152"><span class='Ref_to_Proto'>ResetLatch</span></a><span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN51"><span class='Ref_to_Global_Var'>MyLatch</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/miscadmin.h.html#LN99"><span class='Ref_to_Macro'>CHECK_FOR_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Process any requests or signals received recently */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN33"><span class='Ref_to_Global_Var'>ConfigReloadPending</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../utils/init/globals.c.html#LN33"><span class='Ref_to_Global_Var'>ConfigReloadPending</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="../utils/misc/guc-file.l.html#LN107"><span class='Ref_to_Func'>ProcessConfigFile</span></a><span class='Parentheses'>(</span><a href="../../include/utils/guc.h.html#LN71"><span class='Ref_to_EnumConst'>PGC_SIGHUP</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../include/replication/syncrep.h.html#LN72"><span class='Ref_to_Proto'>SyncRepInitConfig</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Check for input from the client */ 
</span>        <a href="walsender.c.html#LN1565"><span class='Ref_to_Func'>ProcessRepliesIfAny</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If we have received CopyDone from the client, sent CopyDone 
         * ourselves, and the output buffer is empty, it's time to exit 
         * streaming. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/libpq/libpq.h.html#LN40"><span class='Ref_to_Macro'>pq_is_send_pending</span></a><span class='Parentheses'>() </span><span class='Operator'>&& </span><a href="walsender.c.html#LN177"><span class='Ref_to_Global_Var'>streamingDoneSending</span></a> <span class='Operator'>&& </span><a href="walsender.c.html#LN178"><span class='Ref_to_Global_Var'>streamingDoneReceiving</span></a><span class='Parentheses'>)</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If we don't have any pending data in the output buffer, try to send 
         * some more.  If there is some, we don't bother to call send_data 
         * again until we've flushed it ... but we'd better assume we are not 
         * caught up. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/libpq/libpq.h.html#LN40"><span class='Ref_to_Macro'>pq_is_send_pending</span></a><span class='Parentheses'>())</span> 
            <a href="walsender.c.html#LN2068"><span class='Ref_to_Parameter'>send_data</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="walsender.c.html#LN181"><span class='Ref_to_Global_Var'>WalSndCaughtUp</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Try to flush pending output to the client */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/libpq/libpq.h.html#LN39"><span class='Ref_to_Macro'>pq_flush_if_writable</span></a><span class='Parentheses'>() </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <a href="walsender.c.html#LN226"><span class='Ref_to_Func'>WalSndShutdown</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* If nothing remains to be sent right now ... */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN181"><span class='Ref_to_Global_Var'>WalSndCaughtUp</span></a> <span class='Operator'>&& !</span><a href="../../include/libpq/libpq.h.html#LN40"><span class='Ref_to_Macro'>pq_is_send_pending</span></a><span class='Parentheses'>())</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * If we're in catchup state, move to streaming.  This is an 
             * important state change for users to know about, since before 
             * this point data loss might occur if the primary dies and we 
             * need to failover to the standby. The state change is also 
             * important for synchronous replication, since commits that 
             * started to wait at that point might wait for some time. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN110"><span class='Ref_to_Global_Var'>MyWalSnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN36"><span class='Ref_to_Member'>state</span></a> <span class='Operator'>== </span><a href="../../include/replication/walsender_private.h.html#LN25"><span class='Ref_to_EnumConst'>WALSNDSTATE_CATCHUP</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Delimiter'>, 
</span>                     <span class='Parentheses'>(</span><a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"standby \"%s\" has now caught up with primary"</span><span class='Delimiter'>, 
</span>                             <a href="../utils/misc/guc.c.html#LN468"><span class='Ref_to_Global_Var'>application_name</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <a href="../../include/replication/walsender_private.h.html#LN102"><span class='Ref_to_Proto'>WalSndSetState</span></a><span class='Parentheses'>(</span><a href="../../include/replication/walsender_private.h.html#LN26"><span class='Ref_to_EnumConst'>WALSNDSTATE_STREAMING</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * When SIGUSR2 arrives, we send any outstanding logs up to the 
             * shutdown checkpoint record (i.e., the latest record), wait for 
             * them to be replicated to the standby, and exit. This may be a 
             * normal termination at shutdown, or a promotion, the walsender 
             * is not sure which. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../postmaster/autovacuum.c.html#LN140"><span class='Ref_to_Global_Var'>got_SIGUSR2</span></a><span class='Parentheses'>) 
</span>                <a href="walsender.c.html#LN2800"><span class='Ref_to_Func'>WalSndDone</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN2068"><span class='Ref_to_Parameter'>send_data</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if WalSndCaughtUp&&!pq_i... &raquo; </span> 
 
        <a href="walsender.c.html#LN2086"><span class='Ref_To_Local'>now</span></a> <span class='Operator'>= </span><a href="../../include/utils/timestamp.h.html#LN69"><span class='Ref_to_Proto'>GetCurrentTimestamp</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Check for replication timeout. */ 
</span>        <a href="walsender.c.html#LN2040"><span class='Ref_to_Func'>WalSndCheckTimeOut</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN2086"><span class='Ref_To_Local'>now</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Send keepalive if the time has come */ 
</span>        <a href="walsender.c.html#LN3324"><span class='Ref_to_Func'>WalSndKeepaliveIfNecessary</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN2086"><span class='Ref_To_Local'>now</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We don't block if not caught up, unless there is unsent data 
         * pending in which case we'd better block until the socket is 
         * write-ready.  This test is only needed for the case where the 
         * send_data callback handled a subset of the available data but then 
         * pq_flush_if_writable flushed it all --- we should immediately try 
         * to send more. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="walsender.c.html#LN181"><span class='Ref_to_Global_Var'>WalSndCaughtUp</span></a> <span class='Operator'>&& !</span><a href="walsender.c.html#LN177"><span class='Ref_to_Global_Var'>streamingDoneSending</span></a><span class='Parentheses'>) </span><span class='Operator'>|| </span><a href="../../include/libpq/libpq.h.html#LN40"><span class='Ref_to_Macro'>pq_is_send_pending</span></a><span class='Parentheses'>())</span> 
        <span class='Delimiter'>{ 
</span><a name="LN2182"></a>            <span class='Keyword'>long</span>        <span class='Declare_Local'>sleeptime</span><span class='Delimiter'>; 
</span><a name="LN2183"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>wakeEvents</span><span class='Delimiter'>; 
</span> 
            <a href="walsender.c.html#LN2183"><span class='Ref_To_Local'>wakeEvents</span></a> <span class='Operator'>= </span><a href="../../include/storage/latch.h.html#LN123"><span class='Ref_to_Const'>WL_LATCH_SET</span></a> <span class='Operator'>| </span><a href="../../include/storage/latch.h.html#LN127"><span class='Ref_to_Const'>WL_POSTMASTER_DEATH</span></a> <span class='Operator'>| </span><a href="../../include/storage/latch.h.html#LN126"><span class='Ref_to_Const'>WL_TIMEOUT</span></a> <span class='Operator'>| 
</span>                <a href="../../include/storage/latch.h.html#LN124"><span class='Ref_to_Const'>WL_SOCKET_READABLE</span></a><span class='Delimiter'>; 
</span> 
            <a href="walsender.c.html#LN2182"><span class='Ref_To_Local'>sleeptime</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN1998"><span class='Ref_to_Func'>WalSndComputeSleeptime</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN2086"><span class='Ref_To_Local'>now</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/libpq/libpq.h.html#LN40"><span class='Ref_to_Macro'>pq_is_send_pending</span></a><span class='Parentheses'>())</span> 
                <a href="walsender.c.html#LN2183"><span class='Ref_To_Local'>wakeEvents</span></a> <span class='Operator'>|= </span><a href="../../include/storage/latch.h.html#LN125"><span class='Ref_to_Const'>WL_SOCKET_WRITEABLE</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Sleep until something happens or we time out */ 
</span>            <a href="../../include/storage/latch.h.html#LN165"><span class='Ref_to_Proto'>WaitLatchOrSocket</span></a><span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN51"><span class='Ref_to_Global_Var'>MyLatch</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN2183"><span class='Ref_To_Local'>wakeEvents</span></a><span class='Delimiter'>, 
</span>                              <a href="../utils/init/globals.c.html#LN40"><span class='Ref_to_Global_Var'>MyProcPort</span></a><span class='Operator'>-&GT;</span><a href="../../include/libpq/libpq-be.h.html#LN117"><span class='Ref_to_Member'>sock</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN2182"><span class='Ref_To_Local'>sleeptime</span></a><span class='Delimiter'>, 
</span>                              <a href="../../include/pgstat.h.html#LN766"><span class='Ref_to_EnumConst'>WAIT_EVENT_WAL_SENDER_MAIN</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for ;; &raquo; </span> 
    <span class='Control'>return</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end WalSndLoop &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* Initialize a per-walsender data structure for this walsender process */ 
</span><span class='Keyword'>static void 
</span><a name="LN2204"></a><span class='Declare_Function'>InitWalSenderSlot</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2206"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * WalSndCtl should be set up already (we inherit this by fork() or 
     * EXEC_BACKEND mechanism from the postmaster). 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="walsender.c.html#LN107"><span class='Ref_to_Global_Var'>WalSndCtl</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="walsender.c.html#LN110"><span class='Ref_to_Global_Var'>MyWalSnd</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Find a free walsender slot and reserve it. If this fails, we must be 
     * out of WalSnd structures. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN2206"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="walsender.c.html#LN2206"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="walsender.c.html#LN119"><span class='Ref_to_Global_Var'>max_wal_senders</span></a><span class='Delimiter'>; </span><a href="walsender.c.html#LN2206"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2221"></a>        <a href="../../include/replication/walsender_private.h.html#LN33"><span class='Ref_to_Struct'>WalSnd</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>walsnd</span> <span class='Operator'>= &</span><a href="walsender.c.html#LN107"><span class='Ref_to_Global_Var'>WalSndCtl</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN96"><span class='Ref_to_Member'>walsnds</span></a><span class='Delimiter'>[</span><a href="walsender.c.html#LN2206"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
        <a href="../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN2221"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN56"><span class='Ref_to_Member'>mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN2221"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN35"><span class='Ref_to_Member'>pid</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN2221"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN56"><span class='Ref_to_Member'>mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Found a free slot. Reserve it for us. 
             */ 
</span>            <a href="walsender.c.html#LN2221"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN35"><span class='Ref_to_Member'>pid</span></a> <span class='Operator'>= </span><a href="../utils/init/globals.c.html#LN38"><span class='Ref_to_Global_Var'>MyProcPid</span></a><span class='Delimiter'>; 
</span>            <a href="walsender.c.html#LN2221"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN37"><span class='Ref_to_Member'>sentPtr</span></a> <span class='Operator'>= </span><a href="../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span>            <a href="walsender.c.html#LN2221"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN46"><span class='Ref_to_Member'>write</span></a> <span class='Operator'>= </span><a href="../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span>            <a href="walsender.c.html#LN2221"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN47"><span class='Ref_to_Member'>flush</span></a> <span class='Operator'>= </span><a href="../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span>            <a href="walsender.c.html#LN2221"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN48"><span class='Ref_to_Member'>apply</span></a> <span class='Operator'>= </span><a href="../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span>            <a href="walsender.c.html#LN2221"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN51"><span class='Ref_to_Member'>writeLag</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>            <a href="walsender.c.html#LN2221"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN52"><span class='Ref_to_Member'>flushLag</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>            <a href="walsender.c.html#LN2221"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN53"><span class='Ref_to_Member'>applyLag</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>            <a href="walsender.c.html#LN2221"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN36"><span class='Ref_to_Member'>state</span></a> <span class='Operator'>= </span><a href="../../include/replication/walsender_private.h.html#LN23"><span class='Ref_to_EnumConst'>WALSNDSTATE_STARTUP</span></a><span class='Delimiter'>; 
</span>            <a href="walsender.c.html#LN2221"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN62"><span class='Ref_to_Member'>latch</span></a> <span class='Operator'>= &</span><a href="../storage/lmgr/proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../include/storage/proc.h.html#LN102"><span class='Ref_to_Member'>procLatch</span></a><span class='Delimiter'>; 
</span>            <a href="../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN2221"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN56"><span class='Ref_to_Member'>mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* don't need the lock anymore */ 
</span>            <a href="walsender.c.html#LN110"><span class='Ref_to_Global_Var'>MyWalSnd</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/replication/walsender_private.h.html#LN33"><span class='Ref_to_Struct'>WalSnd</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="walsender.c.html#LN2221"><span class='Ref_To_Local'>walsnd</span></a><span class='Delimiter'>; 
</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;max_wal_senders... &raquo; </span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN110"><span class='Ref_to_Global_Var'>MyWalSnd</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_TOO_MANY_CONNECTIONS<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"number of requested standby connections "</span> 
                        <span class='String'>"exceeds max_wal_senders (currently %d)"</span><span class='Delimiter'>, 
</span>                        <a href="walsender.c.html#LN119"><span class='Ref_to_Global_Var'>max_wal_senders</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Arrange to clean up at walsender exit */ 
</span>    <a href="../../include/storage/ipc.h.html#LN69"><span class='Ref_to_Proto'>on_shmem_exit</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN225"><span class='Ref_to_Proto'>WalSndKill</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end InitWalSenderSlot &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* Destroy the per-walsender data structure for this walsender process */ 
</span><span class='Keyword'>static void 
</span><a name="LN2265"></a><span class='Declare_Function'>WalSndKill</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>code</span><span class='Delimiter'>, </span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>arg</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2267"></a>    <a href="../../include/replication/walsender_private.h.html#LN33"><span class='Ref_to_Struct'>WalSnd</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>walsnd</span> <span class='Operator'>= </span><a href="walsender.c.html#LN110"><span class='Ref_to_Global_Var'>MyWalSnd</span></a><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="walsender.c.html#LN2267"><span class='Ref_To_Local'>walsnd</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="walsender.c.html#LN110"><span class='Ref_to_Global_Var'>MyWalSnd</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN2267"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN56"><span class='Ref_to_Member'>mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* clear latch while holding the spinlock, so it can safely be read */ 
</span>    <a href="walsender.c.html#LN2267"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN62"><span class='Ref_to_Member'>latch</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* Mark WalSnd struct as no longer being in use. */ 
</span>    <a href="walsender.c.html#LN2267"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN35"><span class='Ref_to_Member'>pid</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN2267"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN56"><span class='Ref_to_Member'>mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Read 'count' bytes from WAL into 'buf', starting at location 'startptr' 
 * 
 * XXX probably this should be improved to suck data directly from the 
 * WAL buffers when possible. 
 * 
 * Will open, and keep open, one WAL segment stored in the global file 
 * descriptor sendFile. This means if XLogRead is used once, there will 
 * always be one descriptor left open until the process ends, but never 
 * more than one. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2293"></a><span class='Declare_Function'>XLogRead</span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Declare_Parameter'>buf</span><span class='Delimiter'>, </span><a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>startptr</span><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a> <span class='Declare_Parameter'>count</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2295"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>p</span><span class='Delimiter'>; 
</span><a name="LN2296"></a>    <a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>recptr</span><span class='Delimiter'>; 
</span><a name="LN2297"></a>    <a href="../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Local'>nbytes</span><span class='Delimiter'>; 
</span><a name="LN2298"></a>    <a href="../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a>   <span class='Declare_Local'>segno</span><span class='Delimiter'>; 
</span> 
<a name="LN2300"></a><span class='Label'>retry</span><span class='Operator'>: 
</span>    <a href="walsender.c.html#LN2295"><span class='Ref_To_Local'>p</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN2293"><span class='Ref_to_Parameter'>buf</span></a><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN2296"><span class='Ref_To_Local'>recptr</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN2293"><span class='Ref_to_Parameter'>startptr</span></a><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN2297"><span class='Ref_To_Local'>nbytes</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN2293"><span class='Ref_to_Parameter'>count</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN2297"><span class='Ref_To_Local'>nbytes</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2307"></a>        <a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>startoff</span><span class='Delimiter'>; 
</span><a name="LN2308"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>segbytes</span><span class='Delimiter'>; 
</span><a name="LN2309"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>readbytes</span><span class='Delimiter'>; 
</span> 
        <a href="walsender.c.html#LN2307"><span class='Ref_To_Local'>startoff</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN2296"><span class='Ref_To_Local'>recptr</span></a> <span class='Operator'>% </span><a href="../../include/access/xlog_internal.h.html#LN91"><span class='Ref_to_Const'>XLogSegSize</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="basebackup.c.html#LN55"><span class='Ref_to_Proto'>sendFile</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span> <span class='Operator'>|| !</span><a href="../../include/access/xlog_internal.h.html#LN117"><span class='Ref_to_Macro'>XLByteInSeg</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN2296"><span class='Ref_To_Local'>recptr</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN134"><span class='Ref_to_Global_Var'>sendSegNo</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN2315"></a>            <span class='Keyword'>char</span>        <span class='Declare_Local'>path</span><span class='Delimiter'>[</span><a href="../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a><span class='Delimiter'>]; 
</span> 
            <span class='Comment_Multi_Line'>/* Switch to another logfile segment */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="basebackup.c.html#LN55"><span class='Ref_to_Proto'>sendFile</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <a href="../../interfaces/libpq/win32.h.html#LN11"><span class='Ref_to_Macro'>close</span></a><span class='Parentheses'>(</span><a href="basebackup.c.html#LN55"><span class='Ref_to_Proto'>sendFile</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../../include/access/xlog_internal.h.html#LN105"><span class='Ref_to_Macro'>XLByteToSeg</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN2296"><span class='Ref_To_Local'>recptr</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN134"><span class='Ref_to_Global_Var'>sendSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/*------- 
             * When reading from a historic timeline, and there is a timeline 
             * switch within this segment, read from the WAL segment belonging 
             * to the new timeline. 
             * 
             * For example, imagine that this server is currently on timeline 
             * 5, and we're streaming timeline 4. The switch from timeline 4 
             * to 5 happened at 0/13002088. In pg_wal, we have these files: 
             * 
             * ... 
             * 000000040000000000000012 
             * 000000040000000000000013 
             * 000000050000000000000013 
             * 000000050000000000000014 
             * ... 
             * 
             * In this situation, when requested to send the WAL from 
             * segment 0x13, on timeline 4, we read the WAL from file 
             * 000000050000000000000013. Archive recovery prefers files from 
             * newer timelines, so if the segment was restored from the 
             * archive on this server, the file belonging to the old timeline, 
             * 000000040000000000000013, might not exist. Their contents are 
             * equal up to the switchpoint, because at a timeline switch, the 
             * used portion of the old segment is copied to the new file. 
             *------- 
             */ 
</span>            <a href="walsender.c.html#LN138"><span class='Ref_to_Global_Var'>curFileTimeLine</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN146"><span class='Ref_to_Global_Var'>sendTimeLine</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN148"><span class='Ref_to_Global_Var'>sendTimeLineIsHistoric</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN2352"></a>                <a href="../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a>   <span class='Declare_Local'>endSegNo</span><span class='Delimiter'>; 
</span> 
                <a href="../../include/access/xlog_internal.h.html#LN105"><span class='Ref_to_Macro'>XLByteToSeg</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN149"><span class='Ref_to_Global_Var'>sendTimeLineValidUpto</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN2352"><span class='Ref_To_Local'>endSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN134"><span class='Ref_to_Global_Var'>sendSegNo</span></a> <span class='Operator'>== </span><a href="walsender.c.html#LN2352"><span class='Ref_To_Local'>endSegNo</span></a><span class='Parentheses'>) 
</span>                    <a href="walsender.c.html#LN138"><span class='Ref_to_Global_Var'>curFileTimeLine</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN147"><span class='Ref_to_Global_Var'>sendTimeLineNextTLI</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <a href="../../include/access/xlog_internal.h.html#LN172"><span class='Ref_to_Macro'>XLogFilePath</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN2315"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN138"><span class='Ref_to_Global_Var'>curFileTimeLine</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN134"><span class='Ref_to_Global_Var'>sendSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="basebackup.c.html#LN55"><span class='Ref_to_Proto'>sendFile</span></a> <span class='Operator'>= </span><a href="../../include/storage/fd.h.html#LN100"><span class='Ref_to_Proto'>BasicOpenFile</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN2315"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span>O_RDONLY <span class='Operator'>| </span><a href="../../include/c.h.html#LN1032"><span class='Ref_to_Const'>PG_BINARY</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="basebackup.c.html#LN55"><span class='Ref_to_Proto'>sendFile</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * If the file is not found, assume it's because the standby 
                 * asked for a too old WAL segment that has already been 
                 * removed or recycled. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span>errno <span class='Operator'>== </span>ENOENT<span class='Parentheses'>) 
</span>                    <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                             <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"requested WAL segment %s has already been removed"</span><span class='Delimiter'>, 
</span>                                <a href="../../include/access/xlog.h.html#LN254"><span class='Ref_to_Proto'>XLogFileNameP</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN138"><span class='Ref_to_Global_Var'>curFileTimeLine</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN134"><span class='Ref_to_Global_Var'>sendSegNo</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>                <span class='Control'>else</span> 
                    <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                             <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not open file \"%s\": %m"</span><span class='Delimiter'>, 
</span>                                    <a href="walsender.c.html#LN2315"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <a href="walsender.c.html#LN135"><span class='Ref_to_Global_Var'>sendOff</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if sendFile&LT;0||!XLByteIn... &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* Need to seek in the file? */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN135"><span class='Ref_to_Global_Var'>sendOff</span></a> <span class='Operator'>!= </span><a href="walsender.c.html#LN2307"><span class='Ref_To_Local'>startoff</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span>lseek<span class='Parentheses'>(</span><a href="basebackup.c.html#LN55"><span class='Ref_to_Proto'>sendFile</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span>off_t<span class='Parentheses'>) </span><a href="walsender.c.html#LN2307"><span class='Ref_To_Local'>startoff</span></a><span class='Delimiter'>, </span>SEEK_SET<span class='Parentheses'>)</span> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                  <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not seek in log segment %s to offset %u: %m"</span><span class='Delimiter'>, 
</span>                         <a href="../../include/access/xlog.h.html#LN254"><span class='Ref_to_Proto'>XLogFileNameP</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN138"><span class='Ref_to_Global_Var'>curFileTimeLine</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN134"><span class='Ref_to_Global_Var'>sendSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="walsender.c.html#LN2307"><span class='Ref_To_Local'>startoff</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <a href="walsender.c.html#LN135"><span class='Ref_to_Global_Var'>sendOff</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN2307"><span class='Ref_To_Local'>startoff</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* How many bytes are within this segment? */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN2297"><span class='Ref_To_Local'>nbytes</span></a> <span class='Operator'>&GT; </span><span class='Parentheses'>(</span><a href="../../include/access/xlog_internal.h.html#LN91"><span class='Ref_to_Const'>XLogSegSize</span></a> <span class='Operator'>- </span><a href="walsender.c.html#LN2307"><span class='Ref_To_Local'>startoff</span></a><span class='Parentheses'>))</span> 
            <a href="walsender.c.html#LN2308"><span class='Ref_To_Local'>segbytes</span></a> <span class='Operator'>= </span><a href="../../include/access/xlog_internal.h.html#LN91"><span class='Ref_to_Const'>XLogSegSize</span></a> <span class='Operator'>- </span><a href="walsender.c.html#LN2307"><span class='Ref_To_Local'>startoff</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="walsender.c.html#LN2308"><span class='Ref_To_Local'>segbytes</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN2297"><span class='Ref_To_Local'>nbytes</span></a><span class='Delimiter'>; 
</span> 
        <a href="../../include/pgstat.h.html#LN1206"><span class='Ref_to_Func'>pgstat_report_wait_start</span></a><span class='Parentheses'>(</span><a href="../../include/pgstat.h.html#LN902"><span class='Ref_to_EnumConst'>WAIT_EVENT_WAL_READ</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN2309"><span class='Ref_To_Local'>readbytes</span></a> <span class='Operator'>= </span><a href="../../interfaces/libpq/win32.h.html#LN12"><span class='Ref_to_Macro'>read</span></a><span class='Parentheses'>(</span><a href="basebackup.c.html#LN55"><span class='Ref_to_Proto'>sendFile</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN2295"><span class='Ref_To_Local'>p</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN2308"><span class='Ref_To_Local'>segbytes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/pgstat.h.html#LN1230"><span class='Ref_to_Func'>pgstat_report_wait_end</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN2309"><span class='Ref_To_Local'>readbytes</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not read from log segment %s, offset %u, length %lu: %m"</span><span class='Delimiter'>, 
</span>                            <a href="../../include/access/xlog.h.html#LN254"><span class='Ref_to_Proto'>XLogFileNameP</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN138"><span class='Ref_to_Global_Var'>curFileTimeLine</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN134"><span class='Ref_to_Global_Var'>sendSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                            <a href="walsender.c.html#LN135"><span class='Ref_to_Global_Var'>sendOff</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>unsigned long</span><span class='Parentheses'>) </span><a href="walsender.c.html#LN2308"><span class='Ref_To_Local'>segbytes</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Update state for read */ 
</span>        <a href="walsender.c.html#LN2296"><span class='Ref_To_Local'>recptr</span></a> <span class='Operator'>+= </span><a href="walsender.c.html#LN2309"><span class='Ref_To_Local'>readbytes</span></a><span class='Delimiter'>; 
</span> 
        <a href="walsender.c.html#LN135"><span class='Ref_to_Global_Var'>sendOff</span></a> <span class='Operator'>+= </span><a href="walsender.c.html#LN2309"><span class='Ref_To_Local'>readbytes</span></a><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN2297"><span class='Ref_To_Local'>nbytes</span></a> <span class='Operator'>-= </span><a href="walsender.c.html#LN2309"><span class='Ref_To_Local'>readbytes</span></a><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN2295"><span class='Ref_To_Local'>p</span></a> <span class='Operator'>+= </span><a href="walsender.c.html#LN2309"><span class='Ref_To_Local'>readbytes</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while nbytes&GT;0 &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * After reading into the buffer, check that what we read was valid. We do 
     * this after reading, because even though the segment was present when we 
     * opened it, it might get recycled or removed while we read it. The 
     * read() succeeds in that case, but the data we tried to read might 
     * already have been overwritten with new WAL records. 
     */ 
</span>    <a href="../../include/access/xlog_internal.h.html#LN105"><span class='Ref_to_Macro'>XLByteToSeg</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN2293"><span class='Ref_to_Parameter'>startptr</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN2298"><span class='Ref_To_Local'>segno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/access/xlog.h.html#LN231"><span class='Ref_to_Proto'>CheckXLogRemoved</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN2298"><span class='Ref_To_Local'>segno</span></a><span class='Delimiter'>, </span><a href="../access/transam/xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * During recovery, the currently-open WAL file might be replaced with the 
     * file of the same name retrieved from archive. So we always need to 
     * check what we read was valid after reading into the buffer. If it's 
     * invalid, we try to open and read the file again. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN114"><span class='Ref_to_Global_Var'>am_cascading_walsender</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2439"></a>        <a href="../../include/replication/walsender_private.h.html#LN33"><span class='Ref_to_Struct'>WalSnd</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>walsnd</span> <span class='Operator'>= </span><a href="walsender.c.html#LN110"><span class='Ref_to_Global_Var'>MyWalSnd</span></a><span class='Delimiter'>; 
</span><a name="LN2440"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>reload</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN2439"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN56"><span class='Ref_to_Member'>mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN2440"><span class='Ref_To_Local'>reload</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN2439"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN38"><span class='Ref_to_Member'>needreload</span></a><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN2439"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN38"><span class='Ref_to_Member'>needreload</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN2439"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN56"><span class='Ref_to_Member'>mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN2440"><span class='Ref_To_Local'>reload</span></a> <span class='Operator'>&& </span><a href="basebackup.c.html#LN55"><span class='Ref_to_Proto'>sendFile</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../interfaces/libpq/win32.h.html#LN11"><span class='Ref_to_Macro'>close</span></a><span class='Parentheses'>(</span><a href="basebackup.c.html#LN55"><span class='Ref_to_Proto'>sendFile</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="basebackup.c.html#LN55"><span class='Ref_to_Proto'>sendFile</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>goto</span> <span class='Symbol_Characters'>&uarr;</span><a href="walsender.c.html#LN2300"><span class='Ref_to_Label'>retry</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end XLogRead &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Send out the WAL in its normal physical/stored form. 
 * 
 * Read up to MAX_SEND_SIZE bytes of WAL that's been flushed to disk, 
 * but not yet sent to the client, and buffer it in the libpq output 
 * buffer. 
 * 
 * If there is no unsent WAL remaining, WalSndCaughtUp is set to true, 
 * otherwise WalSndCaughtUp is set to false. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2468"></a><span class='Declare_Function'>XLogSendPhysical</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2470"></a>    <a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>SendRqstPtr</span><span class='Delimiter'>; 
</span><a name="LN2471"></a>    <a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>startptr</span><span class='Delimiter'>; 
</span><a name="LN2472"></a>    <a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>endptr</span><span class='Delimiter'>; 
</span><a name="LN2473"></a>    <a href="../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Local'>nbytes</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If requested switch the WAL sender to the stopping state. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN185"><span class='Ref_to_Global_Var'>got_STOPPING</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/replication/walsender_private.h.html#LN102"><span class='Ref_to_Proto'>WalSndSetState</span></a><span class='Parentheses'>(</span><a href="../../include/replication/walsender_private.h.html#LN27"><span class='Ref_to_EnumConst'>WALSNDSTATE_STOPPING</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN177"><span class='Ref_to_Global_Var'>streamingDoneSending</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="walsender.c.html#LN181"><span class='Ref_to_Global_Var'>WalSndCaughtUp</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Figure out how far we can safely send the WAL. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN148"><span class='Ref_to_Global_Var'>sendTimeLineIsHistoric</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Streaming an old timeline that's in this server's history, but is 
         * not the one we're currently inserting or replaying. It can be 
         * streamed up to the point where we switched off that timeline. 
         */ 
</span>        <a href="walsender.c.html#LN2470"><span class='Ref_To_Local'>SendRqstPtr</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN149"><span class='Ref_to_Global_Var'>sendTimeLineValidUpto</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN114"><span class='Ref_to_Global_Var'>am_cascading_walsender</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Streaming the latest timeline on a standby. 
         * 
         * Attempt to send all WAL that has already been replayed, so that we 
         * know it's valid. If we're receiving WAL through streaming 
         * replication, it's also OK to send any WAL that has been received 
         * but not replayed. 
         * 
         * The timeline we're recovering from can change, or we can be 
         * promoted. In either case, the current timeline becomes historic. We 
         * need to detect that so that we don't try to stream past the point 
         * where we switched to another timeline. We check for promotion or 
         * timeline switch after calculating FlushPtr, to avoid a race 
         * condition: if the timeline becomes historic just after we checked 
         * that it was still current, it's still be OK to stream it up to the 
         * FlushPtr that was calculated before it became historic. 
         */ 
</span><a name="LN2514"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>becameHistoric</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
        <a href="walsender.c.html#LN2470"><span class='Ref_To_Local'>SendRqstPtr</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN2840"><span class='Ref_to_Func'>GetStandbyFlushRecPtr</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/xlog.h.html#LN242"><span class='Ref_to_Proto'>RecoveryInProgress</span></a><span class='Parentheses'>())</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * We have been promoted. RecoveryInProgress() updated 
             * ThisTimeLineID to the new current timeline. 
             */ 
</span>            <a href="walsender.c.html#LN114"><span class='Ref_to_Global_Var'>am_cascading_walsender</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="walsender.c.html#LN2514"><span class='Ref_To_Local'>becameHistoric</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Still a cascading standby. But is the timeline we're sending 
             * still the one recovery is recovering from? ThisTimeLineID was 
             * updated by the GetStandbyFlushRecPtr() call above. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN146"><span class='Ref_to_Global_Var'>sendTimeLine</span></a> <span class='Operator'>!= </span><a href="../access/transam/xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Parentheses'>) 
</span>                <a href="walsender.c.html#LN2514"><span class='Ref_To_Local'>becameHistoric</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN2514"><span class='Ref_To_Local'>becameHistoric</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * The timeline we were sending has become historic. Read the 
             * timeline history file of the new timeline to see where exactly 
             * we forked off from the timeline we were sending. 
             */ 
</span><a name="LN2545"></a>            <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>history</span><span class='Delimiter'>; 
</span> 
            <a href="walsender.c.html#LN2545"><span class='Ref_To_Local'>history</span></a> <span class='Operator'>= </span><a href="../../include/access/timeline.h.html#LN31"><span class='Ref_to_Proto'>readTimeLineHistory</span></a><span class='Parentheses'>(</span><a href="../access/transam/xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="walsender.c.html#LN149"><span class='Ref_to_Global_Var'>sendTimeLineValidUpto</span></a> <span class='Operator'>= </span><a href="../../include/access/timeline.h.html#LN40"><span class='Ref_to_Proto'>tliSwitchPoint</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN146"><span class='Ref_to_Global_Var'>sendTimeLine</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN2545"><span class='Ref_To_Local'>history</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="walsender.c.html#LN147"><span class='Ref_to_Global_Var'>sendTimeLineNextTLI</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="walsender.c.html#LN146"><span class='Ref_to_Global_Var'>sendTimeLine</span></a> <span class='Operator'>&LT; </span><a href="walsender.c.html#LN147"><span class='Ref_to_Global_Var'>sendTimeLineNextTLI</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../include/nodes/pg_list.h.html#LN266"><span class='Ref_to_Proto'>list_free_deep</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN2545"><span class='Ref_To_Local'>history</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="walsender.c.html#LN148"><span class='Ref_to_Global_Var'>sendTimeLineIsHistoric</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
            <a href="walsender.c.html#LN2470"><span class='Ref_To_Local'>SendRqstPtr</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN149"><span class='Ref_to_Global_Var'>sendTimeLineValidUpto</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if am_cascading_walsende... &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Streaming the current timeline on a master. 
         * 
         * Attempt to send all data that's already been written out and 
         * fsync'd to disk.  We cannot go further than what's been written out 
         * given the current implementation of XLogRead().  And in any case 
         * it's unsafe to send WAL that is not securely down to disk on the 
         * master: if the master subsequently crashes and restarts, slaves 
         * must not have applied any WAL that got lost on the master. 
         */ 
</span>        <a href="walsender.c.html#LN2470"><span class='Ref_To_Local'>SendRqstPtr</span></a> <span class='Operator'>= </span><a href="../../include/access/xlog.h.html#LN275"><span class='Ref_to_Proto'>GetFlushRecPtr</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Record the current system time as an approximation of the time at which 
     * this WAL location was written for the purposes of lag tracking. 
     * 
     * In theory we could make XLogFlush() record a time in shmem whenever WAL 
     * is flushed and we could get that time as well as the LSN when we call 
     * GetFlushRecPtr() above (and likewise for the cascading standby 
     * equivalent), but rather than putting any new code into the hot WAL path 
     * it seems good enough to capture the time here.  We should reach this 
     * after XLogFlush() runs WalSndWakeupProcessRequests(), and although that 
     * may take some time, we read the WAL flush pointer and take the time 
     * very close to together here so that we'll get a later position if it is 
     * still moving. 
     * 
     * Because LagTrackerWriter ignores samples when the LSN hasn't advanced, 
     * this gives us a cheap approximation for the WAL flush time for this 
     * LSN. 
     * 
     * Note that the LSN is not necessarily the LSN for the data contained in 
     * the present message; it's the end of the WAL, which might be further 
     * ahead.  All the lag tracking machinery cares about is finding out when 
     * that arbitrary LSN is eventually reported as written, flushed and 
     * applied, so that it can measure the elapsed time. 
     */ 
</span>    <a href="walsender.c.html#LN3363"><span class='Ref_to_Func'>LagTrackerWrite</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN2470"><span class='Ref_To_Local'>SendRqstPtr</span></a><span class='Delimiter'>, </span><a href="../../include/utils/timestamp.h.html#LN69"><span class='Ref_to_Proto'>GetCurrentTimestamp</span></a><span class='Parentheses'>())</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If this is a historic timeline and we've reached the point where we 
     * forked to the next timeline, stop streaming. 
     * 
     * Note: We might already have sent WAL &GT; sendTimeLineValidUpto. The 
     * startup process will normally replay all WAL that has been received 
     * from the master, before promoting, but if the WAL streaming is 
     * terminated at a WAL page boundary, the valid portion of the timeline 
     * might end in the middle of a WAL record. We might've already sent the 
     * first half of that partial WAL record to the cascading standby, so that 
     * sentPtr &GT; sendTimeLineValidUpto. That's OK; the cascading standby can't 
     * replay the partial WAL record either, so it can still follow our 
     * timeline switch. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN148"><span class='Ref_to_Global_Var'>sendTimeLineIsHistoric</span></a> <span class='Operator'>&& </span><a href="walsender.c.html#LN149"><span class='Ref_to_Global_Var'>sendTimeLineValidUpto</span></a> <span class='Operator'>&LT;= </span><a href="walsender.c.html#LN155"><span class='Ref_to_Global_Var'>sentPtr</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* close the current file. */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="basebackup.c.html#LN55"><span class='Ref_to_Proto'>sendFile</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <a href="../../interfaces/libpq/win32.h.html#LN11"><span class='Ref_to_Macro'>close</span></a><span class='Parentheses'>(</span><a href="basebackup.c.html#LN55"><span class='Ref_to_Proto'>sendFile</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="basebackup.c.html#LN55"><span class='Ref_to_Proto'>sendFile</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Send CopyDone */ 
</span>        <a href="../../include/libpq/libpq.h.html#LN43"><span class='Ref_to_Macro'>pq_putmessage_noblock</span></a><span class='Parentheses'>(</span><span class='String'>'c'</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN177"><span class='Ref_to_Global_Var'>streamingDoneSending</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
        <a href="walsender.c.html#LN181"><span class='Ref_to_Global_Var'>WalSndCaughtUp</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Delimiter'>, </span><span class='String'>"walsender reached end of timeline at %X/%X (sent up to %X/%X)"</span><span class='Delimiter'>, 
</span>             <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="walsender.c.html#LN149"><span class='Ref_to_Global_Var'>sendTimeLineValidUpto</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="walsender.c.html#LN149"><span class='Ref_to_Global_Var'>sendTimeLineValidUpto</span></a><span class='Delimiter'>, 
</span>             <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="walsender.c.html#LN155"><span class='Ref_to_Global_Var'>sentPtr</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="walsender.c.html#LN155"><span class='Ref_to_Global_Var'>sentPtr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Do we have any work to do? */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="walsender.c.html#LN155"><span class='Ref_to_Global_Var'>sentPtr</span></a> <span class='Operator'>&LT;= </span><a href="walsender.c.html#LN2470"><span class='Ref_To_Local'>SendRqstPtr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN2470"><span class='Ref_To_Local'>SendRqstPtr</span></a> <span class='Operator'>&LT;= </span><a href="walsender.c.html#LN155"><span class='Ref_to_Global_Var'>sentPtr</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="walsender.c.html#LN181"><span class='Ref_to_Global_Var'>WalSndCaughtUp</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Figure out how much to send in one message. If there's no more than 
     * MAX_SEND_SIZE bytes to send, send everything. Otherwise send 
     * MAX_SEND_SIZE bytes, but round back to logfile or page boundary. 
     * 
     * The rounding is not only for performance reasons. Walreceiver relies on 
     * the fact that we never split a WAL record across two messages. Since a 
     * long WAL record is split at page boundary into continuation records, 
     * page boundary is always a safe cut-off point. We also assume that 
     * SendRqstPtr never points to the middle of a WAL record. 
     */ 
</span>    <a href="walsender.c.html#LN2471"><span class='Ref_To_Local'>startptr</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN155"><span class='Ref_to_Global_Var'>sentPtr</span></a><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN2472"><span class='Ref_To_Local'>endptr</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN2471"><span class='Ref_To_Local'>startptr</span></a><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN2472"><span class='Ref_To_Local'>endptr</span></a> <span class='Operator'>+= </span><a href="walsender.c.html#LN104"><span class='Ref_to_Const'>MAX_SEND_SIZE</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* if we went beyond SendRqstPtr, back off */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN2470"><span class='Ref_To_Local'>SendRqstPtr</span></a> <span class='Operator'>&LT;= </span><a href="walsender.c.html#LN2472"><span class='Ref_To_Local'>endptr</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="walsender.c.html#LN2472"><span class='Ref_To_Local'>endptr</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN2470"><span class='Ref_To_Local'>SendRqstPtr</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN148"><span class='Ref_to_Global_Var'>sendTimeLineIsHistoric</span></a><span class='Parentheses'>) 
</span>            <a href="walsender.c.html#LN181"><span class='Ref_to_Global_Var'>WalSndCaughtUp</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="walsender.c.html#LN181"><span class='Ref_to_Global_Var'>WalSndCaughtUp</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* round down to page boundary. */ 
</span>        <a href="walsender.c.html#LN2472"><span class='Ref_To_Local'>endptr</span></a> <span class='Operator'>-= </span><span class='Parentheses'>(</span><a href="walsender.c.html#LN2472"><span class='Ref_To_Local'>endptr</span></a> <span class='Operator'>% </span>XLOG_BLCKSZ<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN181"><span class='Ref_to_Global_Var'>WalSndCaughtUp</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="walsender.c.html#LN2473"><span class='Ref_To_Local'>nbytes</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN2472"><span class='Ref_To_Local'>endptr</span></a> <span class='Operator'>- </span><a href="walsender.c.html#LN2471"><span class='Ref_To_Local'>startptr</span></a><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="walsender.c.html#LN2473"><span class='Ref_To_Local'>nbytes</span></a> <span class='Operator'>&LT;= </span><a href="walsender.c.html#LN104"><span class='Ref_to_Const'>MAX_SEND_SIZE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * OK to read and send the slice. 
     */ 
</span>    <a href="../lib/stringinfo.c.html#LN60"><span class='Ref_to_Func'>resetStringInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN158"><span class='Ref_to_Global_Var'>output_message</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/libpq/pqformat.h.html#LN18"><span class='Ref_to_Proto'>pq_sendbyte</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN158"><span class='Ref_to_Global_Var'>output_message</span></a><span class='Delimiter'>, </span><span class='String'>'w'</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/libpq/pqformat.h.html#LN26"><span class='Ref_to_Proto'>pq_sendint64</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN158"><span class='Ref_to_Global_Var'>output_message</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN2471"><span class='Ref_To_Local'>startptr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* dataStart */ 
</span>    <a href="../../include/libpq/pqformat.h.html#LN26"><span class='Ref_to_Proto'>pq_sendint64</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN158"><span class='Ref_to_Global_Var'>output_message</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN2470"><span class='Ref_To_Local'>SendRqstPtr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* walEnd */ 
</span>    <a href="../../include/libpq/pqformat.h.html#LN26"><span class='Ref_to_Proto'>pq_sendint64</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN158"><span class='Ref_to_Global_Var'>output_message</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* sendtime, filled in last */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Read the log directly into the output buffer to avoid extra memcpy 
     * calls. 
     */ 
</span>    <a href="../../include/lib/stringinfo.h.html#LN149"><span class='Ref_to_Proto'>enlargeStringInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN158"><span class='Ref_to_Global_Var'>output_message</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN2473"><span class='Ref_To_Local'>nbytes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../access/transam/xlogutils.c.html#LN655"><span class='Ref_to_Func'>XLogRead</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN158"><span class='Ref_to_Global_Var'>output_message</span></a><span class='Operator'>.</span><a href="../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Delimiter'>[</span><a href="walsender.c.html#LN158"><span class='Ref_to_Global_Var'>output_message</span></a><span class='Operator'>.</span><a href="../../include/lib/stringinfo.h.html#LN37"><span class='Ref_to_Member'>len</span></a><span class='Delimiter'>], </span><a href="walsender.c.html#LN2471"><span class='Ref_To_Local'>startptr</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN2473"><span class='Ref_To_Local'>nbytes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN158"><span class='Ref_to_Global_Var'>output_message</span></a><span class='Operator'>.</span><a href="../../include/lib/stringinfo.h.html#LN37"><span class='Ref_to_Member'>len</span></a> <span class='Operator'>+= </span><a href="walsender.c.html#LN2473"><span class='Ref_To_Local'>nbytes</span></a><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN158"><span class='Ref_to_Global_Var'>output_message</span></a><span class='Operator'>.</span><a href="../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Delimiter'>[</span><a href="walsender.c.html#LN158"><span class='Ref_to_Global_Var'>output_message</span></a><span class='Operator'>.</span><a href="../../include/lib/stringinfo.h.html#LN37"><span class='Ref_to_Member'>len</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='String'>'\0'</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Fill the send timestamp last, so that it is taken as late as possible. 
     */ 
</span>    <a href="../lib/stringinfo.c.html#LN60"><span class='Ref_to_Func'>resetStringInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN160"><span class='Ref_to_Global_Var'>tmpbuf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/libpq/pqformat.h.html#LN26"><span class='Ref_to_Proto'>pq_sendint64</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN160"><span class='Ref_to_Global_Var'>tmpbuf</span></a><span class='Delimiter'>, </span><a href="../../include/utils/timestamp.h.html#LN69"><span class='Ref_to_Proto'>GetCurrentTimestamp</span></a><span class='Parentheses'>())</span><span class='Delimiter'>; 
</span>    memcpy<span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN158"><span class='Ref_to_Global_Var'>output_message</span></a><span class='Operator'>.</span><a href="../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Delimiter'>[</span><span class='Number'>1</span> <span class='Operator'>+ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a><span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a><span class='Parentheses'>)</span><span class='Delimiter'>], 
</span>           <a href="walsender.c.html#LN160"><span class='Ref_to_Global_Var'>tmpbuf</span></a><span class='Operator'>.</span><a href="../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/libpq/libpq.h.html#LN43"><span class='Ref_to_Macro'>pq_putmessage_noblock</span></a><span class='Parentheses'>(</span><span class='String'>'d'</span><span class='Delimiter'>, </span><a href="walsender.c.html#LN158"><span class='Ref_to_Global_Var'>output_message</span></a><span class='Operator'>.</span><a href="../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN158"><span class='Ref_to_Global_Var'>output_message</span></a><span class='Operator'>.</span><a href="../../include/lib/stringinfo.h.html#LN37"><span class='Ref_to_Member'>len</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="walsender.c.html#LN155"><span class='Ref_to_Global_Var'>sentPtr</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN2472"><span class='Ref_To_Local'>endptr</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Update shared memory status */ 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2707"></a>        <a href="../../include/replication/walsender_private.h.html#LN33"><span class='Ref_to_Struct'>WalSnd</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>walsnd</span> <span class='Operator'>= </span><a href="walsender.c.html#LN110"><span class='Ref_to_Global_Var'>MyWalSnd</span></a><span class='Delimiter'>; 
</span> 
        <a href="../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN2707"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN56"><span class='Ref_to_Member'>mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN2707"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN37"><span class='Ref_to_Member'>sentPtr</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN155"><span class='Ref_to_Global_Var'>sentPtr</span></a><span class='Delimiter'>; 
</span>        <a href="../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN2707"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN56"><span class='Ref_to_Member'>mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Report progress of XLOG streaming in PS display */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../utils/misc/ps_status.c.html#LN34"><span class='Ref_to_Global_Var'>update_process_title</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2717"></a>        <span class='Keyword'>char</span>        <span class='Declare_Local'>activitymsg</span><span class='Delimiter'>[</span><span class='Number'>50</span><span class='Delimiter'>]; 
</span> 
        <a href="../../pl/plperl/plperl.h.html#LN60"><span class='Ref_to_Macro'>snprintf</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN2717"><span class='Ref_To_Local'>activitymsg</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="walsender.c.html#LN2717"><span class='Ref_To_Local'>activitymsg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='String'>"streaming %X/%X"</span><span class='Delimiter'>, 
</span>                 <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="walsender.c.html#LN155"><span class='Ref_to_Global_Var'>sentPtr</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="walsender.c.html#LN155"><span class='Ref_to_Global_Var'>sentPtr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/utils/ps_status.h.html#LN21"><span class='Ref_to_Proto'>set_ps_display</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN2717"><span class='Ref_To_Local'>activitymsg</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end XLogSendPhysical &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Stream out logically decoded data. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2731"></a><span class='Declare_Function'>XLogSendLogical</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2733"></a>    <a href="../../include/access/xlogrecord.h.html#LN40"><span class='Ref_to_Struct'>XLogRecord</span></a> <span class='Operator'>*</span><span class='Declare_Local'>record</span><span class='Delimiter'>; 
</span><a name="LN2734"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>errm</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Don't know whether we've caught up yet. We'll set it to true in 
     * WalSndWaitForWal, if we're actually waiting. We also set to true if 
     * XLogReadRecord() had to stop reading but WalSndWaitForWal didn't wait - 
     * i.e. when we're shutting down. 
     */ 
</span>    <a href="walsender.c.html#LN181"><span class='Ref_to_Global_Var'>WalSndCaughtUp</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <a href="walsender.c.html#LN2733"><span class='Ref_To_Local'>record</span></a> <span class='Operator'>= </span><a href="../access/transam/xlogreader.c.html#LN191"><span class='Ref_to_Func'>XLogReadRecord</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN195"><span class='Ref_to_Global_Var'>logical_decoding_ctx</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/logical.h.html#LN43"><span class='Ref_to_Member'>reader</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN196"><span class='Ref_to_Global_Var'>logical_startptr</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="walsender.c.html#LN2734"><span class='Ref_To_Local'>errm</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN196"><span class='Ref_to_Global_Var'>logical_startptr</span></a> <span class='Operator'>= </span><a href="../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* xlog record was invalid */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN2734"><span class='Ref_To_Local'>errm</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"%s"</span><span class='Delimiter'>, </span><a href="walsender.c.html#LN2734"><span class='Ref_To_Local'>errm</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN2733"><span class='Ref_To_Local'>record</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Note the lack of any call to LagTrackerWrite() which is handled by 
         * WalSndUpdateProgress which is called by output plugin through 
         * logical decoding write api. 
         */ 
</span>        <a href="../../include/replication/decode.h.html#LN16"><span class='Ref_to_Proto'>LogicalDecodingProcessRecord</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN195"><span class='Ref_to_Global_Var'>logical_decoding_ctx</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN195"><span class='Ref_to_Global_Var'>logical_decoding_ctx</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/logical.h.html#LN43"><span class='Ref_to_Member'>reader</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="walsender.c.html#LN155"><span class='Ref_to_Global_Var'>sentPtr</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN195"><span class='Ref_to_Global_Var'>logical_decoding_ctx</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/logical.h.html#LN43"><span class='Ref_to_Member'>reader</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/xlogreader.h.html#LN114"><span class='Ref_to_Member'>EndRecPtr</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * If the record we just wanted read is at or beyond the flushed 
         * point, then we're caught up. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN195"><span class='Ref_to_Global_Var'>logical_decoding_ctx</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/logical.h.html#LN43"><span class='Ref_to_Member'>reader</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/xlogreader.h.html#LN114"><span class='Ref_to_Member'>EndRecPtr</span></a> <span class='Operator'>&GT;= </span><a href="../../include/access/xlog.h.html#LN275"><span class='Ref_to_Proto'>GetFlushRecPtr</span></a><span class='Parentheses'>())</span> 
        <span class='Delimiter'>{ 
</span>            <a href="walsender.c.html#LN181"><span class='Ref_to_Global_Var'>WalSndCaughtUp</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Have WalSndLoop() terminate the connection in an orderly 
             * manner, after writing out all the pending data. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN185"><span class='Ref_to_Global_Var'>got_STOPPING</span></a><span class='Parentheses'>) 
</span>                <a href="../postmaster/autovacuum.c.html#LN140"><span class='Ref_to_Global_Var'>got_SIGUSR2</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Update shared memory status */ 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2783"></a>        <a href="../../include/replication/walsender_private.h.html#LN33"><span class='Ref_to_Struct'>WalSnd</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>walsnd</span> <span class='Operator'>= </span><a href="walsender.c.html#LN110"><span class='Ref_to_Global_Var'>MyWalSnd</span></a><span class='Delimiter'>; 
</span> 
        <a href="../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN2783"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN56"><span class='Ref_to_Member'>mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN2783"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN37"><span class='Ref_to_Member'>sentPtr</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN155"><span class='Ref_to_Global_Var'>sentPtr</span></a><span class='Delimiter'>; 
</span>        <a href="../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN2783"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN56"><span class='Ref_to_Member'>mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end XLogSendLogical &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Shutdown if the sender is caught up. 
 * 
 * NB: This should only be called when the shutdown signal has been received 
 * from postmaster. 
 * 
 * Note that if we determine that there's still more data to send, this 
 * function will return control to the caller. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2801"></a><span class='Declare_Function'>WalSndDone</span><span class='Parentheses'>(</span><a href="walsender.c.html#LN222"><span class='Ref_to_Typedef'>WalSndSendDataCallback</span></a> <span class='Declare_Parameter'>send_data</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2803"></a>    <a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>replicatedPtr</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* ... let's just be real sure we're caught up ... */ 
</span>    <a href="walsender.c.html#LN2801"><span class='Ref_to_Parameter'>send_data</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * To figure out whether all WAL has successfully been replicated, check 
     * flush location if valid, write otherwise. Tools like pg_receivewal will 
     * usually (unless in synchronous mode) return an invalid flush location. 
     */ 
</span>    <a href="walsender.c.html#LN2803"><span class='Ref_To_Local'>replicatedPtr</span></a> <span class='Operator'>= </span><a href="../../include/access/xlogdefs.h.html#LN28"><span class='Ref_to_Macro'>XLogRecPtrIsInvalid</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN110"><span class='Ref_to_Global_Var'>MyWalSnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN47"><span class='Ref_to_Member'>flush</span></a><span class='Parentheses'>) </span><span class='Operator'>? 
</span>        <a href="walsender.c.html#LN110"><span class='Ref_to_Global_Var'>MyWalSnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN46"><span class='Ref_to_Member'>write</span></a> <span class='Operator'>: </span><a href="walsender.c.html#LN110"><span class='Ref_to_Global_Var'>MyWalSnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN47"><span class='Ref_to_Member'>flush</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN181"><span class='Ref_to_Global_Var'>WalSndCaughtUp</span></a> <span class='Operator'>&& </span><a href="walsender.c.html#LN155"><span class='Ref_to_Global_Var'>sentPtr</span></a> <span class='Operator'>== </span><a href="walsender.c.html#LN2803"><span class='Ref_To_Local'>replicatedPtr</span></a> <span class='Operator'>&& 
</span>        <span class='Operator'>!</span><a href="../../include/libpq/libpq.h.html#LN40"><span class='Ref_to_Macro'>pq_is_send_pending</span></a><span class='Parentheses'>())</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Inform the standby that XLOG streaming is done */ 
</span>        <a href="../../include/tcop/dest.h.html#LN137"><span class='Ref_to_Proto'>EndCommand</span></a><span class='Parentheses'>(</span><span class='String'>"COPY 0"</span><span class='Delimiter'>, </span><a href="../../include/tcop/dest.h.html#LN89"><span class='Ref_to_EnumConst'>DestRemote</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/libpq/libpq.h.html#LN38"><span class='Ref_to_Macro'>pq_flush</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <a href="../storage/ipc/ipc.c.html#LN97"><span class='Ref_to_Func'>proc_exit</span></a><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="walsender.c.html#LN169"><span class='Ref_to_Global_Var'>waiting_for_ping_response</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="walsender.c.html#LN3305"><span class='Ref_to_Func'>WalSndKeepalive</span></a><span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN169"><span class='Ref_to_Global_Var'>waiting_for_ping_response</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end WalSndDone &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Returns the latest point in WAL that has been safely flushed to disk, and 
 * can be sent to the standby. This should only be called when in recovery, 
 * ie. we're streaming to a cascaded standby. 
 * 
 * As a side-effect, ThisTimeLineID is updated to the TLI of the last 
 * replayed WAL record. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> 
<a name="LN2841"></a><span class='Declare_Function'>GetStandbyFlushRecPtr</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2843"></a>    <a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>replayPtr</span><span class='Delimiter'>; 
</span><a name="LN2844"></a>    <a href="../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a>  <span class='Declare_Local'>replayTLI</span><span class='Delimiter'>; 
</span><a name="LN2845"></a>    <a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>receivePtr</span><span class='Delimiter'>; 
</span><a name="LN2846"></a>    <a href="../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a>  <span class='Declare_Local'>receiveTLI</span><span class='Delimiter'>; 
</span><a name="LN2847"></a>    <a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We can safely send what's already been replayed. Also, if walreceiver 
     * is streaming WAL from the same timeline, we can send anything that it 
     * has streamed, but hasn't been replayed yet. 
     */ 
</span> 
    <a href="walsender.c.html#LN2845"><span class='Ref_To_Local'>receivePtr</span></a> <span class='Operator'>= </span><a href="walreceiverfuncs.c.html#LN292"><span class='Ref_to_Func'>GetWalRcvWriteRecPtr</span></a><span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="walsender.c.html#LN2846"><span class='Ref_To_Local'>receiveTLI</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN2843"><span class='Ref_To_Local'>replayPtr</span></a> <span class='Operator'>= </span><a href="../../include/access/xlog.h.html#LN247"><span class='Ref_to_Proto'>GetXLogReplayRecPtr</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN2844"><span class='Ref_To_Local'>replayTLI</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../access/transam/xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN2844"><span class='Ref_To_Local'>replayTLI</span></a><span class='Delimiter'>; 
</span> 
    <a href="walsender.c.html#LN2847"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN2843"><span class='Ref_To_Local'>replayPtr</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN2846"><span class='Ref_To_Local'>receiveTLI</span></a> <span class='Operator'>== </span><a href="../access/transam/xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a> <span class='Operator'>&& </span><a href="walsender.c.html#LN2845"><span class='Ref_To_Local'>receivePtr</span></a> <span class='Operator'>&GT; </span><a href="walsender.c.html#LN2843"><span class='Ref_To_Local'>replayPtr</span></a><span class='Parentheses'>) 
</span>        <a href="walsender.c.html#LN2847"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN2845"><span class='Ref_To_Local'>receivePtr</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="walsender.c.html#LN2847"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end GetStandbyFlushRecPtr &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Request walsenders to reload the currently-open WAL file 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2871"></a><span class='Declare_Function'>WalSndRqstFileReload</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2873"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN2873"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="walsender.c.html#LN2873"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="walsender.c.html#LN119"><span class='Ref_to_Global_Var'>max_wal_senders</span></a><span class='Delimiter'>; </span><a href="walsender.c.html#LN2873"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2877"></a>        <a href="../../include/replication/walsender_private.h.html#LN33"><span class='Ref_to_Struct'>WalSnd</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>walsnd</span> <span class='Operator'>= &</span><a href="walsender.c.html#LN107"><span class='Ref_to_Global_Var'>WalSndCtl</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN96"><span class='Ref_to_Member'>walsnds</span></a><span class='Delimiter'>[</span><a href="walsender.c.html#LN2873"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN2877"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN35"><span class='Ref_to_Member'>pid</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN2877"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN56"><span class='Ref_to_Member'>mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN2877"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN38"><span class='Ref_to_Member'>needreload</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <a href="../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN2877"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN56"><span class='Ref_to_Member'>mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Handle PROCSIG_WALSND_INIT_STOPPING signal. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2892"></a><span class='Declare_Function'>HandleWalSndInitStopping</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="walsender.c.html#LN113"><span class='Ref_to_Global_Var'>am_walsender</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If replication has not yet started, die like with SIGTERM. If 
     * replication is active, only set a flag and wake up the main loop. It 
     * will send any outstanding WAL, wait for it to be replicated to the 
     * standby, and then exit gracefully. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="walsender.c.html#LN193"><span class='Ref_to_Global_Var'>replication_active</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/port.h.html#LN210"><span class='Ref_to_Macro'>kill</span></a><span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN38"><span class='Ref_to_Global_Var'>MyProcPid</span></a><span class='Delimiter'>, </span>SIGTERM<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="walsender.c.html#LN185"><span class='Ref_to_Global_Var'>got_STOPPING</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * SIGUSR2: set flag to do a last cycle and shut down afterwards. The WAL 
 * sender should already have been switched to WALSNDSTATE_STOPPING at 
 * this point. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2914"></a><span class='Declare_Function'>WalSndLastCycleHandler</span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN1078"><span class='Ref_to_Const'>SIGNAL_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2916"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>save_errno</span> <span class='Operator'>= </span>errno<span class='Delimiter'>; 
</span> 
    <a href="../postmaster/autovacuum.c.html#LN140"><span class='Ref_to_Global_Var'>got_SIGUSR2</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <a href="../../include/storage/latch.h.html#LN151"><span class='Ref_to_Proto'>SetLatch</span></a><span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN51"><span class='Ref_to_Global_Var'>MyLatch</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    errno <span class='Operator'>= </span><a href="walsender.c.html#LN2916"><span class='Ref_To_Local'>save_errno</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* Set up signal handlers */ 
</span><span class='Keyword'>void 
</span><a name="LN2926"></a><span class='Declare_Function'>WalSndSignals</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* Set up signal handlers */ 
</span>    <a href="../../port/pqsignal.c.html#LN38"><span class='Ref_to_Func'>pqsignal</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32.h.html#LN187"><span class='Ref_to_Const'>SIGHUP</span></a><span class='Delimiter'>, </span><a href="../../include/miscadmin.h.html#LN278"><span class='Ref_to_Proto'>PostgresSigHupHandler</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>    <span class='Comment_Multi_Line'>/* set flag to read config 
                                                 * file */ 
</span>    <a href="../../port/pqsignal.c.html#LN38"><span class='Ref_to_Func'>pqsignal</span></a><span class='Parentheses'>(</span>SIGINT<span class='Delimiter'>, </span><a href="../../include/tcop/tcopprot.h.html#LN69"><span class='Ref_to_Proto'>StatementCancelHandler</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* query cancel */ 
</span>    <a href="../../port/pqsignal.c.html#LN38"><span class='Ref_to_Func'>pqsignal</span></a><span class='Parentheses'>(</span>SIGTERM<span class='Delimiter'>, </span><a href="../../include/tcop/tcopprot.h.html#LN67"><span class='Ref_to_Proto'>die</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* request shutdown */ 
</span>    <a href="../../port/pqsignal.c.html#LN38"><span class='Ref_to_Func'>pqsignal</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32.h.html#LN188"><span class='Ref_to_Const'>SIGQUIT</span></a><span class='Delimiter'>, </span><a href="../tcop/postgres.c.html#LN2554"><span class='Ref_to_Func'>quickdie</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* hard crash time */ 
</span>    <a href="../../include/utils/timeout.h.html#LN69"><span class='Ref_to_Proto'>InitializeTimeouts</span></a><span class='Parentheses'>()</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* establishes SIGALRM handler */ 
</span>    <a href="../../port/pqsignal.c.html#LN38"><span class='Ref_to_Func'>pqsignal</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32.h.html#LN192"><span class='Ref_to_Const'>SIGPIPE</span></a><span class='Delimiter'>, </span><a href="../../include/port/win32.h.html#LN184"><span class='Ref_to_Const'>SIG_IGN</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../port/pqsignal.c.html#LN38"><span class='Ref_to_Func'>pqsignal</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32.h.html#LN201"><span class='Ref_to_Const'>SIGUSR1</span></a><span class='Delimiter'>, </span><a href="../../include/storage/procsignal.h.html#LN58"><span class='Ref_to_Proto'>procsignal_sigusr1_handler</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../port/pqsignal.c.html#LN38"><span class='Ref_to_Func'>pqsignal</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32.h.html#LN202"><span class='Ref_to_Const'>SIGUSR2</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN219"><span class='Ref_to_Proto'>WalSndLastCycleHandler</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>  <span class='Comment_Multi_Line'>/* request a last cycle and 
                                                 * shutdown */ 
</span> 
    <span class='Comment_Multi_Line'>/* Reset some signals that are accepted by postmaster but not here */ 
</span>    <a href="../../port/pqsignal.c.html#LN38"><span class='Ref_to_Func'>pqsignal</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32.h.html#LN197"><span class='Ref_to_Const'>SIGCHLD</span></a><span class='Delimiter'>, </span><a href="../../include/port/win32.h.html#LN182"><span class='Ref_to_Const'>SIG_DFL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../port/pqsignal.c.html#LN38"><span class='Ref_to_Func'>pqsignal</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32.h.html#LN198"><span class='Ref_to_Const'>SIGTTIN</span></a><span class='Delimiter'>, </span><a href="../../include/port/win32.h.html#LN182"><span class='Ref_to_Const'>SIG_DFL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../port/pqsignal.c.html#LN38"><span class='Ref_to_Func'>pqsignal</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32.h.html#LN199"><span class='Ref_to_Const'>SIGTTOU</span></a><span class='Delimiter'>, </span><a href="../../include/port/win32.h.html#LN182"><span class='Ref_to_Const'>SIG_DFL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../port/pqsignal.c.html#LN38"><span class='Ref_to_Func'>pqsignal</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32.h.html#LN196"><span class='Ref_to_Const'>SIGCONT</span></a><span class='Delimiter'>, </span><a href="../../include/port/win32.h.html#LN182"><span class='Ref_to_Const'>SIG_DFL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../port/pqsignal.c.html#LN38"><span class='Ref_to_Func'>pqsignal</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32.h.html#LN200"><span class='Ref_to_Const'>SIGWINCH</span></a><span class='Delimiter'>, </span><a href="../../include/port/win32.h.html#LN182"><span class='Ref_to_Const'>SIG_DFL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end WalSndSignals &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* Report shared-memory space needed by WalSndShmemInit */ 
</span><a href="../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a> 
<a name="LN2950"></a><span class='Declare_Function'>WalSndShmemSize</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2952"></a>    <a href="../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Local'>size</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <a href="walsender.c.html#LN2952"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../include/replication/walsender_private.h.html#LN75"><span class='Ref_to_Typedef'>WalSndCtlData</span></a><span class='Delimiter'>, </span>walsnds<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN2952"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN2952"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, </span><a href="../../include/storage/shmem.h.html#LN45"><span class='Ref_to_Proto'>mul_size</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN119"><span class='Ref_to_Global_Var'>max_wal_senders</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/replication/walsender_private.h.html#LN33"><span class='Ref_to_Struct'>WalSnd</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="walsender.c.html#LN2952"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* Allocate and initialize walsender-related shared memory */ 
</span><span class='Keyword'>void 
</span><a name="LN2962"></a><span class='Declare_Function'>WalSndShmemInit</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2964"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span><span class='Delimiter'>; 
</span><a name="LN2965"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <a href="walsender.c.html#LN107"><span class='Ref_to_Global_Var'>WalSndCtl</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/replication/walsender_private.h.html#LN75"><span class='Ref_to_Typedef'>WalSndCtlData</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>        <a href="../../include/storage/shmem.h.html#LN43"><span class='Ref_to_Proto'>ShmemInitStruct</span></a><span class='Parentheses'>(</span><span class='String'>"Wal Sender Ctl"</span><span class='Delimiter'>, </span><a href="../../include/replication/walsender.h.html#LN43"><span class='Ref_to_Proto'>WalSndShmemSize</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="walsender.c.html#LN2964"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="walsender.c.html#LN2964"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* First time through, so initialize */ 
</span>        <a href="../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN107"><span class='Ref_to_Global_Var'>WalSndCtl</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><a href="../../include/replication/walsender.h.html#LN43"><span class='Ref_to_Proto'>WalSndShmemSize</span></a><span class='Parentheses'>())</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN2965"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="walsender.c.html#LN2965"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="../../include/replication/syncrep.h.html#LN27"><span class='Ref_to_Const'>NUM_SYNC_REP_WAIT_MODE</span></a><span class='Delimiter'>; </span><a href="walsender.c.html#LN2965"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <a href="../storage/ipc/shmqueue.c.html#LN34"><span class='Ref_to_Func'>SHMQueueInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="walsender.c.html#LN107"><span class='Ref_to_Global_Var'>WalSndCtl</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN81"><span class='Ref_to_Member'>SyncRepQueue</span></a><span class='Delimiter'>[</span><a href="walsender.c.html#LN2965"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN2965"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="walsender.c.html#LN2965"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="walsender.c.html#LN119"><span class='Ref_to_Global_Var'>max_wal_senders</span></a><span class='Delimiter'>; </span><a href="walsender.c.html#LN2965"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN2980"></a>            <a href="../../include/replication/walsender_private.h.html#LN33"><span class='Ref_to_Struct'>WalSnd</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>walsnd</span> <span class='Operator'>= &</span><a href="walsender.c.html#LN107"><span class='Ref_to_Global_Var'>WalSndCtl</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN96"><span class='Ref_to_Member'>walsnds</span></a><span class='Delimiter'>[</span><a href="walsender.c.html#LN2965"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
            <a href="../../include/storage/spin.h.html#LN59"><span class='Ref_to_Macro'>SpinLockInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN2980"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN56"><span class='Ref_to_Member'>mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end WalSndShmemInit &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Wake up all walsenders 
 * 
 * This will be called inside critical sections, so throwing an error is not 
 * advisable. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2994"></a><span class='Declare_Function'>WalSndWakeup</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2996"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN2996"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="walsender.c.html#LN2996"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="walsender.c.html#LN119"><span class='Ref_to_Global_Var'>max_wal_senders</span></a><span class='Delimiter'>; </span><a href="walsender.c.html#LN2996"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3000"></a>        <a href="../../include/storage/latch.h.html#LN109"><span class='Ref_to_Struct'>Latch</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>latch</span><span class='Delimiter'>; 
</span><a name="LN3001"></a>        <a href="../../include/replication/walsender_private.h.html#LN33"><span class='Ref_to_Struct'>WalSnd</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>walsnd</span> <span class='Operator'>= &</span><a href="walsender.c.html#LN107"><span class='Ref_to_Global_Var'>WalSndCtl</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN96"><span class='Ref_to_Member'>walsnds</span></a><span class='Delimiter'>[</span><a href="walsender.c.html#LN2996"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Get latch pointer with spinlock held, for the unlikely case that 
         * pointer reads aren't atomic (as they're 8 bytes). 
         */ 
</span>        <a href="../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN3001"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN56"><span class='Ref_to_Member'>mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN3000"><span class='Ref_To_Local'>latch</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN3001"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN62"><span class='Ref_to_Member'>latch</span></a><span class='Delimiter'>; 
</span>        <a href="../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN3001"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN56"><span class='Ref_to_Member'>mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN3000"><span class='Ref_To_Local'>latch</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <a href="../../include/storage/latch.h.html#LN151"><span class='Ref_to_Proto'>SetLatch</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN3000"><span class='Ref_To_Local'>latch</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end WalSndWakeup &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Signal all walsenders to move to stopping state. 
 * 
 * This will trigger walsenders to move to a state where no further WAL can be 
 * generated. See this file's header for details. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN3023"></a><span class='Declare_Function'>WalSndInitStopping</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3025"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN3025"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="walsender.c.html#LN3025"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="walsender.c.html#LN119"><span class='Ref_to_Global_Var'>max_wal_senders</span></a><span class='Delimiter'>; </span><a href="walsender.c.html#LN3025"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3029"></a>        <a href="../../include/replication/walsender_private.h.html#LN33"><span class='Ref_to_Struct'>WalSnd</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>walsnd</span> <span class='Operator'>= &</span><a href="walsender.c.html#LN107"><span class='Ref_to_Global_Var'>WalSndCtl</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN96"><span class='Ref_to_Member'>walsnds</span></a><span class='Delimiter'>[</span><a href="walsender.c.html#LN3025"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span><a name="LN3030"></a>        <a href="../../include/port/win32.h.html#LN255"><span class='Ref_to_Typedef'>pid_t</span></a>       <span class='Declare_Local'>pid</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN3029"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN56"><span class='Ref_to_Member'>mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN3030"><span class='Ref_To_Local'>pid</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN3029"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN35"><span class='Ref_to_Member'>pid</span></a><span class='Delimiter'>; 
</span>        <a href="../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN3029"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN56"><span class='Ref_to_Member'>mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN3030"><span class='Ref_To_Local'>pid</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/storage/procsignal.h.html#LN55"><span class='Ref_to_Proto'>SendProcSignal</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN3030"><span class='Ref_To_Local'>pid</span></a><span class='Delimiter'>, </span><a href="../../include/storage/procsignal.h.html#LN34"><span class='Ref_to_EnumConst'>PROCSIG_WALSND_INIT_STOPPING</span></a><span class='Delimiter'>, </span><a href="../../include/storage/backendid.h.html#LN22"><span class='Ref_to_Const'>InvalidBackendId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end WalSndInitStopping &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Wait that all the WAL senders have quit or reached the stopping state. This 
 * is used by the checkpointer to control when the shutdown checkpoint can 
 * safely be performed. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN3049"></a><span class='Declare_Function'>WalSndWaitStopping</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3053"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN3054"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>all_stopped</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN3053"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="walsender.c.html#LN3053"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="walsender.c.html#LN119"><span class='Ref_to_Global_Var'>max_wal_senders</span></a><span class='Delimiter'>; </span><a href="walsender.c.html#LN3053"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN3058"></a>            <a href="../../include/replication/walsender_private.h.html#LN21"><span class='Ref_to_Enum'>WalSndState</span></a> <span class='Declare_Local'>state</span><span class='Delimiter'>; 
</span><a name="LN3059"></a>            <a href="../../include/replication/walsender_private.h.html#LN33"><span class='Ref_to_Struct'>WalSnd</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>walsnd</span> <span class='Operator'>= &</span><a href="walsender.c.html#LN107"><span class='Ref_to_Global_Var'>WalSndCtl</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN96"><span class='Ref_to_Member'>walsnds</span></a><span class='Delimiter'>[</span><a href="walsender.c.html#LN3053"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
            <a href="../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN3059"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN56"><span class='Ref_to_Member'>mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN3059"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN35"><span class='Ref_to_Member'>pid</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN3059"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN56"><span class='Ref_to_Member'>mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <a href="walsender.c.html#LN3058"><span class='Ref_To_Local'>state</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN3059"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN36"><span class='Ref_to_Member'>state</span></a><span class='Delimiter'>; 
</span>            <a href="../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN3059"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN56"><span class='Ref_to_Member'>mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN3058"><span class='Ref_To_Local'>state</span></a> <span class='Operator'>!= </span><a href="../../include/replication/walsender_private.h.html#LN27"><span class='Ref_to_EnumConst'>WALSNDSTATE_STOPPING</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="walsender.c.html#LN3054"><span class='Ref_To_Local'>all_stopped</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;max_wal_senders... &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* safe to leave if confirmation is done for all WAL senders */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN3054"><span class='Ref_To_Local'>all_stopped</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
        <a href="../../port/pgsleep.c.html#LN45"><span class='Ref_to_Func'>pg_usleep</span></a><span class='Parentheses'>(</span><span class='Number'>10000L</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* wait for 10 msec */ 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for ;; &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end WalSndWaitStopping &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* Set state for current walsender (only called in walsender) */ 
</span><span class='Keyword'>void 
</span><a name="LN3089"></a><span class='Declare_Function'>WalSndSetState</span><span class='Parentheses'>(</span><a href="../../include/replication/walsender_private.h.html#LN21"><span class='Ref_to_Enum'>WalSndState</span></a> <span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3091"></a>    <a href="../../include/replication/walsender_private.h.html#LN33"><span class='Ref_to_Struct'>WalSnd</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>walsnd</span> <span class='Operator'>= </span><a href="walsender.c.html#LN110"><span class='Ref_to_Global_Var'>MyWalSnd</span></a><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="walsender.c.html#LN113"><span class='Ref_to_Global_Var'>am_walsender</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN3091"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN36"><span class='Ref_to_Member'>state</span></a> <span class='Operator'>== </span><a href="walsender.c.html#LN3089"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN3091"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN56"><span class='Ref_to_Member'>mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN3091"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN36"><span class='Ref_to_Member'>state</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN3089"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>; 
</span>    <a href="../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN3091"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN56"><span class='Ref_to_Member'>mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Return a string constant representing the state. This is used 
 * in system views, and should *not* be translated. 
 */ 
</span><span class='Keyword'>static const char </span><span class='Operator'>* 
</span><a name="LN3108"></a><span class='Declare_Function'>WalSndGetStateString</span><span class='Parentheses'>(</span><a href="../../include/replication/walsender_private.h.html#LN21"><span class='Ref_to_Enum'>WalSndState</span></a> <span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN3108"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../include/replication/walsender_private.h.html#LN23"><span class='Ref_to_EnumConst'>WALSNDSTATE_STARTUP</span></a><span class='Operator'>: 
</span>            <span class='Control'>return</span> <span class='String'>"startup"</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/replication/walsender_private.h.html#LN24"><span class='Ref_to_EnumConst'>WALSNDSTATE_BACKUP</span></a><span class='Operator'>: 
</span>            <span class='Control'>return</span> <span class='String'>"backup"</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/replication/walsender_private.h.html#LN25"><span class='Ref_to_EnumConst'>WALSNDSTATE_CATCHUP</span></a><span class='Operator'>: 
</span>            <span class='Control'>return</span> <span class='String'>"catchup"</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/replication/walsender_private.h.html#LN26"><span class='Ref_to_EnumConst'>WALSNDSTATE_STREAMING</span></a><span class='Operator'>: 
</span>            <span class='Control'>return</span> <span class='String'>"streaming"</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/replication/walsender_private.h.html#LN27"><span class='Ref_to_EnumConst'>WALSNDSTATE_STOPPING</span></a><span class='Operator'>: 
</span>            <span class='Control'>return</span> <span class='String'>"stopping"</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <span class='String'>"UNKNOWN"</span><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static </span><a href="../../include/datatype/timestamp.h.html#LN42"><span class='Ref_to_Typedef'>Interval</span></a> <span class='Operator'>* 
</span><a name="LN3127"></a><span class='Declare_Function'>offset_to_interval</span><span class='Parentheses'>(</span><a href="../../include/datatype/timestamp.h.html#LN39"><span class='Ref_to_Typedef'>TimeOffset</span></a> <span class='Declare_Parameter'>offset</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3129"></a>    <a href="../../include/datatype/timestamp.h.html#LN42"><span class='Ref_to_Typedef'>Interval</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>result</span> <span class='Operator'>= </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/datatype/timestamp.h.html#LN42"><span class='Ref_to_Typedef'>Interval</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="walsender.c.html#LN3129"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../interfaces/ecpg/include/pgtypes_interval.h.html#LN28"><span class='Ref_to_Member'>month</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN3129"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../include/datatype/timestamp.h.html#LN46"><span class='Ref_to_Member'>day</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN3129"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../interfaces/ecpg/include/pgtypes_interval.h.html#LN27"><span class='Ref_to_Member'>time</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN3127"><span class='Ref_to_Parameter'>offset</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="walsender.c.html#LN3129"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Returns activity of walsenders, including pids and xlog locations sent to 
 * standby servers. 
 */ 
</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN3143"></a><span class='Declare_Function'>pg_stat_get_wal_senders</span><span class='Parentheses'>(</span><a href="../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3145"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PG_STAT_GET_WAL_SENDERS_COLS</span>    <span class='Number'>11</span> 
<a name="LN3146"></a>    <a href="../../include/nodes/execnodes.h.html#LN261"><span class='Ref_to_Struct'>ReturnSetInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rsinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN261"><span class='Ref_to_Struct'>ReturnSetInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span>fcinfo<span class='Operator'>-&GT;</span>resultinfo<span class='Delimiter'>; 
</span><a name="LN3147"></a>    <a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Local'>tupdesc</span><span class='Delimiter'>; 
</span><a name="LN3148"></a>    <a href="../utils/sort/tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tupstore</span><span class='Delimiter'>; 
</span><a name="LN3149"></a>    <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>per_query_ctx</span><span class='Delimiter'>; 
</span><a name="LN3150"></a>    <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span><span class='Delimiter'>; 
</span><a name="LN3151"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>sync_standbys</span><span class='Delimiter'>; 
</span><a name="LN3152"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* check to see if caller supports us returning a tuplestore */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN3146"><span class='Ref_To_Local'>rsinfo</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| !</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN3146"><span class='Ref_To_Local'>rsinfo</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/execnodes.h.html#LN261"><span class='Ref_to_Struct'>ReturnSetInfo</span></a><span class='Parentheses'>))</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"set-valued function called in context that cannot accept a set"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="walsender.c.html#LN3146"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN267"><span class='Ref_to_Member'>allowedModes</span></a> <span class='Operator'>& </span><a href="../../include/nodes/execnodes.h.html#LN250"><span class='Ref_to_EnumConst'>SFRM_Materialize</span></a><span class='Parentheses'>))</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"materialize mode required, but it is not "</span> <span class='Operator'>\ 
</span>                        <span class='String'>"allowed in this context"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Build a tuple descriptor for our result type */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/funcapi.h.html#LN157"><span class='Ref_to_Proto'>get_call_result_type</span></a><span class='Parentheses'>(</span>fcinfo<span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="walsender.c.html#LN3147"><span class='Ref_To_Local'>tupdesc</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="../../include/funcapi.h.html#LN152"><span class='Ref_to_EnumConst'>TYPEFUNC_COMPOSITE</span></a><span class='Parentheses'>)</span> 
        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"return type must be a row type"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="walsender.c.html#LN3149"><span class='Ref_To_Local'>per_query_ctx</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN3146"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN265"><span class='Ref_to_Member'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN201"><span class='Ref_to_Member'>ecxt_per_query_memory</span></a><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN3150"><span class='Ref_To_Local'>oldcontext</span></a> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN3149"><span class='Ref_To_Local'>per_query_ctx</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="walsender.c.html#LN3148"><span class='Ref_To_Local'>tupstore</span></a> <span class='Operator'>= </span><a href="../../include/utils/tuplestore.h.html#LN46"><span class='Ref_to_Proto'>tuplestore_begin_heap</span></a><span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><a href="../utils/init/globals.c.html#LN112"><span class='Ref_to_Global_Var'>work_mem</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN3146"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN269"><span class='Ref_to_Member'>returnMode</span></a> <span class='Operator'>= </span><a href="../../include/nodes/execnodes.h.html#LN250"><span class='Ref_to_EnumConst'>SFRM_Materialize</span></a><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN3146"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN272"><span class='Ref_to_Member'>setResult</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN3148"><span class='Ref_To_Local'>tupstore</span></a><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN3146"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN273"><span class='Ref_to_Member'>setDesc</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN3147"><span class='Ref_To_Local'>tupdesc</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN3150"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Get the currently active synchronous standbys. 
     */ 
</span>    <a href="../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SyncRepLock<span class='Delimiter'>, </span><a href="../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN3151"><span class='Ref_To_Local'>sync_standbys</span></a> <span class='Operator'>= </span><a href="../../include/replication/syncrep.h.html#LN76"><span class='Ref_to_Proto'>SyncRepGetSyncStandbys</span></a><span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SyncRepLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN3152"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="walsender.c.html#LN3152"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="walsender.c.html#LN119"><span class='Ref_to_Global_Var'>max_wal_senders</span></a><span class='Delimiter'>; </span><a href="walsender.c.html#LN3152"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3188"></a>        <a href="../../include/replication/walsender_private.h.html#LN33"><span class='Ref_to_Struct'>WalSnd</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>walsnd</span> <span class='Operator'>= &</span><a href="walsender.c.html#LN107"><span class='Ref_to_Global_Var'>WalSndCtl</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN96"><span class='Ref_to_Member'>walsnds</span></a><span class='Delimiter'>[</span><a href="walsender.c.html#LN3152"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span><a name="LN3189"></a>        <a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>sentPtr</span><span class='Delimiter'>; 
</span><a name="LN3190"></a>        <a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>write</span><span class='Delimiter'>; 
</span><a name="LN3191"></a>        <a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>flush</span><span class='Delimiter'>; 
</span><a name="LN3192"></a>        <a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>apply</span><span class='Delimiter'>; 
</span><a name="LN3193"></a>        <a href="../../include/datatype/timestamp.h.html#LN39"><span class='Ref_to_Typedef'>TimeOffset</span></a>  <span class='Declare_Local'>writeLag</span><span class='Delimiter'>; 
</span><a name="LN3194"></a>        <a href="../../include/datatype/timestamp.h.html#LN39"><span class='Ref_to_Typedef'>TimeOffset</span></a>  <span class='Declare_Local'>flushLag</span><span class='Delimiter'>; 
</span><a name="LN3195"></a>        <a href="../../include/datatype/timestamp.h.html#LN39"><span class='Ref_to_Typedef'>TimeOffset</span></a>  <span class='Declare_Local'>applyLag</span><span class='Delimiter'>; 
</span><a name="LN3196"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>priority</span><span class='Delimiter'>; 
</span><a name="LN3197"></a>        <a href="../../include/replication/walsender_private.h.html#LN21"><span class='Ref_to_Enum'>WalSndState</span></a> <span class='Declare_Local'>state</span><span class='Delimiter'>; 
</span><a name="LN3198"></a>        <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>values</span><span class='Delimiter'>[</span><a href="walsender.c.html#LN3145"><span class='Ref_to_Const'>PG_STAT_GET_WAL_SENDERS_COLS</span></a><span class='Delimiter'>]; 
</span><a name="LN3199"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>nulls</span><span class='Delimiter'>[</span><a href="walsender.c.html#LN3145"><span class='Ref_to_Const'>PG_STAT_GET_WAL_SENDERS_COLS</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN3188"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN35"><span class='Ref_to_Member'>pid</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN3188"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN56"><span class='Ref_to_Member'>mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN3189"><span class='Ref_To_Local'>sentPtr</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN3188"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN37"><span class='Ref_to_Member'>sentPtr</span></a><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN3197"><span class='Ref_To_Local'>state</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN3188"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN36"><span class='Ref_to_Member'>state</span></a><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN3190"><span class='Ref_To_Local'>write</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN3188"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN46"><span class='Ref_to_Member'>write</span></a><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN3191"><span class='Ref_To_Local'>flush</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN3188"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN47"><span class='Ref_to_Member'>flush</span></a><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN3192"><span class='Ref_To_Local'>apply</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN3188"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN48"><span class='Ref_to_Member'>apply</span></a><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN3193"><span class='Ref_To_Local'>writeLag</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN3188"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN51"><span class='Ref_to_Member'>writeLag</span></a><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN3194"><span class='Ref_To_Local'>flushLag</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN3188"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN52"><span class='Ref_to_Member'>flushLag</span></a><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN3195"><span class='Ref_To_Local'>applyLag</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN3188"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN53"><span class='Ref_to_Member'>applyLag</span></a><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN3196"><span class='Ref_To_Local'>priority</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN3188"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN69"><span class='Ref_to_Member'>sync_standby_priority</span></a><span class='Delimiter'>; 
</span>        <a href="../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN3188"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN56"><span class='Ref_to_Member'>mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        memset<span class='Parentheses'>(</span><a href="walsender.c.html#LN3199"><span class='Ref_To_Local'>nulls</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="walsender.c.html#LN3199"><span class='Ref_To_Local'>nulls</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN3198"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/postgres.h.html#LN484"><span class='Ref_to_Macro'>Int32GetDatum</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN3188"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN35"><span class='Ref_to_Member'>pid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../utils/misc/superuser.c.html#LN45"><span class='Ref_to_Func'>superuser</span></a><span class='Parentheses'>())</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Only superusers can see details. Other users only get the pid 
             * value to know it's a walsender, but no details. 
             */ 
</span>            <a href="../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN3199"><span class='Ref_To_Local'>nulls</span></a><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>], </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><a href="walsender.c.html#LN3145"><span class='Ref_to_Const'>PG_STAT_GET_WAL_SENDERS_COLS</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="walsender.c.html#LN3198"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/utils/builtins.h.html#LN90"><span class='Ref_to_Macro'>CStringGetTextDatum</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN3107"><span class='Ref_to_Func'>WalSndGetStateString</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN3197"><span class='Ref_To_Local'>state</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/xlogdefs.h.html#LN28"><span class='Ref_to_Macro'>XLogRecPtrIsInvalid</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN3189"><span class='Ref_To_Local'>sentPtr</span></a><span class='Parentheses'>))</span> 
                <a href="walsender.c.html#LN3199"><span class='Ref_To_Local'>nulls</span></a><span class='Delimiter'>[</span><span class='Number'>2</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="walsender.c.html#LN3198"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><span class='Number'>2</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/utils/pg_lsn.h.html#LN21"><span class='Ref_to_Macro'>LSNGetDatum</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN3189"><span class='Ref_To_Local'>sentPtr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/xlogdefs.h.html#LN28"><span class='Ref_to_Macro'>XLogRecPtrIsInvalid</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN3190"><span class='Ref_To_Local'>write</span></a><span class='Parentheses'>))</span> 
                <a href="walsender.c.html#LN3199"><span class='Ref_To_Local'>nulls</span></a><span class='Delimiter'>[</span><span class='Number'>3</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="walsender.c.html#LN3198"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><span class='Number'>3</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/utils/pg_lsn.h.html#LN21"><span class='Ref_to_Macro'>LSNGetDatum</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN3190"><span class='Ref_To_Local'>write</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/xlogdefs.h.html#LN28"><span class='Ref_to_Macro'>XLogRecPtrIsInvalid</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN3191"><span class='Ref_To_Local'>flush</span></a><span class='Parentheses'>))</span> 
                <a href="walsender.c.html#LN3199"><span class='Ref_To_Local'>nulls</span></a><span class='Delimiter'>[</span><span class='Number'>4</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="walsender.c.html#LN3198"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><span class='Number'>4</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/utils/pg_lsn.h.html#LN21"><span class='Ref_to_Macro'>LSNGetDatum</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN3191"><span class='Ref_To_Local'>flush</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/xlogdefs.h.html#LN28"><span class='Ref_to_Macro'>XLogRecPtrIsInvalid</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN3192"><span class='Ref_To_Local'>apply</span></a><span class='Parentheses'>))</span> 
                <a href="walsender.c.html#LN3199"><span class='Ref_To_Local'>nulls</span></a><span class='Delimiter'>[</span><span class='Number'>5</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="walsender.c.html#LN3198"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><span class='Number'>5</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/utils/pg_lsn.h.html#LN21"><span class='Ref_to_Macro'>LSNGetDatum</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN3192"><span class='Ref_To_Local'>apply</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Treat a standby such as a pg_basebackup background process 
             * which always returns an invalid flush location, as an 
             * asynchronous standby. 
             */ 
</span>            <a href="walsender.c.html#LN3196"><span class='Ref_To_Local'>priority</span></a> <span class='Operator'>= </span><a href="../../include/access/xlogdefs.h.html#LN28"><span class='Ref_to_Macro'>XLogRecPtrIsInvalid</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN3188"><span class='Ref_To_Local'>walsnd</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/walsender_private.h.html#LN47"><span class='Ref_to_Member'>flush</span></a><span class='Parentheses'>) </span><span class='Operator'>? </span><span class='Number'>0</span> <span class='Operator'>: </span><a href="walsender.c.html#LN3196"><span class='Ref_To_Local'>priority</span></a><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN3193"><span class='Ref_To_Local'>writeLag</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <a href="walsender.c.html#LN3199"><span class='Ref_To_Local'>nulls</span></a><span class='Delimiter'>[</span><span class='Number'>6</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="walsender.c.html#LN3198"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><span class='Number'>6</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/utils/timestamp.h.html#LN32"><span class='Ref_to_Macro'>IntervalPGetDatum</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN3126"><span class='Ref_to_Func'>offset_to_interval</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN3193"><span class='Ref_To_Local'>writeLag</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN3194"><span class='Ref_To_Local'>flushLag</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <a href="walsender.c.html#LN3199"><span class='Ref_To_Local'>nulls</span></a><span class='Delimiter'>[</span><span class='Number'>7</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="walsender.c.html#LN3198"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><span class='Number'>7</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/utils/timestamp.h.html#LN32"><span class='Ref_to_Macro'>IntervalPGetDatum</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN3126"><span class='Ref_to_Func'>offset_to_interval</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN3194"><span class='Ref_To_Local'>flushLag</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN3195"><span class='Ref_To_Local'>applyLag</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <a href="walsender.c.html#LN3199"><span class='Ref_To_Local'>nulls</span></a><span class='Delimiter'>[</span><span class='Number'>8</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="walsender.c.html#LN3198"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><span class='Number'>8</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/utils/timestamp.h.html#LN32"><span class='Ref_to_Macro'>IntervalPGetDatum</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN3126"><span class='Ref_to_Func'>offset_to_interval</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN3195"><span class='Ref_To_Local'>applyLag</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <a href="walsender.c.html#LN3198"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><span class='Number'>9</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/postgres.h.html#LN484"><span class='Ref_to_Macro'>Int32GetDatum</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN3196"><span class='Ref_To_Local'>priority</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * More easily understood version of standby state. This is purely 
             * informational. 
             * 
             * In quorum-based sync replication, the role of each standby 
             * listed in synchronous_standby_names can be changing very 
             * frequently. Any standbys considered as "sync" at one moment can 
             * be switched to "potential" ones at the next moment. So, it's 
             * basically useless to report "sync" or "potential" as their sync 
             * states. We report just "quorum" for them. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN3196"><span class='Ref_To_Local'>priority</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <a href="walsender.c.html#LN3198"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><span class='Number'>10</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/utils/builtins.h.html#LN90"><span class='Ref_to_Macro'>CStringGetTextDatum</span></a><span class='Parentheses'>(</span><span class='String'>"async"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN230"><span class='Ref_to_Proto'>list_member_int</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN3151"><span class='Ref_To_Local'>sync_standbys</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN3152"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>))</span> 
                <a href="walsender.c.html#LN3198"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><span class='Number'>10</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="syncrep.c.html#LN96"><span class='Ref_to_Global_Var'>SyncRepConfig</span></a><span class='Operator'>-&GT;</span><a href="../../include/replication/syncrep.h.html#LN50"><span class='Ref_to_Member'>syncrep_method</span></a> <span class='Operator'>== </span><a href="../../include/replication/syncrep.h.html#LN35"><span class='Ref_to_Const'>SYNC_REP_PRIORITY</span></a> <span class='Operator'>? 
</span>                    <a href="../../include/utils/builtins.h.html#LN90"><span class='Ref_to_Macro'>CStringGetTextDatum</span></a><span class='Parentheses'>(</span><span class='String'>"sync"</span><span class='Parentheses'>) </span><span class='Operator'>: </span><a href="../../include/utils/builtins.h.html#LN90"><span class='Ref_to_Macro'>CStringGetTextDatum</span></a><span class='Parentheses'>(</span><span class='String'>"quorum"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="walsender.c.html#LN3198"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><span class='Number'>10</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/utils/builtins.h.html#LN90"><span class='Ref_to_Macro'>CStringGetTextDatum</span></a><span class='Parentheses'>(</span><span class='String'>"potential"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
        <a href="../../include/utils/tuplestore.h.html#LN55"><span class='Ref_to_Proto'>tuplestore_putvalues</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN3148"><span class='Ref_To_Local'>tupstore</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN3147"><span class='Ref_To_Local'>tupdesc</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN3198"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN3199"><span class='Ref_To_Local'>nulls</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;max_wal_senders... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* clean up and return the tuplestore */ 
</span>    <a href="../../include/utils/tuplestore.h.html#LN59"><span class='Ref_to_Macro'>tuplestore_donestoring</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN3148"><span class='Ref_To_Local'>tupstore</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end pg_stat_get_wal_senders &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
  * This function is used to send a keepalive message to standby. 
  * If requestReply is set, sets a flag in the message requesting the standby 
  * to send a message back to us, for heartbeat purposes. 
  */ 
</span><span class='Keyword'>static void 
</span><a name="LN3306"></a><span class='Declare_Function'>WalSndKeepalive</span><span class='Parentheses'>(</span><span class='Keyword'>bool </span><span class='Declare_Parameter'>requestReply</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, </span><span class='String'>"sending replication keepalive"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* construct the message... */ 
</span>    <a href="../lib/stringinfo.c.html#LN60"><span class='Ref_to_Func'>resetStringInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN158"><span class='Ref_to_Global_Var'>output_message</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/libpq/pqformat.h.html#LN18"><span class='Ref_to_Proto'>pq_sendbyte</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN158"><span class='Ref_to_Global_Var'>output_message</span></a><span class='Delimiter'>, </span><span class='String'>'k'</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/libpq/pqformat.h.html#LN26"><span class='Ref_to_Proto'>pq_sendint64</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN158"><span class='Ref_to_Global_Var'>output_message</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN155"><span class='Ref_to_Global_Var'>sentPtr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/libpq/pqformat.h.html#LN26"><span class='Ref_to_Proto'>pq_sendint64</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN158"><span class='Ref_to_Global_Var'>output_message</span></a><span class='Delimiter'>, </span><a href="../../include/utils/timestamp.h.html#LN69"><span class='Ref_to_Proto'>GetCurrentTimestamp</span></a><span class='Parentheses'>())</span><span class='Delimiter'>; 
</span>    <a href="../../include/libpq/pqformat.h.html#LN18"><span class='Ref_to_Proto'>pq_sendbyte</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="walsender.c.html#LN158"><span class='Ref_to_Global_Var'>output_message</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN3306"><span class='Ref_to_Parameter'>requestReply</span></a> <span class='Operator'>? </span><span class='Number'>1</span> <span class='Operator'>: </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* ... and send it wrapped in CopyData */ 
</span>    <a href="../../include/libpq/libpq.h.html#LN43"><span class='Ref_to_Macro'>pq_putmessage_noblock</span></a><span class='Parentheses'>(</span><span class='String'>'d'</span><span class='Delimiter'>, </span><a href="walsender.c.html#LN158"><span class='Ref_to_Global_Var'>output_message</span></a><span class='Operator'>.</span><a href="../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Delimiter'>, </span><a href="walsender.c.html#LN158"><span class='Ref_to_Global_Var'>output_message</span></a><span class='Operator'>.</span><a href="../../include/lib/stringinfo.h.html#LN37"><span class='Ref_to_Member'>len</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Send keepalive message if too much time has elapsed. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3325"></a><span class='Declare_Function'>WalSndKeepaliveIfNecessary</span><span class='Parentheses'>(</span><a href="../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Parameter'>now</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3327"></a>    <a href="../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Local'>ping_time</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Don't send keepalive messages if timeouts are globally disabled or 
     * we're doing something not partaking in timeouts. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN120"><span class='Ref_to_Global_Var'>wal_sender_timeout</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span> <span class='Operator'>|| </span><a href="walsender.c.html#LN166"><span class='Ref_to_Global_Var'>last_reply_timestamp</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN169"><span class='Ref_to_Global_Var'>waiting_for_ping_response</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If half of wal_sender_timeout has lapsed without receiving any reply 
     * from the standby, send a keep-alive message to the standby requesting 
     * an immediate reply. 
     */ 
</span>    <a href="walsender.c.html#LN3327"><span class='Ref_To_Local'>ping_time</span></a> <span class='Operator'>= </span><a href="../../include/utils/timestamp.h.html#LN55"><span class='Ref_to_Macro'>TimestampTzPlusMilliseconds</span></a><span class='Parentheses'>(</span><a href="walsender.c.html#LN166"><span class='Ref_to_Global_Var'>last_reply_timestamp</span></a><span class='Delimiter'>, 
</span>                                            <a href="walsender.c.html#LN120"><span class='Ref_to_Global_Var'>wal_sender_timeout</span></a> <span class='Operator'>/ </span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN3325"><span class='Ref_to_Parameter'>now</span></a> <span class='Operator'>&GT;= </span><a href="walsender.c.html#LN3327"><span class='Ref_To_Local'>ping_time</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="walsender.c.html#LN3305"><span class='Ref_to_Func'>WalSndKeepalive</span></a><span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN169"><span class='Ref_to_Global_Var'>waiting_for_ping_response</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Try to flush pending output to the client */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/libpq/libpq.h.html#LN39"><span class='Ref_to_Macro'>pq_flush_if_writable</span></a><span class='Parentheses'>() </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <a href="walsender.c.html#LN226"><span class='Ref_to_Func'>WalSndShutdown</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end WalSndKeepaliveIfNecessary &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Record the end of the WAL and the time it was flushed locally, so that 
 * LagTrackerRead can compute the elapsed time (lag) when this WAL location is 
 * eventually reported to have been written, flushed and applied by the 
 * standby in a reply message. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3364"></a><span class='Declare_Function'>LagTrackerWrite</span><span class='Parentheses'>(</span><a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>lsn</span><span class='Delimiter'>, </span><a href="../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Parameter'>local_flush_time</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3366"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>buffer_full</span><span class='Delimiter'>; 
</span><a name="LN3367"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>new_write_head</span><span class='Delimiter'>; 
</span><a name="LN3368"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="walsender.c.html#LN113"><span class='Ref_to_Global_Var'>am_walsender</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the lsn hasn't advanced since last time, then do nothing.  This way 
     * we only record a new sample when new WAL has been written. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN216"><span class='Ref_to_Global_Var'>LagTracker</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN211"><span class='Ref_to_Member'>last_lsn</span></a> <span class='Operator'>== </span><a href="walsender.c.html#LN3364"><span class='Ref_to_Parameter'>lsn</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN216"><span class='Ref_to_Global_Var'>LagTracker</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN211"><span class='Ref_to_Member'>last_lsn</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN3364"><span class='Ref_to_Parameter'>lsn</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If advancing the write head of the circular buffer would crash into any 
     * of the read heads, then the buffer is full.  In other words, the 
     * slowest reader (presumably apply) is the one that controls the release 
     * of space. 
     */ 
</span>    <a href="walsender.c.html#LN3367"><span class='Ref_To_Local'>new_write_head</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="walsender.c.html#LN216"><span class='Ref_to_Global_Var'>LagTracker</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN213"><span class='Ref_to_Member'>write_head</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>% </span><a href="walsender.c.html#LN206"><span class='Ref_to_Const'>LAG_TRACKER_BUFFER_SIZE</span></a><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN3366"><span class='Ref_To_Local'>buffer_full</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN3368"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="walsender.c.html#LN3368"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="../../include/replication/syncrep.h.html#LN27"><span class='Ref_to_Const'>NUM_SYNC_REP_WAIT_MODE</span></a><span class='Delimiter'>; </span><span class='Operator'>++</span><a href="walsender.c.html#LN3368"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN3367"><span class='Ref_To_Local'>new_write_head</span></a> <span class='Operator'>== </span><a href="walsender.c.html#LN216"><span class='Ref_to_Global_Var'>LagTracker</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN214"><span class='Ref_to_Member'>read_heads</span></a><span class='Delimiter'>[</span><a href="walsender.c.html#LN3368"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>            <a href="walsender.c.html#LN3366"><span class='Ref_To_Local'>buffer_full</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the buffer is full, for now we just rewind by one slot and overwrite 
     * the last sample, as a simple (if somewhat uneven) way to lower the 
     * sampling rate.  There may be better adaptive compaction algorithms. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN3366"><span class='Ref_To_Local'>buffer_full</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="walsender.c.html#LN3367"><span class='Ref_To_Local'>new_write_head</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN216"><span class='Ref_to_Global_Var'>LagTracker</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN213"><span class='Ref_to_Member'>write_head</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN216"><span class='Ref_to_Global_Var'>LagTracker</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN213"><span class='Ref_to_Member'>write_head</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <a href="walsender.c.html#LN216"><span class='Ref_to_Global_Var'>LagTracker</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN213"><span class='Ref_to_Member'>write_head</span></a><span class='Operator'>--</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="walsender.c.html#LN216"><span class='Ref_to_Global_Var'>LagTracker</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN213"><span class='Ref_to_Member'>write_head</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN206"><span class='Ref_to_Const'>LAG_TRACKER_BUFFER_SIZE</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Store a sample at the current write head position. */ 
</span>    <a href="walsender.c.html#LN216"><span class='Ref_to_Global_Var'>LagTracker</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN212"><span class='Ref_to_Member'>buffer</span></a><span class='Delimiter'>[</span><a href="walsender.c.html#LN216"><span class='Ref_to_Global_Var'>LagTracker</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN213"><span class='Ref_to_Member'>write_head</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="walsender.c.html#LN201"><span class='Ref_to_Member'>lsn</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN3364"><span class='Ref_to_Parameter'>lsn</span></a><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN216"><span class='Ref_to_Global_Var'>LagTracker</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN212"><span class='Ref_to_Member'>buffer</span></a><span class='Delimiter'>[</span><a href="walsender.c.html#LN216"><span class='Ref_to_Global_Var'>LagTracker</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN213"><span class='Ref_to_Member'>write_head</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="walsender.c.html#LN202"><span class='Ref_to_Member'>time</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN3364"><span class='Ref_to_Parameter'>local_flush_time</span></a><span class='Delimiter'>; 
</span>    <a href="walsender.c.html#LN216"><span class='Ref_to_Global_Var'>LagTracker</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN213"><span class='Ref_to_Member'>write_head</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN3367"><span class='Ref_To_Local'>new_write_head</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end LagTrackerWrite &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Find out how much time has elapsed between the moment WAL location 'lsn' 
 * (or the highest known earlier LSN) was flushed locally and the time 'now'. 
 * We have a separate read head for each of the reported LSN locations we 
 * receive in replies from standby; 'head' controls which read head is 
 * used.  Whenever a read head crosses an LSN which was written into the 
 * lag buffer with LagTrackerWrite, we can use the associated timestamp to 
 * find out the time this LSN (or an earlier one) was flushed locally, and 
 * therefore compute the lag. 
 * 
 * Return -1 if no new sample data is available, and otherwise the elapsed 
 * time in microseconds. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/datatype/timestamp.h.html#LN39"><span class='Ref_to_Typedef'>TimeOffset</span></a> 
<a name="LN3429"></a><span class='Declare_Function'>LagTrackerRead</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>head</span><span class='Delimiter'>, </span><a href="../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>lsn</span><span class='Delimiter'>, </span><a href="../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Parameter'>now</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3431"></a>    <a href="../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Local'>time</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Read all unread samples up to this LSN or end of buffer. */ 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN216"><span class='Ref_to_Global_Var'>LagTracker</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN214"><span class='Ref_to_Member'>read_heads</span></a><span class='Delimiter'>[</span><a href="walsender.c.html#LN3429"><span class='Ref_to_Parameter'>head</span></a><span class='Delimiter'>] </span><span class='Operator'>!= </span><a href="walsender.c.html#LN216"><span class='Ref_to_Global_Var'>LagTracker</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN213"><span class='Ref_to_Member'>write_head</span></a> <span class='Operator'>&& 
</span>           <a href="walsender.c.html#LN216"><span class='Ref_to_Global_Var'>LagTracker</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN212"><span class='Ref_to_Member'>buffer</span></a><span class='Delimiter'>[</span><a href="walsender.c.html#LN216"><span class='Ref_to_Global_Var'>LagTracker</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN214"><span class='Ref_to_Member'>read_heads</span></a><span class='Delimiter'>[</span><a href="walsender.c.html#LN3429"><span class='Ref_to_Parameter'>head</span></a><span class='Delimiter'>]]</span><span class='Operator'>.</span><a href="walsender.c.html#LN201"><span class='Ref_to_Member'>lsn</span></a> <span class='Operator'>&LT;= </span><a href="walsender.c.html#LN3429"><span class='Ref_to_Parameter'>lsn</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="walsender.c.html#LN3431"><span class='Ref_To_Local'>time</span></a> <span class='Operator'>= </span><a href="walsender.c.html#LN216"><span class='Ref_to_Global_Var'>LagTracker</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN212"><span class='Ref_to_Member'>buffer</span></a><span class='Delimiter'>[</span><a href="walsender.c.html#LN216"><span class='Ref_to_Global_Var'>LagTracker</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN214"><span class='Ref_to_Member'>read_heads</span></a><span class='Delimiter'>[</span><a href="walsender.c.html#LN3429"><span class='Ref_to_Parameter'>head</span></a><span class='Delimiter'>]]</span><span class='Operator'>.</span><a href="walsender.c.html#LN202"><span class='Ref_to_Member'>time</span></a><span class='Delimiter'>; 
</span>        <a href="walsender.c.html#LN216"><span class='Ref_to_Global_Var'>LagTracker</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN215"><span class='Ref_to_Member'>last_read</span></a><span class='Delimiter'>[</span><a href="walsender.c.html#LN3429"><span class='Ref_to_Parameter'>head</span></a><span class='Delimiter'>] </span><span class='Operator'>= 
</span>            <a href="walsender.c.html#LN216"><span class='Ref_to_Global_Var'>LagTracker</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN212"><span class='Ref_to_Member'>buffer</span></a><span class='Delimiter'>[</span><a href="walsender.c.html#LN216"><span class='Ref_to_Global_Var'>LagTracker</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN214"><span class='Ref_to_Member'>read_heads</span></a><span class='Delimiter'>[</span><a href="walsender.c.html#LN3429"><span class='Ref_to_Parameter'>head</span></a><span class='Delimiter'>]]; 
</span>        <a href="walsender.c.html#LN216"><span class='Ref_to_Global_Var'>LagTracker</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN214"><span class='Ref_to_Member'>read_heads</span></a><span class='Delimiter'>[</span><a href="walsender.c.html#LN3429"><span class='Ref_to_Parameter'>head</span></a><span class='Delimiter'>] </span><span class='Operator'>= 
</span>            <span class='Parentheses'>(</span><a href="walsender.c.html#LN216"><span class='Ref_to_Global_Var'>LagTracker</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN214"><span class='Ref_to_Member'>read_heads</span></a><span class='Delimiter'>[</span><a href="walsender.c.html#LN3429"><span class='Ref_to_Parameter'>head</span></a><span class='Delimiter'>] </span><span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>% </span><a href="walsender.c.html#LN206"><span class='Ref_to_Const'>LAG_TRACKER_BUFFER_SIZE</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN3431"><span class='Ref_To_Local'>time</span></a> <span class='Operator'>&GT; </span><a href="walsender.c.html#LN3429"><span class='Ref_to_Parameter'>now</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* If the clock somehow went backwards, treat as not found. */ 
</span>        <span class='Control'>return</span> <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN3431"><span class='Ref_To_Local'>time</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We didn't cross a time.  If there is a future sample that we 
         * haven't reached yet, and we've already reached at least one sample, 
         * let's interpolate the local flushed time.  This is mainly useful 
         * for reporting a completely stuck apply position as having 
         * increasing lag, since otherwise we'd have to wait for it to 
         * eventually start moving again and cross one of our samples before 
         * we can show the lag increasing. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN216"><span class='Ref_to_Global_Var'>LagTracker</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN214"><span class='Ref_to_Member'>read_heads</span></a><span class='Delimiter'>[</span><a href="walsender.c.html#LN3429"><span class='Ref_to_Parameter'>head</span></a><span class='Delimiter'>] </span><span class='Operator'>!= </span><a href="walsender.c.html#LN216"><span class='Ref_to_Global_Var'>LagTracker</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN213"><span class='Ref_to_Member'>write_head</span></a> <span class='Operator'>&& 
</span>            <a href="walsender.c.html#LN216"><span class='Ref_to_Global_Var'>LagTracker</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN215"><span class='Ref_to_Member'>last_read</span></a><span class='Delimiter'>[</span><a href="walsender.c.html#LN3429"><span class='Ref_to_Parameter'>head</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="walsender.c.html#LN202"><span class='Ref_to_Member'>time</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN3463"></a>            <span class='Keyword'>double</span>      <span class='Declare_Local'>fraction</span><span class='Delimiter'>; 
</span><a name="LN3464"></a>            <a href="walsender.c.html#LN199"><span class='Ref_to_Typedef'>WalTimeSample</span></a> <span class='Declare_Local'>prev</span> <span class='Operator'>= </span><a href="walsender.c.html#LN216"><span class='Ref_to_Global_Var'>LagTracker</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN215"><span class='Ref_to_Member'>last_read</span></a><span class='Delimiter'>[</span><a href="walsender.c.html#LN3429"><span class='Ref_to_Parameter'>head</span></a><span class='Delimiter'>]; 
</span><a name="LN3465"></a>            <a href="walsender.c.html#LN199"><span class='Ref_to_Typedef'>WalTimeSample</span></a> <span class='Declare_Local'>next</span> <span class='Operator'>= </span><a href="walsender.c.html#LN216"><span class='Ref_to_Global_Var'>LagTracker</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN212"><span class='Ref_to_Member'>buffer</span></a><span class='Delimiter'>[</span><a href="walsender.c.html#LN216"><span class='Ref_to_Global_Var'>LagTracker</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN214"><span class='Ref_to_Member'>read_heads</span></a><span class='Delimiter'>[</span><a href="walsender.c.html#LN3429"><span class='Ref_to_Parameter'>head</span></a><span class='Delimiter'>]]; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN3429"><span class='Ref_to_Parameter'>lsn</span></a> <span class='Operator'>&LT; </span><a href="walsender.c.html#LN3464"><span class='Ref_To_Local'>prev</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN201"><span class='Ref_to_Member'>lsn</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * Reported LSNs shouldn't normally go backwards, but it's 
                 * possible when there is a timeline change.  Treat as not 
                 * found. 
                 */ 
</span>                <span class='Control'>return</span> <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="walsender.c.html#LN3464"><span class='Ref_To_Local'>prev</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN201"><span class='Ref_to_Member'>lsn</span></a> <span class='Operator'>&LT; </span><a href="walsender.c.html#LN3465"><span class='Ref_To_Local'>next</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN201"><span class='Ref_to_Member'>lsn</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="walsender.c.html#LN3464"><span class='Ref_To_Local'>prev</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN202"><span class='Ref_to_Member'>time</span></a> <span class='Operator'>&GT; </span><a href="walsender.c.html#LN3465"><span class='Ref_To_Local'>next</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN202"><span class='Ref_to_Member'>time</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* If the clock somehow went backwards, treat as not found. */ 
</span>                <span class='Control'>return</span> <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* See how far we are between the previous and next samples. */ 
</span>            <a href="walsender.c.html#LN3463"><span class='Ref_To_Local'>fraction</span></a> <span class='Operator'>= 
</span>                <span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) (</span><a href="walsender.c.html#LN3429"><span class='Ref_to_Parameter'>lsn</span></a> <span class='Operator'>- </span><a href="walsender.c.html#LN3464"><span class='Ref_To_Local'>prev</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN201"><span class='Ref_to_Member'>lsn</span></a><span class='Parentheses'>) </span><span class='Operator'>/ </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) (</span><a href="walsender.c.html#LN3465"><span class='Ref_To_Local'>next</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN201"><span class='Ref_to_Member'>lsn</span></a> <span class='Operator'>- </span><a href="walsender.c.html#LN3464"><span class='Ref_To_Local'>prev</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN201"><span class='Ref_to_Member'>lsn</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Scale the local flush time proportionally. */ 
</span>            <a href="walsender.c.html#LN3431"><span class='Ref_To_Local'>time</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a><span class='Parentheses'>) 
</span>                <span class='Parentheses'>((</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="walsender.c.html#LN3464"><span class='Ref_To_Local'>prev</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN202"><span class='Ref_to_Member'>time</span></a> <span class='Operator'>+ </span><span class='Parentheses'>(</span><a href="walsender.c.html#LN3465"><span class='Ref_To_Local'>next</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN202"><span class='Ref_to_Member'>time</span></a> <span class='Operator'>- </span><a href="walsender.c.html#LN3464"><span class='Ref_To_Local'>prev</span></a><span class='Operator'>.</span><a href="walsender.c.html#LN202"><span class='Ref_to_Member'>time</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="walsender.c.html#LN3463"><span class='Ref_To_Local'>fraction</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if LagTracker.read_heads... &raquo; </span> 
        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Couldn't interpolate due to lack of data. */ 
</span>            <span class='Control'>return</span> <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if time==0 &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Return the elapsed time since local flush time in microseconds. */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="walsender.c.html#LN3431"><span class='Ref_To_Local'>time</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="walsender.c.html#LN3429"><span class='Ref_to_Parameter'>now</span></a> <span class='Operator'>- </span><a href="walsender.c.html#LN3431"><span class='Ref_To_Local'>time</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end LagTrackerRead &raquo; </span> 
</pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>