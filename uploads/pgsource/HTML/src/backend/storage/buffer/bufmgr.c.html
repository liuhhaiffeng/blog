<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\storage\buffer\bufmgr.c</title>
<LINK REL=StyleSheet HREF="../../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\storage\buffer\bufmgr.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:48 2017
</td></tr>
<tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * bufmgr.c 
 *    buffer manager interface routines 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * 
 * IDENTIFICATION 
 *    src/backend/storage/buffer/bufmgr.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
/* 
 * Principal entry points: 
 * 
 * ReadBuffer() -- find or create a buffer holding the requested page, 
 *      and pin it so that no one can destroy it while this process 
 *      is using it. 
 * 
 * ReleaseBuffer() -- unpin a buffer 
 * 
 * MarkBufferDirty() -- mark a pinned buffer's contents as "dirty". 
 *      The disk write is delayed until buffer replacement or checkpoint. 
 * 
 * See also these files: 
 *      freelist.c -- chooses victim for buffer replacement 
 *      buf_table.c -- manages the buffer lookup table 
 */ 
</span><span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>&LT;sys/file.h&GT;</span> 
<span class='Keyword'>#include </span><span class='String'>&LT;unistd.h&GT;</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/xlog.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/catalog.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/storage.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"executor/instrument.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"lib/binaryheap.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"miscadmin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"pg_trace.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"pgstat.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"postmaster/bgwriter.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/buf_internals.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/bufmgr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/ipc.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/proc.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/smgr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/standby.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/rel.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/resowner_private.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/timestamp.h"</span> 
 
 
<span class='Comment_Multi_Line'>/* Note: these two macros only work on shared buffers, not local ones! */ 
</span><a name="LN56"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>BufHdrGetBlock</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>bufHdr</span><span class='Parentheses'>)</span>  <span class='Parentheses'>((</span><a href="../../../include/storage/bufmgr.h.html#LN24"><span class='Ref_to_Typedef'>Block</span></a><span class='Parentheses'>)</span> <span class='Parentheses'>(</span><a href="buf_init.c.html#LN21"><span class='Ref_to_Global_Var'>BufferBlocks</span></a> <span class='Operator'>+ </span><span class='Parentheses'>((</span><a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a><span class='Parentheses'>) (</span><a href="bufmgr.c.html#LN56"><span class='Ref_to_Parameter'>bufHdr</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>buf_id<span class='Parentheses'>)</span> <span class='Operator'>* </span>BLCKSZ<span class='Parentheses'>))</span> 
<a name="LN57"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>BufferGetLSN</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>bufHdr</span><span class='Parentheses'>)</span>    <span class='Parentheses'>(</span><a href="../../../include/storage/bufpage.h.html#LN362"><span class='Ref_to_Macro'>PageGetLSN</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN56"><span class='Ref_to_Macro'>BufHdrGetBlock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN57"><span class='Ref_to_Parameter'>bufHdr</span></a><span class='Parentheses'>)))</span> 
 
<span class='Comment_Multi_Line'>/* Note: this macro only works on local buffers, not shared ones! */ 
</span><a name="LN60"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>LocalBufHdrGetBlock</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>bufHdr</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <a href="localbuf.c.html#LN43"><span class='Ref_to_Global_Var'>LocalBufferBlockPointers</span></a><span class='Delimiter'>[</span><span class='Operator'>-</span><span class='Parentheses'>((</span><a href="bufmgr.c.html#LN60"><span class='Ref_to_Parameter'>bufHdr</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>buf_id <span class='Operator'>+ </span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>] 
</span> 
<span class='Comment_Multi_Line'>/* Bits in SyncOneBuffer's return value */ 
</span><a name="LN64"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>BUF_WRITTEN</span>             <span class='Number'>0x01</span> 
<a name="LN65"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>BUF_REUSABLE</span>            <span class='Number'>0x02</span> 
 
<a name="LN67"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>DROP_RELS_BSEARCH_THRESHOLD</span>     <span class='Number'>20</span> 
 
<a name="LN69"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>PrivateRefCountEntry</span> 
<span class='Delimiter'>{ 
</span><a name="LN71"></a>    <a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a>      <span class='Declare_Member'>buffer</span><span class='Delimiter'>; 
</span><a name="LN72"></a>    <a href="../../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Member'>refcount</span><span class='Delimiter'>; 
</span><a name="LN73"></a>} <span class='Declare_Typedef'>PrivateRefCountEntry</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 64 bytes, about the size of a cache line on common systems */ 
</span><a name="LN76"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>REFCOUNT_ARRAY_ENTRIES</span> <span class='Number'>8</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Status of buffers to checkpoint for a particular tablespace, used 
 * internally in BufferSync. 
 */ 
</span><a name="LN82"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CkptTsStatus</span> 
<span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* oid of the tablespace */ 
</span><a name="LN85"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>tsId</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Checkpoint progress for this tablespace. To make progress comparable 
     * between tablespaces the progress is, for each tablespace, measured as a 
     * number between 0 and the total number of to-be-checkpointed pages. Each 
     * page checkpointed in this tablespace increments this space's progress 
     * by progress_slice. 
     */ 
</span><a name="LN94"></a>    <a href="../../../include/c.h.html#LN380"><span class='Ref_to_Typedef'>float8</span></a>      <span class='Declare_Member'>progress</span><span class='Delimiter'>; 
</span><a name="LN95"></a>    <a href="../../../include/c.h.html#LN380"><span class='Ref_to_Typedef'>float8</span></a>      <span class='Declare_Member'>progress_slice</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* number of to-be checkpointed pages in this tablespace */ 
</span><a name="LN98"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>num_to_scan</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* already processed pages in this tablespace */ 
</span><a name="LN100"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>num_scanned</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* current offset in CkptBufferIds for this tablespace */ 
</span><a name="LN103"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>index</span><span class='Delimiter'>; 
</span><a name="LN104"></a>}<span class='Auto_Annotations'> &laquo; end CkptTsStatus &raquo; </span> <span class='Declare_Typedef'>CkptTsStatus</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* GUC variables */ 
</span><a name="LN107"></a><span class='Keyword'>bool</span>        <span class='Declare_Var'>zero_damaged_pages</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN108"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>bgwriter_lru_maxpages</span> <span class='Operator'>= </span><span class='Number'>100</span><span class='Delimiter'>; 
</span><a name="LN109"></a><span class='Keyword'>double</span>      <span class='Declare_Var'>bgwriter_lru_multiplier</span> <span class='Operator'>= </span><span class='Number'>2</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN110"></a><span class='Keyword'>bool</span>        <span class='Declare_Var'>track_io_timing</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN111"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>effective_io_concurrency</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * GUC variables about triggering kernel writeback for buffers written; OS 
 * dependent defaults are set via the GUC mechanism. 
 */ 
</span><a name="LN117"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>checkpoint_flush_after</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN118"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>bgwriter_flush_after</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN119"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>backend_flush_after</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * How many buffers PrefetchBuffer callers should try to stay ahead of their 
 * ReadBuffer calls by.  This is maintained by the assign hook for 
 * effective_io_concurrency.  Zero means "never prefetch".  This value is 
 * only used for buffers not belonging to tablespaces that have their 
 * effective_io_concurrency parameter set. 
 */ 
</span><a name="LN128"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>target_prefetch_pages</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* local state for StartBufferIO and related functions */ 
</span><a name="LN131"></a><span class='Keyword'>static </span><a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Var'>InProgressBuf</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN132"></a><span class='Keyword'>static bool </span><span class='Declare_Var'>IsForInput</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* local state for LockBufferForCleanup */ 
</span><a name="LN135"></a><span class='Keyword'>static </span><a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Var'>PinCountWaitBuf</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Backend-Private refcount management: 
 * 
 * Each buffer also has a private refcount that keeps track of the number of 
 * times the buffer is pinned in the current process.  This is so that the 
 * shared refcount needs to be modified only once if a buffer is pinned more 
 * than once by an individual backend.  It's also used to check that no buffers 
 * are still pinned at the end of transactions and when exiting. 
 * 
 * 
 * To avoid - as we used to - requiring an array with NBuffers entries to keep 
 * track of local buffers, we use a small sequentially searched array 
 * (PrivateRefCountArray) and an overflow hash table (PrivateRefCountHash) to 
 * keep track of backend local pins. 
 * 
 * Until no more than REFCOUNT_ARRAY_ENTRIES buffers are pinned at once, all 
 * refcounts are kept track of in the array; after that, new array entries 
 * displace old ones into the hash table. That way a frequently used entry 
 * can't get "stuck" in the hashtable while infrequent ones clog the array. 
 * 
 * Note that in most scenarios the number of pinned buffers will not exceed 
 * REFCOUNT_ARRAY_ENTRIES. 
 * 
 * 
 * To enter a buffer into the refcount tracking mechanism first reserve a free 
 * entry using ReservePrivateRefCountEntry() and then later, if necessary, 
 * fill it with NewPrivateRefCountEntry(). That split lets us avoid doing 
 * memory allocations in NewPrivateRefCountEntry() which can be important 
 * because in some scenarios it's called with a spinlock held... 
 */ 
</span><a name="LN167"></a><span class='Keyword'>static </span><span class='Control'>struct</span> <a href="bufmgr.c.html#LN69"><span class='Ref_to_Struct'>PrivateRefCountEntry</span></a> <span class='Declare_Var'>PrivateRefCountArray</span><span class='Delimiter'>[</span><a href="bufmgr.c.html#LN76"><span class='Ref_to_Const'>REFCOUNT_ARRAY_ENTRIES</span></a><span class='Delimiter'>]; 
</span><a name="LN168"></a><span class='Keyword'>static </span><a href="../../utils/hash/dynahash.c.html#LN192"><span class='Ref_to_Struct'>HTAB</span></a> <span class='Operator'>*</span><span class='Declare_Var'>PrivateRefCountHash</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN169"></a><span class='Keyword'>static </span><a href="../../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a> <span class='Declare_Var'>PrivateRefCountOverflowed</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN170"></a><span class='Keyword'>static </span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Var'>PrivateRefCountClock</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN171"></a><span class='Keyword'>static </span><a href="bufmgr.c.html#LN69"><span class='Ref_to_Struct'>PrivateRefCountEntry</span></a> <span class='Operator'>*</span><span class='Declare_Var'>ReservedRefCountEntry</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
<a name="LN173"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>ReservePrivateRefCountEntry</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN174"></a><span class='Keyword'>static </span><a href="bufmgr.c.html#LN69"><span class='Ref_to_Struct'>PrivateRefCountEntry</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>NewPrivateRefCountEntry</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> <span class='Declare_Parameter'>buffer</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN175"></a><span class='Keyword'>static </span><a href="bufmgr.c.html#LN69"><span class='Ref_to_Struct'>PrivateRefCountEntry</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>GetPrivateRefCountEntry</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> <span class='Declare_Parameter'>buffer</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>do_move</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN176"></a><span class='Keyword'>static inline </span><a href="../../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a> <span class='Declare_Prototype'>GetPrivateRefCount</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> <span class='Declare_Parameter'>buffer</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN177"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>ForgetPrivateRefCountEntry</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN69"><span class='Ref_to_Struct'>PrivateRefCountEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>ref</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Ensure that the PrivateRefCountArray has sufficient space to store one more 
 * entry. This has to be called before using NewPrivateRefCountEntry() to fill 
 * a new entry - but it's perfectly fine to not use a reserved entry. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN185"></a><span class='Declare_Function'>ReservePrivateRefCountEntry</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* Already reserved (or freed), nothing to do */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN171"><span class='Ref_to_Global_Var'>ReservedRefCountEntry</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * First search for a free entry the array, that'll be sufficient in the 
     * majority of cases. 
     */ 
</span>    <span class='Delimiter'>{ 
</span><a name="LN196"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN196"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="bufmgr.c.html#LN196"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="bufmgr.c.html#LN76"><span class='Ref_to_Const'>REFCOUNT_ARRAY_ENTRIES</span></a><span class='Delimiter'>; </span><a href="bufmgr.c.html#LN196"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN200"></a>            <a href="bufmgr.c.html#LN69"><span class='Ref_to_Struct'>PrivateRefCountEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>res</span><span class='Delimiter'>; 
</span> 
            <a href="bufmgr.c.html#LN200"><span class='Ref_To_Local'>res</span></a> <span class='Operator'>= &</span><a href="bufmgr.c.html#LN167"><span class='Ref_to_Global_Var'>PrivateRefCountArray</span></a><span class='Delimiter'>[</span><a href="bufmgr.c.html#LN196"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN200"><span class='Ref_To_Local'>res</span></a><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN71"><span class='Ref_to_Member'>buffer</span></a> <span class='Operator'>== </span><a href="../../../include/storage/buf.h.html#LN24"><span class='Ref_to_Const'>InvalidBuffer</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="bufmgr.c.html#LN171"><span class='Ref_to_Global_Var'>ReservedRefCountEntry</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN200"><span class='Ref_To_Local'>res</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>return</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * No luck. All array entries are full. Move one array entry into the hash 
     * table. 
     */ 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Move entry from the current clock position in the array into the 
         * hashtable. Use that slot. 
         */ 
</span><a name="LN221"></a>        <a href="bufmgr.c.html#LN69"><span class='Ref_to_Struct'>PrivateRefCountEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>hashent</span><span class='Delimiter'>; 
</span><a name="LN222"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* select victim slot */ 
</span>        <a href="bufmgr.c.html#LN171"><span class='Ref_to_Global_Var'>ReservedRefCountEntry</span></a> <span class='Operator'>= 
</span>            <span class='Operator'>&</span><a href="bufmgr.c.html#LN167"><span class='Ref_to_Global_Var'>PrivateRefCountArray</span></a><span class='Delimiter'>[</span><a href="bufmgr.c.html#LN170"><span class='Ref_to_Global_Var'>PrivateRefCountClock</span></a><span class='Operator'>++ % </span><a href="bufmgr.c.html#LN76"><span class='Ref_to_Const'>REFCOUNT_ARRAY_ENTRIES</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Comment_Multi_Line'>/* Better be used, otherwise we shouldn't get here. */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN171"><span class='Ref_to_Global_Var'>ReservedRefCountEntry</span></a><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN71"><span class='Ref_to_Member'>buffer</span></a> <span class='Operator'>!= </span><a href="../../../include/storage/buf.h.html#LN24"><span class='Ref_to_Const'>InvalidBuffer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* enter victim array entry into hashtable */ 
</span>        <a href="bufmgr.c.html#LN221"><span class='Ref_To_Local'>hashent</span></a> <span class='Operator'>= </span><a href="../../../include/utils/hsearch.h.html#LN125"><span class='Ref_to_Proto'>hash_search</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN168"><span class='Ref_to_Global_Var'>PrivateRefCountHash</span></a><span class='Delimiter'>, 
</span>                              <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN171"><span class='Ref_to_Global_Var'>ReservedRefCountEntry</span></a><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN71"><span class='Ref_to_Member'>buffer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                              <a href="../../../include/utils/hsearch.h.html#LN105"><span class='Ref_to_EnumConst'>HASH_ENTER</span></a><span class='Delimiter'>, 
</span>                              <span class='Operator'>&</span><a href="bufmgr.c.html#LN222"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="bufmgr.c.html#LN222"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="bufmgr.c.html#LN221"><span class='Ref_To_Local'>hashent</span></a><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN72"><span class='Ref_to_Member'>refcount</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN171"><span class='Ref_to_Global_Var'>ReservedRefCountEntry</span></a><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN72"><span class='Ref_to_Member'>refcount</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* clear the now free array slot */ 
</span>        <a href="bufmgr.c.html#LN171"><span class='Ref_to_Global_Var'>ReservedRefCountEntry</span></a><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN71"><span class='Ref_to_Member'>buffer</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf.h.html#LN24"><span class='Ref_to_Const'>InvalidBuffer</span></a><span class='Delimiter'>; 
</span>        <a href="bufmgr.c.html#LN171"><span class='Ref_to_Global_Var'>ReservedRefCountEntry</span></a><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN72"><span class='Ref_to_Member'>refcount</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
        <a href="bufmgr.c.html#LN169"><span class='Ref_to_Global_Var'>PrivateRefCountOverflowed</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end ReservePrivateRefCountEntry &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Fill a previously reserved refcount entry. 
 */ 
</span><span class='Keyword'>static </span><a href="bufmgr.c.html#LN69"><span class='Ref_to_Struct'>PrivateRefCountEntry</span></a> <span class='Operator'>* 
</span><a name="LN251"></a><span class='Declare_Function'>NewPrivateRefCountEntry</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> <span class='Declare_Parameter'>buffer</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN253"></a>    <a href="bufmgr.c.html#LN69"><span class='Ref_to_Struct'>PrivateRefCountEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>res</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* only allowed to be called when a reservation has been made */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN171"><span class='Ref_to_Global_Var'>ReservedRefCountEntry</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* use up the reserved entry */ 
</span>    <a href="bufmgr.c.html#LN253"><span class='Ref_To_Local'>res</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN171"><span class='Ref_to_Global_Var'>ReservedRefCountEntry</span></a><span class='Delimiter'>; 
</span>    <a href="bufmgr.c.html#LN171"><span class='Ref_to_Global_Var'>ReservedRefCountEntry</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* and fill it */ 
</span>    <a href="bufmgr.c.html#LN253"><span class='Ref_To_Local'>res</span></a><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN71"><span class='Ref_to_Member'>buffer</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN251"><span class='Ref_to_Parameter'>buffer</span></a><span class='Delimiter'>; 
</span>    <a href="bufmgr.c.html#LN253"><span class='Ref_To_Local'>res</span></a><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN72"><span class='Ref_to_Member'>refcount</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="bufmgr.c.html#LN253"><span class='Ref_To_Local'>res</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Return the PrivateRefCount entry for the passed buffer. 
 * 
 * Returns NULL if a buffer doesn't have a refcount entry. Otherwise, if 
 * do_move is true, and the entry resides in the hashtable the entry is 
 * optimized for frequent access by moving it to the array. 
 */ 
</span><span class='Keyword'>static </span><a href="bufmgr.c.html#LN69"><span class='Ref_to_Struct'>PrivateRefCountEntry</span></a> <span class='Operator'>* 
</span><a name="LN277"></a><span class='Declare_Function'>GetPrivateRefCountEntry</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> <span class='Declare_Parameter'>buffer</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>do_move</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN279"></a>    <a href="bufmgr.c.html#LN69"><span class='Ref_to_Struct'>PrivateRefCountEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>res</span><span class='Delimiter'>; 
</span><a name="LN280"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/bufmgr.h.html#LN113"><span class='Ref_to_Macro'>BufferIsValid</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN277"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/storage/buf.h.html#LN36"><span class='Ref_to_Macro'>BufferIsLocal</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN277"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * First search for references in the array, that'll be sufficient in the 
     * majority of cases. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN280"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="bufmgr.c.html#LN280"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="bufmgr.c.html#LN76"><span class='Ref_to_Const'>REFCOUNT_ARRAY_ENTRIES</span></a><span class='Delimiter'>; </span><a href="bufmgr.c.html#LN280"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="bufmgr.c.html#LN279"><span class='Ref_To_Local'>res</span></a> <span class='Operator'>= &</span><a href="bufmgr.c.html#LN167"><span class='Ref_to_Global_Var'>PrivateRefCountArray</span></a><span class='Delimiter'>[</span><a href="bufmgr.c.html#LN280"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN279"><span class='Ref_To_Local'>res</span></a><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN71"><span class='Ref_to_Member'>buffer</span></a> <span class='Operator'>== </span><a href="bufmgr.c.html#LN277"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <a href="bufmgr.c.html#LN279"><span class='Ref_To_Local'>res</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * By here we know that the buffer, if already pinned, isn't residing in 
     * the array. 
     * 
     * Only look up the buffer in the hashtable if we've previously overflowed 
     * into it. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN169"><span class='Ref_to_Global_Var'>PrivateRefCountOverflowed</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <a href="bufmgr.c.html#LN279"><span class='Ref_To_Local'>res</span></a> <span class='Operator'>= </span><a href="../../../include/utils/hsearch.h.html#LN125"><span class='Ref_to_Proto'>hash_search</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN168"><span class='Ref_to_Global_Var'>PrivateRefCountHash</span></a><span class='Delimiter'>, 
</span>                      <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="bufmgr.c.html#LN277"><span class='Ref_to_Parameter'>buffer</span></a><span class='Delimiter'>, 
</span>                      <a href="../../../include/utils/hsearch.h.html#LN104"><span class='Ref_to_EnumConst'>HASH_FIND</span></a><span class='Delimiter'>, 
</span>                      <span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN279"><span class='Ref_To_Local'>res</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="bufmgr.c.html#LN277"><span class='Ref_to_Parameter'>do_move</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* caller doesn't want us to move the hash entry into the array */ 
</span>        <span class='Control'>return</span> <a href="bufmgr.c.html#LN279"><span class='Ref_To_Local'>res</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* move buffer from hashtable into the free array slot */ 
</span><a name="LN322"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span><span class='Delimiter'>; 
</span><a name="LN323"></a>        <a href="bufmgr.c.html#LN69"><span class='Ref_to_Struct'>PrivateRefCountEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>free</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Ensure there's a free array slot */ 
</span>        <a href="bufmgr.c.html#LN173"><span class='Ref_to_Proto'>ReservePrivateRefCountEntry</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Use up the reserved slot */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN171"><span class='Ref_to_Global_Var'>ReservedRefCountEntry</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="bufmgr.c.html#LN323"><span class='Ref_To_Local'>free</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN171"><span class='Ref_to_Global_Var'>ReservedRefCountEntry</span></a><span class='Delimiter'>; 
</span>        <a href="bufmgr.c.html#LN171"><span class='Ref_to_Global_Var'>ReservedRefCountEntry</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN323"><span class='Ref_To_Local'>free</span></a><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN71"><span class='Ref_to_Member'>buffer</span></a> <span class='Operator'>== </span><a href="../../../include/storage/buf.h.html#LN24"><span class='Ref_to_Const'>InvalidBuffer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* and fill it */ 
</span>        <a href="bufmgr.c.html#LN323"><span class='Ref_To_Local'>free</span></a><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN71"><span class='Ref_to_Member'>buffer</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN277"><span class='Ref_to_Parameter'>buffer</span></a><span class='Delimiter'>; 
</span>        <a href="bufmgr.c.html#LN323"><span class='Ref_To_Local'>free</span></a><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN72"><span class='Ref_to_Member'>refcount</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN279"><span class='Ref_To_Local'>res</span></a><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN72"><span class='Ref_to_Member'>refcount</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* delete from hashtable */ 
</span>        <a href="../../../include/utils/hsearch.h.html#LN125"><span class='Ref_to_Proto'>hash_search</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN168"><span class='Ref_to_Global_Var'>PrivateRefCountHash</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="bufmgr.c.html#LN277"><span class='Ref_to_Parameter'>buffer</span></a><span class='Delimiter'>, 
</span>                    <a href="../../../include/utils/hsearch.h.html#LN106"><span class='Ref_to_EnumConst'>HASH_REMOVE</span></a><span class='Delimiter'>, 
</span>                    <span class='Operator'>&</span><a href="bufmgr.c.html#LN322"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN322"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN169"><span class='Ref_to_Global_Var'>PrivateRefCountOverflowed</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="bufmgr.c.html#LN169"><span class='Ref_to_Global_Var'>PrivateRefCountOverflowed</span></a><span class='Operator'>--</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>return</span> <a href="bufmgr.c.html#LN323"><span class='Ref_To_Local'>free</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end GetPrivateRefCountEntry &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Returns how many times the passed buffer is pinned by this backend. 
 * 
 * Only works for shared memory buffers! 
 */ 
</span><span class='Keyword'>static inline </span><a href="../../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a> 
<a name="LN357"></a><span class='Declare_Function'>GetPrivateRefCount</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> <span class='Declare_Parameter'>buffer</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN359"></a>    <a href="bufmgr.c.html#LN69"><span class='Ref_to_Struct'>PrivateRefCountEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>ref</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/bufmgr.h.html#LN113"><span class='Ref_to_Macro'>BufferIsValid</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN357"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/storage/buf.h.html#LN36"><span class='Ref_to_Macro'>BufferIsLocal</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN357"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Not moving the entry - that's ok for the current users, but we might 
     * want to change this one day. 
     */ 
</span>    <span class='Keyword'>ref </span><span class='Operator'>= </span><a href="bufmgr.c.html#LN175"><span class='Ref_to_Proto'>GetPrivateRefCountEntry</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN357"><span class='Ref_to_Parameter'>buffer</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Keyword'>ref </span><span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Keyword'>ref</span><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN72"><span class='Ref_to_Member'>refcount</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Release resources used to track the reference count of a buffer which we no 
 * longer have pinned and don't want to pin again immediately. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN380"></a><span class='Declare_Function'>ForgetPrivateRefCountEntry</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN69"><span class='Ref_to_Struct'>PrivateRefCountEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>ref</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Keyword'>ref</span><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN72"><span class='Ref_to_Member'>refcount</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Keyword'>ref </span><span class='Operator'>&GT;= &</span><a href="bufmgr.c.html#LN167"><span class='Ref_to_Global_Var'>PrivateRefCountArray</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>&& 
</span>        <span class='Keyword'>ref </span><span class='Operator'>&LT; &</span><a href="bufmgr.c.html#LN167"><span class='Ref_to_Global_Var'>PrivateRefCountArray</span></a><span class='Delimiter'>[</span><a href="bufmgr.c.html#LN76"><span class='Ref_to_Const'>REFCOUNT_ARRAY_ENTRIES</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Keyword'>ref</span><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN71"><span class='Ref_to_Member'>buffer</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf.h.html#LN24"><span class='Ref_to_Const'>InvalidBuffer</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Mark the just used entry as reserved - in many scenarios that 
         * allows us to avoid ever having to search the array/hash for free 
         * entries. 
         */ 
</span>        <a href="bufmgr.c.html#LN171"><span class='Ref_to_Global_Var'>ReservedRefCountEntry</span></a> <span class='Operator'>= </span><span class='Keyword'>ref</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span><a name="LN398"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span><span class='Delimiter'>; 
</span><a name="LN399"></a>        <a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a>      <span class='Declare_Local'>buffer</span> <span class='Operator'>= </span><span class='Keyword'>ref</span><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN71"><span class='Ref_to_Member'>buffer</span></a><span class='Delimiter'>; 
</span> 
        <a href="../../../include/utils/hsearch.h.html#LN125"><span class='Ref_to_Proto'>hash_search</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN168"><span class='Ref_to_Global_Var'>PrivateRefCountHash</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="bufmgr.c.html#LN399"><span class='Ref_To_Local'>buffer</span></a><span class='Delimiter'>, 
</span>                    <a href="../../../include/utils/hsearch.h.html#LN106"><span class='Ref_to_EnumConst'>HASH_REMOVE</span></a><span class='Delimiter'>, 
</span>                    <span class='Operator'>&</span><a href="bufmgr.c.html#LN398"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN398"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN169"><span class='Ref_to_Global_Var'>PrivateRefCountOverflowed</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="bufmgr.c.html#LN169"><span class='Ref_to_Global_Var'>PrivateRefCountOverflowed</span></a><span class='Operator'>--</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end ForgetPrivateRefCountEntry &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * BufferIsPinned 
 *      True iff the buffer is pinned (also checks for valid buffer number). 
 * 
 *      NOTE: what we check here is that *this* backend holds a pin on 
 *      the buffer.  We do not care whether some other backend does. 
 */ 
</span><a name="LN418"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>BufferIsPinned</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>bufnum</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span><span class='Parentheses'>(</span> <span class='Operator'>\ 
</span>    <span class='Operator'>!</span><a href="../../../include/storage/bufmgr.h.html#LN113"><span class='Ref_to_Macro'>BufferIsValid</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN418"><span class='Ref_to_Parameter'>bufnum</span></a><span class='Parentheses'>)</span> <span class='Operator'>? \ 
</span>        <span class='Boolean'>false </span><span class='Operator'>\ 
</span>    <span class='Operator'>: \ 
</span>        <a href="../../../include/storage/buf.h.html#LN36"><span class='Ref_to_Macro'>BufferIsLocal</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN418"><span class='Ref_to_Parameter'>bufnum</span></a><span class='Parentheses'>)</span> <span class='Operator'>? \ 
</span>            <span class='Parentheses'>(</span><a href="localbuf.c.html#LN44"><span class='Ref_to_Global_Var'>LocalRefCount</span></a><span class='Delimiter'>[</span><span class='Operator'>-</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN418"><span class='Ref_to_Parameter'>bufnum</span></a><span class='Parentheses'>) </span><span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span> <span class='Operator'>\ 
</span>        <span class='Operator'>: \ 
</span>    <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN176"><span class='Ref_to_Proto'>GetPrivateRefCount</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN418"><span class='Ref_to_Parameter'>bufnum</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span> <span class='Operator'>\ 
</span><span class='Parentheses'>)</span> 
 
 
<a name="LN430"></a><span class='Keyword'>static </span><a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> <span class='Declare_Prototype'>ReadBuffer_common</span><span class='Parentheses'>(</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> <span class='Declare_Parameter'>reln</span><span class='Delimiter'>, </span><span class='Keyword'>char </span><span class='Declare_Parameter'>relpersistence</span><span class='Delimiter'>, 
</span><a name="LN431"></a>                  <a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a> <span class='Declare_Parameter'>forkNum</span><span class='Delimiter'>, </span><a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Parameter'>blockNum</span><span class='Delimiter'>, 
</span><a name="LN432"></a>                  <a href="../../../include/storage/bufmgr.h.html#LN37"><span class='Ref_to_Typedef'>ReadBufferMode</span></a> <span class='Declare_Parameter'>mode</span><span class='Delimiter'>, </span><a href="../../../include/storage/buf.h.html#LN43"><span class='Ref_to_Typedef'>BufferAccessStrategy</span></a> <span class='Declare_Parameter'>strategy</span><span class='Delimiter'>, 
</span><a name="LN433"></a>                  <span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>hit</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN434"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>PinBuffer</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>buf</span><span class='Delimiter'>, </span><a href="../../../include/storage/buf.h.html#LN43"><span class='Ref_to_Typedef'>BufferAccessStrategy</span></a> <span class='Declare_Parameter'>strategy</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN435"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>PinBuffer_Locked</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>buf</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN436"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>UnpinBuffer</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>buf</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>fixOwner</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN437"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>BufferSync</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>flags</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN438"></a><span class='Keyword'>static </span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Prototype'>WaitBufHdrUnlocked</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>buf</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN439"></a><span class='Keyword'>static int</span>  <span class='Declare_Prototype'>SyncOneBuffer</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>buf_id</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>skip_recently_used</span><span class='Delimiter'>, </span><a href="../../../include/storage/buf_internals.h.html#LN261"><span class='Ref_to_Struct'>WritebackContext</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>flush_context</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN440"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>WaitIO</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>buf</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN441"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>StartBufferIO</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>buf</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>forInput</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN442"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>TerminateBufferIO</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>buf</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>clear_dirty</span><span class='Delimiter'>, 
</span><a name="LN443"></a>                  <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Parameter'>set_flag_bits</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN444"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>shared_buffer_write_error_callback</span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>arg</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN445"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>local_buffer_write_error_callback</span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>arg</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN446"></a><span class='Keyword'>static </span><a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>BufferAlloc</span><span class='Parentheses'>(</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> <span class='Declare_Parameter'>smgr</span><span class='Delimiter'>, 
</span><a name="LN447"></a>            <span class='Keyword'>char </span><span class='Declare_Parameter'>relpersistence</span><span class='Delimiter'>, 
</span><a name="LN448"></a>            <a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a> <span class='Declare_Parameter'>forkNum</span><span class='Delimiter'>, 
</span><a name="LN449"></a>            <a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Parameter'>blockNum</span><span class='Delimiter'>, 
</span><a name="LN450"></a>            <a href="../../../include/storage/buf.h.html#LN43"><span class='Ref_to_Typedef'>BufferAccessStrategy</span></a> <span class='Declare_Parameter'>strategy</span><span class='Delimiter'>, 
</span><a name="LN451"></a>            <span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>foundPtr</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN452"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>FlushBuffer</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>buf</span><span class='Delimiter'>, </span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> <span class='Declare_Parameter'>reln</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN453"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>AtProcExit_Buffers</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>code</span><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>arg</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN454"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>CheckForBufferLeaks</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN455"></a><span class='Keyword'>static int</span>  <span class='Declare_Prototype'>rnode_comparator</span><span class='Parentheses'>(</span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>p1</span><span class='Delimiter'>, </span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>p2</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN456"></a><span class='Keyword'>static int</span>  <span class='Declare_Prototype'>buffertag_comparator</span><span class='Parentheses'>(</span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>p1</span><span class='Delimiter'>, </span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>p2</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN457"></a><span class='Keyword'>static int</span>  <span class='Declare_Prototype'>ckpt_buforder_comparator</span><span class='Parentheses'>(</span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>pa</span><span class='Delimiter'>, </span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>pb</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN458"></a><span class='Keyword'>static int</span>  <span class='Declare_Prototype'>ts_ckpt_progress_comparator</span><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>a</span><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>b</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>arg</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * ComputeIoConcurrency -- get the number of pages to prefetch for a given 
 *      number of spindles. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN466"></a><span class='Declare_Function'>ComputeIoConcurrency</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>io_concurrency</span><span class='Delimiter'>, </span><span class='Keyword'>double </span><span class='Operator'>*</span><span class='Declare_Parameter'>target</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN468"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>new_prefetch_pages</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN469"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Make sure the io_concurrency value is within valid range; it may have 
     * been forced with a manual pg_tablespace update. 
     */ 
</span>    <a href="bufmgr.c.html#LN466"><span class='Ref_to_Parameter'>io_concurrency</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN11"><span class='Ref_to_Macro'>Min</span></a><span class='Parentheses'>(</span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN10"><span class='Ref_to_Macro'>Max</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN466"><span class='Ref_to_Parameter'>io_concurrency</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="../../../include/storage/bufmgr.h.html#LN78"><span class='Ref_to_Const'>MAX_IO_CONCURRENCY</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/*---------- 
     * The user-visible GUC parameter is the number of drives (spindles), 
     * which we need to translate to a number-of-pages-to-prefetch target. 
     * The target value is stashed in *extra and then assigned to the actual 
     * variable by assign_effective_io_concurrency. 
     * 
     * The expected number of prefetch pages needed to keep N drives busy is: 
     * 
     * drives |   I/O requests 
     * -------+---------------- 
     *      1 |   1 
     *      2 |   2/1 + 2/2 = 3 
     *      3 |   3/1 + 3/2 + 3/3 = 5 1/2 
     *      4 |   4/1 + 4/2 + 4/3 + 4/4 = 8 1/3 
     *      n |   n * H(n) 
     * 
     * This is called the "coupon collector problem" and H(n) is called the 
     * harmonic series.  This could be approximated by n * ln(n), but for 
     * reasonable numbers of drives we might as well just compute the series. 
     * 
     * Alternatively we could set the target to the number of pages necessary 
     * so that the expected number of active spindles is some arbitrary 
     * percentage of the total.  This sounds the same but is actually slightly 
     * different.  The result ends up being ln(1-P)/ln((n-1)/n) where P is 
     * that desired fraction. 
     * 
     * Experimental results show that both of these formulas aren't aggressive 
     * enough, but we don't really have any better proposals. 
     * 
     * Note that if io_concurrency = 0 (disabled), we must set target = 0. 
     *---------- 
     */ 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN469"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="bufmgr.c.html#LN469"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT;= </span><a href="bufmgr.c.html#LN466"><span class='Ref_to_Parameter'>io_concurrency</span></a><span class='Delimiter'>; </span><a href="bufmgr.c.html#LN469"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <a href="bufmgr.c.html#LN468"><span class='Ref_To_Local'>new_prefetch_pages</span></a> <span class='Operator'>+= </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="bufmgr.c.html#LN466"><span class='Ref_to_Parameter'>io_concurrency</span></a> <span class='Operator'>/ </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="bufmgr.c.html#LN469"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>; 
</span> 
    <span class='Operator'>*</span><a href="bufmgr.c.html#LN466"><span class='Ref_to_Parameter'>target</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN468"><span class='Ref_To_Local'>new_prefetch_pages</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* This range check shouldn't fail, but let's be paranoid */ 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN468"><span class='Ref_To_Local'>new_prefetch_pages</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="bufmgr.c.html#LN468"><span class='Ref_To_Local'>new_prefetch_pages</span></a> <span class='Operator'>&LT; </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span>INT_MAX<span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ComputeIoConcurrency &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * PrefetchBuffer -- initiate asynchronous read of a block of a relation 
 * 
 * This is named by analogy to ReadBuffer but doesn't actually allocate a 
 * buffer.  Instead it tries to ensure that a future ReadBuffer for the given 
 * block will not be delayed by the I/O.  Prefetching is optional. 
 * No-op if prefetching isn't compiled in. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN528"></a><span class='Declare_Function'>PrefetchBuffer</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>reln</span><span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a> <span class='Declare_Parameter'>forkNum</span><span class='Delimiter'>, </span><a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Parameter'>blockNum</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><span class='Directive'>#ifdef</span> <a href="../../../include/pg_config_manual.h.html#LN145"><span class='Ref_to_Const'>USE_PREFETCH</span></a> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/utils/rel.h.html#LN389"><span class='Ref_to_Macro'>RelationIsValid</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN528"><span class='Ref_to_Parameter'>reln</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/block.h.html#LN69"><span class='Ref_to_Macro'>BlockNumberIsValid</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN528"><span class='Ref_to_Parameter'>blockNum</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Open it at the smgr level if not already done */ 
</span>    <a href="../../../include/utils/rel.h.html#LN460"><span class='Ref_to_Macro'>RelationOpenSmgr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN528"><span class='Ref_to_Parameter'>reln</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/rel.h.html#LN512"><span class='Ref_to_Macro'>RelationUsesLocalBuffers</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN528"><span class='Ref_to_Parameter'>reln</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* see comments in ReadBufferExtended */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/rel.h.html#LN533"><span class='Ref_to_Macro'>RELATION_IS_OTHER_TEMP</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN528"><span class='Ref_to_Parameter'>reln</span></a><span class='Parentheses'>))</span> 
            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"cannot access temporary tables of other sessions"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* pass it off to localbuf.c */ 
</span>        <a href="localbuf.c.html#LN62"><span class='Ref_to_Func'>LocalPrefetchBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN528"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN86"><span class='Ref_to_Member'>rd_smgr</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN528"><span class='Ref_to_Parameter'>forkNum</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN528"><span class='Ref_to_Parameter'>blockNum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span><a name="LN550"></a>        <a href="../../../include/storage/buf_internals.h.html#LN90"><span class='Ref_to_Typedef'>BufferTag</span></a>   <span class='Declare_Local'>newTag</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* identity of requested block */ 
</span><a name="LN551"></a>        <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>newHash</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* hash value for newTag */ 
</span><a name="LN552"></a>        <a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>newPartitionLock</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* buffer partition lock for it */ 
</span><a name="LN553"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>buf_id</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* create a tag so we can lookup the buffer */ 
</span>        <a href="../../../include/storage/buf_internals.h.html#LN106"><span class='Ref_to_Macro'>INIT_BUFFERTAG</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN550"><span class='Ref_To_Local'>newTag</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN528"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN86"><span class='Ref_to_Member'>rd_smgr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN42"><span class='Ref_to_Member'>smgr_rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN73"><span class='Ref_to_Member'>node</span></a><span class='Delimiter'>, 
</span>                       <a href="bufmgr.c.html#LN528"><span class='Ref_to_Parameter'>forkNum</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN528"><span class='Ref_to_Parameter'>blockNum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* determine its hash code and partition lock ID */ 
</span>        <a href="bufmgr.c.html#LN551"><span class='Ref_To_Local'>newHash</span></a> <span class='Operator'>= </span><a href="buf_table.c.html#LN78"><span class='Ref_to_Func'>BufTableHashCode</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN550"><span class='Ref_To_Local'>newTag</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="bufmgr.c.html#LN552"><span class='Ref_To_Local'>newPartitionLock</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN128"><span class='Ref_to_Macro'>BufMappingPartitionLock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN551"><span class='Ref_To_Local'>newHash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* see if the block is in the buffer pool already */ 
</span>        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN552"><span class='Ref_To_Local'>newPartitionLock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="bufmgr.c.html#LN553"><span class='Ref_To_Local'>buf_id</span></a> <span class='Operator'>= </span><a href="buf_table.c.html#LN90"><span class='Ref_to_Func'>BufTableLookup</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN550"><span class='Ref_To_Local'>newTag</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN551"><span class='Ref_To_Local'>newHash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN552"><span class='Ref_To_Local'>newPartitionLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* If not in buffers, initiate prefetch */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN553"><span class='Ref_To_Local'>buf_id</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <a href="../../../include/storage/smgr.h.html#LN96"><span class='Ref_to_Proto'>smgrprefetch</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN528"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN86"><span class='Ref_to_Member'>rd_smgr</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN528"><span class='Ref_to_Parameter'>forkNum</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN528"><span class='Ref_to_Parameter'>blockNum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If the block *is* in buffers, we do nothing.  This is not really 
         * ideal: the block might be just about to be evicted, which would be 
         * stupid since we know we are going to need it soon.  But the only 
         * easy answer is to bump the usage_count, which does not seem like a 
         * great solution: when the caller does ultimately touch the block, 
         * usage_count would get bumped again, resulting in too much 
         * favoritism for blocks that are involved in a prefetch sequence. A 
         * real fix would involve some additional per-buffer state, and it's 
         * not clear that there's enough of a problem to justify that. 
         */ 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
<span class='Directive'>#endif</span>   <span class='Comment_Single_Line'>/* USE_PREFETCH */ 
</span><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end PrefetchBuffer &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * ReadBuffer -- a shorthand for ReadBufferExtended, for reading from main 
 *      fork with RBM_NORMAL mode and default strategy. 
 */ 
</span><a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> 
<a name="LN593"></a><span class='Declare_Function'>ReadBuffer</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>reln</span><span class='Delimiter'>, </span><a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Parameter'>blockNum</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="../../../include/storage/bufmgr.h.html#LN168"><span class='Ref_to_Proto'>ReadBufferExtended</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN593"><span class='Ref_to_Parameter'>reln</span></a><span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN26"><span class='Ref_to_EnumConst'>MAIN_FORKNUM</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN593"><span class='Ref_to_Parameter'>blockNum</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/bufmgr.h.html#LN39"><span class='Ref_to_EnumConst'>RBM_NORMAL</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * ReadBufferExtended -- returns a buffer containing the requested 
 *      block of the requested relation.  If the blknum 
 *      requested is P_NEW, extend the relation file and 
 *      allocate a new block.  (Caller is responsible for 
 *      ensuring that only one backend tries to extend a 
 *      relation at the same time!) 
 * 
 * Returns: the buffer number for the buffer containing 
 *      the block read.  The returned buffer has been pinned. 
 *      Does not return on error --- elog's instead. 
 * 
 * Assume when this function is called, that reln has been opened already. 
 * 
 * In RBM_NORMAL mode, the page is read from disk, and the page header is 
 * validated.  An error is thrown if the page header is not valid.  (But 
 * note that an all-zero page is considered "valid"; see PageIsVerified().) 
 * 
 * RBM_ZERO_ON_ERROR is like the normal mode, but if the page header is not 
 * valid, the page is zeroed instead of throwing an error. This is intended 
 * for non-critical data, where the caller is prepared to repair errors. 
 * 
 * In RBM_ZERO_AND_LOCK mode, if the page isn't in buffer cache already, it's 
 * filled with zeros instead of reading it from disk.  Useful when the caller 
 * is going to fill the page from scratch, since this saves I/O and avoids 
 * unnecessary failure if the page-on-disk has corrupt page headers. 
 * The page is returned locked to ensure that the caller has a chance to 
 * initialize the page before it's made visible to others. 
 * Caution: do not use this mode to read a page that is beyond the relation's 
 * current physical EOF; that is likely to cause problems in md.c when 
 * the page is modified and written out. P_NEW is OK, though. 
 * 
 * RBM_ZERO_AND_CLEANUP_LOCK is the same as RBM_ZERO_AND_LOCK, but acquires 
 * a cleanup-strength lock on the page. 
 * 
 * RBM_NORMAL_NO_LOG mode is treated the same as RBM_NORMAL here. 
 * 
 * If strategy is not NULL, a nondefault buffer access strategy is used. 
 * See buffer/README for details. 
 */ 
</span><a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> 
<a name="LN639"></a><span class='Declare_Function'>ReadBufferExtended</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>reln</span><span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a> <span class='Declare_Parameter'>forkNum</span><span class='Delimiter'>, </span><a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Parameter'>blockNum</span><span class='Delimiter'>, 
</span><a name="LN640"></a>                   <a href="../../../include/storage/bufmgr.h.html#LN37"><span class='Ref_to_Typedef'>ReadBufferMode</span></a> <span class='Declare_Parameter'>mode</span><span class='Delimiter'>, </span><a href="../../../include/storage/buf.h.html#LN43"><span class='Ref_to_Typedef'>BufferAccessStrategy</span></a> <span class='Declare_Parameter'>strategy</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN642"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>hit</span><span class='Delimiter'>; 
</span><a name="LN643"></a>    <a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a>      <span class='Declare_Local'>buf</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Open it at the smgr level if not already done */ 
</span>    <a href="../../../include/utils/rel.h.html#LN460"><span class='Ref_to_Macro'>RelationOpenSmgr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN639"><span class='Ref_to_Parameter'>reln</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Reject attempts to read non-local temporary relations; we would be 
     * likely to get wrong data since we have no visibility into the owning 
     * session's local buffers. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/rel.h.html#LN533"><span class='Ref_to_Macro'>RELATION_IS_OTHER_TEMP</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN639"><span class='Ref_to_Parameter'>reln</span></a><span class='Parentheses'>))</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"cannot access temporary tables of other sessions"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Read the buffer, and update pgstat counters to reflect a cache hit or 
     * miss. 
     */ 
</span>    <a href="../../../include/pgstat.h.html#LN1272"><span class='Ref_to_Macro'>pgstat_count_buffer_read</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN639"><span class='Ref_to_Parameter'>reln</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="bufmgr.c.html#LN643"><span class='Ref_To_Local'>buf</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN430"><span class='Ref_to_Proto'>ReadBuffer_common</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN639"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN86"><span class='Ref_to_Member'>rd_smgr</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN639"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relpersistence<span class='Delimiter'>, 
</span>                            <a href="bufmgr.c.html#LN639"><span class='Ref_to_Parameter'>forkNum</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN639"><span class='Ref_to_Parameter'>blockNum</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN640"><span class='Ref_to_Parameter'>mode</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN640"><span class='Ref_to_Parameter'>strategy</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="bufmgr.c.html#LN642"><span class='Ref_To_Local'>hit</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN642"><span class='Ref_To_Local'>hit</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/pgstat.h.html#LN1277"><span class='Ref_to_Macro'>pgstat_count_buffer_hit</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN639"><span class='Ref_to_Parameter'>reln</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="bufmgr.c.html#LN643"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ReadBufferExtended &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * ReadBufferWithoutRelcache -- like ReadBufferExtended, but doesn't require 
 *      a relcache entry for the relation. 
 * 
 * NB: At present, this function may only be used on permanent relations, which 
 * is OK, because we only use it during XLOG replay.  If in the future we 
 * want to use it on temporary or unlogged relations, we could pass additional 
 * parameters. 
 */ 
</span><a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> 
<a name="LN681"></a><span class='Declare_Function'>ReadBufferWithoutRelcache</span><span class='Parentheses'>(</span><a href="../../../include/storage/relfilenode.h.html#LN56"><span class='Ref_to_Struct'>RelFileNode</span></a> <span class='Declare_Parameter'>rnode</span><span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a> <span class='Declare_Parameter'>forkNum</span><span class='Delimiter'>, 
</span><a name="LN682"></a>                          <a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Parameter'>blockNum</span><span class='Delimiter'>, </span><a href="../../../include/storage/bufmgr.h.html#LN37"><span class='Ref_to_Typedef'>ReadBufferMode</span></a> <span class='Declare_Parameter'>mode</span><span class='Delimiter'>, 
</span><a name="LN683"></a>                          <a href="../../../include/storage/buf.h.html#LN43"><span class='Ref_to_Typedef'>BufferAccessStrategy</span></a> <span class='Declare_Parameter'>strategy</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN685"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>hit</span><span class='Delimiter'>; 
</span> 
<a name="LN687"></a>    <a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> <span class='Declare_Local'>smgr</span> <span class='Operator'>= </span><a href="../../../include/storage/smgr.h.html#LN83"><span class='Ref_to_Proto'>smgropen</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN681"><span class='Ref_to_Parameter'>rnode</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/backendid.h.html#LN22"><span class='Ref_to_Const'>InvalidBackendId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../access/transam/xlog.c.html#LN191"><span class='Ref_to_Global_Var'>InRecovery</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="bufmgr.c.html#LN430"><span class='Ref_to_Proto'>ReadBuffer_common</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN687"><span class='Ref_To_Local'>smgr</span></a><span class='Delimiter'>, </span><a href="../../../include/catalog/pg_class.h.html#LN169"><span class='Ref_to_Const'>RELPERSISTENCE_PERMANENT</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN681"><span class='Ref_to_Parameter'>forkNum</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN682"><span class='Ref_to_Parameter'>blockNum</span></a><span class='Delimiter'>, 
</span>                             <a href="bufmgr.c.html#LN682"><span class='Ref_to_Parameter'>mode</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN683"><span class='Ref_to_Parameter'>strategy</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="bufmgr.c.html#LN685"><span class='Ref_To_Local'>hit</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * ReadBuffer_common -- common logic for all ReadBuffer variants 
 * 
 * *hit is set to true if the request was satisfied from shared buffer cache. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> 
<a name="LN702"></a><span class='Declare_Function'>ReadBuffer_common</span><span class='Parentheses'>(</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> <span class='Declare_Parameter'>smgr</span><span class='Delimiter'>, </span><span class='Keyword'>char </span><span class='Declare_Parameter'>relpersistence</span><span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a> <span class='Declare_Parameter'>forkNum</span><span class='Delimiter'>, 
</span><a name="LN703"></a>                  <a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Parameter'>blockNum</span><span class='Delimiter'>, </span><a href="../../../include/storage/bufmgr.h.html#LN37"><span class='Ref_to_Typedef'>ReadBufferMode</span></a> <span class='Declare_Parameter'>mode</span><span class='Delimiter'>, 
</span><a name="LN704"></a>                  <a href="../../../include/storage/buf.h.html#LN43"><span class='Ref_to_Typedef'>BufferAccessStrategy</span></a> <span class='Declare_Parameter'>strategy</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>hit</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN706"></a>    <a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>bufHdr</span><span class='Delimiter'>; 
</span><a name="LN707"></a>    <a href="../../../include/storage/bufmgr.h.html#LN24"><span class='Ref_to_Typedef'>Block</span></a>       <span class='Declare_Local'>bufBlock</span><span class='Delimiter'>; 
</span><a name="LN708"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span><span class='Delimiter'>; 
</span><a name="LN709"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isExtend</span><span class='Delimiter'>; 
</span><a name="LN710"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isLocalBuf</span> <span class='Operator'>= </span><a href="../../../include/storage/smgr.h.html#LN79"><span class='Ref_to_Macro'>SmgrIsTemp</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN702"><span class='Ref_to_Parameter'>smgr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Operator'>*</span><a href="bufmgr.c.html#LN704"><span class='Ref_to_Parameter'>hit</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Make sure we will have room to remember the buffer pin */ 
</span>    <a href="../../../include/utils/resowner_private.h.html#LN28"><span class='Ref_to_Proto'>ResourceOwnerEnlargeBuffers</span></a><span class='Parentheses'>(</span><a href="../../utils/resowner/resowner.c.html#LN137"><span class='Ref_to_Global_Var'>CurrentResourceOwner</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="bufmgr.c.html#LN709"><span class='Ref_To_Local'>isExtend</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN703"><span class='Ref_to_Parameter'>blockNum</span></a> <span class='Operator'>== </span><a href="../../../include/storage/bufmgr.h.html#LN81"><span class='Ref_to_Const'>P_NEW</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    TRACE_POSTGRESQL_BUFFER_READ_START<span class='Parentheses'>(</span><a href="bufmgr.c.html#LN702"><span class='Ref_to_Parameter'>forkNum</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN703"><span class='Ref_to_Parameter'>blockNum</span></a><span class='Delimiter'>, 
</span>                                       <a href="bufmgr.c.html#LN702"><span class='Ref_to_Parameter'>smgr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN42"><span class='Ref_to_Member'>smgr_rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN73"><span class='Ref_to_Member'>node</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN58"><span class='Ref_to_Member'>spcNode</span></a><span class='Delimiter'>, 
</span>                                       <a href="bufmgr.c.html#LN702"><span class='Ref_to_Parameter'>smgr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN42"><span class='Ref_to_Member'>smgr_rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN73"><span class='Ref_to_Member'>node</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN59"><span class='Ref_to_Member'>dbNode</span></a><span class='Delimiter'>, 
</span>                                       <a href="bufmgr.c.html#LN702"><span class='Ref_to_Parameter'>smgr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN42"><span class='Ref_to_Member'>smgr_rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN73"><span class='Ref_to_Member'>node</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN60"><span class='Ref_to_Member'>relNode</span></a><span class='Delimiter'>, 
</span>                                       <a href="bufmgr.c.html#LN702"><span class='Ref_to_Parameter'>smgr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN42"><span class='Ref_to_Member'>smgr_rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN74"><span class='Ref_to_Member'>backend</span></a><span class='Delimiter'>, 
</span>                                       <a href="bufmgr.c.html#LN709"><span class='Ref_To_Local'>isExtend</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Substitute proper block number if caller asked for P_NEW */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN709"><span class='Ref_To_Local'>isExtend</span></a><span class='Parentheses'>) 
</span>        <a href="bufmgr.c.html#LN703"><span class='Ref_to_Parameter'>blockNum</span></a> <span class='Operator'>= </span><a href="../../../include/storage/smgr.h.html#LN104"><span class='Ref_to_Proto'>smgrnblocks</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN702"><span class='Ref_to_Parameter'>smgr</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN702"><span class='Ref_to_Parameter'>forkNum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN710"><span class='Ref_To_Local'>isLocalBuf</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="bufmgr.c.html#LN706"><span class='Ref_To_Local'>bufHdr</span></a> <span class='Operator'>= </span><a href="localbuf.c.html#LN101"><span class='Ref_to_Func'>LocalBufferAlloc</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN702"><span class='Ref_to_Parameter'>smgr</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN702"><span class='Ref_to_Parameter'>forkNum</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN703"><span class='Ref_to_Parameter'>blockNum</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="bufmgr.c.html#LN708"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN708"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>            <a href="../../executor/instrument.c.html#LN19"><span class='Ref_to_Global_Var'>pgBufferUsage</span></a><span class='Operator'>.</span><a href="../../../include/executor/instrument.h.html#LN24"><span class='Ref_to_Member'>local_blks_hit</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="../../executor/instrument.c.html#LN19"><span class='Ref_to_Global_Var'>pgBufferUsage</span></a><span class='Operator'>.</span><a href="../../../include/executor/instrument.h.html#LN25"><span class='Ref_to_Member'>local_blks_read</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * lookup the buffer.  IO_IN_PROGRESS is set if the requested block is 
         * not currently in memory. 
         */ 
</span>        <a href="bufmgr.c.html#LN706"><span class='Ref_To_Local'>bufHdr</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN446"><span class='Ref_to_Proto'>BufferAlloc</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN702"><span class='Ref_to_Parameter'>smgr</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN702"><span class='Ref_to_Parameter'>relpersistence</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN702"><span class='Ref_to_Parameter'>forkNum</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN703"><span class='Ref_to_Parameter'>blockNum</span></a><span class='Delimiter'>, 
</span>                             <a href="bufmgr.c.html#LN704"><span class='Ref_to_Parameter'>strategy</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="bufmgr.c.html#LN708"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN708"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>            <a href="../../executor/instrument.c.html#LN19"><span class='Ref_to_Global_Var'>pgBufferUsage</span></a><span class='Operator'>.</span><a href="../../../include/executor/instrument.h.html#LN20"><span class='Ref_to_Member'>shared_blks_hit</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="../../executor/instrument.c.html#LN19"><span class='Ref_to_Global_Var'>pgBufferUsage</span></a><span class='Operator'>.</span><a href="../../../include/executor/instrument.h.html#LN21"><span class='Ref_to_Member'>shared_blks_read</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* At this point we do NOT hold any locks. */ 
</span> 
    <span class='Comment_Multi_Line'>/* if it was already in the buffer pool, we're done */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN708"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="bufmgr.c.html#LN709"><span class='Ref_To_Local'>isExtend</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Just need to update stats before we exit */ 
</span>            <span class='Operator'>*</span><a href="bufmgr.c.html#LN704"><span class='Ref_to_Parameter'>hit</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="../../utils/init/globals.c.html#LN134"><span class='Ref_to_Global_Var'>VacuumPageHit</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../utils/init/globals.c.html#LN139"><span class='Ref_to_Global_Var'>VacuumCostActive</span></a><span class='Parentheses'>) 
</span>                <a href="../../utils/init/globals.c.html#LN138"><span class='Ref_to_Global_Var'>VacuumCostBalance</span></a> <span class='Operator'>+= </span><a href="../../utils/init/globals.c.html#LN128"><span class='Ref_to_Global_Var'>VacuumCostPageHit</span></a><span class='Delimiter'>; 
</span> 
            TRACE_POSTGRESQL_BUFFER_READ_DONE<span class='Parentheses'>(</span><a href="bufmgr.c.html#LN702"><span class='Ref_to_Parameter'>forkNum</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN703"><span class='Ref_to_Parameter'>blockNum</span></a><span class='Delimiter'>, 
</span>                                              <a href="bufmgr.c.html#LN702"><span class='Ref_to_Parameter'>smgr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN42"><span class='Ref_to_Member'>smgr_rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN73"><span class='Ref_to_Member'>node</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN58"><span class='Ref_to_Member'>spcNode</span></a><span class='Delimiter'>, 
</span>                                              <a href="bufmgr.c.html#LN702"><span class='Ref_to_Parameter'>smgr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN42"><span class='Ref_to_Member'>smgr_rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN73"><span class='Ref_to_Member'>node</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN59"><span class='Ref_to_Member'>dbNode</span></a><span class='Delimiter'>, 
</span>                                              <a href="bufmgr.c.html#LN702"><span class='Ref_to_Parameter'>smgr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN42"><span class='Ref_to_Member'>smgr_rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN73"><span class='Ref_to_Member'>node</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN60"><span class='Ref_to_Member'>relNode</span></a><span class='Delimiter'>, 
</span>                                              <a href="bufmgr.c.html#LN702"><span class='Ref_to_Parameter'>smgr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN42"><span class='Ref_to_Member'>smgr_rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN74"><span class='Ref_to_Member'>backend</span></a><span class='Delimiter'>, 
</span>                                              <a href="bufmgr.c.html#LN709"><span class='Ref_To_Local'>isExtend</span></a><span class='Delimiter'>, 
</span>                                              <a href="bufmgr.c.html#LN708"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * In RBM_ZERO_AND_LOCK mode the caller expects the page to be 
             * locked on return. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="bufmgr.c.html#LN710"><span class='Ref_To_Local'>isLocalBuf</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN703"><span class='Ref_to_Parameter'>mode</span></a> <span class='Operator'>== </span><a href="../../../include/storage/bufmgr.h.html#LN40"><span class='Ref_to_EnumConst'>RBM_ZERO_AND_LOCK</span></a><span class='Parentheses'>) 
</span>                    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN226"><span class='Ref_to_Macro'>BufferDescriptorGetContentLock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN706"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                  <a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN703"><span class='Ref_to_Parameter'>mode</span></a> <span class='Operator'>== </span><a href="../../../include/storage/bufmgr.h.html#LN42"><span class='Ref_to_EnumConst'>RBM_ZERO_AND_CLEANUP_LOCK</span></a><span class='Parentheses'>) 
</span>                    <a href="../../../include/storage/bufmgr.h.html#LN216"><span class='Ref_to_Proto'>LockBufferForCleanup</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN222"><span class='Ref_to_Macro'>BufferDescriptorGetBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN706"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Control'>return</span> <a href="../../../include/storage/buf_internals.h.html#LN222"><span class='Ref_to_Macro'>BufferDescriptorGetBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN706"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !isExtend &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* 
         * We get here only in the corner case where we are trying to extend 
         * the relation but we found a pre-existing buffer marked BM_VALID. 
         * This can happen because mdread doesn't complain about reads beyond 
         * EOF (when zero_damaged_pages is ON) and so a previous attempt to 
         * read a block beyond EOF could have left a "valid" zero-filled 
         * buffer.  Unfortunately, we have also seen this case occurring 
         * because of buggy Linux kernels that sometimes return an 
         * lseek(SEEK_END) result that doesn't account for a recent write. In 
         * that situation, the pre-existing buffer would contain valid data 
         * that we don't want to overwrite.  Since the legitimate case should 
         * always have left a zero-filled buffer, complain if not PageIsNew. 
         */ 
</span>        <a href="bufmgr.c.html#LN707"><span class='Ref_To_Local'>bufBlock</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN710"><span class='Ref_To_Local'>isLocalBuf</span></a> <span class='Operator'>? </span><a href="localbuf.c.html#LN37"><span class='Ref_to_Macro'>LocalBufHdrGetBlock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN706"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>) </span><span class='Operator'>: </span><a href="bufmgr.c.html#LN56"><span class='Ref_to_Macro'>BufHdrGetBlock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN706"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/storage/bufpage.h.html#LN225"><span class='Ref_to_Macro'>PageIsNew</span></a><span class='Parentheses'>((</span><a href="../../../include/storage/bufpage.h.html#LN73"><span class='Ref_to_Typedef'>Page</span></a><span class='Parentheses'>) </span><a href="bufmgr.c.html#LN707"><span class='Ref_To_Local'>bufBlock</span></a><span class='Parentheses'>))</span> 
            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>             <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"unexpected data beyond EOF in block %u of relation %s"</span><span class='Delimiter'>, 
</span>                     <a href="bufmgr.c.html#LN703"><span class='Ref_to_Parameter'>blockNum</span></a><span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN70"><span class='Ref_to_Macro'>relpath</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN702"><span class='Ref_to_Parameter'>smgr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN42"><span class='Ref_to_Member'>smgr_rnode</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN702"><span class='Ref_to_Parameter'>forkNum</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>              <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"This has been seen to occur with buggy kernels; consider updating your system."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We *must* do smgrextend before succeeding, else the page will not 
         * be reserved by the kernel, and the next P_NEW call will decide to 
         * return the same page.  Clear the BM_VALID bit, do the StartBufferIO 
         * call that BufferAlloc didn't, and proceed. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN710"><span class='Ref_To_Local'>isLocalBuf</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Only need to adjust flags */ 
</span><a name="LN819"></a>            <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>buf_state</span> <span class='Operator'>= </span><a href="../../../include/port/atomics.h.html#LN250"><span class='Ref_to_Func'>pg_atomic_read_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN706"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN183"><span class='Ref_to_Member'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN819"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN59"><span class='Ref_to_Const'>BM_VALID</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="bufmgr.c.html#LN819"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>&= ~</span><a href="../../../include/storage/buf_internals.h.html#LN59"><span class='Ref_to_Const'>BM_VALID</span></a><span class='Delimiter'>; 
</span>            <a href="../../../include/port/atomics.h.html#LN286"><span class='Ref_to_Func'>pg_atomic_unlocked_write_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN706"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN183"><span class='Ref_to_Member'>state</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN819"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Loop to handle the very small possibility that someone re-sets 
             * BM_VALID between our clearing it and StartBufferIO inspecting 
             * it. 
             */ 
</span>            <span class='Control'>do</span> 
            <span class='Delimiter'>{ 
</span><a name="LN834"></a>                <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>buf_state</span> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN242"><span class='Ref_to_Proto'>LockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN706"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN834"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN59"><span class='Ref_to_Const'>BM_VALID</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="bufmgr.c.html#LN834"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>&= ~</span><a href="../../../include/storage/buf_internals.h.html#LN59"><span class='Ref_to_Const'>BM_VALID</span></a><span class='Delimiter'>; 
</span>                <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN706"><span class='Ref_To_Local'>bufHdr</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN834"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} </span><span class='Control'>while</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="bufmgr.c.html#LN441"><span class='Ref_to_Proto'>StartBufferIO</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN706"><span class='Ref_To_Local'>bufHdr</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if found &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * if we have gotten to this point, we have allocated a buffer for the 
     * page but its contents are not yet valid.  IO_IN_PROGRESS is set for it, 
     * if it's a shared buffer. 
     * 
     * Note: if smgrextend fails, we will end up with a buffer that is 
     * allocated but not marked BM_VALID.  P_NEW will still select the same 
     * block number (because the relation didn't get any longer on disk) and 
     * so future attempts to extend the relation will find the same buffer (if 
     * it's not been recycled) but come right back here to try smgrextend 
     * again. 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="../../../include/port/atomics.h.html#LN250"><span class='Ref_to_Func'>pg_atomic_read_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN706"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN183"><span class='Ref_to_Member'>state</span></a><span class='Parentheses'>) </span><span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN59"><span class='Ref_to_Const'>BM_VALID</span></a><span class='Parentheses'>))</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* spinlock not needed */ 
</span> 
    <a href="bufmgr.c.html#LN707"><span class='Ref_To_Local'>bufBlock</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN710"><span class='Ref_To_Local'>isLocalBuf</span></a> <span class='Operator'>? </span><a href="localbuf.c.html#LN37"><span class='Ref_to_Macro'>LocalBufHdrGetBlock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN706"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>) </span><span class='Operator'>: </span><a href="bufmgr.c.html#LN56"><span class='Ref_to_Macro'>BufHdrGetBlock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN706"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN709"><span class='Ref_To_Local'>isExtend</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* new buffers are zero-filled */ 
</span>        <a href="../../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>((</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="bufmgr.c.html#LN707"><span class='Ref_To_Local'>bufBlock</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span>BLCKSZ<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* don't set checksum for all-zero page */ 
</span>        <a href="../../../include/storage/smgr.h.html#LN94"><span class='Ref_to_Proto'>smgrextend</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN702"><span class='Ref_to_Parameter'>smgr</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN702"><span class='Ref_to_Parameter'>forkNum</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN703"><span class='Ref_to_Parameter'>blockNum</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="bufmgr.c.html#LN707"><span class='Ref_To_Local'>bufBlock</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * NB: we're *not* doing a ScheduleBufferTagForWriteback here; 
         * although we're essentially performing a write. At least on linux 
         * doing so defeats the 'delayed allocation' mechanism, leading to 
         * increased file fragmentation. 
         */ 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Read in the page, unless the caller intends to overwrite it and 
         * just wants us to allocate a buffer. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN703"><span class='Ref_to_Parameter'>mode</span></a> <span class='Operator'>== </span><a href="../../../include/storage/bufmgr.h.html#LN40"><span class='Ref_to_EnumConst'>RBM_ZERO_AND_LOCK</span></a> <span class='Operator'>|| </span><a href="bufmgr.c.html#LN703"><span class='Ref_to_Parameter'>mode</span></a> <span class='Operator'>== </span><a href="../../../include/storage/bufmgr.h.html#LN42"><span class='Ref_to_EnumConst'>RBM_ZERO_AND_CLEANUP_LOCK</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>((</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="bufmgr.c.html#LN707"><span class='Ref_To_Local'>bufBlock</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span>BLCKSZ<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span><a name="LN883"></a>            <a href="../../../include/portability/instr_time.h.html#LN146"><span class='Ref_to_Typedef'>instr_time</span></a>  <span class='Declare_Local'>io_start</span><span class='Delimiter'>, 
</span><a name="LN884"></a>                        <span class='Declare_Local'>io_time</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN110"><span class='Ref_to_Global_Var'>track_io_timing</span></a><span class='Parentheses'>) 
</span>                <a href="../../../include/portability/instr_time.h.html#LN88"><span class='Ref_to_Macro'>INSTR_TIME_SET_CURRENT</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN883"><span class='Ref_To_Local'>io_start</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/storage/smgr.h.html#LN98"><span class='Ref_to_Proto'>smgrread</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN702"><span class='Ref_to_Parameter'>smgr</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN702"><span class='Ref_to_Parameter'>forkNum</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN703"><span class='Ref_to_Parameter'>blockNum</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="bufmgr.c.html#LN707"><span class='Ref_To_Local'>bufBlock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN110"><span class='Ref_to_Global_Var'>track_io_timing</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="../../../include/portability/instr_time.h.html#LN88"><span class='Ref_to_Macro'>INSTR_TIME_SET_CURRENT</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN884"><span class='Ref_To_Local'>io_time</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../include/portability/instr_time.h.html#LN102"><span class='Ref_to_Macro'>INSTR_TIME_SUBTRACT</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN884"><span class='Ref_To_Local'>io_time</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN883"><span class='Ref_To_Local'>io_start</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../include/pgstat.h.html#LN1282"><span class='Ref_to_Macro'>pgstat_count_buffer_read_time</span></a><span class='Parentheses'>(</span><a href="../../../include/portability/instr_time.h.html#LN137"><span class='Ref_to_Macro'>INSTR_TIME_GET_MICROSEC</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN884"><span class='Ref_To_Local'>io_time</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <a href="../../../include/portability/instr_time.h.html#LN90"><span class='Ref_to_Macro'>INSTR_TIME_ADD</span></a><span class='Parentheses'>(</span><a href="../../executor/instrument.c.html#LN19"><span class='Ref_to_Global_Var'>pgBufferUsage</span></a><span class='Operator'>.</span><a href="../../../include/executor/instrument.h.html#LN30"><span class='Ref_to_Member'>blk_read_time</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN884"><span class='Ref_To_Local'>io_time</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* check for garbage data */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../page/bufpage.c.html#LN79"><span class='Ref_to_Func'>PageIsVerified</span></a><span class='Parentheses'>((</span><a href="../../../include/storage/bufpage.h.html#LN73"><span class='Ref_to_Typedef'>Page</span></a><span class='Parentheses'>) </span><a href="bufmgr.c.html#LN707"><span class='Ref_To_Local'>bufBlock</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN703"><span class='Ref_to_Parameter'>blockNum</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN703"><span class='Ref_to_Parameter'>mode</span></a> <span class='Operator'>== </span><a href="../../../include/storage/bufmgr.h.html#LN44"><span class='Ref_to_EnumConst'>RBM_ZERO_ON_ERROR</span></a> <span class='Operator'>|| </span><a href="bufmgr.c.html#LN107"><span class='Ref_to_Global_Var'>zero_damaged_pages</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN39"><span class='Ref_to_Const'>WARNING</span></a><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_DATA_CORRUPTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"invalid page in block %u of relation %s; zeroing out page"</span><span class='Delimiter'>, 
</span>                                    <a href="bufmgr.c.html#LN703"><span class='Ref_to_Parameter'>blockNum</span></a><span class='Delimiter'>, 
</span>                                    <a href="../../../include/common/relpath.h.html#LN70"><span class='Ref_to_Macro'>relpath</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN702"><span class='Ref_to_Parameter'>smgr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN42"><span class='Ref_to_Member'>smgr_rnode</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN702"><span class='Ref_to_Parameter'>forkNum</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>                    <a href="../../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>((</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="bufmgr.c.html#LN707"><span class='Ref_To_Local'>bufBlock</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span>BLCKSZ<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>else</span> 
                    <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_DATA_CORRUPTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"invalid page in block %u of relation %s"</span><span class='Delimiter'>, 
</span>                                    <a href="bufmgr.c.html#LN703"><span class='Ref_to_Parameter'>blockNum</span></a><span class='Delimiter'>, 
</span>                                    <a href="../../../include/common/relpath.h.html#LN70"><span class='Ref_to_Macro'>relpath</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN702"><span class='Ref_to_Parameter'>smgr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN42"><span class='Ref_to_Member'>smgr_rnode</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN702"><span class='Ref_to_Parameter'>forkNum</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * In RBM_ZERO_AND_LOCK mode, grab the buffer content lock before marking 
     * the page as valid, to make sure that no other backend sees the zeroed 
     * page before the caller has had a chance to initialize it. 
     * 
     * Since no-one else can be looking at the page contents yet, there is no 
     * difference between an exclusive lock and a cleanup-strength lock. (Note 
     * that we cannot use LockBuffer() or LockBufferForCleanup() here, because 
     * they assert that the buffer is already valid.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="bufmgr.c.html#LN703"><span class='Ref_to_Parameter'>mode</span></a> <span class='Operator'>== </span><a href="../../../include/storage/bufmgr.h.html#LN40"><span class='Ref_to_EnumConst'>RBM_ZERO_AND_LOCK</span></a> <span class='Operator'>|| </span><a href="bufmgr.c.html#LN703"><span class='Ref_to_Parameter'>mode</span></a> <span class='Operator'>== </span><a href="../../../include/storage/bufmgr.h.html#LN42"><span class='Ref_to_EnumConst'>RBM_ZERO_AND_CLEANUP_LOCK</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>        <span class='Operator'>!</span><a href="bufmgr.c.html#LN710"><span class='Ref_To_Local'>isLocalBuf</span></a><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN226"><span class='Ref_to_Macro'>BufferDescriptorGetContentLock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN706"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN710"><span class='Ref_To_Local'>isLocalBuf</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Only need to adjust flags */ 
</span><a name="LN940"></a>        <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>buf_state</span> <span class='Operator'>= </span><a href="../../../include/port/atomics.h.html#LN250"><span class='Ref_to_Func'>pg_atomic_read_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN706"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN183"><span class='Ref_to_Member'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="bufmgr.c.html#LN940"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>|= </span><a href="../../../include/storage/buf_internals.h.html#LN59"><span class='Ref_to_Const'>BM_VALID</span></a><span class='Delimiter'>; 
</span>        <a href="../../../include/port/atomics.h.html#LN286"><span class='Ref_to_Func'>pg_atomic_unlocked_write_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN706"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN183"><span class='Ref_to_Member'>state</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN940"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Set BM_VALID, terminate IO, and wake up any waiters */ 
</span>        <a href="bufmgr.c.html#LN442"><span class='Ref_to_Proto'>TerminateBufferIO</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN706"><span class='Ref_To_Local'>bufHdr</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><a href="../../../include/storage/buf_internals.h.html#LN59"><span class='Ref_to_Const'>BM_VALID</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../utils/init/globals.c.html#LN135"><span class='Ref_to_Global_Var'>VacuumPageMiss</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../utils/init/globals.c.html#LN139"><span class='Ref_to_Global_Var'>VacuumCostActive</span></a><span class='Parentheses'>) 
</span>        <a href="../../utils/init/globals.c.html#LN138"><span class='Ref_to_Global_Var'>VacuumCostBalance</span></a> <span class='Operator'>+= </span><a href="../../utils/init/globals.c.html#LN129"><span class='Ref_to_Global_Var'>VacuumCostPageMiss</span></a><span class='Delimiter'>; 
</span> 
    TRACE_POSTGRESQL_BUFFER_READ_DONE<span class='Parentheses'>(</span><a href="bufmgr.c.html#LN702"><span class='Ref_to_Parameter'>forkNum</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN703"><span class='Ref_to_Parameter'>blockNum</span></a><span class='Delimiter'>, 
</span>                                      <a href="bufmgr.c.html#LN702"><span class='Ref_to_Parameter'>smgr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN42"><span class='Ref_to_Member'>smgr_rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN73"><span class='Ref_to_Member'>node</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN58"><span class='Ref_to_Member'>spcNode</span></a><span class='Delimiter'>, 
</span>                                      <a href="bufmgr.c.html#LN702"><span class='Ref_to_Parameter'>smgr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN42"><span class='Ref_to_Member'>smgr_rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN73"><span class='Ref_to_Member'>node</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN59"><span class='Ref_to_Member'>dbNode</span></a><span class='Delimiter'>, 
</span>                                      <a href="bufmgr.c.html#LN702"><span class='Ref_to_Parameter'>smgr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN42"><span class='Ref_to_Member'>smgr_rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN73"><span class='Ref_to_Member'>node</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN60"><span class='Ref_to_Member'>relNode</span></a><span class='Delimiter'>, 
</span>                                      <a href="bufmgr.c.html#LN702"><span class='Ref_to_Parameter'>smgr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN42"><span class='Ref_to_Member'>smgr_rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN74"><span class='Ref_to_Member'>backend</span></a><span class='Delimiter'>, 
</span>                                      <a href="bufmgr.c.html#LN709"><span class='Ref_To_Local'>isExtend</span></a><span class='Delimiter'>, 
</span>                                      <a href="bufmgr.c.html#LN708"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="../../../include/storage/buf_internals.h.html#LN222"><span class='Ref_to_Macro'>BufferDescriptorGetBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN706"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ReadBuffer_common &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * BufferAlloc -- subroutine for ReadBuffer.  Handles lookup of a shared 
 *      buffer.  If no buffer exists already, selects a replacement 
 *      victim and evicts the old page, but does NOT read in new page. 
 * 
 * "strategy" can be a buffer replacement strategy object, or NULL for 
 * the default strategy.  The selected buffer's usage_count is advanced when 
 * using the default strategy, but otherwise possibly not (see PinBuffer). 
 * 
 * The returned buffer is pinned and is already marked as holding the 
 * desired page.  If it already did have the desired page, *foundPtr is 
 * set TRUE.  Otherwise, *foundPtr is set FALSE and the buffer is marked 
 * as IO_IN_PROGRESS; ReadBuffer will now need to do I/O to fill it. 
 * 
 * *foundPtr is actually redundant with the buffer's BM_VALID flag, but 
 * we keep it for simplicity in ReadBuffer. 
 * 
 * No locks are held either at entry or exit. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>* 
</span><a name="LN986"></a><span class='Declare_Function'>BufferAlloc</span><span class='Parentheses'>(</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> <span class='Declare_Parameter'>smgr</span><span class='Delimiter'>, </span><span class='Keyword'>char </span><span class='Declare_Parameter'>relpersistence</span><span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a> <span class='Declare_Parameter'>forkNum</span><span class='Delimiter'>, 
</span><a name="LN987"></a>            <a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Parameter'>blockNum</span><span class='Delimiter'>, 
</span><a name="LN988"></a>            <a href="../../../include/storage/buf.h.html#LN43"><span class='Ref_to_Typedef'>BufferAccessStrategy</span></a> <span class='Declare_Parameter'>strategy</span><span class='Delimiter'>, 
</span><a name="LN989"></a>            <span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>foundPtr</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN991"></a>    <a href="../../../include/storage/buf_internals.h.html#LN90"><span class='Ref_to_Typedef'>BufferTag</span></a>   <span class='Declare_Local'>newTag</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* identity of requested block */ 
</span><a name="LN992"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>newHash</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* hash value for newTag */ 
</span><a name="LN993"></a>    <a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>newPartitionLock</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* buffer partition lock for it */ 
</span><a name="LN994"></a>    <a href="../../../include/storage/buf_internals.h.html#LN90"><span class='Ref_to_Typedef'>BufferTag</span></a>   <span class='Declare_Local'>oldTag</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* previous identity of selected buffer */ 
</span><a name="LN995"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>oldHash</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* hash value for oldTag */ 
</span><a name="LN996"></a>    <a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>oldPartitionLock</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* buffer partition lock for it */ 
</span><a name="LN997"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>oldFlags</span><span class='Delimiter'>; 
</span><a name="LN998"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>buf_id</span><span class='Delimiter'>; 
</span><a name="LN999"></a>    <a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>buf</span><span class='Delimiter'>; 
</span><a name="LN1000"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>valid</span><span class='Delimiter'>; 
</span><a name="LN1001"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>buf_state</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* create a tag so we can lookup the buffer */ 
</span>    <a href="../../../include/storage/buf_internals.h.html#LN106"><span class='Ref_to_Macro'>INIT_BUFFERTAG</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN991"><span class='Ref_To_Local'>newTag</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN986"><span class='Ref_to_Parameter'>smgr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN42"><span class='Ref_to_Member'>smgr_rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN73"><span class='Ref_to_Member'>node</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN986"><span class='Ref_to_Parameter'>forkNum</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN987"><span class='Ref_to_Parameter'>blockNum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* determine its hash code and partition lock ID */ 
</span>    <a href="bufmgr.c.html#LN992"><span class='Ref_To_Local'>newHash</span></a> <span class='Operator'>= </span><a href="buf_table.c.html#LN78"><span class='Ref_to_Func'>BufTableHashCode</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN991"><span class='Ref_To_Local'>newTag</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="bufmgr.c.html#LN993"><span class='Ref_To_Local'>newPartitionLock</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN128"><span class='Ref_to_Macro'>BufMappingPartitionLock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN992"><span class='Ref_To_Local'>newHash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* see if the block is in the buffer pool already */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN993"><span class='Ref_To_Local'>newPartitionLock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="bufmgr.c.html#LN998"><span class='Ref_To_Local'>buf_id</span></a> <span class='Operator'>= </span><a href="buf_table.c.html#LN90"><span class='Ref_to_Func'>BufTableLookup</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN991"><span class='Ref_To_Local'>newTag</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN992"><span class='Ref_To_Local'>newHash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN998"><span class='Ref_To_Local'>buf_id</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Found it.  Now, pin the buffer so no one can steal it from the 
         * buffer pool, and check to see if the correct data has been loaded 
         * into the buffer. 
         */ 
</span>        <a href="bufmgr.c.html#LN999"><span class='Ref_To_Local'>buf</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN219"><span class='Ref_to_Macro'>GetBufferDescriptor</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN998"><span class='Ref_To_Local'>buf_id</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="bufmgr.c.html#LN1000"><span class='Ref_To_Local'>valid</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN434"><span class='Ref_to_Proto'>PinBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN999"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN988"><span class='Ref_to_Parameter'>strategy</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Can release the mapping lock as soon as we've pinned it */ 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN993"><span class='Ref_To_Local'>newPartitionLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Operator'>*</span><a href="bufmgr.c.html#LN989"><span class='Ref_to_Parameter'>foundPtr</span></a> <span class='Operator'>= </span><span class='Boolean'>TRUE</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="bufmgr.c.html#LN1000"><span class='Ref_To_Local'>valid</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * We can only get here if (a) someone else is still reading in 
             * the page, or (b) a previous read attempt failed.  We have to 
             * wait for any active read attempt to finish, and then set up our 
             * own read attempt if the page is still not BM_VALID. 
             * StartBufferIO does it all. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN441"><span class='Ref_to_Proto'>StartBufferIO</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN999"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * If we get here, previous attempts to read the buffer must 
                 * have failed ... but we shall bravely try again. 
                 */ 
</span>                <span class='Operator'>*</span><a href="bufmgr.c.html#LN989"><span class='Ref_to_Parameter'>foundPtr</span></a> <span class='Operator'>= </span><span class='Boolean'>FALSE</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>return</span> <a href="bufmgr.c.html#LN999"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if buf_id&GT;=0 &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Didn't find it in the buffer pool.  We'll have to initialize a new 
     * buffer.  Remember to unlock the mapping lock while doing the work. 
     */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN993"><span class='Ref_To_Local'>newPartitionLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Loop here in case we have to try another victim buffer */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Ensure, while the spinlock's not yet held, that there's a free 
         * refcount entry. 
         */ 
</span>        <a href="bufmgr.c.html#LN173"><span class='Ref_to_Proto'>ReservePrivateRefCountEntry</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Select a victim buffer.  The buffer is returned with its header 
         * spinlock still held! 
         */ 
</span>        <a href="bufmgr.c.html#LN999"><span class='Ref_To_Local'>buf</span></a> <span class='Operator'>= </span><a href="freelist.c.html#LN182"><span class='Ref_to_Func'>StrategyGetBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN988"><span class='Ref_to_Parameter'>strategy</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="bufmgr.c.html#LN1001"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN48"><span class='Ref_to_Macro'>BUF_STATE_GET_REFCOUNT</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1001"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Must copy buffer flags while we still hold the spinlock */ 
</span>        <a href="bufmgr.c.html#LN997"><span class='Ref_To_Local'>oldFlags</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN1001"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN45"><span class='Ref_to_Const'>BUF_FLAG_MASK</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Pin the buffer and then release the buffer spinlock */ 
</span>        <a href="bufmgr.c.html#LN435"><span class='Ref_to_Proto'>PinBuffer_Locked</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN999"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If the buffer was dirty, try to write it out.  There is a race 
         * condition here, in that someone might dirty it after we released it 
         * above, or even while we are writing it out (since our share-lock 
         * won't prevent hint-bit updates).  We will recheck the dirty bit 
         * after re-locking the buffer header. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN997"><span class='Ref_To_Local'>oldFlags</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN58"><span class='Ref_to_Const'>BM_DIRTY</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * We need a share-lock on the buffer contents to write it out 
             * (else we might write invalid data, eg because someone else is 
             * compacting the page contents while we write).  We must use a 
             * conditional lock acquisition here to avoid deadlock.  Even 
             * though the buffer was not pinned (and therefore surely not 
             * locked) when StrategyGetBuffer returned it, someone else could 
             * have pinned and exclusive-locked it by the time we get here. If 
             * we try to get the lock unconditionally, we'd block waiting for 
             * them; if they later block waiting for us, deadlock ensues. 
             * (This has been observed to happen when two backends are both 
             * trying to split btree index pages, and the second one just 
             * happens to be trying to split the page the first one got from 
             * StrategyGetBuffer.) 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN146"><span class='Ref_to_Proto'>LWLockConditionalAcquire</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN226"><span class='Ref_to_Macro'>BufferDescriptorGetContentLock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN999"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                         <a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * If using a nondefault strategy, and writing the buffer 
                 * would require a WAL flush, let the strategy decide whether 
                 * to go ahead and write/reuse the buffer or to choose another 
                 * victim.  We need lock to inspect the page LSN, so this 
                 * can't be done inside StrategyGetBuffer. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN988"><span class='Ref_to_Parameter'>strategy</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN1116"></a>                    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>lsn</span><span class='Delimiter'>; 
</span> 
                    <span class='Comment_Multi_Line'>/* Read the LSN while holding buffer header lock */ 
</span>                    <a href="bufmgr.c.html#LN1001"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN242"><span class='Ref_to_Proto'>LockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN999"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="bufmgr.c.html#LN1116"><span class='Ref_To_Local'>lsn</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN57"><span class='Ref_to_Macro'>BufferGetLSN</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN999"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN999"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN1001"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN227"><span class='Ref_to_Proto'>XLogNeedsFlush</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1116"><span class='Ref_To_Local'>lsn</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                        <a href="../../../include/storage/buf_internals.h.html#LN311"><span class='Ref_to_Proto'>StrategyRejectBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN988"><span class='Ref_to_Parameter'>strategy</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN999"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>))</span> 
                    <span class='Delimiter'>{ 
</span>                        <span class='Comment_Multi_Line'>/* Drop lock/pin and loop around for another buffer */ 
</span>                        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN226"><span class='Ref_to_Macro'>BufferDescriptorGetContentLock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN999"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                        <a href="bufmgr.c.html#LN436"><span class='Ref_to_Proto'>UnpinBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN999"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <span class='Control'>continue</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                <span class='Delimiter'>} 
</span> 
                <span class='Comment_Multi_Line'>/* OK, do the I/O */ 
</span>                TRACE_POSTGRESQL_BUFFER_WRITE_DIRTY_START<span class='Parentheses'>(</span><a href="bufmgr.c.html#LN986"><span class='Ref_to_Parameter'>forkNum</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN987"><span class='Ref_to_Parameter'>blockNum</span></a><span class='Delimiter'>, 
</span>                                               <a href="bufmgr.c.html#LN986"><span class='Ref_to_Parameter'>smgr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN42"><span class='Ref_to_Member'>smgr_rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN73"><span class='Ref_to_Member'>node</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN58"><span class='Ref_to_Member'>spcNode</span></a><span class='Delimiter'>, 
</span>                                                <a href="bufmgr.c.html#LN986"><span class='Ref_to_Parameter'>smgr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN42"><span class='Ref_to_Member'>smgr_rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN73"><span class='Ref_to_Member'>node</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN59"><span class='Ref_to_Member'>dbNode</span></a><span class='Delimiter'>, 
</span>                                              <a href="bufmgr.c.html#LN986"><span class='Ref_to_Parameter'>smgr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN42"><span class='Ref_to_Member'>smgr_rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN73"><span class='Ref_to_Member'>node</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN60"><span class='Ref_to_Member'>relNode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="bufmgr.c.html#LN452"><span class='Ref_to_Proto'>FlushBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN999"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN226"><span class='Ref_to_Macro'>BufferDescriptorGetContentLock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN999"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
                <a href="../../../include/storage/buf_internals.h.html#LN305"><span class='Ref_to_Proto'>ScheduleBufferTagForWriteback</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="buf_init.c.html#LN23"><span class='Ref_to_Global_Var'>BackendWritebackContext</span></a><span class='Delimiter'>, 
</span>                                              <span class='Operator'>&</span><a href="bufmgr.c.html#LN999"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                TRACE_POSTGRESQL_BUFFER_WRITE_DIRTY_DONE<span class='Parentheses'>(</span><a href="bufmgr.c.html#LN986"><span class='Ref_to_Parameter'>forkNum</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN987"><span class='Ref_to_Parameter'>blockNum</span></a><span class='Delimiter'>, 
</span>                                               <a href="bufmgr.c.html#LN986"><span class='Ref_to_Parameter'>smgr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN42"><span class='Ref_to_Member'>smgr_rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN73"><span class='Ref_to_Member'>node</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN58"><span class='Ref_to_Member'>spcNode</span></a><span class='Delimiter'>, 
</span>                                                <a href="bufmgr.c.html#LN986"><span class='Ref_to_Parameter'>smgr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN42"><span class='Ref_to_Member'>smgr_rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN73"><span class='Ref_to_Member'>node</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN59"><span class='Ref_to_Member'>dbNode</span></a><span class='Delimiter'>, 
</span>                                              <a href="bufmgr.c.html#LN986"><span class='Ref_to_Parameter'>smgr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN42"><span class='Ref_to_Member'>smgr_rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN73"><span class='Ref_to_Member'>node</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN60"><span class='Ref_to_Member'>relNode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if LWLockConditionalAcqu... &raquo; </span> 
            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * Someone else has locked the buffer, so give it up and loop 
                 * back to get another one. 
                 */ 
</span>                <a href="bufmgr.c.html#LN436"><span class='Ref_to_Proto'>UnpinBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN999"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if oldFlags&BM_DIRTY &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* 
         * To change the association of a valid buffer, we'll need to have 
         * exclusive lock on both the old and new mapping partitions. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN997"><span class='Ref_To_Local'>oldFlags</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN60"><span class='Ref_to_Const'>BM_TAG_VALID</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Need to compute the old tag's hashcode and partition lock ID. 
             * XXX is it worth storing the hashcode in BufferDesc so we need 
             * not recompute it here?  Probably not. 
             */ 
</span>            <a href="bufmgr.c.html#LN994"><span class='Ref_To_Local'>oldTag</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN999"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Delimiter'>; 
</span>            <a href="bufmgr.c.html#LN995"><span class='Ref_To_Local'>oldHash</span></a> <span class='Operator'>= </span><a href="buf_table.c.html#LN78"><span class='Ref_to_Func'>BufTableHashCode</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN994"><span class='Ref_To_Local'>oldTag</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="bufmgr.c.html#LN996"><span class='Ref_To_Local'>oldPartitionLock</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN128"><span class='Ref_to_Macro'>BufMappingPartitionLock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN995"><span class='Ref_To_Local'>oldHash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Must lock the lower-numbered partition first to avoid 
             * deadlocks. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN996"><span class='Ref_To_Local'>oldPartitionLock</span></a> <span class='Operator'>&LT; </span><a href="bufmgr.c.html#LN993"><span class='Ref_To_Local'>newPartitionLock</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN996"><span class='Ref_To_Local'>oldPartitionLock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN993"><span class='Ref_To_Local'>newPartitionLock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN996"><span class='Ref_To_Local'>oldPartitionLock</span></a> <span class='Operator'>&GT; </span><a href="bufmgr.c.html#LN993"><span class='Ref_To_Local'>newPartitionLock</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN993"><span class='Ref_To_Local'>newPartitionLock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN996"><span class='Ref_To_Local'>oldPartitionLock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* only one partition, only one lock */ 
</span>                <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN993"><span class='Ref_To_Local'>newPartitionLock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if oldFlags&BM_TAG_VALID &raquo; </span> 
        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* if it wasn't valid, we need only the new partition */ 
</span>            <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN993"><span class='Ref_To_Local'>newPartitionLock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* remember we have no old-partition lock or tag */ 
</span>            <a href="bufmgr.c.html#LN996"><span class='Ref_To_Local'>oldPartitionLock</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* this just keeps the compiler quiet about uninit variables */ 
</span>            <a href="bufmgr.c.html#LN995"><span class='Ref_To_Local'>oldHash</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Try to make a hashtable entry for the buffer under its new tag. 
         * This could fail because while we were writing someone else 
         * allocated another buffer for the same block we want to read in. 
         * Note that we have not yet removed the hashtable entry for the old 
         * tag. 
         */ 
</span>        <a href="bufmgr.c.html#LN998"><span class='Ref_To_Local'>buf_id</span></a> <span class='Operator'>= </span><a href="buf_table.c.html#LN118"><span class='Ref_to_Func'>BufTableInsert</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN991"><span class='Ref_To_Local'>newTag</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN992"><span class='Ref_To_Local'>newHash</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN999"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN180"><span class='Ref_to_Member'>buf_id</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN998"><span class='Ref_To_Local'>buf_id</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Got a collision. Someone has already done what we were about to 
             * do. We'll just handle this as if it were found in the buffer 
             * pool in the first place.  First, give up the buffer we were 
             * planning to use. 
             */ 
</span>            <a href="bufmgr.c.html#LN436"><span class='Ref_to_Proto'>UnpinBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN999"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Can give up that buffer's mapping partition lock now */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN996"><span class='Ref_To_Local'>oldPartitionLock</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL </span><span class='Operator'>&& 
</span>                <a href="bufmgr.c.html#LN996"><span class='Ref_To_Local'>oldPartitionLock</span></a> <span class='Operator'>!= </span><a href="bufmgr.c.html#LN993"><span class='Ref_To_Local'>newPartitionLock</span></a><span class='Parentheses'>) 
</span>                <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN996"><span class='Ref_To_Local'>oldPartitionLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* remaining code should match code at top of routine */ 
</span> 
            <a href="bufmgr.c.html#LN999"><span class='Ref_To_Local'>buf</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN219"><span class='Ref_to_Macro'>GetBufferDescriptor</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN998"><span class='Ref_To_Local'>buf_id</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="bufmgr.c.html#LN1000"><span class='Ref_To_Local'>valid</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN434"><span class='Ref_to_Proto'>PinBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN999"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN988"><span class='Ref_to_Parameter'>strategy</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Can release the mapping lock as soon as we've pinned it */ 
</span>            <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN993"><span class='Ref_To_Local'>newPartitionLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Operator'>*</span><a href="bufmgr.c.html#LN989"><span class='Ref_to_Parameter'>foundPtr</span></a> <span class='Operator'>= </span><span class='Boolean'>TRUE</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="bufmgr.c.html#LN1000"><span class='Ref_To_Local'>valid</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * We can only get here if (a) someone else is still reading 
                 * in the page, or (b) a previous read attempt failed.  We 
                 * have to wait for any active read attempt to finish, and 
                 * then set up our own read attempt if the page is still not 
                 * BM_VALID.  StartBufferIO does it all. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN441"><span class='Ref_to_Proto'>StartBufferIO</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN999"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* 
                     * If we get here, previous attempts to read the buffer 
                     * must have failed ... but we shall bravely try again. 
                     */ 
</span>                    <span class='Operator'>*</span><a href="bufmgr.c.html#LN989"><span class='Ref_to_Parameter'>foundPtr</span></a> <span class='Operator'>= </span><span class='Boolean'>FALSE</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Control'>return</span> <a href="bufmgr.c.html#LN999"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if buf_id&GT;=0 &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* 
         * Need to lock the buffer header too in order to change its tag. 
         */ 
</span>        <a href="bufmgr.c.html#LN1001"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN242"><span class='Ref_to_Proto'>LockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN999"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Somebody could have pinned or re-dirtied the buffer while we were 
         * doing the I/O and making the new hashtable entry.  If so, we can't 
         * recycle this buffer; we must undo everything we've done and start 
         * over with a new victim buffer. 
         */ 
</span>        <a href="bufmgr.c.html#LN997"><span class='Ref_To_Local'>oldFlags</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN1001"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN45"><span class='Ref_to_Const'>BUF_FLAG_MASK</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN48"><span class='Ref_to_Macro'>BUF_STATE_GET_REFCOUNT</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1001"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>1</span> <span class='Operator'>&& !</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN997"><span class='Ref_To_Local'>oldFlags</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN58"><span class='Ref_to_Const'>BM_DIRTY</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN999"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN1001"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="buf_table.c.html#LN148"><span class='Ref_to_Func'>BufTableDelete</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN991"><span class='Ref_To_Local'>newTag</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN992"><span class='Ref_To_Local'>newHash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN996"><span class='Ref_To_Local'>oldPartitionLock</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL </span><span class='Operator'>&& 
</span>            <a href="bufmgr.c.html#LN996"><span class='Ref_To_Local'>oldPartitionLock</span></a> <span class='Operator'>!= </span><a href="bufmgr.c.html#LN993"><span class='Ref_To_Local'>newPartitionLock</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN996"><span class='Ref_To_Local'>oldPartitionLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN993"><span class='Ref_To_Local'>newPartitionLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="bufmgr.c.html#LN436"><span class='Ref_to_Proto'>UnpinBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN999"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for ;; &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Okay, it's finally safe to rename the buffer. 
     * 
     * Clearing BM_VALID here is necessary, clearing the dirtybits is just 
     * paranoia.  We also reset the usage_count since any recency of use of 
     * the old content is no longer relevant.  (The usage_count starts out at 
     * 1 so that the buffer can survive one clock-sweep pass.) 
     * 
     * Make sure BM_PERMANENT is set for buffers that must be written at every 
     * checkpoint.  Unlogged buffers only need to be written at shutdown 
     * checkpoints, except for their "init" forks, which need to be treated 
     * just like permanent relations. 
     */ 
</span>    <a href="bufmgr.c.html#LN999"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN991"><span class='Ref_To_Local'>newTag</span></a><span class='Delimiter'>; 
</span>    <a href="bufmgr.c.html#LN1001"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>&= ~</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN59"><span class='Ref_to_Const'>BM_VALID</span></a> <span class='Operator'>| </span><a href="../../../include/storage/buf_internals.h.html#LN58"><span class='Ref_to_Const'>BM_DIRTY</span></a> <span class='Operator'>| </span><a href="../../../include/storage/buf_internals.h.html#LN63"><span class='Ref_to_Const'>BM_JUST_DIRTIED</span></a> <span class='Operator'>| 
</span>                   <a href="../../../include/storage/buf_internals.h.html#LN65"><span class='Ref_to_Const'>BM_CHECKPOINT_NEEDED</span></a> <span class='Operator'>| </span><a href="../../../include/storage/buf_internals.h.html#LN62"><span class='Ref_to_Const'>BM_IO_ERROR</span></a> <span class='Operator'>| </span><a href="../../../include/storage/buf_internals.h.html#LN66"><span class='Ref_to_Const'>BM_PERMANENT</span></a> <span class='Operator'>| 
</span>                   <a href="../../../include/storage/buf_internals.h.html#LN42"><span class='Ref_to_Const'>BUF_USAGECOUNT_MASK</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN986"><span class='Ref_to_Parameter'>relpersistence</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_class.h.html#LN169"><span class='Ref_to_Const'>RELPERSISTENCE_PERMANENT</span></a> <span class='Operator'>|| </span><a href="bufmgr.c.html#LN986"><span class='Ref_to_Parameter'>forkNum</span></a> <span class='Operator'>== </span><a href="../../../include/common/relpath.h.html#LN29"><span class='Ref_to_EnumConst'>INIT_FORKNUM</span></a><span class='Parentheses'>) 
</span>        <a href="bufmgr.c.html#LN1001"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>|= </span><a href="../../../include/storage/buf_internals.h.html#LN60"><span class='Ref_to_Const'>BM_TAG_VALID</span></a> <span class='Operator'>| </span><a href="../../../include/storage/buf_internals.h.html#LN66"><span class='Ref_to_Const'>BM_PERMANENT</span></a> <span class='Operator'>| </span><a href="../../../include/storage/buf_internals.h.html#LN43"><span class='Ref_to_Const'>BUF_USAGECOUNT_ONE</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="bufmgr.c.html#LN1001"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>|= </span><a href="../../../include/storage/buf_internals.h.html#LN60"><span class='Ref_to_Const'>BM_TAG_VALID</span></a> <span class='Operator'>| </span><a href="../../../include/storage/buf_internals.h.html#LN43"><span class='Ref_to_Const'>BUF_USAGECOUNT_ONE</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN999"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN1001"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN996"><span class='Ref_To_Local'>oldPartitionLock</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="buf_table.c.html#LN148"><span class='Ref_to_Func'>BufTableDelete</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN994"><span class='Ref_To_Local'>oldTag</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN995"><span class='Ref_To_Local'>oldHash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN996"><span class='Ref_To_Local'>oldPartitionLock</span></a> <span class='Operator'>!= </span><a href="bufmgr.c.html#LN993"><span class='Ref_To_Local'>newPartitionLock</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN996"><span class='Ref_To_Local'>oldPartitionLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN993"><span class='Ref_To_Local'>newPartitionLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Buffer contents are currently invalid.  Try to get the io_in_progress 
     * lock.  If StartBufferIO returns false, then someone else managed to 
     * read it before we did, so there's nothing left for BufferAlloc() to do. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN441"><span class='Ref_to_Proto'>StartBufferIO</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN999"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>))</span> 
        <span class='Operator'>*</span><a href="bufmgr.c.html#LN989"><span class='Ref_to_Parameter'>foundPtr</span></a> <span class='Operator'>= </span><span class='Boolean'>FALSE</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <span class='Operator'>*</span><a href="bufmgr.c.html#LN989"><span class='Ref_to_Parameter'>foundPtr</span></a> <span class='Operator'>= </span><span class='Boolean'>TRUE</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="bufmgr.c.html#LN999"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end BufferAlloc &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * InvalidateBuffer -- mark a shared buffer invalid and return it to the 
 * freelist. 
 * 
 * The buffer header spinlock must be held at entry.  We drop it before 
 * returning.  (This is sane because the caller must have locked the 
 * buffer in order to be sure it should be dropped.) 
 * 
 * This is used only in contexts such as dropping a relation.  We assume 
 * that no other backend could possibly be interested in using the page, 
 * so the only reason the buffer might be pinned is if someone else is 
 * trying to write it out.  We have to let them finish before we can 
 * reclaim the buffer. 
 * 
 * The buffer could get reclaimed by someone else while we are waiting 
 * to acquire the necessary locks; if so, don't mess it up. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1351"></a><span class='Declare_Function'>InvalidateBuffer</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>buf</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1353"></a>    <a href="../../../include/storage/buf_internals.h.html#LN90"><span class='Ref_to_Typedef'>BufferTag</span></a>   <span class='Declare_Local'>oldTag</span><span class='Delimiter'>; 
</span><a name="LN1354"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>oldHash</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* hash value for oldTag */ 
</span><a name="LN1355"></a>    <a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>oldPartitionLock</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* buffer partition lock for it */ 
</span><a name="LN1356"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>oldFlags</span><span class='Delimiter'>; 
</span><a name="LN1357"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>buf_state</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Save the original buffer tag before dropping the spinlock */ 
</span>    <a href="bufmgr.c.html#LN1353"><span class='Ref_To_Local'>oldTag</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN1351"><span class='Ref_to_Parameter'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Delimiter'>; 
</span> 
    <a href="bufmgr.c.html#LN1357"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>= </span><a href="../../../include/port/atomics.h.html#LN250"><span class='Ref_to_Func'>pg_atomic_read_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN1351"><span class='Ref_to_Parameter'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN183"><span class='Ref_to_Member'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1357"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN57"><span class='Ref_to_Const'>BM_LOCKED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1351"><span class='Ref_to_Parameter'>buf</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN1357"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Need to compute the old tag's hashcode and partition lock ID. XXX is it 
     * worth storing the hashcode in BufferDesc so we need not recompute it 
     * here?  Probably not. 
     */ 
</span>    <a href="bufmgr.c.html#LN1354"><span class='Ref_To_Local'>oldHash</span></a> <span class='Operator'>= </span><a href="buf_table.c.html#LN78"><span class='Ref_to_Func'>BufTableHashCode</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN1353"><span class='Ref_To_Local'>oldTag</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="bufmgr.c.html#LN1355"><span class='Ref_To_Local'>oldPartitionLock</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN128"><span class='Ref_to_Macro'>BufMappingPartitionLock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1354"><span class='Ref_To_Local'>oldHash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<a name="LN1374"></a><span class='Label'>retry</span><span class='Operator'>: 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Acquire exclusive mapping lock in preparation for changing the buffer's 
     * association. 
     */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1355"><span class='Ref_To_Local'>oldPartitionLock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Re-lock the buffer header */ 
</span>    <a href="bufmgr.c.html#LN1357"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN242"><span class='Ref_to_Proto'>LockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1351"><span class='Ref_to_Parameter'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If it's changed while we were waiting for lock, do nothing */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/storage/buf_internals.h.html#LN113"><span class='Ref_to_Macro'>BUFFERTAGS_EQUAL</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1351"><span class='Ref_to_Parameter'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN1353"><span class='Ref_To_Local'>oldTag</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1351"><span class='Ref_to_Parameter'>buf</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN1357"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1355"><span class='Ref_To_Local'>oldPartitionLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We assume the only reason for it to be pinned is that someone else is 
     * flushing the page out.  Wait for them to finish.  (This could be an 
     * infinite loop if the refcount is messed up... it would be nice to time 
     * out after awhile, but there seems no way to be sure how many loops may 
     * be needed.  Note that if the other guy has pinned the buffer but not 
     * yet done StartBufferIO, WaitIO will fall through and we'll effectively 
     * be busy-looping here.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN48"><span class='Ref_to_Macro'>BUF_STATE_GET_REFCOUNT</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1357"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1351"><span class='Ref_to_Parameter'>buf</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN1357"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1355"><span class='Ref_To_Local'>oldPartitionLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* safety check: should definitely not be our *own* pin */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN176"><span class='Ref_to_Proto'>GetPrivateRefCount</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN222"><span class='Ref_to_Macro'>BufferDescriptorGetBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1351"><span class='Ref_to_Parameter'>buf</span></a><span class='Parentheses'>))</span> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"buffer is pinned in InvalidateBuffer"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="bufmgr.c.html#LN440"><span class='Ref_to_Proto'>WaitIO</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1351"><span class='Ref_to_Parameter'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>goto</span> <span class='Symbol_Characters'>&uarr;</span><a href="bufmgr.c.html#LN1374"><span class='Ref_to_Label'>retry</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Clear out the buffer's tag and flags.  We must do this to ensure that 
     * linear scans of the buffer array don't think the buffer is valid. 
     */ 
</span>    <a href="bufmgr.c.html#LN1356"><span class='Ref_To_Local'>oldFlags</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN1357"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN45"><span class='Ref_to_Const'>BUF_FLAG_MASK</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/buf_internals.h.html#LN97"><span class='Ref_to_Macro'>CLEAR_BUFFERTAG</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1351"><span class='Ref_to_Parameter'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="bufmgr.c.html#LN1357"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>&= ~</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN45"><span class='Ref_to_Const'>BUF_FLAG_MASK</span></a> <span class='Operator'>| </span><a href="../../../include/storage/buf_internals.h.html#LN42"><span class='Ref_to_Const'>BUF_USAGECOUNT_MASK</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1351"><span class='Ref_to_Parameter'>buf</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN1357"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Remove the buffer from the lookup hashtable, if it was in there. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1356"><span class='Ref_To_Local'>oldFlags</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN60"><span class='Ref_to_Const'>BM_TAG_VALID</span></a><span class='Parentheses'>) 
</span>        <a href="buf_table.c.html#LN148"><span class='Ref_to_Func'>BufTableDelete</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN1353"><span class='Ref_To_Local'>oldTag</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN1354"><span class='Ref_To_Local'>oldHash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Done with mapping lock. 
     */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1355"><span class='Ref_To_Local'>oldPartitionLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Insert the buffer at the head of the list of free buffers. 
     */ 
</span>    <a href="../../../include/storage/buf_internals.h.html#LN310"><span class='Ref_to_Proto'>StrategyFreeBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1351"><span class='Ref_to_Parameter'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end InvalidateBuffer &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * MarkBufferDirty 
 * 
 *      Marks buffer contents as dirty (actual write happens later). 
 * 
 * Buffer must be pinned and exclusive-locked.  (If caller does not hold 
 * exclusive lock, then somebody could be in process of writing the buffer, 
 * leading to risk of bad data written to disk.) 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1449"></a><span class='Declare_Function'>MarkBufferDirty</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> <span class='Declare_Parameter'>buffer</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1451"></a>    <a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>bufHdr</span><span class='Delimiter'>; 
</span><a name="LN1452"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>buf_state</span><span class='Delimiter'>; 
</span><a name="LN1453"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>old_buf_state</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/storage/bufmgr.h.html#LN113"><span class='Ref_to_Macro'>BufferIsValid</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1449"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"bad buffer ID: %d"</span><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN1449"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN36"><span class='Ref_to_Macro'>BufferIsLocal</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1449"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="localbuf.c.html#LN278"><span class='Ref_to_Func'>MarkLocalBufferDirty</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1449"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="bufmgr.c.html#LN1451"><span class='Ref_To_Local'>bufHdr</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN219"><span class='Ref_to_Macro'>GetBufferDescriptor</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1449"><span class='Ref_to_Parameter'>buffer</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN418"><span class='Ref_to_Macro'>BufferIsPinned</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1449"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN152"><span class='Ref_to_Proto'>LWLockHeldByMeInMode</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN226"><span class='Ref_to_Macro'>BufferDescriptorGetContentLock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1451"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                <a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="bufmgr.c.html#LN1453"><span class='Ref_To_Local'>old_buf_state</span></a> <span class='Operator'>= </span><a href="../../../include/port/atomics.h.html#LN250"><span class='Ref_to_Func'>pg_atomic_read_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN1451"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN183"><span class='Ref_to_Member'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1453"><span class='Ref_To_Local'>old_buf_state</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN57"><span class='Ref_to_Const'>BM_LOCKED</span></a><span class='Parentheses'>) 
</span>            <a href="bufmgr.c.html#LN1453"><span class='Ref_To_Local'>old_buf_state</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN438"><span class='Ref_to_Proto'>WaitBufHdrUnlocked</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1451"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="bufmgr.c.html#LN1452"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN1453"><span class='Ref_To_Local'>old_buf_state</span></a><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN48"><span class='Ref_to_Macro'>BUF_STATE_GET_REFCOUNT</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1452"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="bufmgr.c.html#LN1452"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>|= </span><a href="../../../include/storage/buf_internals.h.html#LN58"><span class='Ref_to_Const'>BM_DIRTY</span></a> <span class='Operator'>| </span><a href="../../../include/storage/buf_internals.h.html#LN63"><span class='Ref_to_Const'>BM_JUST_DIRTIED</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/port/atomics.h.html#LN320"><span class='Ref_to_Func'>pg_atomic_compare_exchange_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN1451"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN183"><span class='Ref_to_Member'>state</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="bufmgr.c.html#LN1453"><span class='Ref_To_Local'>old_buf_state</span></a><span class='Delimiter'>, 
</span>                                           <a href="bufmgr.c.html#LN1452"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the buffer was not dirty already, do vacuum accounting. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1453"><span class='Ref_To_Local'>old_buf_state</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN58"><span class='Ref_to_Const'>BM_DIRTY</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../utils/init/globals.c.html#LN136"><span class='Ref_to_Global_Var'>VacuumPageDirty</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <a href="../../executor/instrument.c.html#LN19"><span class='Ref_to_Global_Var'>pgBufferUsage</span></a><span class='Operator'>.</span><a href="../../../include/executor/instrument.h.html#LN22"><span class='Ref_to_Member'>shared_blks_dirtied</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../utils/init/globals.c.html#LN139"><span class='Ref_to_Global_Var'>VacuumCostActive</span></a><span class='Parentheses'>) 
</span>            <a href="../../utils/init/globals.c.html#LN138"><span class='Ref_to_Global_Var'>VacuumCostBalance</span></a> <span class='Operator'>+= </span><a href="../../utils/init/globals.c.html#LN130"><span class='Ref_to_Global_Var'>VacuumCostPageDirty</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end MarkBufferDirty &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * ReleaseAndReadBuffer -- combine ReleaseBuffer() and ReadBuffer() 
 * 
 * Formerly, this saved one cycle of acquiring/releasing the BufMgrLock 
 * compared to calling the two routines separately.  Now it's mainly just 
 * a convenience function.  However, if the passed buffer is valid and 
 * already contains the desired block, we just return it as-is; and that 
 * does save considerable work compared to a full release and reacquire. 
 * 
 * Note: it is OK to pass buffer == InvalidBuffer, indicating that no old 
 * buffer actually needs to be released.  This case is the same as ReadBuffer, 
 * but can save some tests in the caller. 
 */ 
</span><a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> 
<a name="LN1512"></a><span class='Declare_Function'>ReleaseAndReadBuffer</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> <span class='Declare_Parameter'>buffer</span><span class='Delimiter'>, 
</span><a name="LN1513"></a>                     <a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>relation</span><span class='Delimiter'>, 
</span><a name="LN1514"></a>                     <a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Parameter'>blockNum</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1516"></a>    <a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a>  <span class='Declare_Local'>forkNum</span> <span class='Operator'>= </span><a href="../../../include/common/relpath.h.html#LN26"><span class='Ref_to_EnumConst'>MAIN_FORKNUM</span></a><span class='Delimiter'>; 
</span><a name="LN1517"></a>    <a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>bufHdr</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/bufmgr.h.html#LN113"><span class='Ref_to_Macro'>BufferIsValid</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1512"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN418"><span class='Ref_to_Macro'>BufferIsPinned</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1512"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN36"><span class='Ref_to_Macro'>BufferIsLocal</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1512"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="bufmgr.c.html#LN1517"><span class='Ref_To_Local'>bufHdr</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN220"><span class='Ref_to_Macro'>GetLocalBufferDescriptor</span></a><span class='Parentheses'>(</span><span class='Operator'>-</span><a href="bufmgr.c.html#LN1512"><span class='Ref_to_Parameter'>buffer</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1517"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN94"><span class='Ref_to_Member'>blockNum</span></a> <span class='Operator'>== </span><a href="bufmgr.c.html#LN1514"><span class='Ref_to_Parameter'>blockNum</span></a> <span class='Operator'>&& 
</span>                <a href="../../../include/storage/relfilenode.h.html#LN87"><span class='Ref_to_Macro'>RelFileNodeEquals</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1517"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN92"><span class='Ref_to_Member'>rnode</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN1513"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN84"><span class='Ref_to_Member'>rd_node</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                <a href="bufmgr.c.html#LN1517"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN93"><span class='Ref_to_Member'>forkNum</span></a> <span class='Operator'>== </span><a href="bufmgr.c.html#LN1516"><span class='Ref_To_Local'>forkNum</span></a><span class='Parentheses'>)</span> 
                <span class='Control'>return</span> <a href="bufmgr.c.html#LN1512"><span class='Ref_to_Parameter'>buffer</span></a><span class='Delimiter'>; 
</span>            <a href="../../../include/utils/resowner_private.h.html#LN30"><span class='Ref_to_Proto'>ResourceOwnerForgetBuffer</span></a><span class='Parentheses'>(</span><a href="../../utils/resowner/resowner.c.html#LN137"><span class='Ref_to_Global_Var'>CurrentResourceOwner</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN1512"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="localbuf.c.html#LN44"><span class='Ref_to_Global_Var'>LocalRefCount</span></a><span class='Delimiter'>[</span><span class='Operator'>-</span><a href="bufmgr.c.html#LN1512"><span class='Ref_to_Parameter'>buffer</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Operator'>--</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="bufmgr.c.html#LN1517"><span class='Ref_To_Local'>bufHdr</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN219"><span class='Ref_to_Macro'>GetBufferDescriptor</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1512"><span class='Ref_to_Parameter'>buffer</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* we have pin, so it's ok to examine tag without spinlock */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1517"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN94"><span class='Ref_to_Member'>blockNum</span></a> <span class='Operator'>== </span><a href="bufmgr.c.html#LN1514"><span class='Ref_to_Parameter'>blockNum</span></a> <span class='Operator'>&& 
</span>                <a href="../../../include/storage/relfilenode.h.html#LN87"><span class='Ref_to_Macro'>RelFileNodeEquals</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1517"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN92"><span class='Ref_to_Member'>rnode</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN1513"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN84"><span class='Ref_to_Member'>rd_node</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                <a href="bufmgr.c.html#LN1517"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN93"><span class='Ref_to_Member'>forkNum</span></a> <span class='Operator'>== </span><a href="bufmgr.c.html#LN1516"><span class='Ref_To_Local'>forkNum</span></a><span class='Parentheses'>)</span> 
                <span class='Control'>return</span> <a href="bufmgr.c.html#LN1512"><span class='Ref_to_Parameter'>buffer</span></a><span class='Delimiter'>; 
</span>            <a href="bufmgr.c.html#LN436"><span class='Ref_to_Proto'>UnpinBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1517"><span class='Ref_To_Local'>bufHdr</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if BufferIsValid(buffer) &raquo; </span> 
 
    <span class='Control'>return</span> <a href="../../../include/storage/bufmgr.h.html#LN167"><span class='Ref_to_Proto'>ReadBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1513"><span class='Ref_to_Parameter'>relation</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN1514"><span class='Ref_to_Parameter'>blockNum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ReleaseAndReadBuffer &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * PinBuffer -- make buffer unavailable for replacement. 
 * 
 * For the default access strategy, the buffer's usage_count is incremented 
 * when we first pin it; for other strategies we just make sure the usage_count 
 * isn't zero.  (The idea of the latter is that we don't want synchronized 
 * heap scans to inflate the count, but we need it to not be zero to discourage 
 * other backends from stealing buffers from our ring.  As long as we cycle 
 * through the ring faster than the global clock-sweep cycles, buffers in 
 * our ring won't be chosen as victims for replacement by other backends.) 
 * 
 * This should be applied only to shared buffers, never local ones. 
 * 
 * Since buffers are pinned/unpinned very frequently, pin buffers without 
 * taking the buffer header lock; instead update the state variable in loop of 
 * CAS operations. Hopefully it's just a single CAS. 
 * 
 * Note that ResourceOwnerEnlargeBuffers must have been done already. 
 * 
 * Returns TRUE if buffer is BM_VALID, else FALSE.  This provision allows 
 * some callers to avoid an extra spinlock cycle. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN1570"></a><span class='Declare_Function'>PinBuffer</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>buf</span><span class='Delimiter'>, </span><a href="../../../include/storage/buf.h.html#LN43"><span class='Ref_to_Typedef'>BufferAccessStrategy</span></a> <span class='Declare_Parameter'>strategy</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1572"></a>    <a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a>      <span class='Declare_Local'>b</span> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN222"><span class='Ref_to_Macro'>BufferDescriptorGetBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1570"><span class='Ref_to_Parameter'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1573"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span><a name="LN1574"></a>    <a href="bufmgr.c.html#LN69"><span class='Ref_to_Struct'>PrivateRefCountEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>ref</span><span class='Delimiter'>; 
</span> 
    <span class='Keyword'>ref </span><span class='Operator'>= </span><a href="bufmgr.c.html#LN175"><span class='Ref_to_Proto'>GetPrivateRefCountEntry</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1572"><span class='Ref_To_Local'>b</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Keyword'>ref </span><span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1580"></a>        <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>buf_state</span><span class='Delimiter'>; 
</span><a name="LN1581"></a>        <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>old_buf_state</span><span class='Delimiter'>; 
</span> 
        <a href="bufmgr.c.html#LN173"><span class='Ref_to_Proto'>ReservePrivateRefCountEntry</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <span class='Keyword'>ref </span><span class='Operator'>= </span><a href="bufmgr.c.html#LN174"><span class='Ref_to_Proto'>NewPrivateRefCountEntry</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1572"><span class='Ref_To_Local'>b</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="bufmgr.c.html#LN1581"><span class='Ref_To_Local'>old_buf_state</span></a> <span class='Operator'>= </span><a href="../../../include/port/atomics.h.html#LN250"><span class='Ref_to_Func'>pg_atomic_read_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN1570"><span class='Ref_to_Parameter'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN183"><span class='Ref_to_Member'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1581"><span class='Ref_To_Local'>old_buf_state</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN57"><span class='Ref_to_Const'>BM_LOCKED</span></a><span class='Parentheses'>) 
</span>                <a href="bufmgr.c.html#LN1581"><span class='Ref_To_Local'>old_buf_state</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN438"><span class='Ref_to_Proto'>WaitBufHdrUnlocked</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1570"><span class='Ref_to_Parameter'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="bufmgr.c.html#LN1580"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN1581"><span class='Ref_To_Local'>old_buf_state</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* increase refcount */ 
</span>            <a href="bufmgr.c.html#LN1580"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>+= </span><a href="../../../include/storage/buf_internals.h.html#LN40"><span class='Ref_to_Const'>BUF_REFCOUNT_ONE</span></a><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1570"><span class='Ref_to_Parameter'>strategy</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Default case: increase usagecount unless already max. */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN49"><span class='Ref_to_Macro'>BUF_STATE_GET_USAGECOUNT</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1580"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>) </span><span class='Operator'>&LT; </span><a href="../../../include/storage/buf_internals.h.html#LN76"><span class='Ref_to_Const'>BM_MAX_USAGE_COUNT</span></a><span class='Parentheses'>)</span> 
                    <a href="bufmgr.c.html#LN1580"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>+= </span><a href="../../../include/storage/buf_internals.h.html#LN43"><span class='Ref_to_Const'>BUF_USAGECOUNT_ONE</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * Ring buffers shouldn't evict others from pool.  Thus we 
                 * don't make usagecount more than 1. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN49"><span class='Ref_to_Macro'>BUF_STATE_GET_USAGECOUNT</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1580"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                    <a href="bufmgr.c.html#LN1580"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>+= </span><a href="../../../include/storage/buf_internals.h.html#LN43"><span class='Ref_to_Const'>BUF_USAGECOUNT_ONE</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/port/atomics.h.html#LN320"><span class='Ref_to_Func'>pg_atomic_compare_exchange_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN1570"><span class='Ref_to_Parameter'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN183"><span class='Ref_to_Member'>state</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="bufmgr.c.html#LN1581"><span class='Ref_To_Local'>old_buf_state</span></a><span class='Delimiter'>, 
</span>                                               <a href="bufmgr.c.html#LN1580"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="bufmgr.c.html#LN1573"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1580"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN59"><span class='Ref_to_Const'>BM_VALID</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for ;; &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if ref==NULL &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* If we previously pinned the buffer, it must surely be valid */ 
</span>        <a href="bufmgr.c.html#LN1573"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Keyword'>ref</span><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN72"><span class='Ref_to_Member'>refcount</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Keyword'>ref</span><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN72"><span class='Ref_to_Member'>refcount</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/utils/resowner_private.h.html#LN29"><span class='Ref_to_Proto'>ResourceOwnerRememberBuffer</span></a><span class='Parentheses'>(</span><a href="../../utils/resowner/resowner.c.html#LN137"><span class='Ref_to_Global_Var'>CurrentResourceOwner</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN1572"><span class='Ref_To_Local'>b</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="bufmgr.c.html#LN1573"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end PinBuffer &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * PinBuffer_Locked -- as above, but caller already locked the buffer header. 
 * The spinlock is released before return. 
 * 
 * As this function is called with the spinlock held, the caller has to 
 * previously call ReservePrivateRefCountEntry(). 
 * 
 * Currently, no callers of this function want to modify the buffer's 
 * usage_count at all, so there's no need for a strategy parameter. 
 * Also we don't bother with a BM_VALID test (the caller could check that for 
 * itself). 
 * 
 * Also all callers only ever use this function when it's known that the 
 * buffer can't have a preexisting pin by this backend. That allows us to skip 
 * searching the private refcount array & hash, which is a boon, because the 
 * spinlock is still held. 
 * 
 * Note: use of this routine is frequently mandatory, not just an optimization 
 * to save a spin lock/unlock cycle, because we need to pin a buffer before 
 * its state can change under us. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1655"></a><span class='Declare_Function'>PinBuffer_Locked</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>buf</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1657"></a>    <a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a>      <span class='Declare_Local'>b</span><span class='Delimiter'>; 
</span><a name="LN1658"></a>    <a href="bufmgr.c.html#LN69"><span class='Ref_to_Struct'>PrivateRefCountEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>ref</span><span class='Delimiter'>; 
</span><a name="LN1659"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>buf_state</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * As explained, We don't expect any preexisting pins. That allows us to 
     * manipulate the PrivateRefCount after releasing the spinlock 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN175"><span class='Ref_to_Proto'>GetPrivateRefCountEntry</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN222"><span class='Ref_to_Macro'>BufferDescriptorGetBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1655"><span class='Ref_to_Parameter'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Since we hold the buffer spinlock, we can update the buffer state and 
     * release the lock in one operation. 
     */ 
</span>    <a href="bufmgr.c.html#LN1659"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>= </span><a href="../../../include/port/atomics.h.html#LN250"><span class='Ref_to_Func'>pg_atomic_read_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN1655"><span class='Ref_to_Parameter'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN183"><span class='Ref_to_Member'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1659"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN57"><span class='Ref_to_Const'>BM_LOCKED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="bufmgr.c.html#LN1659"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>+= </span><a href="../../../include/storage/buf_internals.h.html#LN40"><span class='Ref_to_Const'>BUF_REFCOUNT_ONE</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1655"><span class='Ref_to_Parameter'>buf</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN1659"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="bufmgr.c.html#LN1657"><span class='Ref_To_Local'>b</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN222"><span class='Ref_to_Macro'>BufferDescriptorGetBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1655"><span class='Ref_to_Parameter'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Keyword'>ref </span><span class='Operator'>= </span><a href="bufmgr.c.html#LN174"><span class='Ref_to_Proto'>NewPrivateRefCountEntry</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1657"><span class='Ref_To_Local'>b</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Keyword'>ref</span><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN72"><span class='Ref_to_Member'>refcount</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/resowner_private.h.html#LN29"><span class='Ref_to_Proto'>ResourceOwnerRememberBuffer</span></a><span class='Parentheses'>(</span><a href="../../utils/resowner/resowner.c.html#LN137"><span class='Ref_to_Global_Var'>CurrentResourceOwner</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN1657"><span class='Ref_To_Local'>b</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end PinBuffer_Locked &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * UnpinBuffer -- make buffer available for replacement. 
 * 
 * This should be applied only to shared buffers, never local ones. 
 * 
 * Most but not all callers want CurrentResourceOwner to be adjusted. 
 * Those that don't should pass fixOwner = FALSE. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1693"></a><span class='Declare_Function'>UnpinBuffer</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>buf</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>fixOwner</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1695"></a>    <a href="bufmgr.c.html#LN69"><span class='Ref_to_Struct'>PrivateRefCountEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>ref</span><span class='Delimiter'>; 
</span><a name="LN1696"></a>    <a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a>      <span class='Declare_Local'>b</span> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN222"><span class='Ref_to_Macro'>BufferDescriptorGetBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1693"><span class='Ref_to_Parameter'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* not moving as we're likely deleting it soon anyway */ 
</span>    <span class='Keyword'>ref </span><span class='Operator'>= </span><a href="bufmgr.c.html#LN175"><span class='Ref_to_Proto'>GetPrivateRefCountEntry</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1696"><span class='Ref_To_Local'>b</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Keyword'>ref </span><span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1693"><span class='Ref_to_Parameter'>fixOwner</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/resowner_private.h.html#LN30"><span class='Ref_to_Proto'>ResourceOwnerForgetBuffer</span></a><span class='Parentheses'>(</span><a href="../../utils/resowner/resowner.c.html#LN137"><span class='Ref_to_Global_Var'>CurrentResourceOwner</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN1696"><span class='Ref_To_Local'>b</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Keyword'>ref</span><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN72"><span class='Ref_to_Member'>refcount</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Keyword'>ref</span><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN72"><span class='Ref_to_Member'>refcount</span></a><span class='Operator'>--</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Keyword'>ref</span><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN72"><span class='Ref_to_Member'>refcount</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1709"></a>        <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>buf_state</span><span class='Delimiter'>; 
</span><a name="LN1710"></a>        <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>old_buf_state</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* I'd better not still hold any locks on the buffer */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/storage/lwlock.h.html#LN151"><span class='Ref_to_Proto'>LWLockHeldByMe</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN226"><span class='Ref_to_Macro'>BufferDescriptorGetContentLock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1693"><span class='Ref_to_Parameter'>buf</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/storage/lwlock.h.html#LN151"><span class='Ref_to_Proto'>LWLockHeldByMe</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN224"><span class='Ref_to_Macro'>BufferDescriptorGetIOLock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1693"><span class='Ref_to_Parameter'>buf</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Decrement the shared reference count. 
         * 
         * Since buffer spinlock holder can update status using just write, 
         * it's not safe to use atomic decrement here; thus use a CAS loop. 
         */ 
</span>        <a href="bufmgr.c.html#LN1710"><span class='Ref_To_Local'>old_buf_state</span></a> <span class='Operator'>= </span><a href="../../../include/port/atomics.h.html#LN250"><span class='Ref_to_Func'>pg_atomic_read_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN1693"><span class='Ref_to_Parameter'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN183"><span class='Ref_to_Member'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1710"><span class='Ref_To_Local'>old_buf_state</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN57"><span class='Ref_to_Const'>BM_LOCKED</span></a><span class='Parentheses'>) 
</span>                <a href="bufmgr.c.html#LN1710"><span class='Ref_To_Local'>old_buf_state</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN438"><span class='Ref_to_Proto'>WaitBufHdrUnlocked</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1693"><span class='Ref_to_Parameter'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="bufmgr.c.html#LN1709"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN1710"><span class='Ref_To_Local'>old_buf_state</span></a><span class='Delimiter'>; 
</span> 
            <a href="bufmgr.c.html#LN1709"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>-= </span><a href="../../../include/storage/buf_internals.h.html#LN40"><span class='Ref_to_Const'>BUF_REFCOUNT_ONE</span></a><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/port/atomics.h.html#LN320"><span class='Ref_to_Func'>pg_atomic_compare_exchange_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN1693"><span class='Ref_to_Parameter'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN183"><span class='Ref_to_Member'>state</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="bufmgr.c.html#LN1710"><span class='Ref_To_Local'>old_buf_state</span></a><span class='Delimiter'>, 
</span>                                               <a href="bufmgr.c.html#LN1709"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Support LockBufferForCleanup() */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1709"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN64"><span class='Ref_to_Const'>BM_PIN_COUNT_WAITER</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Acquire the buffer header lock, re-check that there's a waiter. 
             * Another backend could have unpinned this buffer, and already 
             * woken up the waiter.  There's no danger of the buffer being 
             * replaced after we unpinned it above, as it's pinned by the 
             * waiter. 
             */ 
</span>            <a href="bufmgr.c.html#LN1709"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN242"><span class='Ref_to_Proto'>LockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1693"><span class='Ref_to_Parameter'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="bufmgr.c.html#LN1709"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN64"><span class='Ref_to_Const'>BM_PIN_COUNT_WAITER</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                <a href="../../../include/storage/buf_internals.h.html#LN48"><span class='Ref_to_Macro'>BUF_STATE_GET_REFCOUNT</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1709"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* we just released the last pin other than the waiter's */ 
</span><a name="LN1753"></a>                <span class='Keyword'>int</span>         <span class='Declare_Local'>wait_backend_pid</span> <span class='Operator'>= </span><a href="bufmgr.c.html#LN1693"><span class='Ref_to_Parameter'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN185"><span class='Ref_to_Member'>wait_backend_pid</span></a><span class='Delimiter'>; 
</span> 
                <a href="bufmgr.c.html#LN1709"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>&= ~</span><a href="../../../include/storage/buf_internals.h.html#LN64"><span class='Ref_to_Const'>BM_PIN_COUNT_WAITER</span></a><span class='Delimiter'>; 
</span>                <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1693"><span class='Ref_to_Parameter'>buf</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN1709"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../include/storage/proc.h.html#LN308"><span class='Ref_to_Proto'>ProcSendSignal</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1753"><span class='Ref_To_Local'>wait_backend_pid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
                <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1693"><span class='Ref_to_Parameter'>buf</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN1709"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if buf_state&BM_PIN_COUN... &raquo; </span> 
        <a href="bufmgr.c.html#LN177"><span class='Ref_to_Proto'>ForgetPrivateRefCountEntry</span></a><span class='Parentheses'>(</span><span class='Keyword'>ref</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if ref-&GT;refcount==0 &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end UnpinBuffer &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * BufferSync -- Write out all dirty buffers in the pool. 
 * 
 * This is called at checkpoint time to write out all dirty shared buffers. 
 * The checkpoint request flags should be passed in.  If CHECKPOINT_IMMEDIATE 
 * is set, we disable delays between writes; if CHECKPOINT_IS_SHUTDOWN, 
 * CHECKPOINT_END_OF_RECOVERY or CHECKPOINT_FLUSH_ALL is set, we write even 
 * unlogged buffers, which are otherwise skipped.  The remaining flags 
 * currently have no effect here. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1777"></a><span class='Declare_Function'>BufferSync</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>flags</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1779"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>buf_state</span><span class='Delimiter'>; 
</span><a name="LN1780"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>buf_id</span><span class='Delimiter'>; 
</span><a name="LN1781"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>num_to_scan</span><span class='Delimiter'>; 
</span><a name="LN1782"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>num_spaces</span><span class='Delimiter'>; 
</span><a name="LN1783"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>num_processed</span><span class='Delimiter'>; 
</span><a name="LN1784"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>num_written</span><span class='Delimiter'>; 
</span><a name="LN1785"></a>    <a href="bufmgr.c.html#LN82"><span class='Ref_to_Struct'>CkptTsStatus</span></a> <span class='Operator'>*</span><span class='Declare_Local'>per_ts_stat</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN1786"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>last_tsid</span><span class='Delimiter'>; 
</span><a name="LN1787"></a>    <a href="../../../include/lib/binaryheap.h.html#LN29"><span class='Ref_to_Struct'>binaryheap</span></a> <span class='Operator'>*</span><span class='Declare_Local'>ts_heap</span><span class='Delimiter'>; 
</span><a name="LN1788"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN1789"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>mask</span> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN58"><span class='Ref_to_Const'>BM_DIRTY</span></a><span class='Delimiter'>; 
</span><a name="LN1790"></a>    <a href="../../../include/storage/buf_internals.h.html#LN261"><span class='Ref_to_Struct'>WritebackContext</span></a> <span class='Declare_Local'>wb_context</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Make sure we can handle the pin inside SyncOneBuffer */ 
</span>    <a href="../../../include/utils/resowner_private.h.html#LN28"><span class='Ref_to_Proto'>ResourceOwnerEnlargeBuffers</span></a><span class='Parentheses'>(</span><a href="../../utils/resowner/resowner.c.html#LN137"><span class='Ref_to_Global_Var'>CurrentResourceOwner</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Unless this is a shutdown checkpoint or we have been explicitly told, 
     * we write only permanent, dirty buffers.  But at shutdown or end of 
     * recovery, we write all dirty buffers. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>((</span><a href="bufmgr.c.html#LN1777"><span class='Ref_to_Parameter'>flags</span></a> <span class='Operator'>& </span><span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN174"><span class='Ref_to_Const'>CHECKPOINT_IS_SHUTDOWN</span></a> <span class='Operator'>| </span><a href="../../../include/access/xlog.h.html#LN175"><span class='Ref_to_Const'>CHECKPOINT_END_OF_RECOVERY</span></a> <span class='Operator'>| 
</span>                    <a href="../../../include/access/xlog.h.html#LN180"><span class='Ref_to_Const'>CHECKPOINT_FLUSH_ALL</span></a><span class='Parentheses'>))))</span> 
        <a href="bufmgr.c.html#LN1789"><span class='Ref_To_Local'>mask</span></a> <span class='Operator'>|= </span><a href="../../../include/storage/buf_internals.h.html#LN66"><span class='Ref_to_Const'>BM_PERMANENT</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Loop over all buffers, and mark the ones that need to be written with 
     * BM_CHECKPOINT_NEEDED.  Count them as we go (num_to_scan), so that we 
     * can estimate how much work needs to be done. 
     * 
     * This allows us to write only those pages that were dirty when the 
     * checkpoint began, and not those that get dirtied while it proceeds. 
     * Whenever a page with BM_CHECKPOINT_NEEDED is written out, either by us 
     * later in this function, or by normal backends or the bgwriter cleaning 
     * scan, the flag is cleared.  Any buffer dirtied after this point won't 
     * have the flag set. 
     * 
     * Note that if we fail to write some buffer, we may leave buffers with 
     * BM_CHECKPOINT_NEEDED still set.  This is OK since any such buffer would 
     * certainly need to be written for the next checkpoint attempt, too. 
     */ 
</span>    <a href="bufmgr.c.html#LN1781"><span class='Ref_To_Local'>num_to_scan</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1780"><span class='Ref_To_Local'>buf_id</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="bufmgr.c.html#LN1780"><span class='Ref_To_Local'>buf_id</span></a> <span class='Operator'>&LT; </span><a href="../../utils/init/globals.c.html#LN122"><span class='Ref_to_Global_Var'>NBuffers</span></a><span class='Delimiter'>; </span><a href="bufmgr.c.html#LN1780"><span class='Ref_To_Local'>buf_id</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1823"></a>        <a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>bufHdr</span> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN219"><span class='Ref_to_Macro'>GetBufferDescriptor</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1780"><span class='Ref_To_Local'>buf_id</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Header spinlock is enough to examine BM_DIRTY, see comment in 
         * SyncOneBuffer. 
         */ 
</span>        <a href="bufmgr.c.html#LN1779"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN242"><span class='Ref_to_Proto'>LockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1823"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="bufmgr.c.html#LN1779"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>& </span><a href="bufmgr.c.html#LN1789"><span class='Ref_To_Local'>mask</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="bufmgr.c.html#LN1789"><span class='Ref_To_Local'>mask</span></a><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span><a name="LN1833"></a>            <a href="../../../include/storage/buf_internals.h.html#LN288"><span class='Ref_to_Struct'>CkptSortItem</span></a> <span class='Operator'>*</span><span class='Declare_Local'>item</span><span class='Delimiter'>; 
</span> 
            <a href="bufmgr.c.html#LN1779"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>|= </span><a href="../../../include/storage/buf_internals.h.html#LN65"><span class='Ref_to_Const'>BM_CHECKPOINT_NEEDED</span></a><span class='Delimiter'>; 
</span> 
            <a href="bufmgr.c.html#LN1833"><span class='Ref_To_Local'>item</span></a> <span class='Operator'>= &</span><a href="buf_init.c.html#LN24"><span class='Ref_to_Global_Var'>CkptBufferIds</span></a><span class='Delimiter'>[</span><a href="bufmgr.c.html#LN1781"><span class='Ref_To_Local'>num_to_scan</span></a><span class='Operator'>++</span><span class='Delimiter'>]; 
</span>            <a href="bufmgr.c.html#LN1833"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN294"><span class='Ref_to_Member'>buf_id</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN1780"><span class='Ref_To_Local'>buf_id</span></a><span class='Delimiter'>; 
</span>            <a href="bufmgr.c.html#LN1833"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN290"><span class='Ref_to_Member'>tsId</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN1823"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN92"><span class='Ref_to_Member'>rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN58"><span class='Ref_to_Member'>spcNode</span></a><span class='Delimiter'>; 
</span>            <a href="bufmgr.c.html#LN1833"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN291"><span class='Ref_to_Member'>relNode</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN1823"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN92"><span class='Ref_to_Member'>rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN60"><span class='Ref_to_Member'>relNode</span></a><span class='Delimiter'>; 
</span>            <a href="bufmgr.c.html#LN1833"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN292"><span class='Ref_to_Member'>forkNum</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN1823"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN93"><span class='Ref_to_Member'>forkNum</span></a><span class='Delimiter'>; 
</span>            <a href="bufmgr.c.html#LN1833"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN293"><span class='Ref_to_Member'>blockNum</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN1823"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN94"><span class='Ref_to_Member'>blockNum</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1823"><span class='Ref_To_Local'>bufHdr</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN1779"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for buf_id=0;buf_id&LT;NBuff... &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1781"><span class='Ref_To_Local'>num_to_scan</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>;</span>                 <span class='Comment_Single_Line'>/* nothing to do */ 
</span> 
    <a href="../../../include/storage/buf_internals.h.html#LN303"><span class='Ref_to_Proto'>WritebackContextInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN1790"><span class='Ref_To_Local'>wb_context</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="bufmgr.c.html#LN117"><span class='Ref_to_Global_Var'>checkpoint_flush_after</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    TRACE_POSTGRESQL_BUFFER_SYNC_START<span class='Parentheses'>(</span><a href="../../utils/init/globals.c.html#LN122"><span class='Ref_to_Global_Var'>NBuffers</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN1781"><span class='Ref_To_Local'>num_to_scan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Sort buffers that need to be written to reduce the likelihood of random 
     * IO. The sorting is also important for the implementation of balancing 
     * writes between tablespaces. Without balancing writes we'd potentially 
     * end up writing to the tablespaces one-by-one; possibly overloading the 
     * underlying system. 
     */ 
</span>    <a href="../../../include/port.h.html#LN439"><span class='Ref_to_Macro'>qsort</span></a><span class='Parentheses'>(</span><a href="buf_init.c.html#LN24"><span class='Ref_to_Global_Var'>CkptBufferIds</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN1781"><span class='Ref_To_Local'>num_to_scan</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN288"><span class='Ref_to_Struct'>CkptSortItem</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>          <a href="bufmgr.c.html#LN457"><span class='Ref_to_Proto'>ckpt_buforder_comparator</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="bufmgr.c.html#LN1782"><span class='Ref_To_Local'>num_spaces</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Allocate progress status for each tablespace with buffers that need to 
     * be flushed. This requires the to-be-flushed array to be sorted. 
     */ 
</span>    <a href="bufmgr.c.html#LN1786"><span class='Ref_To_Local'>last_tsid</span></a> <span class='Operator'>= </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1788"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="bufmgr.c.html#LN1788"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="bufmgr.c.html#LN1781"><span class='Ref_To_Local'>num_to_scan</span></a><span class='Delimiter'>; </span><a href="bufmgr.c.html#LN1788"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1874"></a>        <a href="bufmgr.c.html#LN82"><span class='Ref_to_Struct'>CkptTsStatus</span></a> <span class='Operator'>*</span><span class='Declare_Local'>s</span><span class='Delimiter'>; 
</span><a name="LN1875"></a>        <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>cur_tsid</span><span class='Delimiter'>; 
</span> 
        <a href="bufmgr.c.html#LN1875"><span class='Ref_To_Local'>cur_tsid</span></a> <span class='Operator'>= </span><a href="buf_init.c.html#LN24"><span class='Ref_to_Global_Var'>CkptBufferIds</span></a><span class='Delimiter'>[</span><a href="bufmgr.c.html#LN1788"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN290"><span class='Ref_to_Member'>tsId</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Grow array of per-tablespace status structs, every time a new 
         * tablespace is found. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1786"><span class='Ref_To_Local'>last_tsid</span></a> <span class='Operator'>== </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a> <span class='Operator'>|| </span><a href="bufmgr.c.html#LN1786"><span class='Ref_To_Local'>last_tsid</span></a> <span class='Operator'>!= </span><a href="bufmgr.c.html#LN1875"><span class='Ref_To_Local'>cur_tsid</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1885"></a>            <a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Local'>sz</span><span class='Delimiter'>; 
</span> 
            <a href="bufmgr.c.html#LN1782"><span class='Ref_To_Local'>num_spaces</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Not worth adding grow-by-power-of-2 logic here - even with a 
             * few hundred tablespaces this should be fine. 
             */ 
</span>            <a href="bufmgr.c.html#LN1885"><span class='Ref_To_Local'>sz</span></a> <span class='Operator'>= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN82"><span class='Ref_to_Struct'>CkptTsStatus</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="bufmgr.c.html#LN1782"><span class='Ref_To_Local'>num_spaces</span></a><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1785"><span class='Ref_To_Local'>per_ts_stat</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>                <a href="bufmgr.c.html#LN1785"><span class='Ref_To_Local'>per_ts_stat</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN82"><span class='Ref_to_Struct'>CkptTsStatus</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1885"><span class='Ref_To_Local'>sz</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="bufmgr.c.html#LN1785"><span class='Ref_To_Local'>per_ts_stat</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN82"><span class='Ref_to_Struct'>CkptTsStatus</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN36"><span class='Ref_to_Proto'>repalloc</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1785"><span class='Ref_To_Local'>per_ts_stat</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN1885"><span class='Ref_To_Local'>sz</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="bufmgr.c.html#LN1874"><span class='Ref_To_Local'>s</span></a> <span class='Operator'>= &</span><a href="bufmgr.c.html#LN1785"><span class='Ref_To_Local'>per_ts_stat</span></a><span class='Delimiter'>[</span><a href="bufmgr.c.html#LN1782"><span class='Ref_To_Local'>num_spaces</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span>            memset<span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1874"><span class='Ref_To_Local'>s</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="bufmgr.c.html#LN1874"><span class='Ref_To_Local'>s</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="bufmgr.c.html#LN1874"><span class='Ref_To_Local'>s</span></a><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN85"><span class='Ref_to_Member'>tsId</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN1875"><span class='Ref_To_Local'>cur_tsid</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * The first buffer in this tablespace. As CkptBufferIds is sorted 
             * by tablespace all (s-&GT;num_to_scan) buffers in this tablespace 
             * will follow afterwards. 
             */ 
</span>            <a href="bufmgr.c.html#LN1874"><span class='Ref_To_Local'>s</span></a><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN103"><span class='Ref_to_Member'>index</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN1788"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * progress_slice will be determined once we know how many buffers 
             * are in each tablespace, i.e. after this loop. 
             */ 
</span> 
            <a href="bufmgr.c.html#LN1786"><span class='Ref_To_Local'>last_tsid</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN1875"><span class='Ref_To_Local'>cur_tsid</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if last_tsid==InvalidOid... &raquo; </span> 
        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="bufmgr.c.html#LN1874"><span class='Ref_To_Local'>s</span></a> <span class='Operator'>= &</span><a href="bufmgr.c.html#LN1785"><span class='Ref_To_Local'>per_ts_stat</span></a><span class='Delimiter'>[</span><a href="bufmgr.c.html#LN1782"><span class='Ref_To_Local'>num_spaces</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="bufmgr.c.html#LN1874"><span class='Ref_To_Local'>s</span></a><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN98"><span class='Ref_to_Member'>num_to_scan</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;num_to_scan;i++ &raquo; </span> 
 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1782"><span class='Ref_To_Local'>num_spaces</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Build a min-heap over the write-progress in the individual tablespaces, 
     * and compute how large a portion of the total progress a single 
     * processed buffer is. 
     */ 
</span>    <a href="bufmgr.c.html#LN1787"><span class='Ref_To_Local'>ts_heap</span></a> <span class='Operator'>= </span><a href="../../lib/binaryheap.c.html#LN31"><span class='Ref_to_Func'>binaryheap_allocate</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1782"><span class='Ref_To_Local'>num_spaces</span></a><span class='Delimiter'>, 
</span>                                  <a href="bufmgr.c.html#LN458"><span class='Ref_to_Proto'>ts_ckpt_progress_comparator</span></a><span class='Delimiter'>, 
</span>                                  <span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1788"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="bufmgr.c.html#LN1788"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="bufmgr.c.html#LN1782"><span class='Ref_To_Local'>num_spaces</span></a><span class='Delimiter'>; </span><a href="bufmgr.c.html#LN1788"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1939"></a>        <a href="bufmgr.c.html#LN82"><span class='Ref_to_Struct'>CkptTsStatus</span></a> <span class='Operator'>*</span><span class='Declare_Local'>ts_stat</span> <span class='Operator'>= &</span><a href="bufmgr.c.html#LN1785"><span class='Ref_To_Local'>per_ts_stat</span></a><span class='Delimiter'>[</span><a href="bufmgr.c.html#LN1788"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
        <a href="bufmgr.c.html#LN1939"><span class='Ref_To_Local'>ts_stat</span></a><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN95"><span class='Ref_to_Member'>progress_slice</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN380"><span class='Ref_to_Typedef'>float8</span></a><span class='Parentheses'>) </span><a href="bufmgr.c.html#LN1781"><span class='Ref_To_Local'>num_to_scan</span></a> <span class='Operator'>/ </span><a href="bufmgr.c.html#LN1939"><span class='Ref_To_Local'>ts_stat</span></a><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN98"><span class='Ref_to_Member'>num_to_scan</span></a><span class='Delimiter'>; 
</span> 
        <a href="../../../include/lib/binaryheap.h.html#LN44"><span class='Ref_to_Proto'>binaryheap_add_unordered</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1787"><span class='Ref_To_Local'>ts_heap</span></a><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1939"><span class='Ref_To_Local'>ts_stat</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/lib/binaryheap.h.html#LN45"><span class='Ref_to_Proto'>binaryheap_build</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1787"><span class='Ref_To_Local'>ts_heap</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Iterate through to-be-checkpointed buffers and write the ones (still) 
     * marked with BM_CHECKPOINT_NEEDED. The writes are balanced between 
     * tablespaces; otherwise the sorting would lead to only one tablespace 
     * receiving writes at a time, making inefficient use of the hardware. 
     */ 
</span>    <a href="bufmgr.c.html#LN1783"><span class='Ref_To_Local'>num_processed</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="bufmgr.c.html#LN1784"><span class='Ref_To_Local'>num_written</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/lib/binaryheap.h.html#LN51"><span class='Ref_to_Macro'>binaryheap_empty</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1787"><span class='Ref_To_Local'>ts_heap</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1958"></a>        <a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>bufHdr</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN1959"></a>        <a href="bufmgr.c.html#LN82"><span class='Ref_to_Struct'>CkptTsStatus</span></a> <span class='Operator'>*</span><span class='Declare_Local'>ts_stat</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN82"><span class='Ref_to_Struct'>CkptTsStatus</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>        <a href="../../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><a href="../../../include/lib/binaryheap.h.html#LN47"><span class='Ref_to_Proto'>binaryheap_first</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1787"><span class='Ref_To_Local'>ts_heap</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <a href="bufmgr.c.html#LN1780"><span class='Ref_To_Local'>buf_id</span></a> <span class='Operator'>= </span><a href="buf_init.c.html#LN24"><span class='Ref_to_Global_Var'>CkptBufferIds</span></a><span class='Delimiter'>[</span><a href="bufmgr.c.html#LN1959"><span class='Ref_To_Local'>ts_stat</span></a><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN103"><span class='Ref_to_Member'>index</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN294"><span class='Ref_to_Member'>buf_id</span></a><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1780"><span class='Ref_To_Local'>buf_id</span></a> <span class='Operator'>!= -</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="bufmgr.c.html#LN1958"><span class='Ref_To_Local'>bufHdr</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN219"><span class='Ref_to_Macro'>GetBufferDescriptor</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1780"><span class='Ref_To_Local'>buf_id</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="bufmgr.c.html#LN1783"><span class='Ref_To_Local'>num_processed</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We don't need to acquire the lock here, because we're only looking 
         * at a single bit. It's possible that someone else writes the buffer 
         * and clears the flag right after we check, but that doesn't matter 
         * since SyncOneBuffer will then do nothing.  However, there is a 
         * further race condition: it's conceivable that between the time we 
         * examine the bit here and the time SyncOneBuffer acquires the lock, 
         * someone else not only wrote the buffer but replaced it with another 
         * page and dirtied it.  In that improbable case, SyncOneBuffer will 
         * write the buffer though we didn't need to.  It doesn't seem worth 
         * guarding against this, though. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/port/atomics.h.html#LN250"><span class='Ref_to_Func'>pg_atomic_read_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN1958"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN183"><span class='Ref_to_Member'>state</span></a><span class='Parentheses'>) </span><span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN65"><span class='Ref_to_Const'>BM_CHECKPOINT_NEEDED</span></a><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN439"><span class='Ref_to_Proto'>SyncOneBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1780"><span class='Ref_To_Local'>buf_id</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="bufmgr.c.html#LN1790"><span class='Ref_To_Local'>wb_context</span></a><span class='Parentheses'>) </span><span class='Operator'>& </span><a href="bufmgr.c.html#LN64"><span class='Ref_to_Const'>BUF_WRITTEN</span></a><span class='Parentheses'>)</span> 
            <span class='Delimiter'>{ 
</span>                TRACE_POSTGRESQL_BUFFER_SYNC_WRITTEN<span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1780"><span class='Ref_To_Local'>buf_id</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../postmaster/pgstat.c.html#LN142"><span class='Ref_to_Global_Var'>BgWriterStats</span></a><span class='Operator'>.</span><a href="../../../include/pgstat.h.html#LN414"><span class='Ref_to_Member'>m_buf_written_checkpoints</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>                <a href="bufmgr.c.html#LN1784"><span class='Ref_To_Local'>num_written</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Measure progress independent of actually having to flush the buffer 
         * - otherwise writing become unbalanced. 
         */ 
</span>        <a href="bufmgr.c.html#LN1959"><span class='Ref_To_Local'>ts_stat</span></a><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN94"><span class='Ref_to_Member'>progress</span></a> <span class='Operator'>+= </span><a href="bufmgr.c.html#LN1959"><span class='Ref_To_Local'>ts_stat</span></a><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN95"><span class='Ref_to_Member'>progress_slice</span></a><span class='Delimiter'>; 
</span>        <a href="bufmgr.c.html#LN1959"><span class='Ref_To_Local'>ts_stat</span></a><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN100"><span class='Ref_to_Member'>num_scanned</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <a href="bufmgr.c.html#LN1959"><span class='Ref_To_Local'>ts_stat</span></a><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN103"><span class='Ref_to_Member'>index</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Have all the buffers from the tablespace been processed? */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1959"><span class='Ref_To_Local'>ts_stat</span></a><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN100"><span class='Ref_to_Member'>num_scanned</span></a> <span class='Operator'>== </span><a href="bufmgr.c.html#LN1959"><span class='Ref_To_Local'>ts_stat</span></a><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN98"><span class='Ref_to_Member'>num_to_scan</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../../include/lib/binaryheap.h.html#LN48"><span class='Ref_to_Proto'>binaryheap_remove_first</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1787"><span class='Ref_To_Local'>ts_heap</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* update heap with the new progress */ 
</span>            <a href="../../../include/lib/binaryheap.h.html#LN49"><span class='Ref_to_Proto'>binaryheap_replace_first</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1787"><span class='Ref_To_Local'>ts_heap</span></a><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1959"><span class='Ref_To_Local'>ts_stat</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Sleep to throttle our I/O rate. 
         */ 
</span>        <a href="../../../include/postmaster/bgwriter.h.html#LN31"><span class='Ref_to_Proto'>CheckpointWriteDelay</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1777"><span class='Ref_to_Parameter'>flags</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="bufmgr.c.html#LN1783"><span class='Ref_To_Local'>num_processed</span></a> <span class='Operator'>/ </span><a href="bufmgr.c.html#LN1781"><span class='Ref_To_Local'>num_to_scan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while !binaryheap_empty(ts_... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* issue all pending flushes */ 
</span>    <a href="../../../include/storage/buf_internals.h.html#LN304"><span class='Ref_to_Proto'>IssuePendingWritebacks</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN1790"><span class='Ref_To_Local'>wb_context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1785"><span class='Ref_To_Local'>per_ts_stat</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="bufmgr.c.html#LN1785"><span class='Ref_To_Local'>per_ts_stat</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="../../../include/lib/binaryheap.h.html#LN43"><span class='Ref_to_Proto'>binaryheap_free</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN1787"><span class='Ref_To_Local'>ts_heap</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Update checkpoint statistics. As noted above, this doesn't include 
     * buffers written by other backends or bgwriter scan. 
     */ 
</span>    <a href="../../access/transam/xlog.c.html#LN172"><span class='Ref_to_Global_Var'>CheckpointStats</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog.h.html#LN204"><span class='Ref_to_Member'>ckpt_bufs_written</span></a> <span class='Operator'>+= </span><a href="bufmgr.c.html#LN1784"><span class='Ref_To_Local'>num_written</span></a><span class='Delimiter'>; 
</span> 
    TRACE_POSTGRESQL_BUFFER_SYNC_DONE<span class='Parentheses'>(</span><a href="../../utils/init/globals.c.html#LN122"><span class='Ref_to_Global_Var'>NBuffers</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN1784"><span class='Ref_To_Local'>num_written</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN1781"><span class='Ref_To_Local'>num_to_scan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end BufferSync &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * BgBufferSync -- Write out some dirty buffers in the pool. 
 * 
 * This is called periodically by the background writer process. 
 * 
 * Returns true if it's appropriate for the bgwriter process to go into 
 * low-power hibernation mode.  (This happens if the strategy clock sweep 
 * has been "lapped" and no buffer allocations have occurred recently, 
 * or if the bgwriter has been effectively disabled by setting 
 * bgwriter_lru_maxpages to 0.) 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN2044"></a><span class='Declare_Function'>BgBufferSync</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN261"><span class='Ref_to_Struct'>WritebackContext</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>wb_context</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* info obtained from freelist.c */ 
</span><a name="LN2047"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>strategy_buf_id</span><span class='Delimiter'>; 
</span><a name="LN2048"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>strategy_passes</span><span class='Delimiter'>; 
</span><a name="LN2049"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>recent_alloc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Information saved between calls so we can determine the strategy 
     * point's advance rate and avoid scanning already-cleaned buffers. 
     */ 
</span><a name="LN2055"></a>    <span class='Keyword'>static bool </span><span class='Declare_Local'>saved_info_valid</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN2056"></a>    <span class='Keyword'>static int</span>  <span class='Declare_Local'>prev_strategy_buf_id</span><span class='Delimiter'>; 
</span><a name="LN2057"></a>    <span class='Keyword'>static </span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Local'>prev_strategy_passes</span><span class='Delimiter'>; 
</span><a name="LN2058"></a>    <span class='Keyword'>static int</span>  <span class='Declare_Local'>next_to_clean</span><span class='Delimiter'>; 
</span><a name="LN2059"></a>    <span class='Keyword'>static </span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Local'>next_passes</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Moving averages of allocation rate and clean-buffer density */ 
</span><a name="LN2062"></a>    <span class='Keyword'>static float </span><span class='Declare_Local'>smoothed_alloc</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN2063"></a>    <span class='Keyword'>static float </span><span class='Declare_Local'>smoothed_density</span> <span class='Operator'>= </span><span class='Number'>10</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Potentially these could be tunables, but for now, not */ 
</span><a name="LN2066"></a>    <span class='Keyword'>float</span>       <span class='Declare_Local'>smoothing_samples</span> <span class='Operator'>= </span><span class='Number'>16</span><span class='Delimiter'>; 
</span><a name="LN2067"></a>    <span class='Keyword'>float</span>       <span class='Declare_Local'>scan_whole_pool_milliseconds</span> <span class='Operator'>= </span><span class='Number'>120000</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Used to compute how far we scan ahead */ 
</span><a name="LN2070"></a>    <span class='Keyword'>long</span>        <span class='Declare_Local'>strategy_delta</span><span class='Delimiter'>; 
</span><a name="LN2071"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>bufs_to_lap</span><span class='Delimiter'>; 
</span><a name="LN2072"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>bufs_ahead</span><span class='Delimiter'>; 
</span><a name="LN2073"></a>    <span class='Keyword'>float</span>       <span class='Declare_Local'>scans_per_alloc</span><span class='Delimiter'>; 
</span><a name="LN2074"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>reusable_buffers_est</span><span class='Delimiter'>; 
</span><a name="LN2075"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>upcoming_alloc_est</span><span class='Delimiter'>; 
</span><a name="LN2076"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>min_scan_buffers</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Variables for the scanning loop proper */ 
</span><a name="LN2079"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>num_to_scan</span><span class='Delimiter'>; 
</span><a name="LN2080"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>num_written</span><span class='Delimiter'>; 
</span><a name="LN2081"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>reusable_buffers</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Variables for final smoothed_density update */ 
</span><a name="LN2084"></a>    <span class='Keyword'>long</span>        <span class='Declare_Local'>new_strategy_delta</span><span class='Delimiter'>; 
</span><a name="LN2085"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>new_recent_alloc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Find out where the freelist clock sweep currently is, and how many 
     * buffer allocations have happened since our last call. 
     */ 
</span>    <a href="bufmgr.c.html#LN2047"><span class='Ref_To_Local'>strategy_buf_id</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN314"><span class='Ref_to_Proto'>StrategySyncStart</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN2048"><span class='Ref_To_Local'>strategy_passes</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="bufmgr.c.html#LN2049"><span class='Ref_To_Local'>recent_alloc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Report buffer alloc counts to pgstat */ 
</span>    <a href="../../postmaster/pgstat.c.html#LN142"><span class='Ref_to_Global_Var'>BgWriterStats</span></a><span class='Operator'>.</span><a href="../../../include/pgstat.h.html#LN419"><span class='Ref_to_Member'>m_buf_alloc</span></a> <span class='Operator'>+= </span><a href="bufmgr.c.html#LN2049"><span class='Ref_To_Local'>recent_alloc</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we're not running the LRU scan, just stop after doing the stats 
     * stuff.  We mark the saved state invalid so that we can recover sanely 
     * if LRU scan is turned back on later. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN108"><span class='Ref_to_Global_Var'>bgwriter_lru_maxpages</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="bufmgr.c.html#LN2055"><span class='Ref_To_Local'>saved_info_valid</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Compute strategy_delta = how many buffers have been scanned by the 
     * clock sweep since last time.  If first time through, assume none. Then 
     * see if we are still ahead of the clock sweep, and if so, how many 
     * buffers we could scan before we'd catch up with it and "lap" it. Note: 
     * weird-looking coding of xxx_passes comparisons are to avoid bogus 
     * behavior when the passes counts wrap around. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2055"><span class='Ref_To_Local'>saved_info_valid</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2117"></a>        <a href="../../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>passes_delta</span> <span class='Operator'>= </span><a href="bufmgr.c.html#LN2048"><span class='Ref_To_Local'>strategy_passes</span></a> <span class='Operator'>- </span><a href="bufmgr.c.html#LN2057"><span class='Ref_To_Local'>prev_strategy_passes</span></a><span class='Delimiter'>; 
</span> 
        <a href="bufmgr.c.html#LN2070"><span class='Ref_To_Local'>strategy_delta</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN2047"><span class='Ref_To_Local'>strategy_buf_id</span></a> <span class='Operator'>- </span><a href="bufmgr.c.html#LN2056"><span class='Ref_To_Local'>prev_strategy_buf_id</span></a><span class='Delimiter'>; 
</span>        <a href="bufmgr.c.html#LN2070"><span class='Ref_To_Local'>strategy_delta</span></a> <span class='Operator'>+= </span><span class='Parentheses'>(</span><span class='Keyword'>long</span><span class='Parentheses'>) </span><a href="bufmgr.c.html#LN2117"><span class='Ref_To_Local'>passes_delta</span></a> <span class='Operator'>*</span><a href="../../utils/init/globals.c.html#LN122"><span class='Ref_to_Global_Var'>NBuffers</span></a><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2070"><span class='Ref_To_Local'>strategy_delta</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="../../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a><span class='Parentheses'>) (</span><a href="bufmgr.c.html#LN2059"><span class='Ref_To_Local'>next_passes</span></a> <span class='Operator'>- </span><a href="bufmgr.c.html#LN2048"><span class='Ref_To_Local'>strategy_passes</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* we're one pass ahead of the strategy point */ 
</span>            <a href="bufmgr.c.html#LN2071"><span class='Ref_To_Local'>bufs_to_lap</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN2047"><span class='Ref_To_Local'>strategy_buf_id</span></a> <span class='Operator'>- </span><a href="bufmgr.c.html#LN2058"><span class='Ref_To_Local'>next_to_clean</span></a><span class='Delimiter'>; 
</span><span class='Directive'>#ifdef</span> BGW_DEBUG 
            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, </span><span class='String'>"bgwriter ahead: bgw %u-%u strategy %u-%u delta=%ld lap=%d"</span><span class='Delimiter'>, 
</span>                 <a href="bufmgr.c.html#LN2059"><span class='Ref_To_Local'>next_passes</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2058"><span class='Ref_To_Local'>next_to_clean</span></a><span class='Delimiter'>, 
</span>                 <a href="bufmgr.c.html#LN2048"><span class='Ref_To_Local'>strategy_passes</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2047"><span class='Ref_To_Local'>strategy_buf_id</span></a><span class='Delimiter'>, 
</span>                 <a href="bufmgr.c.html#LN2070"><span class='Ref_To_Local'>strategy_delta</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2071"><span class='Ref_To_Local'>bufs_to_lap</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2059"><span class='Ref_To_Local'>next_passes</span></a> <span class='Operator'>== </span><a href="bufmgr.c.html#LN2048"><span class='Ref_To_Local'>strategy_passes</span></a> <span class='Operator'>&& 
</span>                 <a href="bufmgr.c.html#LN2058"><span class='Ref_To_Local'>next_to_clean</span></a> <span class='Operator'>&GT;= </span><a href="bufmgr.c.html#LN2047"><span class='Ref_To_Local'>strategy_buf_id</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* on same pass, but ahead or at least not behind */ 
</span>            <a href="bufmgr.c.html#LN2071"><span class='Ref_To_Local'>bufs_to_lap</span></a> <span class='Operator'>= </span><a href="../../utils/init/globals.c.html#LN122"><span class='Ref_to_Global_Var'>NBuffers</span></a> <span class='Operator'>- </span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2058"><span class='Ref_To_Local'>next_to_clean</span></a> <span class='Operator'>- </span><a href="bufmgr.c.html#LN2047"><span class='Ref_To_Local'>strategy_buf_id</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#ifdef</span> BGW_DEBUG 
            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, </span><span class='String'>"bgwriter ahead: bgw %u-%u strategy %u-%u delta=%ld lap=%d"</span><span class='Delimiter'>, 
</span>                 <a href="bufmgr.c.html#LN2059"><span class='Ref_To_Local'>next_passes</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2058"><span class='Ref_To_Local'>next_to_clean</span></a><span class='Delimiter'>, 
</span>                 <a href="bufmgr.c.html#LN2048"><span class='Ref_To_Local'>strategy_passes</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2047"><span class='Ref_To_Local'>strategy_buf_id</span></a><span class='Delimiter'>, 
</span>                 <a href="bufmgr.c.html#LN2070"><span class='Ref_To_Local'>strategy_delta</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2071"><span class='Ref_To_Local'>bufs_to_lap</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * We're behind, so skip forward to the strategy point and start 
             * cleaning from there. 
             */ 
</span><span class='Directive'>#ifdef</span> BGW_DEBUG 
            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, </span><span class='String'>"bgwriter behind: bgw %u-%u strategy %u-%u delta=%ld"</span><span class='Delimiter'>, 
</span>                 <a href="bufmgr.c.html#LN2059"><span class='Ref_To_Local'>next_passes</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2058"><span class='Ref_To_Local'>next_to_clean</span></a><span class='Delimiter'>, 
</span>                 <a href="bufmgr.c.html#LN2048"><span class='Ref_To_Local'>strategy_passes</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2047"><span class='Ref_To_Local'>strategy_buf_id</span></a><span class='Delimiter'>, 
</span>                 <a href="bufmgr.c.html#LN2070"><span class='Ref_To_Local'>strategy_delta</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
            <a href="bufmgr.c.html#LN2058"><span class='Ref_To_Local'>next_to_clean</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN2047"><span class='Ref_To_Local'>strategy_buf_id</span></a><span class='Delimiter'>; 
</span>            <a href="bufmgr.c.html#LN2059"><span class='Ref_To_Local'>next_passes</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN2048"><span class='Ref_To_Local'>strategy_passes</span></a><span class='Delimiter'>; 
</span>            <a href="bufmgr.c.html#LN2071"><span class='Ref_To_Local'>bufs_to_lap</span></a> <span class='Operator'>= </span><a href="../../utils/init/globals.c.html#LN122"><span class='Ref_to_Global_Var'>NBuffers</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if saved_info_valid &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Initializing at startup or after LRU scanning had been off. Always 
         * start at the strategy point. 
         */ 
</span><span class='Directive'>#ifdef</span> BGW_DEBUG 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, </span><span class='String'>"bgwriter initializing: strategy %u-%u"</span><span class='Delimiter'>, 
</span>             <a href="bufmgr.c.html#LN2048"><span class='Ref_To_Local'>strategy_passes</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2047"><span class='Ref_To_Local'>strategy_buf_id</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
        <a href="bufmgr.c.html#LN2070"><span class='Ref_To_Local'>strategy_delta</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="bufmgr.c.html#LN2058"><span class='Ref_To_Local'>next_to_clean</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN2047"><span class='Ref_To_Local'>strategy_buf_id</span></a><span class='Delimiter'>; 
</span>        <a href="bufmgr.c.html#LN2059"><span class='Ref_To_Local'>next_passes</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN2048"><span class='Ref_To_Local'>strategy_passes</span></a><span class='Delimiter'>; 
</span>        <a href="bufmgr.c.html#LN2071"><span class='Ref_To_Local'>bufs_to_lap</span></a> <span class='Operator'>= </span><a href="../../utils/init/globals.c.html#LN122"><span class='Ref_to_Global_Var'>NBuffers</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Update saved info for next time */ 
</span>    <a href="bufmgr.c.html#LN2056"><span class='Ref_To_Local'>prev_strategy_buf_id</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN2047"><span class='Ref_To_Local'>strategy_buf_id</span></a><span class='Delimiter'>; 
</span>    <a href="bufmgr.c.html#LN2057"><span class='Ref_To_Local'>prev_strategy_passes</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN2048"><span class='Ref_To_Local'>strategy_passes</span></a><span class='Delimiter'>; 
</span>    <a href="bufmgr.c.html#LN2055"><span class='Ref_To_Local'>saved_info_valid</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Compute how many buffers had to be scanned for each new allocation, ie, 
     * 1/density of reusable buffers, and track a moving average of that. 
     * 
     * If the strategy point didn't move, we don't update the density estimate 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2070"><span class='Ref_To_Local'>strategy_delta</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="bufmgr.c.html#LN2049"><span class='Ref_To_Local'>recent_alloc</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="bufmgr.c.html#LN2073"><span class='Ref_To_Local'>scans_per_alloc</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>float</span><span class='Parentheses'>) </span><a href="bufmgr.c.html#LN2070"><span class='Ref_To_Local'>strategy_delta</span></a> <span class='Operator'>/ </span><span class='Parentheses'>(</span><span class='Keyword'>float</span><span class='Parentheses'>) </span><a href="bufmgr.c.html#LN2049"><span class='Ref_To_Local'>recent_alloc</span></a><span class='Delimiter'>; 
</span>        <a href="bufmgr.c.html#LN2063"><span class='Ref_To_Local'>smoothed_density</span></a> <span class='Operator'>+= </span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2073"><span class='Ref_To_Local'>scans_per_alloc</span></a> <span class='Operator'>- </span><a href="bufmgr.c.html#LN2063"><span class='Ref_To_Local'>smoothed_density</span></a><span class='Parentheses'>) </span><span class='Operator'>/ 
</span>            <a href="bufmgr.c.html#LN2066"><span class='Ref_To_Local'>smoothing_samples</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Estimate how many reusable buffers there are between the current 
     * strategy point and where we've scanned ahead to, based on the smoothed 
     * density estimate. 
     */ 
</span>    <a href="bufmgr.c.html#LN2072"><span class='Ref_To_Local'>bufs_ahead</span></a> <span class='Operator'>= </span><a href="../../utils/init/globals.c.html#LN122"><span class='Ref_to_Global_Var'>NBuffers</span></a> <span class='Operator'>- </span><a href="bufmgr.c.html#LN2071"><span class='Ref_To_Local'>bufs_to_lap</span></a><span class='Delimiter'>; 
</span>    <a href="bufmgr.c.html#LN2074"><span class='Ref_To_Local'>reusable_buffers_est</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>float</span><span class='Parentheses'>) </span><a href="bufmgr.c.html#LN2072"><span class='Ref_To_Local'>bufs_ahead</span></a> <span class='Operator'>/ </span><a href="bufmgr.c.html#LN2063"><span class='Ref_To_Local'>smoothed_density</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Track a moving average of recent buffer allocations.  Here, rather than 
     * a true average we want a fast-attack, slow-decline behavior: we 
     * immediately follow any increase. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2062"><span class='Ref_To_Local'>smoothed_alloc</span></a> <span class='Operator'>&LT;= </span><span class='Parentheses'>(</span><span class='Keyword'>float</span><span class='Parentheses'>) </span><a href="bufmgr.c.html#LN2049"><span class='Ref_To_Local'>recent_alloc</span></a><span class='Parentheses'>)</span> 
        <a href="bufmgr.c.html#LN2062"><span class='Ref_To_Local'>smoothed_alloc</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN2049"><span class='Ref_To_Local'>recent_alloc</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="bufmgr.c.html#LN2062"><span class='Ref_To_Local'>smoothed_alloc</span></a> <span class='Operator'>+= </span><span class='Parentheses'>((</span><span class='Keyword'>float</span><span class='Parentheses'>) </span><a href="bufmgr.c.html#LN2049"><span class='Ref_To_Local'>recent_alloc</span></a> <span class='Operator'>- </span><a href="bufmgr.c.html#LN2062"><span class='Ref_To_Local'>smoothed_alloc</span></a><span class='Parentheses'>)</span> <span class='Operator'>/ 
</span>            <a href="bufmgr.c.html#LN2066"><span class='Ref_To_Local'>smoothing_samples</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Scale the estimate by a GUC to allow more aggressive tuning. */ 
</span>    <a href="bufmgr.c.html#LN2075"><span class='Ref_To_Local'>upcoming_alloc_est</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) (</span><a href="bufmgr.c.html#LN2062"><span class='Ref_To_Local'>smoothed_alloc</span></a> <span class='Operator'>* </span><a href="bufmgr.c.html#LN109"><span class='Ref_to_Global_Var'>bgwriter_lru_multiplier</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If recent_alloc remains at zero for many cycles, smoothed_alloc will 
     * eventually underflow to zero, and the underflows produce annoying 
     * kernel warnings on some platforms.  Once upcoming_alloc_est has gone to 
     * zero, there's no point in tracking smaller and smaller values of 
     * smoothed_alloc, so just reset it to exactly zero to avoid this 
     * syndrome.  It will pop back up as soon as recent_alloc increases. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2075"><span class='Ref_To_Local'>upcoming_alloc_est</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="bufmgr.c.html#LN2062"><span class='Ref_To_Local'>smoothed_alloc</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Even in cases where there's been little or no buffer allocation 
     * activity, we want to make a small amount of progress through the buffer 
     * cache so that as many reusable buffers as possible are clean after an 
     * idle period. 
     * 
     * (scan_whole_pool_milliseconds / BgWriterDelay) computes how many times 
     * the BGW will be called during the scan_whole_pool time; slice the 
     * buffer pool into that many sections. 
     */ 
</span>    <a href="bufmgr.c.html#LN2076"><span class='Ref_To_Local'>min_scan_buffers</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) (</span><a href="../../utils/init/globals.c.html#LN122"><span class='Ref_to_Global_Var'>NBuffers</span></a> <span class='Operator'>/ </span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2067"><span class='Ref_To_Local'>scan_whole_pool_milliseconds</span></a> <span class='Operator'>/ </span><a href="../../postmaster/bgwriter.c.html#LN66"><span class='Ref_to_Global_Var'>BgWriterDelay</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2075"><span class='Ref_To_Local'>upcoming_alloc_est</span></a> <span class='Operator'>&LT; </span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2076"><span class='Ref_To_Local'>min_scan_buffers</span></a> <span class='Operator'>+ </span><a href="bufmgr.c.html#LN2074"><span class='Ref_To_Local'>reusable_buffers_est</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><span class='Directive'>#ifdef</span> BGW_DEBUG 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, </span><span class='String'>"bgwriter: alloc_est=%d too small, using min=%d + reusable_est=%d"</span><span class='Delimiter'>, 
</span>             <a href="bufmgr.c.html#LN2075"><span class='Ref_To_Local'>upcoming_alloc_est</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2076"><span class='Ref_To_Local'>min_scan_buffers</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2074"><span class='Ref_To_Local'>reusable_buffers_est</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
        <a href="bufmgr.c.html#LN2075"><span class='Ref_To_Local'>upcoming_alloc_est</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN2076"><span class='Ref_To_Local'>min_scan_buffers</span></a> <span class='Operator'>+ </span><a href="bufmgr.c.html#LN2074"><span class='Ref_To_Local'>reusable_buffers_est</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now write out dirty reusable buffers, working forward from the 
     * next_to_clean point, until we have lapped the strategy scan, or cleaned 
     * enough buffers to match our estimate of the next cycle's allocation 
     * requirements, or hit the bgwriter_lru_maxpages limit. 
     */ 
</span> 
    <span class='Comment_Multi_Line'>/* Make sure we can handle the pin inside SyncOneBuffer */ 
</span>    <a href="../../../include/utils/resowner_private.h.html#LN28"><span class='Ref_to_Proto'>ResourceOwnerEnlargeBuffers</span></a><span class='Parentheses'>(</span><a href="../../utils/resowner/resowner.c.html#LN137"><span class='Ref_to_Global_Var'>CurrentResourceOwner</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="bufmgr.c.html#LN2079"><span class='Ref_To_Local'>num_to_scan</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN2071"><span class='Ref_To_Local'>bufs_to_lap</span></a><span class='Delimiter'>; 
</span>    <a href="bufmgr.c.html#LN2080"><span class='Ref_To_Local'>num_written</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="bufmgr.c.html#LN2081"><span class='Ref_To_Local'>reusable_buffers</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN2074"><span class='Ref_To_Local'>reusable_buffers_est</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Execute the LRU scan */ 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2079"><span class='Ref_To_Local'>num_to_scan</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="bufmgr.c.html#LN2081"><span class='Ref_To_Local'>reusable_buffers</span></a> <span class='Operator'>&LT; </span><a href="bufmgr.c.html#LN2075"><span class='Ref_To_Local'>upcoming_alloc_est</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2269"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>sync_state</span> <span class='Operator'>= </span><a href="bufmgr.c.html#LN439"><span class='Ref_to_Proto'>SyncOneBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2058"><span class='Ref_To_Local'>next_to_clean</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, 
</span>                                               <a href="bufmgr.c.html#LN2044"><span class='Ref_to_Parameter'>wb_context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>++</span><a href="bufmgr.c.html#LN2058"><span class='Ref_To_Local'>next_to_clean</span></a> <span class='Operator'>&GT;= </span><a href="../../utils/init/globals.c.html#LN122"><span class='Ref_to_Global_Var'>NBuffers</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="bufmgr.c.html#LN2058"><span class='Ref_To_Local'>next_to_clean</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <a href="bufmgr.c.html#LN2059"><span class='Ref_To_Local'>next_passes</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="bufmgr.c.html#LN2079"><span class='Ref_To_Local'>num_to_scan</span></a><span class='Operator'>--</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2269"><span class='Ref_To_Local'>sync_state</span></a> <span class='Operator'>& </span><a href="bufmgr.c.html#LN64"><span class='Ref_to_Const'>BUF_WRITTEN</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="bufmgr.c.html#LN2081"><span class='Ref_To_Local'>reusable_buffers</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>++</span><a href="bufmgr.c.html#LN2080"><span class='Ref_To_Local'>num_written</span></a> <span class='Operator'>&GT;= </span><a href="bufmgr.c.html#LN108"><span class='Ref_to_Global_Var'>bgwriter_lru_maxpages</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="../../postmaster/pgstat.c.html#LN142"><span class='Ref_to_Global_Var'>BgWriterStats</span></a><span class='Operator'>.</span><a href="../../../include/pgstat.h.html#LN416"><span class='Ref_to_Member'>m_maxwritten_clean</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2269"><span class='Ref_To_Local'>sync_state</span></a> <span class='Operator'>& </span><a href="bufmgr.c.html#LN65"><span class='Ref_to_Const'>BUF_REUSABLE</span></a><span class='Parentheses'>) 
</span>            <a href="bufmgr.c.html#LN2081"><span class='Ref_To_Local'>reusable_buffers</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while num_to_scan&GT;0&&reusab... &raquo; </span> 
 
    <a href="../../postmaster/pgstat.c.html#LN142"><span class='Ref_to_Global_Var'>BgWriterStats</span></a><span class='Operator'>.</span><a href="../../../include/pgstat.h.html#LN415"><span class='Ref_to_Member'>m_buf_written_clean</span></a> <span class='Operator'>+= </span><a href="bufmgr.c.html#LN2080"><span class='Ref_To_Local'>num_written</span></a><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> BGW_DEBUG 
    <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Delimiter'>, </span><span class='String'>"bgwriter: recent_alloc=%u smoothed=%.2f delta=%ld ahead=%d density=%.2f reusable_est=%d upcoming_est=%d scanned=%d wrote=%d reusable=%d"</span><span class='Delimiter'>, 
</span>         <a href="bufmgr.c.html#LN2049"><span class='Ref_To_Local'>recent_alloc</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2062"><span class='Ref_To_Local'>smoothed_alloc</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2070"><span class='Ref_To_Local'>strategy_delta</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2072"><span class='Ref_To_Local'>bufs_ahead</span></a><span class='Delimiter'>, 
</span>         <a href="bufmgr.c.html#LN2063"><span class='Ref_To_Local'>smoothed_density</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2074"><span class='Ref_To_Local'>reusable_buffers_est</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2075"><span class='Ref_To_Local'>upcoming_alloc_est</span></a><span class='Delimiter'>, 
</span>         <a href="bufmgr.c.html#LN2071"><span class='Ref_To_Local'>bufs_to_lap</span></a> <span class='Operator'>- </span><a href="bufmgr.c.html#LN2079"><span class='Ref_To_Local'>num_to_scan</span></a><span class='Delimiter'>, 
</span>         <a href="bufmgr.c.html#LN2080"><span class='Ref_To_Local'>num_written</span></a><span class='Delimiter'>, 
</span>         <a href="bufmgr.c.html#LN2081"><span class='Ref_To_Local'>reusable_buffers</span></a> <span class='Operator'>- </span><a href="bufmgr.c.html#LN2074"><span class='Ref_To_Local'>reusable_buffers_est</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Consider the above scan as being like a new allocation scan. 
     * Characterize its density and update the smoothed one based on it. This 
     * effectively halves the moving average period in cases where both the 
     * strategy and the background writer are doing some useful scanning, 
     * which is helpful because a long memory isn't as desirable on the 
     * density estimates. 
     */ 
</span>    <a href="bufmgr.c.html#LN2084"><span class='Ref_To_Local'>new_strategy_delta</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN2071"><span class='Ref_To_Local'>bufs_to_lap</span></a> <span class='Operator'>- </span><a href="bufmgr.c.html#LN2079"><span class='Ref_To_Local'>num_to_scan</span></a><span class='Delimiter'>; 
</span>    <a href="bufmgr.c.html#LN2085"><span class='Ref_To_Local'>new_recent_alloc</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN2081"><span class='Ref_To_Local'>reusable_buffers</span></a> <span class='Operator'>- </span><a href="bufmgr.c.html#LN2074"><span class='Ref_To_Local'>reusable_buffers_est</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2084"><span class='Ref_To_Local'>new_strategy_delta</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="bufmgr.c.html#LN2085"><span class='Ref_To_Local'>new_recent_alloc</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="bufmgr.c.html#LN2073"><span class='Ref_To_Local'>scans_per_alloc</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>float</span><span class='Parentheses'>) </span><a href="bufmgr.c.html#LN2084"><span class='Ref_To_Local'>new_strategy_delta</span></a> <span class='Operator'>/ </span><span class='Parentheses'>(</span><span class='Keyword'>float</span><span class='Parentheses'>) </span><a href="bufmgr.c.html#LN2085"><span class='Ref_To_Local'>new_recent_alloc</span></a><span class='Delimiter'>; 
</span>        <a href="bufmgr.c.html#LN2063"><span class='Ref_To_Local'>smoothed_density</span></a> <span class='Operator'>+= </span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2073"><span class='Ref_To_Local'>scans_per_alloc</span></a> <span class='Operator'>- </span><a href="bufmgr.c.html#LN2063"><span class='Ref_To_Local'>smoothed_density</span></a><span class='Parentheses'>) </span><span class='Operator'>/ 
</span>            <a href="bufmgr.c.html#LN2066"><span class='Ref_To_Local'>smoothing_samples</span></a><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> BGW_DEBUG 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, </span><span class='String'>"bgwriter: cleaner density alloc=%u scan=%ld density=%.2f new smoothed=%.2f"</span><span class='Delimiter'>, 
</span>             <a href="bufmgr.c.html#LN2085"><span class='Ref_To_Local'>new_recent_alloc</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2084"><span class='Ref_To_Local'>new_strategy_delta</span></a><span class='Delimiter'>, 
</span>             <a href="bufmgr.c.html#LN2073"><span class='Ref_To_Local'>scans_per_alloc</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2063"><span class='Ref_To_Local'>smoothed_density</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Return true if OK to hibernate */ 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2071"><span class='Ref_To_Local'>bufs_to_lap</span></a> <span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="bufmgr.c.html#LN2049"><span class='Ref_To_Local'>recent_alloc</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end BgBufferSync &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * SyncOneBuffer -- process a single buffer during syncing. 
 * 
 * If skip_recently_used is true, we don't write currently-pinned buffers, nor 
 * buffers marked recently used, as these are not replacement candidates. 
 * 
 * Returns a bitmask containing the following flag bits: 
 *  BUF_WRITTEN: we wrote the buffer. 
 *  BUF_REUSABLE: buffer is available for replacement, ie, it has 
 *      pin count 0 and usage count 0. 
 * 
 * (BUF_WRITTEN could be set in error if FlushBuffers finds the buffer clean 
 * after locking it, but we don't care all that much.) 
 * 
 * Note: caller must have done ResourceOwnerEnlargeBuffers. 
 */ 
</span><span class='Keyword'>static int 
</span><a name="LN2347"></a><span class='Declare_Function'>SyncOneBuffer</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>buf_id</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>skip_recently_used</span><span class='Delimiter'>, </span><a href="../../../include/storage/buf_internals.h.html#LN261"><span class='Ref_to_Struct'>WritebackContext</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>wb_context</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2349"></a>    <a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>bufHdr</span> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN219"><span class='Ref_to_Macro'>GetBufferDescriptor</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2347"><span class='Ref_to_Parameter'>buf_id</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2350"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>result</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN2351"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>buf_state</span><span class='Delimiter'>; 
</span><a name="LN2352"></a>    <a href="../../../include/storage/buf_internals.h.html#LN90"><span class='Ref_to_Typedef'>BufferTag</span></a>   <span class='Declare_Local'>tag</span><span class='Delimiter'>; 
</span> 
    <a href="bufmgr.c.html#LN173"><span class='Ref_to_Proto'>ReservePrivateRefCountEntry</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Check whether buffer needs writing. 
     * 
     * We can make this check without taking the buffer content lock so long 
     * as we mark pages dirty in access methods *before* logging changes with 
     * XLogInsert(): if someone marks the buffer dirty just after our check we 
     * don't worry because our checkpoint.redo points before log record for 
     * upcoming changes and so we are not required to write such dirty buffer. 
     */ 
</span>    <a href="bufmgr.c.html#LN2351"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN242"><span class='Ref_to_Proto'>LockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2349"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN48"><span class='Ref_to_Macro'>BUF_STATE_GET_REFCOUNT</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2351"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>&& 
</span>        <a href="../../../include/storage/buf_internals.h.html#LN49"><span class='Ref_to_Macro'>BUF_STATE_GET_USAGECOUNT</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2351"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <a href="bufmgr.c.html#LN2350"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>|= </span><a href="bufmgr.c.html#LN65"><span class='Ref_to_Const'>BUF_REUSABLE</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2347"><span class='Ref_to_Parameter'>skip_recently_used</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Caller told us not to write recently-used buffers */ 
</span>        <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2349"><span class='Ref_To_Local'>bufHdr</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2351"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <a href="bufmgr.c.html#LN2350"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2351"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN59"><span class='Ref_to_Const'>BM_VALID</span></a><span class='Parentheses'>) </span><span class='Operator'>|| !</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2351"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN58"><span class='Ref_to_Const'>BM_DIRTY</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* It's clean, so nothing to do */ 
</span>        <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2349"><span class='Ref_To_Local'>bufHdr</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2351"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <a href="bufmgr.c.html#LN2350"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Pin it, share-lock it, write it.  (FlushBuffer will do nothing if the 
     * buffer is clean by the time we've locked it.) 
     */ 
</span>    <a href="bufmgr.c.html#LN435"><span class='Ref_to_Proto'>PinBuffer_Locked</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2349"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN226"><span class='Ref_to_Macro'>BufferDescriptorGetContentLock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2349"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="bufmgr.c.html#LN452"><span class='Ref_to_Proto'>FlushBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2349"><span class='Ref_To_Local'>bufHdr</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN226"><span class='Ref_to_Macro'>BufferDescriptorGetContentLock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2349"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="bufmgr.c.html#LN2352"><span class='Ref_To_Local'>tag</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN2349"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Delimiter'>; 
</span> 
    <a href="bufmgr.c.html#LN436"><span class='Ref_to_Proto'>UnpinBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2349"><span class='Ref_To_Local'>bufHdr</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/buf_internals.h.html#LN305"><span class='Ref_to_Proto'>ScheduleBufferTagForWriteback</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2347"><span class='Ref_to_Parameter'>wb_context</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="bufmgr.c.html#LN2352"><span class='Ref_To_Local'>tag</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="bufmgr.c.html#LN2350"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>| </span><a href="bufmgr.c.html#LN64"><span class='Ref_to_Const'>BUF_WRITTEN</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end SyncOneBuffer &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *      AtEOXact_Buffers - clean up at end of transaction. 
 * 
 *      As of PostgreSQL 8.0, buffer pins should get released by the 
 *      ResourceOwner mechanism.  This routine is just a debugging 
 *      cross-check that no pins remain. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2414"></a><span class='Declare_Function'>AtEOXact_Buffers</span><span class='Parentheses'>(</span><span class='Keyword'>bool </span><span class='Declare_Parameter'>isCommit</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="bufmgr.c.html#LN454"><span class='Ref_to_Proto'>CheckForBufferLeaks</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/buf_internals.h.html#LN337"><span class='Ref_to_Proto'>AtEOXact_LocalBuffers</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2414"><span class='Ref_to_Parameter'>isCommit</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN169"><span class='Ref_to_Global_Var'>PrivateRefCountOverflowed</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Initialize access to shared buffer pool 
 * 
 * This is called during backend startup (whether standalone or under the 
 * postmaster).  It sets up for this backend's access to the already-existing 
 * buffer pool. 
 * 
 * NB: this is called before InitProcess(), so we do not have a PGPROC and 
 * cannot do LWLockAcquire; hence we can't actually access stuff in 
 * shared memory yet.  We are only initializing local data here. 
 * (See also InitBufferPoolBackend) 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2436"></a><span class='Declare_Function'>InitBufferPoolAccess</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2438"></a>    <a href="../../../include/utils/hsearch.h.html#LN64"><span class='Ref_to_Struct'>HASHCTL</span></a>     <span class='Declare_Local'>hash_ctl</span><span class='Delimiter'>; 
</span> 
    memset<span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN167"><span class='Ref_to_Global_Var'>PrivateRefCountArray</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN167"><span class='Ref_to_Global_Var'>PrivateRefCountArray</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN2438"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2438"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="bufmgr.c.html#LN2438"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Operator'>.</span><a href="../../../include/utils/hsearch.h.html#LN71"><span class='Ref_to_Member'>keysize</span></a> <span class='Operator'>= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="bufmgr.c.html#LN2438"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Operator'>.</span><a href="../../../include/utils/hsearch.h.html#LN72"><span class='Ref_to_Member'>entrysize</span></a> <span class='Operator'>= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN69"><span class='Ref_to_Struct'>PrivateRefCountEntry</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="bufmgr.c.html#LN168"><span class='Ref_to_Global_Var'>PrivateRefCountHash</span></a> <span class='Operator'>= </span><a href="../../../include/utils/hsearch.h.html#LN121"><span class='Ref_to_Proto'>hash_create</span></a><span class='Parentheses'>(</span><span class='String'>"PrivateRefCount"</span><span class='Delimiter'>, </span><span class='Number'>100</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="bufmgr.c.html#LN2438"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Delimiter'>, 
</span>                                      <a href="../../../include/utils/hsearch.h.html#LN86"><span class='Ref_to_Const'>HASH_ELEM</span></a> <span class='Operator'>| </span><a href="../../../include/utils/hsearch.h.html#LN87"><span class='Ref_to_Const'>HASH_BLOBS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * InitBufferPoolBackend --- second-stage initialization of a new backend 
 * 
 * This is called after we have acquired a PGPROC and so can safely get 
 * LWLocks.  We don't currently need to do anything at this stage ... 
 * except register a shmem-exit callback.  AtProcExit_Buffers needs LWLock 
 * access, and thereby has to be called at the corresponding phase of 
 * backend shutdown. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2460"></a><span class='Declare_Function'>InitBufferPoolBackend</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/storage/ipc.h.html#LN69"><span class='Ref_to_Proto'>on_shmem_exit</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN453"><span class='Ref_to_Proto'>AtProcExit_Buffers</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * During backend exit, ensure that we released all shared-buffer locks and 
 * assert that we have no remaining pins. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2470"></a><span class='Declare_Function'>AtProcExit_Buffers</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>code</span><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>arg</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/storage/bufmgr.h.html#LN221"><span class='Ref_to_Proto'>AbortBufferIO</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/bufmgr.h.html#LN213"><span class='Ref_to_Proto'>UnlockBuffers</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <a href="bufmgr.c.html#LN454"><span class='Ref_to_Proto'>CheckForBufferLeaks</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* localbuf.c needs a chance too */ 
</span>    <a href="../../../include/storage/bufmgr.h.html#LN226"><span class='Ref_to_Proto'>AtProcExit_LocalBuffers</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *      CheckForBufferLeaks - ensure this backend holds no buffer pins 
 * 
 *      As of PostgreSQL 8.0, buffer pins should get released by the 
 *      ResourceOwner mechanism.  This routine is just a debugging 
 *      cross-check that no pins remain. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2489"></a><span class='Declare_Function'>CheckForBufferLeaks</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><span class='Directive'>#ifdef</span> USE_ASSERT_CHECKING 
<a name="LN2492"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>RefCountErrors</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN2493"></a>    <a href="bufmgr.c.html#LN69"><span class='Ref_to_Struct'>PrivateRefCountEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>res</span><span class='Delimiter'>; 
</span><a name="LN2494"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* check the array */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2494"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="bufmgr.c.html#LN2494"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="bufmgr.c.html#LN76"><span class='Ref_to_Const'>REFCOUNT_ARRAY_ENTRIES</span></a><span class='Delimiter'>; </span><a href="bufmgr.c.html#LN2494"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="bufmgr.c.html#LN2493"><span class='Ref_To_Local'>res</span></a> <span class='Operator'>= &</span><a href="bufmgr.c.html#LN167"><span class='Ref_to_Global_Var'>PrivateRefCountArray</span></a><span class='Delimiter'>[</span><a href="bufmgr.c.html#LN2494"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2493"><span class='Ref_To_Local'>res</span></a><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN71"><span class='Ref_to_Member'>buffer</span></a> <span class='Operator'>!= </span><a href="../../../include/storage/buf.h.html#LN24"><span class='Ref_to_Const'>InvalidBuffer</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../../include/storage/bufmgr.h.html#LN185"><span class='Ref_to_Proto'>PrintBufferLeakWarning</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2493"><span class='Ref_To_Local'>res</span></a><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN71"><span class='Ref_to_Member'>buffer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="bufmgr.c.html#LN2492"><span class='Ref_To_Local'>RefCountErrors</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* if necessary search the hash */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN169"><span class='Ref_to_Global_Var'>PrivateRefCountOverflowed</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2511"></a>        <a href="../../../include/utils/hsearch.h.html#LN111"><span class='Ref_to_Typedef'>HASH_SEQ_STATUS</span></a> <span class='Declare_Local'>hstat</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/utils/hsearch.h.html#LN134"><span class='Ref_to_Proto'>hash_seq_init</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN2511"><span class='Ref_To_Local'>hstat</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN168"><span class='Ref_to_Global_Var'>PrivateRefCountHash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>while</span> <span class='Parentheses'>((</span><a href="bufmgr.c.html#LN2493"><span class='Ref_To_Local'>res</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN69"><span class='Ref_to_Struct'>PrivateRefCountEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/utils/hsearch.h.html#LN135"><span class='Ref_to_Proto'>hash_seq_search</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN2511"><span class='Ref_To_Local'>hstat</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../../include/storage/bufmgr.h.html#LN185"><span class='Ref_to_Proto'>PrintBufferLeakWarning</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2493"><span class='Ref_To_Local'>res</span></a><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN71"><span class='Ref_to_Member'>buffer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="bufmgr.c.html#LN2492"><span class='Ref_To_Local'>RefCountErrors</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
    <span class='Delimiter'>} 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2492"><span class='Ref_To_Local'>RefCountErrors</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end CheckForBufferLeaks &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Helper routine to issue warnings when a buffer is unexpectedly pinned 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2530"></a><span class='Declare_Function'>PrintBufferLeakWarning</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> <span class='Declare_Parameter'>buffer</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2532"></a>    <a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>buf</span><span class='Delimiter'>; 
</span><a name="LN2533"></a>    <a href="../../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>loccount</span><span class='Delimiter'>; 
</span><a name="LN2534"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>path</span><span class='Delimiter'>; 
</span><a name="LN2535"></a>    <a href="../../../include/storage/backendid.h.html#LN20"><span class='Ref_to_Typedef'>BackendId</span></a>   <span class='Declare_Local'>backend</span><span class='Delimiter'>; 
</span><a name="LN2536"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>buf_state</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/bufmgr.h.html#LN113"><span class='Ref_to_Macro'>BufferIsValid</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2530"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN36"><span class='Ref_to_Macro'>BufferIsLocal</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2530"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="bufmgr.c.html#LN2532"><span class='Ref_To_Local'>buf</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN220"><span class='Ref_to_Macro'>GetLocalBufferDescriptor</span></a><span class='Parentheses'>(</span><span class='Operator'>-</span><a href="bufmgr.c.html#LN2530"><span class='Ref_to_Parameter'>buffer</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="bufmgr.c.html#LN2533"><span class='Ref_To_Local'>loccount</span></a> <span class='Operator'>= </span><a href="localbuf.c.html#LN44"><span class='Ref_to_Global_Var'>LocalRefCount</span></a><span class='Delimiter'>[</span><span class='Operator'>-</span><a href="bufmgr.c.html#LN2530"><span class='Ref_to_Parameter'>buffer</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span>        <a href="bufmgr.c.html#LN2535"><span class='Ref_To_Local'>backend</span></a> <span class='Operator'>= </span><a href="../../utils/init/globals.c.html#LN72"><span class='Ref_to_Global_Var'>MyBackendId</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="bufmgr.c.html#LN2532"><span class='Ref_To_Local'>buf</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN219"><span class='Ref_to_Macro'>GetBufferDescriptor</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2530"><span class='Ref_to_Parameter'>buffer</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="bufmgr.c.html#LN2533"><span class='Ref_To_Local'>loccount</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN176"><span class='Ref_to_Proto'>GetPrivateRefCount</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2530"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="bufmgr.c.html#LN2535"><span class='Ref_To_Local'>backend</span></a> <span class='Operator'>= </span><a href="../../../include/storage/backendid.h.html#LN22"><span class='Ref_to_Const'>InvalidBackendId</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* theoretically we should lock the bufhdr here */ 
</span>    <a href="bufmgr.c.html#LN2534"><span class='Ref_To_Local'>path</span></a> <span class='Operator'>= </span><a href="../../../include/common/relpath.h.html#LN61"><span class='Ref_to_Macro'>relpathbackend</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2532"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN92"><span class='Ref_to_Member'>rnode</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2535"><span class='Ref_To_Local'>backend</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2532"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN93"><span class='Ref_to_Member'>forkNum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="bufmgr.c.html#LN2536"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>= </span><a href="../../../include/port/atomics.h.html#LN250"><span class='Ref_to_Func'>pg_atomic_read_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN2532"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN183"><span class='Ref_to_Member'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN39"><span class='Ref_to_Const'>WARNING</span></a><span class='Delimiter'>, 
</span>         <span class='String'>"buffer refcount leak: [%03d] "</span> 
         <span class='String'>"(rel=%s, blockNum=%u, flags=0x%x, refcount=%u %d)"</span><span class='Delimiter'>, 
</span>         <a href="bufmgr.c.html#LN2530"><span class='Ref_to_Parameter'>buffer</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2534"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, 
</span>         <a href="bufmgr.c.html#LN2532"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN94"><span class='Ref_to_Member'>blockNum</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2536"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN45"><span class='Ref_to_Const'>BUF_FLAG_MASK</span></a><span class='Delimiter'>, 
</span>         <a href="../../../include/storage/buf_internals.h.html#LN48"><span class='Ref_to_Macro'>BUF_STATE_GET_REFCOUNT</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2536"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2533"><span class='Ref_To_Local'>loccount</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2534"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end PrintBufferLeakWarning &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * CheckPointBuffers 
 * 
 * Flush all dirty blocks in buffer pool to disk at checkpoint time. 
 * 
 * Note: temporary relations do not participate in checkpoints, so they don't 
 * need to be flushed. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2573"></a><span class='Declare_Function'>CheckPointBuffers</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>flags</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    TRACE_POSTGRESQL_BUFFER_CHECKPOINT_START<span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2573"><span class='Ref_to_Parameter'>flags</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../access/transam/xlog.c.html#LN172"><span class='Ref_to_Global_Var'>CheckpointStats</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog.h.html#LN199"><span class='Ref_to_Member'>ckpt_write_t</span></a> <span class='Operator'>= </span><a href="../../../include/utils/timestamp.h.html#LN69"><span class='Ref_to_Proto'>GetCurrentTimestamp</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="bufmgr.c.html#LN437"><span class='Ref_to_Proto'>BufferSync</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2573"><span class='Ref_to_Parameter'>flags</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../access/transam/xlog.c.html#LN172"><span class='Ref_to_Global_Var'>CheckpointStats</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog.h.html#LN200"><span class='Ref_to_Member'>ckpt_sync_t</span></a> <span class='Operator'>= </span><a href="../../../include/utils/timestamp.h.html#LN69"><span class='Ref_to_Proto'>GetCurrentTimestamp</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    TRACE_POSTGRESQL_BUFFER_CHECKPOINT_SYNC_START<span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/smgr.h.html#LN109"><span class='Ref_to_Proto'>smgrsync</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="../../access/transam/xlog.c.html#LN172"><span class='Ref_to_Global_Var'>CheckpointStats</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog.h.html#LN201"><span class='Ref_to_Member'>ckpt_sync_end_t</span></a> <span class='Operator'>= </span><a href="../../../include/utils/timestamp.h.html#LN69"><span class='Ref_to_Proto'>GetCurrentTimestamp</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    TRACE_POSTGRESQL_BUFFER_CHECKPOINT_DONE<span class='Parentheses'>()</span><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Do whatever is needed to prepare for commit at the bufmgr and smgr levels 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2590"></a><span class='Declare_Function'>BufmgrCommit</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* Nothing to do in bufmgr anymore... */ 
</span><span class='Delimiter'>} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * BufferGetBlockNumber 
 *      Returns the block number associated with a buffer. 
 * 
 * Note: 
 *      Assumes that the buffer is valid and pinned, else the 
 *      value may be obsolete immediately... 
 */ 
</span><a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> 
<a name="LN2604"></a><span class='Declare_Function'>BufferGetBlockNumber</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> <span class='Declare_Parameter'>buffer</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2606"></a>    <a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>bufHdr</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN418"><span class='Ref_to_Macro'>BufferIsPinned</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2604"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN36"><span class='Ref_to_Macro'>BufferIsLocal</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2604"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span> 
        <a href="bufmgr.c.html#LN2606"><span class='Ref_To_Local'>bufHdr</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN220"><span class='Ref_to_Macro'>GetLocalBufferDescriptor</span></a><span class='Parentheses'>(</span><span class='Operator'>-</span><a href="bufmgr.c.html#LN2604"><span class='Ref_to_Parameter'>buffer</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="bufmgr.c.html#LN2606"><span class='Ref_To_Local'>bufHdr</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN219"><span class='Ref_to_Macro'>GetBufferDescriptor</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2604"><span class='Ref_to_Parameter'>buffer</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* pinned, so OK to read tag without spinlock */ 
</span>    <span class='Control'>return</span> <a href="bufmgr.c.html#LN2606"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN94"><span class='Ref_to_Member'>blockNum</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * BufferGetTag 
 *      Returns the relfilenode, fork number and block number associated with 
 *      a buffer. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2625"></a><span class='Declare_Function'>BufferGetTag</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> <span class='Declare_Parameter'>buffer</span><span class='Delimiter'>, </span><a href="../../../include/storage/relfilenode.h.html#LN56"><span class='Ref_to_Struct'>RelFileNode</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rnode</span><span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>forknum</span><span class='Delimiter'>, 
</span><a name="LN2626"></a>             <a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>blknum</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2628"></a>    <a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>bufHdr</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Do the same checks as BufferGetBlockNumber. */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN418"><span class='Ref_to_Macro'>BufferIsPinned</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2625"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN36"><span class='Ref_to_Macro'>BufferIsLocal</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2625"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span> 
        <a href="bufmgr.c.html#LN2628"><span class='Ref_To_Local'>bufHdr</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN220"><span class='Ref_to_Macro'>GetLocalBufferDescriptor</span></a><span class='Parentheses'>(</span><span class='Operator'>-</span><a href="bufmgr.c.html#LN2625"><span class='Ref_to_Parameter'>buffer</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="bufmgr.c.html#LN2628"><span class='Ref_To_Local'>bufHdr</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN219"><span class='Ref_to_Macro'>GetBufferDescriptor</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2625"><span class='Ref_to_Parameter'>buffer</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* pinned, so OK to read tag without spinlock */ 
</span>    <span class='Operator'>*</span><a href="bufmgr.c.html#LN2625"><span class='Ref_to_Parameter'>rnode</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN2628"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN92"><span class='Ref_to_Member'>rnode</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="bufmgr.c.html#LN2625"><span class='Ref_to_Parameter'>forknum</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN2628"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN93"><span class='Ref_to_Member'>forkNum</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="bufmgr.c.html#LN2626"><span class='Ref_to_Parameter'>blknum</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN2628"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN94"><span class='Ref_to_Member'>blockNum</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * FlushBuffer 
 *      Physically write out a shared buffer. 
 * 
 * NOTE: this actually just passes the buffer contents to the kernel; the 
 * real write to disk won't happen until the kernel feels like it.  This 
 * is okay from our point of view since we can redo the changes from WAL. 
 * However, we will need to force the changes to disk via fsync before 
 * we can checkpoint WAL. 
 * 
 * The caller must hold a pin on the buffer and have share-locked the 
 * buffer contents.  (Note: a share-lock does not prevent updates of 
 * hint bits in the buffer, so the page could change while the write 
 * is in progress, but we assume that that will not invalidate the data 
 * written.) 
 * 
 * If the caller has an smgr reference for the buffer's relation, pass it 
 * as the second parameter.  If not, pass NULL. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2664"></a><span class='Declare_Function'>FlushBuffer</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>buf</span><span class='Delimiter'>, </span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> <span class='Declare_Parameter'>reln</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2666"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>recptr</span><span class='Delimiter'>; 
</span><a name="LN2667"></a>    ErrorContextCallback <span class='Declare_Local'>errcallback</span><span class='Delimiter'>; 
</span><a name="LN2668"></a>    <a href="../../../include/portability/instr_time.h.html#LN146"><span class='Ref_to_Typedef'>instr_time</span></a>  <span class='Declare_Local'>io_start</span><span class='Delimiter'>, 
</span><a name="LN2669"></a>                <span class='Declare_Local'>io_time</span><span class='Delimiter'>; 
</span><a name="LN2670"></a>    <a href="../../../include/storage/bufmgr.h.html#LN24"><span class='Ref_to_Typedef'>Block</span></a>       <span class='Declare_Local'>bufBlock</span><span class='Delimiter'>; 
</span><a name="LN2671"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>bufToWrite</span><span class='Delimiter'>; 
</span><a name="LN2672"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>buf_state</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Acquire the buffer's io_in_progress lock.  If StartBufferIO returns 
     * false, then someone else flushed the buffer before we could, so we need 
     * not do anything. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="bufmgr.c.html#LN441"><span class='Ref_to_Proto'>StartBufferIO</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2664"><span class='Ref_to_Parameter'>buf</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Setup error traceback support for ereport() */ 
</span>    <a href="bufmgr.c.html#LN2667"><span class='Ref_To_Local'>errcallback</span></a><span class='Operator'>.</span>callback <span class='Operator'>= </span><a href="bufmgr.c.html#LN444"><span class='Ref_to_Proto'>shared_buffer_write_error_callback</span></a><span class='Delimiter'>; 
</span>    <a href="bufmgr.c.html#LN2667"><span class='Ref_To_Local'>errcallback</span></a><span class='Operator'>.</span>arg <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="bufmgr.c.html#LN2664"><span class='Ref_to_Parameter'>buf</span></a><span class='Delimiter'>; 
</span>    <a href="bufmgr.c.html#LN2667"><span class='Ref_To_Local'>errcallback</span></a><span class='Operator'>.</span>previous <span class='Operator'>= </span><a href="../../utils/error/elog.c.html#LN87"><span class='Ref_to_Global_Var'>error_context_stack</span></a><span class='Delimiter'>; 
</span>    <a href="../../utils/error/elog.c.html#LN87"><span class='Ref_to_Global_Var'>error_context_stack</span></a> <span class='Operator'>= &</span><a href="bufmgr.c.html#LN2667"><span class='Ref_To_Local'>errcallback</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Find smgr relation for buffer */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2664"><span class='Ref_to_Parameter'>reln</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="bufmgr.c.html#LN2664"><span class='Ref_to_Parameter'>reln</span></a> <span class='Operator'>= </span><a href="../../../include/storage/smgr.h.html#LN83"><span class='Ref_to_Proto'>smgropen</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2664"><span class='Ref_to_Parameter'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN92"><span class='Ref_to_Member'>rnode</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/backendid.h.html#LN22"><span class='Ref_to_Const'>InvalidBackendId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    TRACE_POSTGRESQL_BUFFER_FLUSH_START<span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2664"><span class='Ref_to_Parameter'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN93"><span class='Ref_to_Member'>forkNum</span></a><span class='Delimiter'>, 
</span>                                        <a href="bufmgr.c.html#LN2664"><span class='Ref_to_Parameter'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN94"><span class='Ref_to_Member'>blockNum</span></a><span class='Delimiter'>, 
</span>                                        <a href="bufmgr.c.html#LN2664"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN42"><span class='Ref_to_Member'>smgr_rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN73"><span class='Ref_to_Member'>node</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN58"><span class='Ref_to_Member'>spcNode</span></a><span class='Delimiter'>, 
</span>                                        <a href="bufmgr.c.html#LN2664"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN42"><span class='Ref_to_Member'>smgr_rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN73"><span class='Ref_to_Member'>node</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN59"><span class='Ref_to_Member'>dbNode</span></a><span class='Delimiter'>, 
</span>                                        <a href="bufmgr.c.html#LN2664"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN42"><span class='Ref_to_Member'>smgr_rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN73"><span class='Ref_to_Member'>node</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN60"><span class='Ref_to_Member'>relNode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="bufmgr.c.html#LN2672"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN242"><span class='Ref_to_Proto'>LockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2664"><span class='Ref_to_Parameter'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Run PageGetLSN while holding header lock, since we don't have the 
     * buffer locked exclusively in all cases. 
     */ 
</span>    <a href="bufmgr.c.html#LN2666"><span class='Ref_To_Local'>recptr</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN57"><span class='Ref_to_Macro'>BufferGetLSN</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2664"><span class='Ref_to_Parameter'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* To check if block content changes while flushing. - vadim 01/17/97 */ 
</span>    <a href="bufmgr.c.html#LN2672"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>&= ~</span><a href="../../../include/storage/buf_internals.h.html#LN63"><span class='Ref_to_Const'>BM_JUST_DIRTIED</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2664"><span class='Ref_to_Parameter'>buf</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2672"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Force XLOG flush up to buffer's LSN.  This implements the basic WAL 
     * rule that log updates must hit disk before any of the data-file changes 
     * they describe do. 
     * 
     * However, this rule does not apply to unlogged relations, which will be 
     * lost after a crash anyway.  Most unlogged relation pages do not bear 
     * LSNs since we never emit WAL records for them, and therefore flushing 
     * up through the buffer LSN would be useless, but harmless.  However, 
     * GiST indexes use LSNs internally to track page-splits, and therefore 
     * unlogged GiST pages bear "fake" LSNs generated by 
     * GetFakeLSNForUnloggedRel.  It is unlikely but possible that the fake 
     * LSN counter could advance past the WAL insertion point; and if it did 
     * happen, attempting to flush WAL through that location would fail, with 
     * disastrous system-wide consequences.  To make sure that can't happen, 
     * skip the flush if the buffer isn't permanent. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2672"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN66"><span class='Ref_to_Const'>BM_PERMANENT</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/access/xlog.h.html#LN225"><span class='Ref_to_Proto'>XLogFlush</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2666"><span class='Ref_To_Local'>recptr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now it's safe to write buffer to disk. Note that no one else should 
     * have been able to write it while we were busy with log flushing because 
     * we have the io_in_progress lock. 
     */ 
</span>    <a href="bufmgr.c.html#LN2670"><span class='Ref_To_Local'>bufBlock</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN56"><span class='Ref_to_Macro'>BufHdrGetBlock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2664"><span class='Ref_to_Parameter'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Update page checksum if desired.  Since we have only shared lock on the 
     * buffer, other processes might be updating hint bits in it, so we must 
     * copy the page to private storage if we do checksumming. 
     */ 
</span>    <a href="bufmgr.c.html#LN2671"><span class='Ref_To_Local'>bufToWrite</span></a> <span class='Operator'>= </span><a href="../../../include/storage/bufpage.h.html#LN435"><span class='Ref_to_Proto'>PageSetChecksumCopy</span></a><span class='Parentheses'>((</span><a href="../../../include/storage/bufpage.h.html#LN73"><span class='Ref_to_Typedef'>Page</span></a><span class='Parentheses'>) </span><a href="bufmgr.c.html#LN2670"><span class='Ref_To_Local'>bufBlock</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2664"><span class='Ref_to_Parameter'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN94"><span class='Ref_to_Member'>blockNum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN110"><span class='Ref_to_Global_Var'>track_io_timing</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/portability/instr_time.h.html#LN88"><span class='Ref_to_Macro'>INSTR_TIME_SET_CURRENT</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2668"><span class='Ref_To_Local'>io_start</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * bufToWrite is either the shared buffer or a copy, as appropriate. 
     */ 
</span>    <a href="../../../include/storage/smgr.h.html#LN100"><span class='Ref_to_Proto'>smgrwrite</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2664"><span class='Ref_to_Parameter'>reln</span></a><span class='Delimiter'>, 
</span>              <a href="bufmgr.c.html#LN2664"><span class='Ref_to_Parameter'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN93"><span class='Ref_to_Member'>forkNum</span></a><span class='Delimiter'>, 
</span>              <a href="bufmgr.c.html#LN2664"><span class='Ref_to_Parameter'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN94"><span class='Ref_to_Member'>blockNum</span></a><span class='Delimiter'>, 
</span>              <a href="bufmgr.c.html#LN2671"><span class='Ref_To_Local'>bufToWrite</span></a><span class='Delimiter'>, 
</span>              <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN110"><span class='Ref_to_Global_Var'>track_io_timing</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/portability/instr_time.h.html#LN88"><span class='Ref_to_Macro'>INSTR_TIME_SET_CURRENT</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2669"><span class='Ref_To_Local'>io_time</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/portability/instr_time.h.html#LN102"><span class='Ref_to_Macro'>INSTR_TIME_SUBTRACT</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2669"><span class='Ref_To_Local'>io_time</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2668"><span class='Ref_To_Local'>io_start</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/pgstat.h.html#LN1284"><span class='Ref_to_Macro'>pgstat_count_buffer_write_time</span></a><span class='Parentheses'>(</span><a href="../../../include/portability/instr_time.h.html#LN137"><span class='Ref_to_Macro'>INSTR_TIME_GET_MICROSEC</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2669"><span class='Ref_To_Local'>io_time</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="../../../include/portability/instr_time.h.html#LN90"><span class='Ref_to_Macro'>INSTR_TIME_ADD</span></a><span class='Parentheses'>(</span><a href="../../executor/instrument.c.html#LN19"><span class='Ref_to_Global_Var'>pgBufferUsage</span></a><span class='Operator'>.</span><a href="../../../include/executor/instrument.h.html#LN31"><span class='Ref_to_Member'>blk_write_time</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2669"><span class='Ref_To_Local'>io_time</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../executor/instrument.c.html#LN19"><span class='Ref_to_Global_Var'>pgBufferUsage</span></a><span class='Operator'>.</span><a href="../../../include/executor/instrument.h.html#LN23"><span class='Ref_to_Member'>shared_blks_written</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Mark the buffer as clean (unless BM_JUST_DIRTIED has become set) and 
     * end the io_in_progress state. 
     */ 
</span>    <a href="bufmgr.c.html#LN442"><span class='Ref_to_Proto'>TerminateBufferIO</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2664"><span class='Ref_to_Parameter'>buf</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    TRACE_POSTGRESQL_BUFFER_FLUSH_DONE<span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2664"><span class='Ref_to_Parameter'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN93"><span class='Ref_to_Member'>forkNum</span></a><span class='Delimiter'>, 
</span>                                       <a href="bufmgr.c.html#LN2664"><span class='Ref_to_Parameter'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN94"><span class='Ref_to_Member'>blockNum</span></a><span class='Delimiter'>, 
</span>                                       <a href="bufmgr.c.html#LN2664"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN42"><span class='Ref_to_Member'>smgr_rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN73"><span class='Ref_to_Member'>node</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN58"><span class='Ref_to_Member'>spcNode</span></a><span class='Delimiter'>, 
</span>                                       <a href="bufmgr.c.html#LN2664"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN42"><span class='Ref_to_Member'>smgr_rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN73"><span class='Ref_to_Member'>node</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN59"><span class='Ref_to_Member'>dbNode</span></a><span class='Delimiter'>, 
</span>                                       <a href="bufmgr.c.html#LN2664"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN42"><span class='Ref_to_Member'>smgr_rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN73"><span class='Ref_to_Member'>node</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN60"><span class='Ref_to_Member'>relNode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Pop the error context stack */ 
</span>    <a href="../../utils/error/elog.c.html#LN87"><span class='Ref_to_Global_Var'>error_context_stack</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN2667"><span class='Ref_To_Local'>errcallback</span></a><span class='Operator'>.</span>previous<span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end FlushBuffer &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * RelationGetNumberOfBlocksInFork 
 *      Determines the current number of pages in the specified relation fork. 
 */ 
</span><a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> 
<a name="LN2787"></a><span class='Declare_Function'>RelationGetNumberOfBlocksInFork</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>relation</span><span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a> <span class='Declare_Parameter'>forkNum</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* Open it at the smgr level if not already done */ 
</span>    <a href="../../../include/utils/rel.h.html#LN460"><span class='Ref_to_Macro'>RelationOpenSmgr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2787"><span class='Ref_to_Parameter'>relation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="../../../include/storage/smgr.h.html#LN104"><span class='Ref_to_Proto'>smgrnblocks</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2787"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN86"><span class='Ref_to_Member'>rd_smgr</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2787"><span class='Ref_to_Parameter'>forkNum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * BufferIsPermanent 
 *      Determines whether a buffer will potentially still be around after 
 *      a crash.  Caller must hold a buffer pin. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN2801"></a><span class='Declare_Function'>BufferIsPermanent</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> <span class='Declare_Parameter'>buffer</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2803"></a>    <a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>bufHdr</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Local buffers are used only for temp relations. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN36"><span class='Ref_to_Macro'>BufferIsLocal</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2801"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Make sure we've got a real buffer, and that we hold a pin on it. */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/bufmgr.h.html#LN113"><span class='Ref_to_Macro'>BufferIsValid</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2801"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN418"><span class='Ref_to_Macro'>BufferIsPinned</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2801"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * BM_PERMANENT can't be changed while we hold a pin on the buffer, so we 
     * need not bother with the buffer header spinlock.  Even if someone else 
     * changes the buffer header state while we're doing this, the state is 
     * changed atomically, so we'll read the old value or the new value, but 
     * not random garbage. 
     */ 
</span>    <a href="bufmgr.c.html#LN2803"><span class='Ref_To_Local'>bufHdr</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN219"><span class='Ref_to_Macro'>GetBufferDescriptor</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2801"><span class='Ref_to_Parameter'>buffer</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/port/atomics.h.html#LN250"><span class='Ref_to_Func'>pg_atomic_read_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN2803"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN183"><span class='Ref_to_Member'>state</span></a><span class='Parentheses'>) </span><span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN66"><span class='Ref_to_Const'>BM_PERMANENT</span></a><span class='Parentheses'>)</span> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end BufferIsPermanent &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * BufferGetLSNAtomic 
 *      Retrieves the LSN of the buffer atomically using a buffer header lock. 
 *      This is necessary for some callers who may not have an exclusive lock 
 *      on the buffer. 
 */ 
</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> 
<a name="LN2831"></a><span class='Declare_Function'>BufferGetLSNAtomic</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> <span class='Declare_Parameter'>buffer</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2833"></a>    <a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>bufHdr</span> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN219"><span class='Ref_to_Macro'>GetBufferDescriptor</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2831"><span class='Ref_to_Parameter'>buffer</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2834"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>page</span> <span class='Operator'>= </span><a href="../../../include/storage/bufmgr.h.html#LN159"><span class='Ref_to_Macro'>BufferGetPage</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2831"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2835"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>lsn</span><span class='Delimiter'>; 
</span><a name="LN2836"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>buf_state</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we don't need locking for correctness, fastpath out. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/xlog.h.html#LN155"><span class='Ref_to_Macro'>XLogHintBitIsNeeded</span></a><span class='Parentheses'>() </span><span class='Operator'>|| </span><a href="../../../include/storage/buf.h.html#LN36"><span class='Ref_to_Macro'>BufferIsLocal</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2831"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <a href="../../../include/storage/bufpage.h.html#LN362"><span class='Ref_to_Macro'>PageGetLSN</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2834"><span class='Ref_To_Local'>page</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Make sure we've got a real buffer, and that we hold a pin on it. */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/bufmgr.h.html#LN113"><span class='Ref_to_Macro'>BufferIsValid</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2831"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN418"><span class='Ref_to_Macro'>BufferIsPinned</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2831"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="bufmgr.c.html#LN2836"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN242"><span class='Ref_to_Proto'>LockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2833"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="bufmgr.c.html#LN2835"><span class='Ref_To_Local'>lsn</span></a> <span class='Operator'>= </span><a href="../../../include/storage/bufpage.h.html#LN362"><span class='Ref_to_Macro'>PageGetLSN</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2834"><span class='Ref_To_Local'>page</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2833"><span class='Ref_To_Local'>bufHdr</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2836"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="bufmgr.c.html#LN2835"><span class='Ref_To_Local'>lsn</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end BufferGetLSNAtomic &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* --------------------------------------------------------------------- 
 *      DropRelFileNodeBuffers 
 * 
 *      This function removes from the buffer pool all the pages of the 
 *      specified relation fork that have block numbers &GT;= firstDelBlock. 
 *      (In particular, with firstDelBlock = 0, all pages are removed.) 
 *      Dirty pages are simply dropped, without bothering to write them 
 *      out first.  Therefore, this is NOT rollback-able, and so should be 
 *      used only with extreme caution! 
 * 
 *      Currently, this is called only from smgr.c when the underlying file 
 *      is about to be deleted or truncated (firstDelBlock is needed for 
 *      the truncation case).  The data in the affected pages would therefore 
 *      be deleted momentarily anyway, and there is no point in writing it. 
 *      It is the responsibility of higher-level code to ensure that the 
 *      deletion or truncation does not lose any data that could be needed 
 *      later.  It is also the responsibility of higher-level code to ensure 
 *      that no other process could be trying to load more pages of the 
 *      relation into buffers. 
 * 
 *      XXX currently it sequentially searches the buffer pool, should be 
 *      changed to more clever ways of searching.  However, this routine 
 *      is used only in code paths that aren't very performance-critical, 
 *      and we shouldn't slow down the hot paths to make it faster ... 
 * -------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2882"></a><span class='Declare_Function'>DropRelFileNodeBuffers</span><span class='Parentheses'>(</span><a href="../../../include/storage/relfilenode.h.html#LN71"><span class='Ref_to_Struct'>RelFileNodeBackend</span></a> <span class='Declare_Parameter'>rnode</span><span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a> <span class='Declare_Parameter'>forkNum</span><span class='Delimiter'>, 
</span><a name="LN2883"></a>                       <a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Parameter'>firstDelBlock</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2885"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If it's a local relation, it's localbuf.c's problem. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/relfilenode.h.html#LN77"><span class='Ref_to_Macro'>RelFileNodeBackendIsTemp</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2882"><span class='Ref_to_Parameter'>rnode</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2882"><span class='Ref_to_Parameter'>rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN74"><span class='Ref_to_Member'>backend</span></a> <span class='Operator'>== </span><a href="../../utils/init/globals.c.html#LN72"><span class='Ref_to_Global_Var'>MyBackendId</span></a><span class='Parentheses'>) 
</span>            <a href="localbuf.c.html#LN318"><span class='Ref_to_Func'>DropRelFileNodeLocalBuffers</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2882"><span class='Ref_to_Parameter'>rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN73"><span class='Ref_to_Member'>node</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2882"><span class='Ref_to_Parameter'>forkNum</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2883"><span class='Ref_to_Parameter'>firstDelBlock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2885"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="bufmgr.c.html#LN2885"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="../../utils/init/globals.c.html#LN122"><span class='Ref_to_Global_Var'>NBuffers</span></a><span class='Delimiter'>; </span><a href="bufmgr.c.html#LN2885"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2897"></a>        <a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>bufHdr</span> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN219"><span class='Ref_to_Macro'>GetBufferDescriptor</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2885"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2898"></a>        <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>buf_state</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We can make this a tad faster by prechecking the buffer tag before 
         * we attempt to lock the buffer; this saves a lot of lock 
         * acquisitions in typical cases.  It should be safe because the 
         * caller must have AccessExclusiveLock on the relation, or some other 
         * reason to be certain that no one is loading new pages of the rel 
         * into the buffer pool.  (Otherwise we might well miss such pages 
         * entirely.)  Therefore, while the tag might be changing while we 
         * look at it, it can't be changing *to* a value we care about, only 
         * *away* from such a value.  So false negatives are impossible, and 
         * false positives are safe because we'll recheck after getting the 
         * buffer lock. 
         * 
         * We could check forkNum and blockNum as well as the rnode, but the 
         * incremental win from doing so seems small. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/storage/relfilenode.h.html#LN87"><span class='Ref_to_Macro'>RelFileNodeEquals</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2897"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN92"><span class='Ref_to_Member'>rnode</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2882"><span class='Ref_to_Parameter'>rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN73"><span class='Ref_to_Member'>node</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <a href="bufmgr.c.html#LN2898"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN242"><span class='Ref_to_Proto'>LockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2897"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/relfilenode.h.html#LN87"><span class='Ref_to_Macro'>RelFileNodeEquals</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2897"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN92"><span class='Ref_to_Member'>rnode</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2882"><span class='Ref_to_Parameter'>rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN73"><span class='Ref_to_Member'>node</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>            <a href="bufmgr.c.html#LN2897"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN93"><span class='Ref_to_Member'>forkNum</span></a> <span class='Operator'>== </span><a href="bufmgr.c.html#LN2882"><span class='Ref_to_Parameter'>forkNum</span></a> <span class='Operator'>&& 
</span>            <a href="bufmgr.c.html#LN2897"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN94"><span class='Ref_to_Member'>blockNum</span></a> <span class='Operator'>&GT;= </span><a href="bufmgr.c.html#LN2883"><span class='Ref_to_Parameter'>firstDelBlock</span></a><span class='Parentheses'>)</span> 
            <a href="bufmgr.c.html#LN1350"><span class='Ref_to_Func'>InvalidateBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2897"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* releases spinlock */ 
</span>        <span class='Control'>else</span> 
            <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2897"><span class='Ref_To_Local'>bufHdr</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2898"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;NBuffers;i++ &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end DropRelFileNodeBuffers &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* --------------------------------------------------------------------- 
 *      DropRelFileNodesAllBuffers 
 * 
 *      This function removes from the buffer pool all the pages of all 
 *      forks of the specified relations.  It's equivalent to calling 
 *      DropRelFileNodeBuffers once per fork per relation with 
 *      firstDelBlock = 0. 
 * -------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2939"></a><span class='Declare_Function'>DropRelFileNodesAllBuffers</span><span class='Parentheses'>(</span><a href="../../../include/storage/relfilenode.h.html#LN71"><span class='Ref_to_Struct'>RelFileNodeBackend</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rnodes</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>nnodes</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2941"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>, 
</span><a name="LN2942"></a>                <span class='Declare_Local'>n</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN2943"></a>    <a href="../../../include/storage/relfilenode.h.html#LN56"><span class='Ref_to_Struct'>RelFileNode</span></a> <span class='Operator'>*</span><span class='Declare_Local'>nodes</span><span class='Delimiter'>; 
</span><a name="LN2944"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>use_bsearch</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2939"><span class='Ref_to_Parameter'>nnodes</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <a href="bufmgr.c.html#LN2943"><span class='Ref_To_Local'>nodes</span></a> <span class='Operator'>= </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/relfilenode.h.html#LN56"><span class='Ref_to_Struct'>RelFileNode</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="bufmgr.c.html#LN2939"><span class='Ref_to_Parameter'>nnodes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* non-local relations */ 
</span> 
    <span class='Comment_Multi_Line'>/* If it's a local relation, it's localbuf.c's problem. */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2941"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="bufmgr.c.html#LN2941"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="bufmgr.c.html#LN2939"><span class='Ref_to_Parameter'>nnodes</span></a><span class='Delimiter'>; </span><a href="bufmgr.c.html#LN2941"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/relfilenode.h.html#LN77"><span class='Ref_to_Macro'>RelFileNodeBackendIsTemp</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2939"><span class='Ref_to_Parameter'>rnodes</span></a><span class='Delimiter'>[</span><a href="bufmgr.c.html#LN2941"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2939"><span class='Ref_to_Parameter'>rnodes</span></a><span class='Delimiter'>[</span><a href="bufmgr.c.html#LN2941"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN74"><span class='Ref_to_Member'>backend</span></a> <span class='Operator'>== </span><a href="../../utils/init/globals.c.html#LN72"><span class='Ref_to_Global_Var'>MyBackendId</span></a><span class='Parentheses'>) 
</span>                <a href="../../../include/storage/buf_internals.h.html#LN336"><span class='Ref_to_Proto'>DropRelFileNodeAllLocalBuffers</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2939"><span class='Ref_to_Parameter'>rnodes</span></a><span class='Delimiter'>[</span><a href="bufmgr.c.html#LN2941"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN73"><span class='Ref_to_Member'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <a href="bufmgr.c.html#LN2943"><span class='Ref_To_Local'>nodes</span></a><span class='Delimiter'>[</span><a href="bufmgr.c.html#LN2942"><span class='Ref_To_Local'>n</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="bufmgr.c.html#LN2939"><span class='Ref_to_Parameter'>rnodes</span></a><span class='Delimiter'>[</span><a href="bufmgr.c.html#LN2941"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN73"><span class='Ref_to_Member'>node</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If there are no non-local relations, then we're done. Release the 
     * memory and return. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2942"><span class='Ref_To_Local'>n</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2943"><span class='Ref_To_Local'>nodes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * For low number of relations to drop just use a simple walk through, to 
     * save the bsearch overhead. The threshold to use is rather a guess than 
     * an exactly determined value, as it depends on many factors (CPU and RAM 
     * speeds, amount of shared buffers etc.). 
     */ 
</span>    <a href="bufmgr.c.html#LN2944"><span class='Ref_To_Local'>use_bsearch</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN2942"><span class='Ref_To_Local'>n</span></a> <span class='Operator'>&GT; </span><a href="bufmgr.c.html#LN67"><span class='Ref_to_Const'>DROP_RELS_BSEARCH_THRESHOLD</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* sort the list of rnodes if necessary */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2944"><span class='Ref_To_Local'>use_bsearch</span></a><span class='Parentheses'>) 
</span>        <a href="../../../port/qsort.c.html#LN111"><span class='Ref_to_Func'>pg_qsort</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2943"><span class='Ref_To_Local'>nodes</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2942"><span class='Ref_To_Local'>n</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/relfilenode.h.html#LN56"><span class='Ref_to_Struct'>RelFileNode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN455"><span class='Ref_to_Proto'>rnode_comparator</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2941"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="bufmgr.c.html#LN2941"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="../../utils/init/globals.c.html#LN122"><span class='Ref_to_Global_Var'>NBuffers</span></a><span class='Delimiter'>; </span><a href="bufmgr.c.html#LN2941"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2987"></a>        <a href="../../../include/storage/relfilenode.h.html#LN56"><span class='Ref_to_Struct'>RelFileNode</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rnode</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN2988"></a>        <a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>bufHdr</span> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN219"><span class='Ref_to_Macro'>GetBufferDescriptor</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2941"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2989"></a>        <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>buf_state</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * As in DropRelFileNodeBuffers, an unlocked precheck should be safe 
         * and saves some cycles. 
         */ 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="bufmgr.c.html#LN2944"><span class='Ref_To_Local'>use_bsearch</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN2998"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>j</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2998"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="bufmgr.c.html#LN2998"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>&LT; </span><a href="bufmgr.c.html#LN2942"><span class='Ref_To_Local'>n</span></a><span class='Delimiter'>; </span><a href="bufmgr.c.html#LN2998"><span class='Ref_To_Local'>j</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/relfilenode.h.html#LN87"><span class='Ref_to_Macro'>RelFileNodeEquals</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2988"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN92"><span class='Ref_to_Member'>rnode</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2943"><span class='Ref_To_Local'>nodes</span></a><span class='Delimiter'>[</span><a href="bufmgr.c.html#LN2998"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]</span><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <a href="bufmgr.c.html#LN2987"><span class='Ref_To_Local'>rnode</span></a> <span class='Operator'>= &</span><a href="bufmgr.c.html#LN2943"><span class='Ref_To_Local'>nodes</span></a><span class='Delimiter'>[</span><a href="bufmgr.c.html#LN2998"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="bufmgr.c.html#LN2987"><span class='Ref_To_Local'>rnode</span></a> <span class='Operator'>= </span>bsearch<span class='Parentheses'>((</span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2988"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN92"><span class='Ref_to_Member'>rnode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                            <a href="bufmgr.c.html#LN2943"><span class='Ref_To_Local'>nodes</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2942"><span class='Ref_To_Local'>n</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/relfilenode.h.html#LN56"><span class='Ref_to_Struct'>RelFileNode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                            <a href="bufmgr.c.html#LN455"><span class='Ref_to_Proto'>rnode_comparator</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* buffer doesn't belong to any of the given relfilenodes; skip it */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2987"><span class='Ref_To_Local'>rnode</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <a href="bufmgr.c.html#LN2989"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN242"><span class='Ref_to_Proto'>LockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2988"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/relfilenode.h.html#LN87"><span class='Ref_to_Macro'>RelFileNodeEquals</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2988"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN92"><span class='Ref_to_Member'>rnode</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="bufmgr.c.html#LN2987"><span class='Ref_To_Local'>rnode</span></a><span class='Parentheses'>)))</span> 
            <a href="bufmgr.c.html#LN1350"><span class='Ref_to_Func'>InvalidateBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2988"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* releases spinlock */ 
</span>        <span class='Control'>else</span> 
            <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2988"><span class='Ref_To_Local'>bufHdr</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN2989"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;NBuffers;i++ &raquo; </span> 
 
    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN2943"><span class='Ref_To_Local'>nodes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end DropRelFileNodesAllBuffers &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* --------------------------------------------------------------------- 
 *      DropDatabaseBuffers 
 * 
 *      This function removes all the buffers in the buffer cache for a 
 *      particular database.  Dirty pages are simply dropped, without 
 *      bothering to write them out first.  This is used when we destroy a 
 *      database, to avoid trying to flush data to disk when the directory 
 *      tree no longer exists.  Implementation is pretty similar to 
 *      DropRelFileNodeBuffers() which is for destroying just one relation. 
 * -------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN3042"></a><span class='Declare_Function'>DropDatabaseBuffers</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>dbid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3044"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We needn't consider local buffers, since by assumption the target 
     * database isn't our own. 
     */ 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3044"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="bufmgr.c.html#LN3044"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="../../utils/init/globals.c.html#LN122"><span class='Ref_to_Global_Var'>NBuffers</span></a><span class='Delimiter'>; </span><a href="bufmgr.c.html#LN3044"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3053"></a>        <a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>bufHdr</span> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN219"><span class='Ref_to_Macro'>GetBufferDescriptor</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3044"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3054"></a>        <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>buf_state</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * As in DropRelFileNodeBuffers, an unlocked precheck should be safe 
         * and saves some cycles. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3053"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN92"><span class='Ref_to_Member'>rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN59"><span class='Ref_to_Member'>dbNode</span></a> <span class='Operator'>!= </span><a href="bufmgr.c.html#LN3042"><span class='Ref_to_Parameter'>dbid</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <a href="bufmgr.c.html#LN3054"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN242"><span class='Ref_to_Proto'>LockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3053"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3053"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN92"><span class='Ref_to_Member'>rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN59"><span class='Ref_to_Member'>dbNode</span></a> <span class='Operator'>== </span><a href="bufmgr.c.html#LN3042"><span class='Ref_to_Parameter'>dbid</span></a><span class='Parentheses'>) 
</span>            <a href="bufmgr.c.html#LN1350"><span class='Ref_to_Func'>InvalidateBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3053"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* releases spinlock */ 
</span>        <span class='Control'>else</span> 
            <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3053"><span class='Ref_To_Local'>bufHdr</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3054"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end DropDatabaseBuffers &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* ----------------------------------------------------------------- 
 *      PrintBufferDescs 
 * 
 *      this function prints all the buffer descriptors, for debugging 
 *      use only. 
 * ----------------------------------------------------------------- 
 */ 
</span><span class='Directive'>#ifdef</span> NOT_USED 
<span class='Keyword'>void 
</span><a name="LN3080"></a><span class='Declare_Function'>PrintBufferDescs</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3082"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3082"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="bufmgr.c.html#LN3082"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="../../utils/init/globals.c.html#LN122"><span class='Ref_to_Global_Var'>NBuffers</span></a><span class='Delimiter'>; </span><span class='Operator'>++</span><a href="bufmgr.c.html#LN3082"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3086"></a>        <a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>buf</span> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN219"><span class='Ref_to_Macro'>GetBufferDescriptor</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3082"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3087"></a>        <a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a>      <span class='Declare_Local'>b</span> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN222"><span class='Ref_to_Macro'>BufferDescriptorGetBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3086"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* theoretically we should lock the bufhdr here */ 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>             <span class='String'>"[%02d] (freeNext=%d, rel=%s, "</span> 
             <span class='String'>"blockNum=%u, flags=0x%x, refcount=%u %d)"</span><span class='Delimiter'>, 
</span>             <a href="bufmgr.c.html#LN3082"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3086"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN186"><span class='Ref_to_Member'>freeNext</span></a><span class='Delimiter'>, 
</span>          <a href="../../../include/common/relpath.h.html#LN61"><span class='Ref_to_Macro'>relpathbackend</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3086"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN92"><span class='Ref_to_Member'>rnode</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/backendid.h.html#LN22"><span class='Ref_to_Const'>InvalidBackendId</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3086"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN93"><span class='Ref_to_Member'>forkNum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>             <a href="bufmgr.c.html#LN3086"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN94"><span class='Ref_to_Member'>blockNum</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3086"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>-&GT;</span>flags<span class='Delimiter'>, 
</span>             <a href="bufmgr.c.html#LN3086"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>-&GT;</span>refcount<span class='Delimiter'>, </span><a href="bufmgr.c.html#LN176"><span class='Ref_to_Proto'>GetPrivateRefCount</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3087"><span class='Ref_To_Local'>b</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end PrintBufferDescs &raquo; </span> 
<span class='Directive'>#endif</span> 
 
<span class='Directive'>#ifdef</span> NOT_USED 
<span class='Keyword'>void 
</span><a name="LN3103"></a><span class='Declare_Function'>PrintPinnedBufs</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3105"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3105"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="bufmgr.c.html#LN3105"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="../../utils/init/globals.c.html#LN122"><span class='Ref_to_Global_Var'>NBuffers</span></a><span class='Delimiter'>; </span><span class='Operator'>++</span><a href="bufmgr.c.html#LN3105"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3109"></a>        <a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>buf</span> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN219"><span class='Ref_to_Macro'>GetBufferDescriptor</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3105"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3110"></a>        <a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a>      <span class='Declare_Local'>b</span> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN222"><span class='Ref_to_Macro'>BufferDescriptorGetBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3109"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN176"><span class='Ref_to_Proto'>GetPrivateRefCount</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3110"><span class='Ref_To_Local'>b</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* theoretically we should lock the bufhdr here */ 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                 <span class='String'>"[%02d] (freeNext=%d, rel=%s, "</span> 
                 <span class='String'>"blockNum=%u, flags=0x%x, refcount=%u %d)"</span><span class='Delimiter'>, 
</span>                 <a href="bufmgr.c.html#LN3105"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3109"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN186"><span class='Ref_to_Member'>freeNext</span></a><span class='Delimiter'>, 
</span>                 <a href="../../../include/common/relpath.h.html#LN66"><span class='Ref_to_Macro'>relpathperm</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3109"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN92"><span class='Ref_to_Member'>rnode</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3109"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN93"><span class='Ref_to_Member'>forkNum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="bufmgr.c.html#LN3109"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN94"><span class='Ref_to_Member'>blockNum</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3109"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>-&GT;</span>flags<span class='Delimiter'>, 
</span>                 <a href="bufmgr.c.html#LN3109"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>-&GT;</span>refcount<span class='Delimiter'>, </span><a href="bufmgr.c.html#LN176"><span class='Ref_to_Proto'>GetPrivateRefCount</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3110"><span class='Ref_To_Local'>b</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end PrintPinnedBufs &raquo; </span> 
<span class='Directive'>#endif</span> 
 
<span class='Comment_Multi_Line'>/* --------------------------------------------------------------------- 
 *      FlushRelationBuffers 
 * 
 *      This function writes all dirty pages of a relation out to disk 
 *      (or more accurately, out to kernel disk buffers), ensuring that the 
 *      kernel has an up-to-date view of the relation. 
 * 
 *      Generally, the caller should be holding AccessExclusiveLock on the 
 *      target relation to ensure that no other backend is busy dirtying 
 *      more blocks of the relation; the effects can't be expected to last 
 *      after the lock is released. 
 * 
 *      XXX currently it sequentially searches the buffer pool, should be 
 *      changed to more clever ways of searching.  This routine is not 
 *      used in any performance-critical code paths, so it's not worth 
 *      adding additional overhead to normal paths to make it go faster; 
 *      but see also DropRelFileNodeBuffers. 
 * -------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN3147"></a><span class='Declare_Function'>FlushRelationBuffers</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>rel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3149"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN3150"></a>    <a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>bufHdr</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Open rel at the smgr level if not already done */ 
</span>    <a href="../../../include/utils/rel.h.html#LN460"><span class='Ref_to_Macro'>RelationOpenSmgr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3147"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/rel.h.html#LN512"><span class='Ref_to_Macro'>RelationUsesLocalBuffers</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3147"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3149"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="bufmgr.c.html#LN3149"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="localbuf.c.html#LN40"><span class='Ref_to_Global_Var'>NLocBuffer</span></a><span class='Delimiter'>; </span><a href="bufmgr.c.html#LN3149"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN3159"></a>            <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>buf_state</span><span class='Delimiter'>; 
</span> 
            <a href="bufmgr.c.html#LN3150"><span class='Ref_To_Local'>bufHdr</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN220"><span class='Ref_to_Macro'>GetLocalBufferDescriptor</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3149"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/relfilenode.h.html#LN87"><span class='Ref_to_Macro'>RelFileNodeEquals</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3150"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN92"><span class='Ref_to_Member'>rnode</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3147"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN84"><span class='Ref_to_Member'>rd_node</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>                <span class='Parentheses'>((</span><a href="bufmgr.c.html#LN3159"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>= </span><a href="../../../include/port/atomics.h.html#LN250"><span class='Ref_to_Func'>pg_atomic_read_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN3150"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN183"><span class='Ref_to_Member'>state</span></a><span class='Parentheses'>))</span> <span class='Operator'>& 
</span>                 <span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN59"><span class='Ref_to_Const'>BM_VALID</span></a> <span class='Operator'>| </span><a href="../../../include/storage/buf_internals.h.html#LN58"><span class='Ref_to_Const'>BM_DIRTY</span></a><span class='Parentheses'>))</span> <span class='Operator'>== </span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN59"><span class='Ref_to_Const'>BM_VALID</span></a> <span class='Operator'>| </span><a href="../../../include/storage/buf_internals.h.html#LN58"><span class='Ref_to_Const'>BM_DIRTY</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span><a name="LN3166"></a>                ErrorContextCallback <span class='Declare_Local'>errcallback</span><span class='Delimiter'>; 
</span><a name="LN3167"></a>                <a href="../../../include/storage/bufpage.h.html#LN73"><span class='Ref_to_Typedef'>Page</span></a>        <span class='Declare_Local'>localpage</span><span class='Delimiter'>; 
</span> 
                <a href="bufmgr.c.html#LN3167"><span class='Ref_To_Local'>localpage</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="localbuf.c.html#LN37"><span class='Ref_to_Macro'>LocalBufHdrGetBlock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3150"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* Setup error traceback support for ereport() */ 
</span>                <a href="bufmgr.c.html#LN3166"><span class='Ref_To_Local'>errcallback</span></a><span class='Operator'>.</span>callback <span class='Operator'>= </span><a href="bufmgr.c.html#LN445"><span class='Ref_to_Proto'>local_buffer_write_error_callback</span></a><span class='Delimiter'>; 
</span>                <a href="bufmgr.c.html#LN3166"><span class='Ref_To_Local'>errcallback</span></a><span class='Operator'>.</span>arg <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="bufmgr.c.html#LN3150"><span class='Ref_To_Local'>bufHdr</span></a><span class='Delimiter'>; 
</span>                <a href="bufmgr.c.html#LN3166"><span class='Ref_To_Local'>errcallback</span></a><span class='Operator'>.</span>previous <span class='Operator'>= </span><a href="../../utils/error/elog.c.html#LN87"><span class='Ref_to_Global_Var'>error_context_stack</span></a><span class='Delimiter'>; 
</span>                <a href="../../utils/error/elog.c.html#LN87"><span class='Ref_to_Global_Var'>error_context_stack</span></a> <span class='Operator'>= &</span><a href="bufmgr.c.html#LN3166"><span class='Ref_To_Local'>errcallback</span></a><span class='Delimiter'>; 
</span> 
                <a href="../../../include/storage/bufpage.h.html#LN436"><span class='Ref_to_Proto'>PageSetChecksumInplace</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3167"><span class='Ref_To_Local'>localpage</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3150"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN94"><span class='Ref_to_Member'>blockNum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="../../../include/storage/smgr.h.html#LN100"><span class='Ref_to_Proto'>smgrwrite</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3147"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN86"><span class='Ref_to_Member'>rd_smgr</span></a><span class='Delimiter'>, 
</span>                          <a href="bufmgr.c.html#LN3150"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN93"><span class='Ref_to_Member'>forkNum</span></a><span class='Delimiter'>, 
</span>                          <a href="bufmgr.c.html#LN3150"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN94"><span class='Ref_to_Member'>blockNum</span></a><span class='Delimiter'>, 
</span>                          <a href="bufmgr.c.html#LN3167"><span class='Ref_To_Local'>localpage</span></a><span class='Delimiter'>, 
</span>                          <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="bufmgr.c.html#LN3159"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>&= ~</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN58"><span class='Ref_to_Const'>BM_DIRTY</span></a> <span class='Operator'>| </span><a href="../../../include/storage/buf_internals.h.html#LN63"><span class='Ref_to_Const'>BM_JUST_DIRTIED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../include/port/atomics.h.html#LN286"><span class='Ref_to_Func'>pg_atomic_unlocked_write_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN3150"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN183"><span class='Ref_to_Member'>state</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3159"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* Pop the error context stack */ 
</span>                <a href="../../utils/error/elog.c.html#LN87"><span class='Ref_to_Global_Var'>error_context_stack</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN3166"><span class='Ref_To_Local'>errcallback</span></a><span class='Operator'>.</span>previous<span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if RelFileNodeEquals(buf... &raquo; </span> 
        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;NLocBuffer;i++ &raquo; </span> 
 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if RelationUsesLocalBuff... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Make sure we can handle the pin inside the loop */ 
</span>    <a href="../../../include/utils/resowner_private.h.html#LN28"><span class='Ref_to_Proto'>ResourceOwnerEnlargeBuffers</span></a><span class='Parentheses'>(</span><a href="../../utils/resowner/resowner.c.html#LN137"><span class='Ref_to_Global_Var'>CurrentResourceOwner</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3149"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="bufmgr.c.html#LN3149"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="../../utils/init/globals.c.html#LN122"><span class='Ref_to_Global_Var'>NBuffers</span></a><span class='Delimiter'>; </span><a href="bufmgr.c.html#LN3149"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3201"></a>        <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>buf_state</span><span class='Delimiter'>; 
</span> 
        <a href="bufmgr.c.html#LN3150"><span class='Ref_To_Local'>bufHdr</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN219"><span class='Ref_to_Macro'>GetBufferDescriptor</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3149"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * As in DropRelFileNodeBuffers, an unlocked precheck should be safe 
         * and saves some cycles. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/storage/relfilenode.h.html#LN87"><span class='Ref_to_Macro'>RelFileNodeEquals</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3150"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN92"><span class='Ref_to_Member'>rnode</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3147"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN84"><span class='Ref_to_Member'>rd_node</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <a href="bufmgr.c.html#LN173"><span class='Ref_to_Proto'>ReservePrivateRefCountEntry</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <a href="bufmgr.c.html#LN3201"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN242"><span class='Ref_to_Proto'>LockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3150"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/relfilenode.h.html#LN87"><span class='Ref_to_Macro'>RelFileNodeEquals</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3150"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN92"><span class='Ref_to_Member'>rnode</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3147"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN84"><span class='Ref_to_Member'>rd_node</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>            <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3201"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>& </span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN59"><span class='Ref_to_Const'>BM_VALID</span></a> <span class='Operator'>| </span><a href="../../../include/storage/buf_internals.h.html#LN58"><span class='Ref_to_Const'>BM_DIRTY</span></a><span class='Parentheses'>))</span> <span class='Operator'>== </span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN59"><span class='Ref_to_Const'>BM_VALID</span></a> <span class='Operator'>| </span><a href="../../../include/storage/buf_internals.h.html#LN58"><span class='Ref_to_Const'>BM_DIRTY</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="bufmgr.c.html#LN435"><span class='Ref_to_Proto'>PinBuffer_Locked</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3150"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN226"><span class='Ref_to_Macro'>BufferDescriptorGetContentLock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3150"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="bufmgr.c.html#LN452"><span class='Ref_to_Proto'>FlushBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3150"><span class='Ref_To_Local'>bufHdr</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3147"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN86"><span class='Ref_to_Member'>rd_smgr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN226"><span class='Ref_to_Macro'>BufferDescriptorGetContentLock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3150"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="bufmgr.c.html#LN436"><span class='Ref_to_Proto'>UnpinBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3150"><span class='Ref_To_Local'>bufHdr</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3150"><span class='Ref_To_Local'>bufHdr</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3201"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;NBuffers;i++ &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end FlushRelationBuffers &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* --------------------------------------------------------------------- 
 *      FlushDatabaseBuffers 
 * 
 *      This function writes all dirty pages of a database out to disk 
 *      (or more accurately, out to kernel disk buffers), ensuring that the 
 *      kernel has an up-to-date view of the database. 
 * 
 *      Generally, the caller should be holding an appropriate lock to ensure 
 *      no other backend is active in the target database; otherwise more 
 *      pages could get dirtied. 
 * 
 *      Note we don't worry about flushing any pages of temporary relations. 
 *      It's assumed these wouldn't be interesting. 
 * -------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN3245"></a><span class='Declare_Function'>FlushDatabaseBuffers</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>dbid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3247"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN3248"></a>    <a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>bufHdr</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Make sure we can handle the pin inside the loop */ 
</span>    <a href="../../../include/utils/resowner_private.h.html#LN28"><span class='Ref_to_Proto'>ResourceOwnerEnlargeBuffers</span></a><span class='Parentheses'>(</span><a href="../../utils/resowner/resowner.c.html#LN137"><span class='Ref_to_Global_Var'>CurrentResourceOwner</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3247"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="bufmgr.c.html#LN3247"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="../../utils/init/globals.c.html#LN122"><span class='Ref_to_Global_Var'>NBuffers</span></a><span class='Delimiter'>; </span><a href="bufmgr.c.html#LN3247"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3255"></a>        <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>buf_state</span><span class='Delimiter'>; 
</span> 
        <a href="bufmgr.c.html#LN3248"><span class='Ref_To_Local'>bufHdr</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN219"><span class='Ref_to_Macro'>GetBufferDescriptor</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3247"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * As in DropRelFileNodeBuffers, an unlocked precheck should be safe 
         * and saves some cycles. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3248"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN92"><span class='Ref_to_Member'>rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN59"><span class='Ref_to_Member'>dbNode</span></a> <span class='Operator'>!= </span><a href="bufmgr.c.html#LN3245"><span class='Ref_to_Parameter'>dbid</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <a href="bufmgr.c.html#LN173"><span class='Ref_to_Proto'>ReservePrivateRefCountEntry</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <a href="bufmgr.c.html#LN3255"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN242"><span class='Ref_to_Proto'>LockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3248"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3248"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN92"><span class='Ref_to_Member'>rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN59"><span class='Ref_to_Member'>dbNode</span></a> <span class='Operator'>== </span><a href="bufmgr.c.html#LN3245"><span class='Ref_to_Parameter'>dbid</span></a> <span class='Operator'>&& 
</span>            <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3255"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>& </span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN59"><span class='Ref_to_Const'>BM_VALID</span></a> <span class='Operator'>| </span><a href="../../../include/storage/buf_internals.h.html#LN58"><span class='Ref_to_Const'>BM_DIRTY</span></a><span class='Parentheses'>))</span> <span class='Operator'>== </span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN59"><span class='Ref_to_Const'>BM_VALID</span></a> <span class='Operator'>| </span><a href="../../../include/storage/buf_internals.h.html#LN58"><span class='Ref_to_Const'>BM_DIRTY</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="bufmgr.c.html#LN435"><span class='Ref_to_Proto'>PinBuffer_Locked</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3248"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN226"><span class='Ref_to_Macro'>BufferDescriptorGetContentLock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3248"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="bufmgr.c.html#LN452"><span class='Ref_to_Proto'>FlushBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3248"><span class='Ref_To_Local'>bufHdr</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN226"><span class='Ref_to_Macro'>BufferDescriptorGetContentLock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3248"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="bufmgr.c.html#LN436"><span class='Ref_to_Proto'>UnpinBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3248"><span class='Ref_To_Local'>bufHdr</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3248"><span class='Ref_To_Local'>bufHdr</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3255"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;NBuffers;i++ &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end FlushDatabaseBuffers &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Flush a previously, shared or exclusively, locked and pinned buffer to the 
 * OS. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN3288"></a><span class='Declare_Function'>FlushOneBuffer</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> <span class='Declare_Parameter'>buffer</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3290"></a>    <a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>bufHdr</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* currently not needed, but no fundamental reason not to support */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/storage/buf.h.html#LN36"><span class='Ref_to_Macro'>BufferIsLocal</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3288"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN418"><span class='Ref_to_Macro'>BufferIsPinned</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3288"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="bufmgr.c.html#LN3290"><span class='Ref_To_Local'>bufHdr</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN219"><span class='Ref_to_Macro'>GetBufferDescriptor</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3288"><span class='Ref_to_Parameter'>buffer</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN151"><span class='Ref_to_Proto'>LWLockHeldByMe</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN226"><span class='Ref_to_Macro'>BufferDescriptorGetContentLock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3290"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <a href="bufmgr.c.html#LN452"><span class='Ref_to_Proto'>FlushBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3290"><span class='Ref_To_Local'>bufHdr</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * ReleaseBuffer -- release the pin on a buffer 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN3308"></a><span class='Declare_Function'>ReleaseBuffer</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> <span class='Declare_Parameter'>buffer</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/storage/bufmgr.h.html#LN113"><span class='Ref_to_Macro'>BufferIsValid</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3308"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"bad buffer ID: %d"</span><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3308"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN36"><span class='Ref_to_Macro'>BufferIsLocal</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3308"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/utils/resowner_private.h.html#LN30"><span class='Ref_to_Proto'>ResourceOwnerForgetBuffer</span></a><span class='Parentheses'>(</span><a href="../../utils/resowner/resowner.c.html#LN137"><span class='Ref_to_Global_Var'>CurrentResourceOwner</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3308"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="localbuf.c.html#LN44"><span class='Ref_to_Global_Var'>LocalRefCount</span></a><span class='Delimiter'>[</span><span class='Operator'>-</span><a href="bufmgr.c.html#LN3308"><span class='Ref_to_Parameter'>buffer</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="localbuf.c.html#LN44"><span class='Ref_to_Global_Var'>LocalRefCount</span></a><span class='Delimiter'>[</span><span class='Operator'>-</span><a href="bufmgr.c.html#LN3308"><span class='Ref_to_Parameter'>buffer</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Operator'>--</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="bufmgr.c.html#LN436"><span class='Ref_to_Proto'>UnpinBuffer</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN219"><span class='Ref_to_Macro'>GetBufferDescriptor</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3308"><span class='Ref_to_Parameter'>buffer</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * UnlockReleaseBuffer -- release the content lock and pin on a buffer 
 * 
 * This is just a shorthand for a common combination. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN3331"></a><span class='Declare_Function'>UnlockReleaseBuffer</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> <span class='Declare_Parameter'>buffer</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/storage/bufmgr.h.html#LN214"><span class='Ref_to_Proto'>LockBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3331"><span class='Ref_to_Parameter'>buffer</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/bufmgr.h.html#LN86"><span class='Ref_to_Const'>BUFFER_LOCK_UNLOCK</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/bufmgr.h.html#LN174"><span class='Ref_to_Proto'>ReleaseBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3331"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * IncrBufferRefCount 
 *      Increment the pin count on a buffer that we have *already* pinned 
 *      at least once. 
 * 
 *      This function cannot be used on a buffer we do not have pinned, 
 *      because it doesn't change the shared buffer state. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN3346"></a><span class='Declare_Function'>IncrBufferRefCount</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> <span class='Declare_Parameter'>buffer</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN418"><span class='Ref_to_Macro'>BufferIsPinned</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3346"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/utils/resowner_private.h.html#LN28"><span class='Ref_to_Proto'>ResourceOwnerEnlargeBuffers</span></a><span class='Parentheses'>(</span><a href="../../utils/resowner/resowner.c.html#LN137"><span class='Ref_to_Global_Var'>CurrentResourceOwner</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/utils/resowner_private.h.html#LN29"><span class='Ref_to_Proto'>ResourceOwnerRememberBuffer</span></a><span class='Parentheses'>(</span><a href="../../utils/resowner/resowner.c.html#LN137"><span class='Ref_to_Global_Var'>CurrentResourceOwner</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3346"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN36"><span class='Ref_to_Macro'>BufferIsLocal</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3346"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span> 
        <a href="localbuf.c.html#LN44"><span class='Ref_to_Global_Var'>LocalRefCount</span></a><span class='Delimiter'>[</span><span class='Operator'>-</span><a href="bufmgr.c.html#LN3346"><span class='Ref_to_Parameter'>buffer</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span><a name="LN3355"></a>        <a href="bufmgr.c.html#LN69"><span class='Ref_to_Struct'>PrivateRefCountEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>ref</span><span class='Delimiter'>; 
</span> 
        <span class='Keyword'>ref </span><span class='Operator'>= </span><a href="bufmgr.c.html#LN175"><span class='Ref_to_Proto'>GetPrivateRefCountEntry</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3346"><span class='Ref_to_Parameter'>buffer</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Keyword'>ref </span><span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Keyword'>ref</span><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN72"><span class='Ref_to_Member'>refcount</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * MarkBufferDirtyHint 
 * 
 *  Mark a buffer dirty for non-critical changes. 
 * 
 * This is essentially the same as MarkBufferDirty, except: 
 * 
 * 1. The caller does not write WAL; so if checksums are enabled, we may need 
 *    to write an XLOG_FPI WAL record to protect against torn pages. 
 * 2. The caller might have only share-lock instead of exclusive-lock on the 
 *    buffer's content lock. 
 * 3. This function does not guarantee that the buffer is always marked dirty 
 *    (due to a race condition), so it cannot be used for important changes. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN3378"></a><span class='Declare_Function'>MarkBufferDirtyHint</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> <span class='Declare_Parameter'>buffer</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>buffer_std</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3380"></a>    <a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>bufHdr</span><span class='Delimiter'>; 
</span><a name="LN3381"></a>    <a href="../../../include/storage/bufpage.h.html#LN73"><span class='Ref_to_Typedef'>Page</span></a>        <span class='Declare_Local'>page</span> <span class='Operator'>= </span><a href="../../../include/storage/bufmgr.h.html#LN159"><span class='Ref_to_Macro'>BufferGetPage</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3378"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/storage/bufmgr.h.html#LN113"><span class='Ref_to_Macro'>BufferIsValid</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3378"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"bad buffer ID: %d"</span><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3378"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN36"><span class='Ref_to_Macro'>BufferIsLocal</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3378"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="localbuf.c.html#LN278"><span class='Ref_to_Func'>MarkLocalBufferDirty</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3378"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="bufmgr.c.html#LN3380"><span class='Ref_To_Local'>bufHdr</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN219"><span class='Ref_to_Macro'>GetBufferDescriptor</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3378"><span class='Ref_to_Parameter'>buffer</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN176"><span class='Ref_to_Proto'>GetPrivateRefCount</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3378"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* here, either share or exclusive lock is OK */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN151"><span class='Ref_to_Proto'>LWLockHeldByMe</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN226"><span class='Ref_to_Macro'>BufferDescriptorGetContentLock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3380"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * This routine might get called many times on the same page, if we are 
     * making the first scan after commit of an xact that added/deleted many 
     * tuples. So, be as quick as we can if the buffer is already dirty.  We 
     * do this by not acquiring spinlock if it looks like the status bits are 
     * already set.  Since we make this test unlocked, there's a chance we 
     * might fail to notice that the flags have just been cleared, and failed 
     * to reset them, due to memory-ordering issues.  But since this function 
     * is only intended to be used in cases where failing to write out the 
     * data would be harmless anyway, it doesn't really matter. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="../../../include/port/atomics.h.html#LN250"><span class='Ref_to_Func'>pg_atomic_read_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN3380"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN183"><span class='Ref_to_Member'>state</span></a><span class='Parentheses'>) </span><span class='Operator'>& </span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN58"><span class='Ref_to_Const'>BM_DIRTY</span></a> <span class='Operator'>| </span><a href="../../../include/storage/buf_internals.h.html#LN63"><span class='Ref_to_Const'>BM_JUST_DIRTIED</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= 
</span>        <span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN58"><span class='Ref_to_Const'>BM_DIRTY</span></a> <span class='Operator'>| </span><a href="../../../include/storage/buf_internals.h.html#LN63"><span class='Ref_to_Const'>BM_JUST_DIRTIED</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN3412"></a>        <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>lsn</span> <span class='Operator'>= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span><a name="LN3413"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>dirtied</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN3414"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>delayChkpt</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN3415"></a>        <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>buf_state</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If we need to protect hint bit updates from torn writes, WAL-log a 
         * full page image of the page. This full page image is only necessary 
         * if the hint bit update is the first change to the page since the 
         * last checkpoint. 
         * 
         * We don't check full_page_writes here because that logic is included 
         * when we call XLogInsert() since the value changes dynamically. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN155"><span class='Ref_to_Macro'>XLogHintBitIsNeeded</span></a><span class='Parentheses'>()</span> <span class='Operator'>&& 
</span>            <span class='Parentheses'>(</span><a href="../../../include/port/atomics.h.html#LN250"><span class='Ref_to_Func'>pg_atomic_read_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN3380"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN183"><span class='Ref_to_Member'>state</span></a><span class='Parentheses'>) </span><span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN66"><span class='Ref_to_Const'>BM_PERMANENT</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * If we're in recovery we cannot dirty a page because of a hint. 
             * We can set the hint, just not dirty the page as a result so the 
             * hint is lost when we evict the page or shutdown. 
             * 
             * See src/backend/storage/page/README for longer discussion. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN242"><span class='Ref_to_Proto'>RecoveryInProgress</span></a><span class='Parentheses'>())</span> 
                <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * If the block is already dirty because we either made a change 
             * or set a hint already, then we don't need to write a full page 
             * image.  Note that aggressive cleaning of blocks dirtied by hint 
             * bit setting would increase the call rate. Bulk setting of hint 
             * bits would reduce the call rate... 
             * 
             * We must issue the WAL record before we mark the buffer dirty. 
             * Otherwise we might write the page before we write the WAL. That 
             * causes a race condition, since a checkpoint might occur between 
             * writing the WAL record and marking the buffer dirty. We solve 
             * that with a kluge, but one that is already in use during 
             * transaction commit to prevent race conditions. Basically, we 
             * simply prevent the checkpoint WAL record from being written 
             * until we have marked the buffer dirty. We don't start the 
             * checkpoint flush until we have marked dirty, so our checkpoint 
             * must flush the change to disk successfully or the checkpoint 
             * never gets written, so crash recovery will fix. 
             * 
             * It's possible we may enter here without an xid, so it is 
             * essential that CreateCheckpoint waits for virtual transactions 
             * rather than full transactionids. 
             */ 
</span>            <a href="../lmgr/proc.c.html#LN67"><span class='Ref_to_Global_Var'>MyPgXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN219"><span class='Ref_to_Member'>delayChkpt</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN3414"><span class='Ref_To_Local'>delayChkpt</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="bufmgr.c.html#LN3412"><span class='Ref_To_Local'>lsn</span></a> <span class='Operator'>= </span><a href="../../../include/access/xloginsert.h.html#LN57"><span class='Ref_to_Proto'>XLogSaveBufferForHint</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3378"><span class='Ref_to_Parameter'>buffer</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3378"><span class='Ref_to_Parameter'>buffer_std</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if XLogHintBitIsNeeded()... &raquo; </span> 
 
        <a href="bufmgr.c.html#LN3415"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN242"><span class='Ref_to_Proto'>LockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3380"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN48"><span class='Ref_to_Macro'>BUF_STATE_GET_REFCOUNT</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3415"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3415"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN58"><span class='Ref_to_Const'>BM_DIRTY</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="bufmgr.c.html#LN3413"><span class='Ref_To_Local'>dirtied</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* Means "will be dirtied by this action" */ 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Set the page LSN if we wrote a backup block. We aren't supposed 
             * to set this when only holding a share lock but as long as we 
             * serialise it somehow we're OK. We choose to set LSN while 
             * holding the buffer header lock, which causes any reader of an 
             * LSN who holds only a share lock to also obtain a buffer header 
             * lock before using PageGetLSN(), which is enforced in 
             * BufferGetLSNAtomic(). 
             * 
             * If checksums are enabled, you might think we should reset the 
             * checksum here. That will happen when the page is written 
             * sometime later in this checkpoint cycle. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/xlogdefs.h.html#LN28"><span class='Ref_to_Macro'>XLogRecPtrIsInvalid</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3412"><span class='Ref_To_Local'>lsn</span></a><span class='Parentheses'>))</span> 
                <a href="../../../include/storage/bufpage.h.html#LN364"><span class='Ref_to_Macro'>PageSetLSN</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3381"><span class='Ref_To_Local'>page</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3412"><span class='Ref_To_Local'>lsn</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !(buf_state&BM_DIRTY) &raquo; </span> 
 
        <a href="bufmgr.c.html#LN3415"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>|= </span><a href="../../../include/storage/buf_internals.h.html#LN58"><span class='Ref_to_Const'>BM_DIRTY</span></a> <span class='Operator'>| </span><a href="../../../include/storage/buf_internals.h.html#LN63"><span class='Ref_to_Const'>BM_JUST_DIRTIED</span></a><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3380"><span class='Ref_To_Local'>bufHdr</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3415"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3414"><span class='Ref_To_Local'>delayChkpt</span></a><span class='Parentheses'>) 
</span>            <a href="../lmgr/proc.c.html#LN67"><span class='Ref_to_Global_Var'>MyPgXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN219"><span class='Ref_to_Member'>delayChkpt</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3413"><span class='Ref_To_Local'>dirtied</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../utils/init/globals.c.html#LN136"><span class='Ref_to_Global_Var'>VacuumPageDirty</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <a href="../../executor/instrument.c.html#LN19"><span class='Ref_to_Global_Var'>pgBufferUsage</span></a><span class='Operator'>.</span><a href="../../../include/executor/instrument.h.html#LN22"><span class='Ref_to_Member'>shared_blks_dirtied</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../utils/init/globals.c.html#LN139"><span class='Ref_to_Global_Var'>VacuumCostActive</span></a><span class='Parentheses'>) 
</span>                <a href="../../utils/init/globals.c.html#LN138"><span class='Ref_to_Global_Var'>VacuumCostBalance</span></a> <span class='Operator'>+= </span><a href="../../utils/init/globals.c.html#LN130"><span class='Ref_to_Global_Var'>VacuumCostPageDirty</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if (pg_atomic_read_u32(&... &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end MarkBufferDirtyHint &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Release buffer content locks for shared buffers. 
 * 
 * Used to clean up after errors. 
 * 
 * Currently, we can expect that lwlock.c's LWLockReleaseAll() took care 
 * of releasing buffer content locks per se; the only thing we need to deal 
 * with here is clearing any PIN_COUNT request that was in progress. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN3517"></a><span class='Declare_Function'>UnlockBuffers</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3519"></a>    <a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>buf</span> <span class='Operator'>= </span><a href="bufmgr.c.html#LN135"><span class='Ref_to_Global_Var'>PinCountWaitBuf</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3519"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3523"></a>        <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>buf_state</span><span class='Delimiter'>; 
</span> 
        <a href="bufmgr.c.html#LN3523"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN242"><span class='Ref_to_Proto'>LockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3519"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Don't complain if flag bit not set; it could have been reset but we 
         * got a cancel/die interrupt before getting the signal. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="bufmgr.c.html#LN3523"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN64"><span class='Ref_to_Const'>BM_PIN_COUNT_WAITER</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span> <span class='Operator'>&& 
</span>            <a href="bufmgr.c.html#LN3519"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN185"><span class='Ref_to_Member'>wait_backend_pid</span></a> <span class='Operator'>== </span><a href="../../utils/init/globals.c.html#LN38"><span class='Ref_to_Global_Var'>MyProcPid</span></a><span class='Parentheses'>)</span> 
            <a href="bufmgr.c.html#LN3523"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>&= ~</span><a href="../../../include/storage/buf_internals.h.html#LN64"><span class='Ref_to_Const'>BM_PIN_COUNT_WAITER</span></a><span class='Delimiter'>; 
</span> 
        <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3519"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3523"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="bufmgr.c.html#LN135"><span class='Ref_to_Global_Var'>PinCountWaitBuf</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end UnlockBuffers &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Acquire or release the content_lock for the buffer. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN3545"></a><span class='Declare_Function'>LockBuffer</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> <span class='Declare_Parameter'>buffer</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>mode</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3547"></a>    <a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>buf</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/bufmgr.h.html#LN113"><span class='Ref_to_Macro'>BufferIsValid</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3545"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN36"><span class='Ref_to_Macro'>BufferIsLocal</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3545"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>;</span>                 <span class='Comment_Single_Line'>/* local buffers need no lock */ 
</span> 
    <a href="bufmgr.c.html#LN3547"><span class='Ref_To_Local'>buf</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN219"><span class='Ref_to_Macro'>GetBufferDescriptor</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3545"><span class='Ref_to_Parameter'>buffer</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3545"><span class='Ref_to_Parameter'>mode</span></a> <span class='Operator'>== </span><a href="../../../include/storage/bufmgr.h.html#LN86"><span class='Ref_to_Const'>BUFFER_LOCK_UNLOCK</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN226"><span class='Ref_to_Macro'>BufferDescriptorGetContentLock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3547"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3545"><span class='Ref_to_Parameter'>mode</span></a> <span class='Operator'>== </span><a href="../../../include/storage/bufmgr.h.html#LN87"><span class='Ref_to_Const'>BUFFER_LOCK_SHARE</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN226"><span class='Ref_to_Macro'>BufferDescriptorGetContentLock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3547"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3545"><span class='Ref_to_Parameter'>mode</span></a> <span class='Operator'>== </span><a href="../../../include/storage/bufmgr.h.html#LN88"><span class='Ref_to_Const'>BUFFER_LOCK_EXCLUSIVE</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN226"><span class='Ref_to_Macro'>BufferDescriptorGetContentLock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3547"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized buffer lock mode: %d"</span><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3545"><span class='Ref_to_Parameter'>mode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end LockBuffer &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Acquire the content_lock for the buffer, but only if we don't have to wait. 
 * 
 * This assumes the caller wants BUFFER_LOCK_EXCLUSIVE mode. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN3571"></a><span class='Declare_Function'>ConditionalLockBuffer</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> <span class='Declare_Parameter'>buffer</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3573"></a>    <a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>buf</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/bufmgr.h.html#LN113"><span class='Ref_to_Macro'>BufferIsValid</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3571"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN36"><span class='Ref_to_Macro'>BufferIsLocal</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3571"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* act as though we got it */ 
</span> 
    <a href="bufmgr.c.html#LN3573"><span class='Ref_To_Local'>buf</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN219"><span class='Ref_to_Macro'>GetBufferDescriptor</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3571"><span class='Ref_to_Parameter'>buffer</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="../../../include/storage/lwlock.h.html#LN146"><span class='Ref_to_Proto'>LWLockConditionalAcquire</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN226"><span class='Ref_to_Macro'>BufferDescriptorGetContentLock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3573"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                    <a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * LockBufferForCleanup - lock a buffer in preparation for deleting items 
 * 
 * Items may be deleted from a disk page only when the caller (a) holds an 
 * exclusive lock on the buffer and (b) has observed that no other backend 
 * holds a pin on the buffer.  If there is a pin, then the other backend 
 * might have a pointer into the buffer (for example, a heapscan reference 
 * to an item --- see README for more details).  It's OK if a pin is added 
 * after the cleanup starts, however; the newly-arrived backend will be 
 * unable to look at the page until we release the exclusive lock. 
 * 
 * To implement this protocol, a would-be deleter must pin the buffer and 
 * then call LockBufferForCleanup().  LockBufferForCleanup() is similar to 
 * LockBuffer(buffer, BUFFER_LOCK_EXCLUSIVE), except that it loops until 
 * it has successfully observed pin count = 1. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN3602"></a><span class='Declare_Function'>LockBufferForCleanup</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> <span class='Declare_Parameter'>buffer</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3604"></a>    <a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>bufHdr</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/bufmgr.h.html#LN113"><span class='Ref_to_Macro'>BufferIsValid</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3602"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN135"><span class='Ref_to_Global_Var'>PinCountWaitBuf</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN36"><span class='Ref_to_Macro'>BufferIsLocal</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3602"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* There should be exactly one pin */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="localbuf.c.html#LN44"><span class='Ref_to_Global_Var'>LocalRefCount</span></a><span class='Delimiter'>[</span><span class='Operator'>-</span><a href="bufmgr.c.html#LN3602"><span class='Ref_to_Parameter'>buffer</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>!= </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"incorrect local pin count: %d"</span><span class='Delimiter'>, 
</span>                 <a href="localbuf.c.html#LN44"><span class='Ref_to_Global_Var'>LocalRefCount</span></a><span class='Delimiter'>[</span><span class='Operator'>-</span><a href="bufmgr.c.html#LN3602"><span class='Ref_to_Parameter'>buffer</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Nobody else to wait for */ 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* There should be exactly one local pin */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN176"><span class='Ref_to_Proto'>GetPrivateRefCount</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3602"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"incorrect local pin count: %d"</span><span class='Delimiter'>, 
</span>             <a href="bufmgr.c.html#LN176"><span class='Ref_to_Proto'>GetPrivateRefCount</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3602"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="bufmgr.c.html#LN3604"><span class='Ref_To_Local'>bufHdr</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN219"><span class='Ref_to_Macro'>GetBufferDescriptor</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3602"><span class='Ref_to_Parameter'>buffer</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3628"></a>        <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>buf_state</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Try to acquire lock */ 
</span>        <a href="../../../include/storage/bufmgr.h.html#LN214"><span class='Ref_to_Proto'>LockBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3602"><span class='Ref_to_Parameter'>buffer</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/bufmgr.h.html#LN88"><span class='Ref_to_Const'>BUFFER_LOCK_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="bufmgr.c.html#LN3628"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN242"><span class='Ref_to_Proto'>LockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3604"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN48"><span class='Ref_to_Macro'>BUF_STATE_GET_REFCOUNT</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3628"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN48"><span class='Ref_to_Macro'>BUF_STATE_GET_REFCOUNT</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3628"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Successfully acquired exclusive lock with pincount 1 */ 
</span>            <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3604"><span class='Ref_To_Local'>bufHdr</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3628"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Comment_Multi_Line'>/* Failed, so mark myself as waiting for pincount 1 */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3628"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN64"><span class='Ref_to_Const'>BM_PIN_COUNT_WAITER</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3604"><span class='Ref_To_Local'>bufHdr</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3628"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/storage/bufmgr.h.html#LN214"><span class='Ref_to_Proto'>LockBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3602"><span class='Ref_to_Parameter'>buffer</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/bufmgr.h.html#LN86"><span class='Ref_to_Const'>BUFFER_LOCK_UNLOCK</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"multiple backends attempting to wait for pincount 1"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="bufmgr.c.html#LN3604"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN185"><span class='Ref_to_Member'>wait_backend_pid</span></a> <span class='Operator'>= </span><a href="../../utils/init/globals.c.html#LN38"><span class='Ref_to_Global_Var'>MyProcPid</span></a><span class='Delimiter'>; 
</span>        <a href="bufmgr.c.html#LN135"><span class='Ref_to_Global_Var'>PinCountWaitBuf</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN3604"><span class='Ref_To_Local'>bufHdr</span></a><span class='Delimiter'>; 
</span>        <a href="bufmgr.c.html#LN3628"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>|= </span><a href="../../../include/storage/buf_internals.h.html#LN64"><span class='Ref_to_Const'>BM_PIN_COUNT_WAITER</span></a><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3604"><span class='Ref_To_Local'>bufHdr</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3628"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/bufmgr.h.html#LN214"><span class='Ref_to_Proto'>LockBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3602"><span class='Ref_to_Parameter'>buffer</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/bufmgr.h.html#LN86"><span class='Ref_to_Const'>BUFFER_LOCK_UNLOCK</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Wait to be signaled by UnpinBuffer() */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN73"><span class='Ref_to_Const'>InHotStandby</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Publish the bufid that Startup process waits on */ 
</span>            <a href="../../../include/storage/proc.h.html#LN293"><span class='Ref_to_Proto'>SetStartupBufferPinWaitBufId</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3602"><span class='Ref_to_Parameter'>buffer</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* Set alarm and then wait to be signaled by UnpinBuffer() */ 
</span>            <a href="../../../include/storage/standby.h.html#LN35"><span class='Ref_to_Proto'>ResolveRecoveryConflictWithBufferPin</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* Reset the published bufid */ 
</span>            <a href="../../../include/storage/proc.h.html#LN293"><span class='Ref_to_Proto'>SetStartupBufferPinWaitBufId</span></a><span class='Parentheses'>(</span><span class='Operator'>-</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <a href="../../../include/storage/proc.h.html#LN307"><span class='Ref_to_Proto'>ProcWaitForSignal</span></a><span class='Parentheses'>(</span><a href="../../../include/pgstat.h.html#LN738"><span class='Ref_to_Const'>PG_WAIT_BUFFER_PIN</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Remove flag marking us as waiter. Normally this will not be set 
         * anymore, but ProcWaitForSignal() can return for other signals as 
         * well.  We take care to only reset the flag if we're the waiter, as 
         * theoretically another backend could have started waiting. That's 
         * impossible with the current usages due to table level locking, but 
         * better be safe. 
         */ 
</span>        <a href="bufmgr.c.html#LN3628"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN242"><span class='Ref_to_Proto'>LockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3604"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="bufmgr.c.html#LN3628"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN64"><span class='Ref_to_Const'>BM_PIN_COUNT_WAITER</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span> <span class='Operator'>&& 
</span>            <a href="bufmgr.c.html#LN3604"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN185"><span class='Ref_to_Member'>wait_backend_pid</span></a> <span class='Operator'>== </span><a href="../../utils/init/globals.c.html#LN38"><span class='Ref_to_Global_Var'>MyProcPid</span></a><span class='Parentheses'>)</span> 
            <a href="bufmgr.c.html#LN3628"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>&= ~</span><a href="../../../include/storage/buf_internals.h.html#LN64"><span class='Ref_to_Const'>BM_PIN_COUNT_WAITER</span></a><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3604"><span class='Ref_To_Local'>bufHdr</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3628"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="bufmgr.c.html#LN135"><span class='Ref_to_Global_Var'>PinCountWaitBuf</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Loop back and try again */ 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for ;; &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end LockBufferForCleanup &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Check called from RecoveryConflictInterrupt handler when Startup 
 * process requests cancellation of all pin holders that are blocking it. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN3691"></a><span class='Declare_Function'>HoldingBufferPinThatDelaysRecovery</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3693"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>bufid</span> <span class='Operator'>= </span><a href="../../../include/storage/proc.h.html#LN294"><span class='Ref_to_Proto'>GetStartupBufferPinWaitBufId</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we get woken slowly then it's possible that the Startup process was 
     * already woken by other backends before we got here. Also possible that 
     * we get here by multiple interrupts or interrupts at inappropriate 
     * times, so make sure we do nothing if the bufid is not set. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3693"><span class='Ref_To_Local'>bufid</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN176"><span class='Ref_to_Proto'>GetPrivateRefCount</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3693"><span class='Ref_To_Local'>bufid</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * ConditionalLockBufferForCleanup - as above, but don't wait to get the lock 
 * 
 * We won't loop, but just check once to see if the pin count is OK.  If 
 * not, return FALSE with no lock held. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN3717"></a><span class='Declare_Function'>ConditionalLockBufferForCleanup</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> <span class='Declare_Parameter'>buffer</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3719"></a>    <a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>bufHdr</span><span class='Delimiter'>; 
</span><a name="LN3720"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>buf_state</span><span class='Delimiter'>, 
</span><a name="LN3721"></a>                <span class='Declare_Local'>refcount</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/bufmgr.h.html#LN113"><span class='Ref_to_Macro'>BufferIsValid</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3717"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN36"><span class='Ref_to_Macro'>BufferIsLocal</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3717"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="bufmgr.c.html#LN3721"><span class='Ref_To_Local'>refcount</span></a> <span class='Operator'>= </span><a href="localbuf.c.html#LN44"><span class='Ref_to_Global_Var'>LocalRefCount</span></a><span class='Delimiter'>[</span><span class='Operator'>-</span><a href="bufmgr.c.html#LN3717"><span class='Ref_to_Parameter'>buffer</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span>        <span class='Comment_Multi_Line'>/* There should be exactly one pin */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3721"><span class='Ref_To_Local'>refcount</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3721"><span class='Ref_To_Local'>refcount</span></a> <span class='Operator'>!= </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Nobody else to wait for */ 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* There should be exactly one local pin */ 
</span>    <a href="bufmgr.c.html#LN3721"><span class='Ref_To_Local'>refcount</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN176"><span class='Ref_to_Proto'>GetPrivateRefCount</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3717"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3721"><span class='Ref_To_Local'>refcount</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3721"><span class='Ref_To_Local'>refcount</span></a> <span class='Operator'>!= </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Try to acquire lock */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/storage/bufmgr.h.html#LN215"><span class='Ref_to_Proto'>ConditionalLockBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3717"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <a href="bufmgr.c.html#LN3719"><span class='Ref_To_Local'>bufHdr</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN219"><span class='Ref_to_Macro'>GetBufferDescriptor</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3717"><span class='Ref_to_Parameter'>buffer</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="bufmgr.c.html#LN3720"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN242"><span class='Ref_to_Proto'>LockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3719"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="bufmgr.c.html#LN3721"><span class='Ref_To_Local'>refcount</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN48"><span class='Ref_to_Macro'>BUF_STATE_GET_REFCOUNT</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3720"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3721"><span class='Ref_To_Local'>refcount</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3721"><span class='Ref_To_Local'>refcount</span></a> <span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Successfully acquired exclusive lock with pincount 1 */ 
</span>        <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3719"><span class='Ref_To_Local'>bufHdr</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3720"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Failed, so release the lock */ 
</span>    <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3719"><span class='Ref_To_Local'>bufHdr</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3720"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/bufmgr.h.html#LN214"><span class='Ref_to_Proto'>LockBuffer</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3717"><span class='Ref_to_Parameter'>buffer</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/bufmgr.h.html#LN86"><span class='Ref_to_Const'>BUFFER_LOCK_UNLOCK</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ConditionalLockBufferForCleanup &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * IsBufferCleanupOK - as above, but we already have the lock 
 * 
 * Check whether it's OK to perform cleanup on a buffer we've already 
 * locked.  If we observe that the pin count is 1, our exclusive lock 
 * happens to be a cleanup lock, and we can proceed with anything that 
 * would have been allowable had we sought a cleanup lock originally. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN3773"></a><span class='Declare_Function'>IsBufferCleanupOK</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> <span class='Declare_Parameter'>buffer</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3775"></a>    <a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>bufHdr</span><span class='Delimiter'>; 
</span><a name="LN3776"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>buf_state</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/bufmgr.h.html#LN113"><span class='Ref_to_Macro'>BufferIsValid</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3773"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN36"><span class='Ref_to_Macro'>BufferIsLocal</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3773"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* There should be exactly one pin */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="localbuf.c.html#LN44"><span class='Ref_to_Global_Var'>LocalRefCount</span></a><span class='Delimiter'>[</span><span class='Operator'>-</span><a href="bufmgr.c.html#LN3773"><span class='Ref_to_Parameter'>buffer</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>!= </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Nobody else to wait for */ 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* There should be exactly one local pin */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN176"><span class='Ref_to_Proto'>GetPrivateRefCount</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3773"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <a href="bufmgr.c.html#LN3775"><span class='Ref_To_Local'>bufHdr</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN219"><span class='Ref_to_Macro'>GetBufferDescriptor</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3773"><span class='Ref_to_Parameter'>buffer</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* caller must hold exclusive lock on buffer */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN152"><span class='Ref_to_Proto'>LWLockHeldByMeInMode</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN226"><span class='Ref_to_Macro'>BufferDescriptorGetContentLock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3775"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                <a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="bufmgr.c.html#LN3776"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN242"><span class='Ref_to_Proto'>LockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3775"><span class='Ref_To_Local'>bufHdr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN48"><span class='Ref_to_Macro'>BUF_STATE_GET_REFCOUNT</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3776"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN48"><span class='Ref_to_Macro'>BUF_STATE_GET_REFCOUNT</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3776"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* pincount is OK. */ 
</span>        <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3775"><span class='Ref_To_Local'>bufHdr</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3776"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3775"><span class='Ref_To_Local'>bufHdr</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3776"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end IsBufferCleanupOK &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 *  Functions for buffer I/O handling 
 * 
 *  Note: We assume that nested buffer I/O never occurs. 
 *  i.e at most one io_in_progress lock is held per proc. 
 * 
 *  Also note that these are used only for shared buffers, not local ones. 
 */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * WaitIO -- Block until the IO_IN_PROGRESS flag on 'buf' is cleared. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3827"></a><span class='Declare_Function'>WaitIO</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>buf</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * Changed to wait until there's no IO - Inoue 01/13/2000 
     * 
     * Note this is *necessary* because an error abort in the process doing 
     * I/O could release the io_in_progress_lock prematurely. See 
     * AbortBufferIO. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3838"></a>        <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>buf_state</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * It may not be necessary to acquire the spinlock to check the flag 
         * here, but since this test is essential for correctness, we'd better 
         * play it safe. 
         */ 
</span>        <a href="bufmgr.c.html#LN3838"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN242"><span class='Ref_to_Proto'>LockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3827"><span class='Ref_to_Parameter'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3827"><span class='Ref_to_Parameter'>buf</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3838"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3838"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN61"><span class='Ref_to_Const'>BM_IO_IN_PROGRESS</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN224"><span class='Ref_to_Macro'>BufferDescriptorGetIOLock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3827"><span class='Ref_to_Parameter'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN224"><span class='Ref_to_Macro'>BufferDescriptorGetIOLock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3827"><span class='Ref_to_Parameter'>buf</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end WaitIO &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * StartBufferIO: begin I/O on this buffer 
 *  (Assumptions) 
 *  My process is executing no IO 
 *  The buffer is Pinned 
 * 
 * In some scenarios there are race conditions in which multiple backends 
 * could attempt the same I/O operation concurrently.  If someone else 
 * has already started I/O on this buffer then we will block on the 
 * io_in_progress lock until he's done. 
 * 
 * Input operations are only attempted on buffers that are not BM_VALID, 
 * and output operations only on buffers that are BM_VALID and BM_DIRTY, 
 * so we can always tell if the work is already done. 
 * 
 * Returns TRUE if we successfully marked the buffer as I/O busy, 
 * FALSE if someone else already did the work. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN3874"></a><span class='Declare_Function'>StartBufferIO</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>buf</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>forInput</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3876"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>buf_state</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="bufmgr.c.html#LN131"><span class='Ref_to_Global_Var'>InProgressBuf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Grab the io_in_progress lock so that other processes can wait for 
         * me to finish the I/O. 
         */ 
</span>        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN224"><span class='Ref_to_Macro'>BufferDescriptorGetIOLock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3874"><span class='Ref_to_Parameter'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="bufmgr.c.html#LN3876"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN242"><span class='Ref_to_Proto'>LockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3874"><span class='Ref_to_Parameter'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3876"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN61"><span class='Ref_to_Const'>BM_IO_IN_PROGRESS</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * The only way BM_IO_IN_PROGRESS could be set when the io_in_progress 
         * lock isn't held is if the process doing the I/O is recovering from 
         * an error (see AbortBufferIO).  If that's the case, we must wait for 
         * him to get unwedged. 
         */ 
</span>        <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3874"><span class='Ref_to_Parameter'>buf</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3876"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN224"><span class='Ref_to_Macro'>BufferDescriptorGetIOLock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3874"><span class='Ref_to_Parameter'>buf</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="bufmgr.c.html#LN440"><span class='Ref_to_Proto'>WaitIO</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3874"><span class='Ref_to_Parameter'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for ;; &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Once we get here, there is definitely no I/O active on this buffer */ 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3874"><span class='Ref_to_Parameter'>forInput</span></a> <span class='Operator'>? </span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3876"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN59"><span class='Ref_to_Const'>BM_VALID</span></a><span class='Parentheses'>) </span><span class='Operator'>: !</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3876"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN58"><span class='Ref_to_Const'>BM_DIRTY</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* someone else already did the I/O */ 
</span>        <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3874"><span class='Ref_to_Parameter'>buf</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3876"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN224"><span class='Ref_to_Macro'>BufferDescriptorGetIOLock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3874"><span class='Ref_to_Parameter'>buf</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="bufmgr.c.html#LN3876"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>|= </span><a href="../../../include/storage/buf_internals.h.html#LN61"><span class='Ref_to_Const'>BM_IO_IN_PROGRESS</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3874"><span class='Ref_to_Parameter'>buf</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3876"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="bufmgr.c.html#LN131"><span class='Ref_to_Global_Var'>InProgressBuf</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN3874"><span class='Ref_to_Parameter'>buf</span></a><span class='Delimiter'>; 
</span>    <a href="bufmgr.c.html#LN132"><span class='Ref_to_Global_Var'>IsForInput</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN3874"><span class='Ref_to_Parameter'>forInput</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end StartBufferIO &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * TerminateBufferIO: release a buffer we were doing I/O on 
 *  (Assumptions) 
 *  My process is executing IO for the buffer 
 *  BM_IO_IN_PROGRESS bit is set for the buffer 
 *  We hold the buffer's io_in_progress lock 
 *  The buffer is Pinned 
 * 
 * If clear_dirty is TRUE and BM_JUST_DIRTIED is not set, we clear the 
 * buffer's BM_DIRTY flag.  This is appropriate when terminating a 
 * successful write.  The check on BM_JUST_DIRTIED is necessary to avoid 
 * marking the buffer clean if it was re-dirtied while we were writing. 
 * 
 * set_flag_bits gets ORed into the buffer's flags.  It must include 
 * BM_IO_ERROR in a failure case.  For successful completion it could 
 * be 0, or BM_VALID if we just finished reading in the page. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3941"></a><span class='Declare_Function'>TerminateBufferIO</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>buf</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>clear_dirty</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Parameter'>set_flag_bits</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3943"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>buf_state</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3941"><span class='Ref_to_Parameter'>buf</span></a> <span class='Operator'>== </span><a href="bufmgr.c.html#LN131"><span class='Ref_to_Global_Var'>InProgressBuf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="bufmgr.c.html#LN3943"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN242"><span class='Ref_to_Proto'>LockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3941"><span class='Ref_to_Parameter'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3943"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN61"><span class='Ref_to_Const'>BM_IO_IN_PROGRESS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="bufmgr.c.html#LN3943"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>&= ~</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN61"><span class='Ref_to_Const'>BM_IO_IN_PROGRESS</span></a> <span class='Operator'>| </span><a href="../../../include/storage/buf_internals.h.html#LN62"><span class='Ref_to_Const'>BM_IO_ERROR</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3941"><span class='Ref_to_Parameter'>clear_dirty</span></a> <span class='Operator'>&& !</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3943"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN63"><span class='Ref_to_Const'>BM_JUST_DIRTIED</span></a><span class='Parentheses'>))</span> 
        <a href="bufmgr.c.html#LN3943"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>&= ~</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN58"><span class='Ref_to_Const'>BM_DIRTY</span></a> <span class='Operator'>| </span><a href="../../../include/storage/buf_internals.h.html#LN65"><span class='Ref_to_Const'>BM_CHECKPOINT_NEEDED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="bufmgr.c.html#LN3943"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>|= </span><a href="bufmgr.c.html#LN3941"><span class='Ref_to_Parameter'>set_flag_bits</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3941"><span class='Ref_to_Parameter'>buf</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3943"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="bufmgr.c.html#LN131"><span class='Ref_to_Global_Var'>InProgressBuf</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN224"><span class='Ref_to_Macro'>BufferDescriptorGetIOLock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3941"><span class='Ref_to_Parameter'>buf</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end TerminateBufferIO &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * AbortBufferIO: Clean up any active buffer I/O after an error. 
 * 
 *  All LWLocks we might have held have been released, 
 *  but we haven't yet released buffer pins, so the buffer is still pinned. 
 * 
 *  If I/O was in progress, we always set BM_IO_ERROR, even though it's 
 *  possible the error condition wasn't related to the I/O. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN3973"></a><span class='Declare_Function'>AbortBufferIO</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3975"></a>    <a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>buf</span> <span class='Operator'>= </span><a href="bufmgr.c.html#LN131"><span class='Ref_to_Global_Var'>InProgressBuf</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3975"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3979"></a>        <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>buf_state</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Since LWLockReleaseAll has already been called, we're not holding 
         * the buffer's io_in_progress_lock. We have to re-acquire it so that 
         * we can use TerminateBufferIO. Anyone who's executing WaitIO on the 
         * buffer will be in a busy spin until we succeed in doing this. 
         */ 
</span>        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN224"><span class='Ref_to_Macro'>BufferDescriptorGetIOLock</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3975"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="bufmgr.c.html#LN3979"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN242"><span class='Ref_to_Proto'>LockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3975"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3979"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN61"><span class='Ref_to_Const'>BM_IO_IN_PROGRESS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN132"><span class='Ref_to_Global_Var'>IsForInput</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3979"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN58"><span class='Ref_to_Const'>BM_DIRTY</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* We'd better not think buffer is valid yet */ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3979"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN59"><span class='Ref_to_Const'>BM_VALID</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3975"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3979"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3979"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN58"><span class='Ref_to_Const'>BM_DIRTY</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3975"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3979"><span class='Ref_To_Local'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* Issue notice if this is not the first failure... */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3979"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN62"><span class='Ref_to_Const'>BM_IO_ERROR</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Buffer is pinned, so we can read tag without spinlock */ 
</span><a name="LN4007"></a>                <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>path</span><span class='Delimiter'>; 
</span> 
                <a href="bufmgr.c.html#LN4007"><span class='Ref_To_Local'>path</span></a> <span class='Operator'>= </span><a href="../../../include/common/relpath.h.html#LN66"><span class='Ref_to_Macro'>relpathperm</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3975"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN92"><span class='Ref_to_Member'>rnode</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN3975"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN93"><span class='Ref_to_Member'>forkNum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN39"><span class='Ref_to_Const'>WARNING</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_IO_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not write block %u of %s"</span><span class='Delimiter'>, 
</span>                                <a href="bufmgr.c.html#LN3975"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN94"><span class='Ref_to_Member'>blockNum</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN4007"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"Multiple failures --- write error might be permanent."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4007"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>        <a href="bufmgr.c.html#LN442"><span class='Ref_to_Proto'>TerminateBufferIO</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN3975"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><a href="../../../include/storage/buf_internals.h.html#LN62"><span class='Ref_to_Const'>BM_IO_ERROR</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if buf &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end AbortBufferIO &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Error context callback for errors occurring during shared buffer writes. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN4026"></a><span class='Declare_Function'>shared_buffer_write_error_callback</span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>arg</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4028"></a>    <a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>bufHdr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="bufmgr.c.html#LN4026"><span class='Ref_to_Parameter'>arg</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Buffer is pinned, so we can read the tag without locking the spinlock */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4028"><span class='Ref_To_Local'>bufHdr</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN4033"></a>        <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>path</span> <span class='Operator'>= </span><a href="../../../include/common/relpath.h.html#LN66"><span class='Ref_to_Macro'>relpathperm</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4028"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN92"><span class='Ref_to_Member'>rnode</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN4028"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN93"><span class='Ref_to_Member'>forkNum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        errcontext<span class='Parentheses'>(</span><span class='String'>"writing block %u of relation %s"</span><span class='Delimiter'>, 
</span>                   <a href="bufmgr.c.html#LN4028"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN94"><span class='Ref_to_Member'>blockNum</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN4033"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4033"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Error context callback for errors occurring during local buffer writes. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN4045"></a><span class='Declare_Function'>local_buffer_write_error_callback</span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>arg</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4047"></a>    <a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>bufHdr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="bufmgr.c.html#LN4045"><span class='Ref_to_Parameter'>arg</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4047"><span class='Ref_To_Local'>bufHdr</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN4051"></a>        <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>path</span> <span class='Operator'>= </span><a href="../../../include/common/relpath.h.html#LN61"><span class='Ref_to_Macro'>relpathbackend</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4047"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN92"><span class='Ref_to_Member'>rnode</span></a><span class='Delimiter'>, </span><a href="../../utils/init/globals.c.html#LN72"><span class='Ref_to_Global_Var'>MyBackendId</span></a><span class='Delimiter'>, 
</span>                                          <a href="bufmgr.c.html#LN4047"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN93"><span class='Ref_to_Member'>forkNum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        errcontext<span class='Parentheses'>(</span><span class='String'>"writing block %u of relation %s"</span><span class='Delimiter'>, 
</span>                   <a href="bufmgr.c.html#LN4047"><span class='Ref_To_Local'>bufHdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN179"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN94"><span class='Ref_to_Member'>blockNum</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN4051"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4051"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * RelFileNode qsort/bsearch comparator; see RelFileNodeEquals. 
 */ 
</span><span class='Keyword'>static int 
</span><a name="LN4064"></a><span class='Declare_Function'>rnode_comparator</span><span class='Parentheses'>(</span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>p1</span><span class='Delimiter'>, </span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>p2</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4066"></a>    <a href="../../../include/storage/relfilenode.h.html#LN56"><span class='Ref_to_Struct'>RelFileNode</span></a> <span class='Declare_Local'>n1</span> <span class='Operator'>= *</span><span class='Parentheses'>(</span><a href="../../../include/storage/relfilenode.h.html#LN56"><span class='Ref_to_Struct'>RelFileNode</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="bufmgr.c.html#LN4064"><span class='Ref_to_Parameter'>p1</span></a><span class='Delimiter'>; 
</span><a name="LN4067"></a>    <a href="../../../include/storage/relfilenode.h.html#LN56"><span class='Ref_to_Struct'>RelFileNode</span></a> <span class='Declare_Local'>n2</span> <span class='Operator'>= *</span><span class='Parentheses'>(</span><a href="../../../include/storage/relfilenode.h.html#LN56"><span class='Ref_to_Struct'>RelFileNode</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="bufmgr.c.html#LN4064"><span class='Ref_to_Parameter'>p2</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4066"><span class='Ref_To_Local'>n1</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN60"><span class='Ref_to_Member'>relNode</span></a> <span class='Operator'>&LT; </span><a href="bufmgr.c.html#LN4067"><span class='Ref_To_Local'>n2</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN60"><span class='Ref_to_Member'>relNode</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4066"><span class='Ref_To_Local'>n1</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN60"><span class='Ref_to_Member'>relNode</span></a> <span class='Operator'>&GT; </span><a href="bufmgr.c.html#LN4067"><span class='Ref_To_Local'>n2</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN60"><span class='Ref_to_Member'>relNode</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4066"><span class='Ref_To_Local'>n1</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN59"><span class='Ref_to_Member'>dbNode</span></a> <span class='Operator'>&LT; </span><a href="bufmgr.c.html#LN4067"><span class='Ref_To_Local'>n2</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN59"><span class='Ref_to_Member'>dbNode</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4066"><span class='Ref_To_Local'>n1</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN59"><span class='Ref_to_Member'>dbNode</span></a> <span class='Operator'>&GT; </span><a href="bufmgr.c.html#LN4067"><span class='Ref_To_Local'>n2</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN59"><span class='Ref_to_Member'>dbNode</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4066"><span class='Ref_To_Local'>n1</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN58"><span class='Ref_to_Member'>spcNode</span></a> <span class='Operator'>&LT; </span><a href="bufmgr.c.html#LN4067"><span class='Ref_To_Local'>n2</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN58"><span class='Ref_to_Member'>spcNode</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4066"><span class='Ref_To_Local'>n1</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN58"><span class='Ref_to_Member'>spcNode</span></a> <span class='Operator'>&GT; </span><a href="bufmgr.c.html#LN4067"><span class='Ref_To_Local'>n2</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN58"><span class='Ref_to_Member'>spcNode</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <span class='Control'>return</span> <span class='Number'>0</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end rnode_comparator &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Lock buffer header - set BM_LOCKED in buffer state. 
 */ 
</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> 
<a name="LN4091"></a><span class='Declare_Function'>LockBufHdr</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>desc</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4093"></a>    <a href="../../../include/storage/s_lock.h.html#LN974"><span class='Ref_to_Typedef'>SpinDelayStatus</span></a> <span class='Declare_Local'>delayStatus</span><span class='Delimiter'>; 
</span><a name="LN4094"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>old_buf_state</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/s_lock.h.html#LN996"><span class='Ref_to_Macro'>init_local_spin_delay</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN4093"><span class='Ref_To_Local'>delayStatus</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>while</span> <span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* set BM_LOCKED flag */ 
</span>        <a href="bufmgr.c.html#LN4094"><span class='Ref_To_Local'>old_buf_state</span></a> <span class='Operator'>= </span><a href="../../../include/port/atomics.h.html#LN381"><span class='Ref_to_Func'>pg_atomic_fetch_or_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN4091"><span class='Ref_to_Parameter'>desc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN183"><span class='Ref_to_Member'>state</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/buf_internals.h.html#LN57"><span class='Ref_to_Const'>BM_LOCKED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* if it wasn't set before we're OK */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4094"><span class='Ref_To_Local'>old_buf_state</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN57"><span class='Ref_to_Const'>BM_LOCKED</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <a href="../lmgr/s_lock.c.html#LN123"><span class='Ref_to_Func'>perform_spin_delay</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN4093"><span class='Ref_To_Local'>delayStatus</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../lmgr/s_lock.c.html#LN173"><span class='Ref_to_Func'>finish_spin_delay</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN4093"><span class='Ref_To_Local'>delayStatus</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="bufmgr.c.html#LN4094"><span class='Ref_To_Local'>old_buf_state</span></a> <span class='Operator'>| </span><a href="../../../include/storage/buf_internals.h.html#LN57"><span class='Ref_to_Const'>BM_LOCKED</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end LockBufHdr &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Wait until the BM_LOCKED flag isn't set anymore and return the buffer's 
 * state at that point. 
 * 
 * Obviously the buffer could be locked by the time the value is returned, so 
 * this is primarily useful in CAS style loops. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> 
<a name="LN4119"></a><span class='Declare_Function'>WaitBufHdrUnlocked</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>buf</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4121"></a>    <a href="../../../include/storage/s_lock.h.html#LN974"><span class='Ref_to_Typedef'>SpinDelayStatus</span></a> <span class='Declare_Local'>delayStatus</span><span class='Delimiter'>; 
</span><a name="LN4122"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>buf_state</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/s_lock.h.html#LN996"><span class='Ref_to_Macro'>init_local_spin_delay</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN4121"><span class='Ref_To_Local'>delayStatus</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="bufmgr.c.html#LN4122"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>= </span><a href="../../../include/port/atomics.h.html#LN250"><span class='Ref_to_Func'>pg_atomic_read_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN4119"><span class='Ref_to_Parameter'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN183"><span class='Ref_to_Member'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4122"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>& </span><a href="../../../include/storage/buf_internals.h.html#LN57"><span class='Ref_to_Const'>BM_LOCKED</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../lmgr/s_lock.c.html#LN123"><span class='Ref_to_Func'>perform_spin_delay</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN4121"><span class='Ref_To_Local'>delayStatus</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="bufmgr.c.html#LN4122"><span class='Ref_To_Local'>buf_state</span></a> <span class='Operator'>= </span><a href="../../../include/port/atomics.h.html#LN250"><span class='Ref_to_Func'>pg_atomic_read_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN4119"><span class='Ref_to_Parameter'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN183"><span class='Ref_to_Member'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../lmgr/s_lock.c.html#LN173"><span class='Ref_to_Func'>finish_spin_delay</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN4121"><span class='Ref_To_Local'>delayStatus</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="bufmgr.c.html#LN4122"><span class='Ref_To_Local'>buf_state</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end WaitBufHdrUnlocked &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * BufferTag comparator. 
 */ 
</span><span class='Keyword'>static int 
</span><a name="LN4143"></a><span class='Declare_Function'>buffertag_comparator</span><span class='Parentheses'>(</span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>a</span><span class='Delimiter'>, </span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>b</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4145"></a>    <span class='Keyword'>const </span><a href="../../../include/storage/buf_internals.h.html#LN90"><span class='Ref_to_Typedef'>BufferTag</span></a> <span class='Operator'>*</span><span class='Declare_Local'>ba</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../../include/storage/buf_internals.h.html#LN90"><span class='Ref_to_Typedef'>BufferTag</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="bufmgr.c.html#LN4143"><span class='Ref_to_Parameter'>a</span></a><span class='Delimiter'>; 
</span><a name="LN4146"></a>    <span class='Keyword'>const </span><a href="../../../include/storage/buf_internals.h.html#LN90"><span class='Ref_to_Typedef'>BufferTag</span></a> <span class='Operator'>*</span><span class='Declare_Local'>bb</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../../include/storage/buf_internals.h.html#LN90"><span class='Ref_to_Typedef'>BufferTag</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="bufmgr.c.html#LN4143"><span class='Ref_to_Parameter'>b</span></a><span class='Delimiter'>; 
</span><a name="LN4147"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>ret</span><span class='Delimiter'>; 
</span> 
    <a href="bufmgr.c.html#LN4147"><span class='Ref_To_Local'>ret</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN455"><span class='Ref_to_Proto'>rnode_comparator</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN4145"><span class='Ref_To_Local'>ba</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN92"><span class='Ref_to_Member'>rnode</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="bufmgr.c.html#LN4146"><span class='Ref_To_Local'>bb</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN92"><span class='Ref_to_Member'>rnode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4147"><span class='Ref_To_Local'>ret</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="bufmgr.c.html#LN4147"><span class='Ref_To_Local'>ret</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4145"><span class='Ref_To_Local'>ba</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN93"><span class='Ref_to_Member'>forkNum</span></a> <span class='Operator'>&LT; </span><a href="bufmgr.c.html#LN4146"><span class='Ref_To_Local'>bb</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN93"><span class='Ref_to_Member'>forkNum</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4145"><span class='Ref_To_Local'>ba</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN93"><span class='Ref_to_Member'>forkNum</span></a> <span class='Operator'>&GT; </span><a href="bufmgr.c.html#LN4146"><span class='Ref_To_Local'>bb</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN93"><span class='Ref_to_Member'>forkNum</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4145"><span class='Ref_To_Local'>ba</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN94"><span class='Ref_to_Member'>blockNum</span></a> <span class='Operator'>&LT; </span><a href="bufmgr.c.html#LN4146"><span class='Ref_To_Local'>bb</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN94"><span class='Ref_to_Member'>blockNum</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4145"><span class='Ref_To_Local'>ba</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN94"><span class='Ref_to_Member'>blockNum</span></a> <span class='Operator'>&GT; </span><a href="bufmgr.c.html#LN4146"><span class='Ref_To_Local'>bb</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN94"><span class='Ref_to_Member'>blockNum</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Number'>0</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end buffertag_comparator &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Comparator determining the writeout order in a checkpoint. 
 * 
 * It is important that tablespaces are compared first, the logic balancing 
 * writes between tablespaces relies on it. 
 */ 
</span><span class='Keyword'>static int 
</span><a name="LN4174"></a><span class='Declare_Function'>ckpt_buforder_comparator</span><span class='Parentheses'>(</span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>pa</span><span class='Delimiter'>, </span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>pb</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4176"></a>    <span class='Keyword'>const </span><a href="../../../include/storage/buf_internals.h.html#LN288"><span class='Ref_to_Struct'>CkptSortItem</span></a> <span class='Operator'>*</span><span class='Declare_Local'>a</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN288"><span class='Ref_to_Struct'>CkptSortItem</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="bufmgr.c.html#LN4174"><span class='Ref_to_Parameter'>pa</span></a><span class='Delimiter'>; 
</span><a name="LN4177"></a>    <span class='Keyword'>const </span><a href="../../../include/storage/buf_internals.h.html#LN288"><span class='Ref_to_Struct'>CkptSortItem</span></a> <span class='Operator'>*</span><span class='Declare_Local'>b</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN288"><span class='Ref_to_Struct'>CkptSortItem</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="bufmgr.c.html#LN4174"><span class='Ref_to_Parameter'>pb</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* compare tablespace */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4176"><span class='Ref_To_Local'>a</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN290"><span class='Ref_to_Member'>tsId</span></a> <span class='Operator'>&LT; </span><a href="bufmgr.c.html#LN4177"><span class='Ref_To_Local'>b</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN290"><span class='Ref_to_Member'>tsId</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4176"><span class='Ref_To_Local'>a</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN290"><span class='Ref_to_Member'>tsId</span></a> <span class='Operator'>&GT; </span><a href="bufmgr.c.html#LN4177"><span class='Ref_To_Local'>b</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN290"><span class='Ref_to_Member'>tsId</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* compare relation */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4176"><span class='Ref_To_Local'>a</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN291"><span class='Ref_to_Member'>relNode</span></a> <span class='Operator'>&LT; </span><a href="bufmgr.c.html#LN4177"><span class='Ref_To_Local'>b</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN291"><span class='Ref_to_Member'>relNode</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4176"><span class='Ref_To_Local'>a</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN291"><span class='Ref_to_Member'>relNode</span></a> <span class='Operator'>&GT; </span><a href="bufmgr.c.html#LN4177"><span class='Ref_To_Local'>b</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN291"><span class='Ref_to_Member'>relNode</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* compare fork */ 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4176"><span class='Ref_To_Local'>a</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN292"><span class='Ref_to_Member'>forkNum</span></a> <span class='Operator'>&LT; </span><a href="bufmgr.c.html#LN4177"><span class='Ref_To_Local'>b</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN292"><span class='Ref_to_Member'>forkNum</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4176"><span class='Ref_To_Local'>a</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN292"><span class='Ref_to_Member'>forkNum</span></a> <span class='Operator'>&GT; </span><a href="bufmgr.c.html#LN4177"><span class='Ref_To_Local'>b</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN292"><span class='Ref_to_Member'>forkNum</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* compare block number */ 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4176"><span class='Ref_To_Local'>a</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN293"><span class='Ref_to_Member'>blockNum</span></a> <span class='Operator'>&LT; </span><a href="bufmgr.c.html#LN4177"><span class='Ref_To_Local'>b</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN293"><span class='Ref_to_Member'>blockNum</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span>    <span class='Comment_Single_Line'>/* should not be the same block ... */ 
</span>        <span class='Control'>return</span> <span class='Number'>1</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ckpt_buforder_comparator &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Comparator for a Min-Heap over the per-tablespace checkpoint completion 
 * progress. 
 */ 
</span><span class='Keyword'>static int 
</span><a name="LN4206"></a><span class='Declare_Function'>ts_ckpt_progress_comparator</span><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>a</span><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>b</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>arg</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4208"></a>    <a href="bufmgr.c.html#LN82"><span class='Ref_to_Struct'>CkptTsStatus</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sa</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN82"><span class='Ref_to_Struct'>CkptTsStatus</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="bufmgr.c.html#LN4206"><span class='Ref_to_Parameter'>a</span></a><span class='Delimiter'>; 
</span><a name="LN4209"></a>    <a href="bufmgr.c.html#LN82"><span class='Ref_to_Struct'>CkptTsStatus</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sb</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN82"><span class='Ref_to_Struct'>CkptTsStatus</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="bufmgr.c.html#LN4206"><span class='Ref_to_Parameter'>b</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* we want a min-heap, so return 1 for the a &LT; b */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4208"><span class='Ref_To_Local'>sa</span></a><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN94"><span class='Ref_to_Member'>progress</span></a> <span class='Operator'>&LT; </span><a href="bufmgr.c.html#LN4209"><span class='Ref_To_Local'>sb</span></a><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN94"><span class='Ref_to_Member'>progress</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4208"><span class='Ref_To_Local'>sa</span></a><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN94"><span class='Ref_to_Member'>progress</span></a> <span class='Operator'>== </span><a href="bufmgr.c.html#LN4209"><span class='Ref_To_Local'>sb</span></a><span class='Operator'>-&GT;</span><a href="bufmgr.c.html#LN94"><span class='Ref_to_Member'>progress</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <span class='Control'>return</span> <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Initialize a writeback context, discarding potential previous state. 
 * 
 * *max_pending is a pointer instead of an immediate value, so the coalesce 
 * limits can easily changed by the GUC mechanism, and so calling code does 
 * not have to check the current configuration. A value is 0 means that no 
 * writeback control will be performed. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN4229"></a><span class='Declare_Function'>WritebackContextInit</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN261"><span class='Ref_to_Struct'>WritebackContext</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Operator'>*</span><span class='Declare_Parameter'>max_pending</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="bufmgr.c.html#LN4229"><span class='Ref_to_Parameter'>max_pending</span></a> <span class='Operator'>&LT;= </span><a href="../../../include/pg_config_manual.h.html#LN164"><span class='Ref_to_Const'>WRITEBACK_MAX_PENDING_FLUSHES</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="bufmgr.c.html#LN4229"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN264"><span class='Ref_to_Member'>max_pending</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN4229"><span class='Ref_to_Parameter'>max_pending</span></a><span class='Delimiter'>; 
</span>    <a href="bufmgr.c.html#LN4229"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN267"><span class='Ref_to_Member'>nr_pending</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Add buffer to list of pending writeback requests. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN4241"></a><span class='Declare_Function'>ScheduleBufferTagForWriteback</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN261"><span class='Ref_to_Struct'>WritebackContext</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Delimiter'>, </span><a href="../../../include/storage/buf_internals.h.html#LN90"><span class='Ref_to_Typedef'>BufferTag</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tag</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4243"></a>    <a href="../../../include/storage/buf_internals.h.html#LN254"><span class='Ref_to_Struct'>PendingWriteback</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pending</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Add buffer to the pending writeback array, unless writeback control is 
     * disabled. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="bufmgr.c.html#LN4241"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN264"><span class='Ref_to_Member'>max_pending</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="bufmgr.c.html#LN4241"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN264"><span class='Ref_to_Member'>max_pending</span></a> <span class='Operator'>&LT;= </span><a href="../../../include/pg_config_manual.h.html#LN164"><span class='Ref_to_Const'>WRITEBACK_MAX_PENDING_FLUSHES</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="bufmgr.c.html#LN4243"><span class='Ref_To_Local'>pending</span></a> <span class='Operator'>= &</span><a href="bufmgr.c.html#LN4241"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN270"><span class='Ref_to_Member'>pending_writebacks</span></a><span class='Delimiter'>[</span><a href="bufmgr.c.html#LN4241"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN267"><span class='Ref_to_Member'>nr_pending</span></a><span class='Operator'>++</span><span class='Delimiter'>]; 
</span> 
        <a href="bufmgr.c.html#LN4243"><span class='Ref_To_Local'>pending</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN257"><span class='Ref_to_Member'>tag</span></a> <span class='Operator'>= *</span><a href="bufmgr.c.html#LN4241"><span class='Ref_to_Parameter'>tag</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Perform pending flushes if the writeback limit is exceeded. This 
     * includes the case where previously an item has been added, but control 
     * is now disabled. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4241"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN267"><span class='Ref_to_Member'>nr_pending</span></a> <span class='Operator'>&GT;= *</span><a href="bufmgr.c.html#LN4241"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN264"><span class='Ref_to_Member'>max_pending</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/buf_internals.h.html#LN304"><span class='Ref_to_Proto'>IssuePendingWritebacks</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4241"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ScheduleBufferTagForWriteback &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Issue all pending writeback requests, previously scheduled with 
 * ScheduleBufferTagForWriteback, to the OS. 
 * 
 * Because this is only used to improve the OSs IO scheduling we try to never 
 * error out - it's just a hint. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN4275"></a><span class='Declare_Function'>IssuePendingWritebacks</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN261"><span class='Ref_to_Struct'>WritebackContext</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4277"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4275"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN267"><span class='Ref_to_Member'>nr_pending</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Executing the writes in-order can make them a lot faster, and allows to 
     * merge writeback requests to consecutive blocks into larger writebacks. 
     */ 
</span>    <a href="../../../include/port.h.html#LN439"><span class='Ref_to_Macro'>qsort</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="bufmgr.c.html#LN4275"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN270"><span class='Ref_to_Member'>pending_writebacks</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN4275"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN267"><span class='Ref_to_Member'>nr_pending</span></a><span class='Delimiter'>, 
</span>          <span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN254"><span class='Ref_to_Struct'>PendingWriteback</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN456"><span class='Ref_to_Proto'>buffertag_comparator</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Coalesce neighbouring writes, but nothing else. For that we iterate 
     * through the, now sorted, array of pending flushes, and look forward to 
     * find all neighbouring (or identical) writes. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4277"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="bufmgr.c.html#LN4277"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="bufmgr.c.html#LN4275"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN267"><span class='Ref_to_Member'>nr_pending</span></a><span class='Delimiter'>; </span><a href="bufmgr.c.html#LN4277"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN4296"></a>        <a href="../../../include/storage/buf_internals.h.html#LN254"><span class='Ref_to_Struct'>PendingWriteback</span></a> <span class='Operator'>*</span><span class='Declare_Local'>cur</span><span class='Delimiter'>; 
</span><a name="LN4297"></a>        <a href="../../../include/storage/buf_internals.h.html#LN254"><span class='Ref_to_Struct'>PendingWriteback</span></a> <span class='Operator'>*</span><span class='Declare_Local'>next</span><span class='Delimiter'>; 
</span><a name="LN4298"></a>        <a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> <span class='Declare_Local'>reln</span><span class='Delimiter'>; 
</span><a name="LN4299"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>ahead</span><span class='Delimiter'>; 
</span><a name="LN4300"></a>        <a href="../../../include/storage/buf_internals.h.html#LN90"><span class='Ref_to_Typedef'>BufferTag</span></a>   <span class='Declare_Local'>tag</span><span class='Delimiter'>; 
</span><a name="LN4301"></a>        <a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Local'>nblocks</span> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
        <a href="bufmgr.c.html#LN4296"><span class='Ref_To_Local'>cur</span></a> <span class='Operator'>= &</span><a href="bufmgr.c.html#LN4275"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN270"><span class='Ref_to_Member'>pending_writebacks</span></a><span class='Delimiter'>[</span><a href="bufmgr.c.html#LN4277"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>        <a href="bufmgr.c.html#LN4300"><span class='Ref_To_Local'>tag</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN4296"><span class='Ref_To_Local'>cur</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN257"><span class='Ref_to_Member'>tag</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Peek ahead, into following writeback requests, to see if they can 
         * be combined with the current one. 
         */ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4299"><span class='Ref_To_Local'>ahead</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="bufmgr.c.html#LN4277"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>+ </span><a href="bufmgr.c.html#LN4299"><span class='Ref_To_Local'>ahead</span></a> <span class='Operator'>+ </span><span class='Number'>1</span> <span class='Operator'>&LT; </span><a href="bufmgr.c.html#LN4275"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN267"><span class='Ref_to_Member'>nr_pending</span></a><span class='Delimiter'>; </span><a href="bufmgr.c.html#LN4299"><span class='Ref_To_Local'>ahead</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="bufmgr.c.html#LN4297"><span class='Ref_To_Local'>next</span></a> <span class='Operator'>= &</span><a href="bufmgr.c.html#LN4275"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN270"><span class='Ref_to_Member'>pending_writebacks</span></a><span class='Delimiter'>[</span><a href="bufmgr.c.html#LN4277"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>+ </span><a href="bufmgr.c.html#LN4299"><span class='Ref_To_Local'>ahead</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span> 
            <span class='Comment_Multi_Line'>/* different file, stop */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/storage/relfilenode.h.html#LN87"><span class='Ref_to_Macro'>RelFileNodeEquals</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4296"><span class='Ref_To_Local'>cur</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN257"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN92"><span class='Ref_to_Member'>rnode</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN4297"><span class='Ref_To_Local'>next</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN257"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN92"><span class='Ref_to_Member'>rnode</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>                <a href="bufmgr.c.html#LN4296"><span class='Ref_To_Local'>cur</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN257"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN93"><span class='Ref_to_Member'>forkNum</span></a> <span class='Operator'>!= </span><a href="bufmgr.c.html#LN4297"><span class='Ref_To_Local'>next</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN257"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN93"><span class='Ref_to_Member'>forkNum</span></a><span class='Parentheses'>)</span> 
                <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* ok, block queued twice, skip */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4296"><span class='Ref_To_Local'>cur</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN257"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN94"><span class='Ref_to_Member'>blockNum</span></a> <span class='Operator'>== </span><a href="bufmgr.c.html#LN4297"><span class='Ref_To_Local'>next</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN257"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN94"><span class='Ref_to_Member'>blockNum</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* only merge consecutive writes */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4296"><span class='Ref_To_Local'>cur</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN257"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN94"><span class='Ref_to_Member'>blockNum</span></a> <span class='Operator'>+ </span><span class='Number'>1</span> <span class='Operator'>!= </span><a href="bufmgr.c.html#LN4297"><span class='Ref_To_Local'>next</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN257"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN94"><span class='Ref_to_Member'>blockNum</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
            <a href="bufmgr.c.html#LN4301"><span class='Ref_To_Local'>nblocks</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <a href="bufmgr.c.html#LN4296"><span class='Ref_To_Local'>cur</span></a> <span class='Operator'>= </span><a href="bufmgr.c.html#LN4297"><span class='Ref_To_Local'>next</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for ahead=0;i+ahead+1&LT;con... &raquo; </span> 
 
        <a href="bufmgr.c.html#LN4277"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>+= </span><a href="bufmgr.c.html#LN4299"><span class='Ref_To_Local'>ahead</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* and finally tell the kernel to write the data to storage */ 
</span>        <a href="bufmgr.c.html#LN4298"><span class='Ref_To_Local'>reln</span></a> <span class='Operator'>= </span><a href="../../../include/storage/smgr.h.html#LN83"><span class='Ref_to_Proto'>smgropen</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4300"><span class='Ref_To_Local'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN92"><span class='Ref_to_Member'>rnode</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/backendid.h.html#LN22"><span class='Ref_to_Const'>InvalidBackendId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/smgr.h.html#LN102"><span class='Ref_to_Proto'>smgrwriteback</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4298"><span class='Ref_To_Local'>reln</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN4300"><span class='Ref_To_Local'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN93"><span class='Ref_to_Member'>forkNum</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN4300"><span class='Ref_To_Local'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/buf_internals.h.html#LN94"><span class='Ref_to_Member'>blockNum</span></a><span class='Delimiter'>, </span><a href="bufmgr.c.html#LN4301"><span class='Ref_To_Local'>nblocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;context-&GT;nr_pen... &raquo; </span> 
 
    <a href="bufmgr.c.html#LN4275"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN267"><span class='Ref_to_Member'>nr_pending</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end IssuePendingWritebacks &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Implement slower/larger portions of TestForOldSnapshot 
 * 
 * Smaller/faster portions are put inline, but the entire set of logic is too 
 * big for that. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN4349"></a><span class='Declare_Function'>TestForOldSnapshot_impl</span><span class='Parentheses'>(</span><a href="../../../include/utils/snapshot.h.html#LN22"><span class='Ref_to_Typedef'>Snapshot</span></a> <span class='Declare_Parameter'>snapshot</span><span class='Delimiter'>, </span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>relation</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/snapmgr.h.html#LN37"><span class='Ref_to_Macro'>RelationAllowsEarlyPruning</span></a><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4349"><span class='Ref_to_Parameter'>relation</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>&& </span><span class='Parentheses'>(</span><a href="bufmgr.c.html#LN4349"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span><a href="../../../include/utils/snapshot.h.html#LN110"><span class='Ref_to_Member'>whenTaken</span></a> <span class='Operator'>&LT; </span><a href="../../../include/utils/snapmgr.h.html#LN54"><span class='Ref_to_Proto'>GetOldSnapshotThresholdTimestamp</span></a><span class='Parentheses'>())</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_SNAPSHOT_TOO_OLD<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"snapshot too old"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
} 
</span></pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>