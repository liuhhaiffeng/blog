<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\storage\buffer\freelist.c</title>
<LINK REL=StyleSheet HREF="../../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\storage\buffer\freelist.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:48 2017
</td></tr>
<tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
</span><span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * freelist.c 
 *    routines for managing the buffer pool's replacement strategy. 
 * 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * 
 * IDENTIFICATION 
 *    src/backend/storage/buffer/freelist.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"port/atomics.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/buf_internals.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/bufmgr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/proc.h"</span> 
 
<a name="LN22"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>INT_ACCESS_ONCE</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>var</span><span class='Parentheses'>)</span>    <span class='Parentheses'>((</span><span class='Keyword'>int</span><span class='Parentheses'>)(</span><span class='Operator'>*</span><span class='Parentheses'>((</span><span class='Keyword'>volatile int </span><span class='Operator'>*</span><span class='Parentheses'>)</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="freelist.c.html#LN22"><span class='Ref_to_Parameter'>var</span></a><span class='Parentheses'>))))</span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * The shared freelist control information. 
 */ 
</span><span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* Spinlock: protects the values below */ 
</span><a name="LN31"></a>    <a href="../../../include/storage/s_lock.h.html#LN137"><span class='Ref_to_Typedef'>slock_t</span></a>     <span class='Declare_Member'>buffer_strategy_lock</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Clock sweep hand: index of next buffer to consider grabbing. Note that 
     * this isn't a concrete buffer - we only ever increase the value. So, to 
     * get an actual buffer, it needs to be used modulo NBuffers. 
     */ 
</span><a name="LN38"></a>    <a href="../../../include/port/atomics/arch-x86.h.html#LN62"><span class='Ref_to_Struct'>pg_atomic_uint32</span></a> <span class='Declare_Member'>nextVictimBuffer</span><span class='Delimiter'>; 
</span> 
<a name="LN40"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>firstFreeBuffer</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* Head of list of unused buffers */ 
</span><a name="LN41"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>lastFreeBuffer</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* Tail of list of unused buffers */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * NOTE: lastFreeBuffer is undefined when firstFreeBuffer is -1 (that is, 
     * when the list is empty) 
     */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Statistics.  These counters should be wide enough that they can't 
     * overflow during a single bgwriter cycle. 
     */ 
</span><a name="LN52"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Member'>completePasses</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* Complete cycles of the clock sweep */ 
</span><a name="LN53"></a>    <a href="../../../include/port/atomics/arch-x86.h.html#LN62"><span class='Ref_to_Struct'>pg_atomic_uint32</span></a> <span class='Declare_Member'>numBufferAllocs</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* Buffers allocated since last reset */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Bgworker process to be notified upon activity or -1 if none. See 
     * StrategyNotifyBgWriter. 
     */ 
</span><a name="LN59"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>bgwprocno</span><span class='Delimiter'>; 
</span><a name="LN60"></a>}<span class='Auto_Annotations'> &laquo; end {anonBufferStrategyControl} &raquo; </span> <span class='Declare_Typedef'>BufferStrategyControl</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Pointers to shared state */ 
</span><a name="LN63"></a><span class='Keyword'>static </span><a href="freelist.c.html#LN28"><span class='Ref_to_Typedef'>BufferStrategyControl</span></a> <span class='Operator'>*</span><span class='Declare_Var'>StrategyControl</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Private (non-shared) state for managing a ring of shared buffers to re-use. 
 * This is currently the only kind of BufferAccessStrategy object, but someday 
 * we might have more kinds. 
 */ 
</span><a name="LN70"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>BufferAccessStrategyData</span> 
<span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* Overall strategy type */ 
</span><a name="LN73"></a>    <a href="../../../include/storage/bufmgr.h.html#LN27"><span class='Ref_to_Enum'>BufferAccessStrategyType</span></a> <span class='Declare_Member'>btype</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* Number of elements in buffers[] array */ 
</span><a name="LN75"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>ring_size</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Index of the "current" slot in the ring, ie, the one most recently 
     * returned by GetBufferFromRing. 
     */ 
</span><a name="LN81"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>current</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * True if the buffer just returned by StrategyGetBuffer had been in the 
     * ring already. 
     */ 
</span><a name="LN87"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>current_was_in_ring</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Array of buffer numbers.  InvalidBuffer (that is, zero) indicates we 
     * have not yet selected a buffer for this ring slot.  For allocation 
     * simplicity this is palloc'd together with the fixed fields of the 
     * struct. 
     */ 
</span><a name="LN95"></a>    <a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a>      <span class='Declare_Member'>buffers</span><span class='Delimiter'>[</span>FLEXIBLE_ARRAY_MEMBER<span class='Delimiter'>]; 
</span><a name="LN96"></a>}<span class='Auto_Annotations'> &laquo; end BufferAccessStrategyData &raquo; </span>   <span class='Declare_Typedef'>BufferAccessStrategyData</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* Prototypes for internal functions */ 
</span><a name="LN100"></a><span class='Keyword'>static </span><a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>GetBufferFromRing</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN43"><span class='Ref_to_Typedef'>BufferAccessStrategy</span></a> <span class='Declare_Parameter'>strategy</span><span class='Delimiter'>, 
</span><a name="LN101"></a>                  <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>buf_state</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN102"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>AddBufferToRing</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN43"><span class='Ref_to_Typedef'>BufferAccessStrategy</span></a> <span class='Declare_Parameter'>strategy</span><span class='Delimiter'>, 
</span><a name="LN103"></a>                <a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>buf</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * ClockSweepTick - Helper routine for StrategyGetBuffer() 
 * 
 * Move the clock hand one buffer ahead of its current position and return the 
 * id of the buffer now under the hand. 
 */ 
</span><span class='Keyword'>static inline </span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> 
<a name="LN112"></a><span class='Declare_Function'>ClockSweepTick</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN114"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>victim</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Atomically move hand ahead one buffer - if there's several processes 
     * doing this, this can lead to buffers being returned slightly out of 
     * apparent order. 
     */ 
</span>    <a href="freelist.c.html#LN114"><span class='Ref_To_Local'>victim</span></a> <span class='Operator'>= 
</span>        <a href="../../../include/port/atomics.h.html#LN337"><span class='Ref_to_Func'>pg_atomic_fetch_add_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="freelist.c.html#LN63"><span class='Ref_to_Global_Var'>StrategyControl</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN38"><span class='Ref_to_Member'>nextVictimBuffer</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="freelist.c.html#LN114"><span class='Ref_To_Local'>victim</span></a> <span class='Operator'>&GT;= </span><a href="../../utils/init/globals.c.html#LN122"><span class='Ref_to_Global_Var'>NBuffers</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN126"></a>        <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>originalVictim</span> <span class='Operator'>= </span><a href="freelist.c.html#LN114"><span class='Ref_To_Local'>victim</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* always wrap what we look up in BufferDescriptors */ 
</span>        <a href="freelist.c.html#LN114"><span class='Ref_To_Local'>victim</span></a> <span class='Operator'>= </span><a href="freelist.c.html#LN114"><span class='Ref_To_Local'>victim</span></a> <span class='Operator'>% </span><a href="../../utils/init/globals.c.html#LN122"><span class='Ref_to_Global_Var'>NBuffers</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If we're the one that just caused a wraparound, force 
         * completePasses to be incremented while holding the spinlock. We 
         * need the spinlock so StrategySyncStart() can return a consistent 
         * value consisting of nextVictimBuffer and completePasses. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="freelist.c.html#LN114"><span class='Ref_To_Local'>victim</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN139"></a>            <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>expected</span><span class='Delimiter'>; 
</span><a name="LN140"></a>            <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>wrapped</span><span class='Delimiter'>; 
</span><a name="LN141"></a>            <span class='Keyword'>bool</span>        <span class='Declare_Local'>success</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
            <a href="freelist.c.html#LN139"><span class='Ref_To_Local'>expected</span></a> <span class='Operator'>= </span><a href="freelist.c.html#LN126"><span class='Ref_To_Local'>originalVictim</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>while</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="freelist.c.html#LN141"><span class='Ref_To_Local'>success</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * Acquire the spinlock while increasing completePasses. That 
                 * allows other readers to read nextVictimBuffer and 
                 * completePasses in a consistent manner which is required for 
                 * StrategySyncStart().  In theory delaying the increment 
                 * could lead to an overflow of nextVictimBuffers, but that's 
                 * highly unlikely and wouldn't be particularly harmful. 
                 */ 
</span>                <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="freelist.c.html#LN63"><span class='Ref_to_Global_Var'>StrategyControl</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN31"><span class='Ref_to_Member'>buffer_strategy_lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="freelist.c.html#LN140"><span class='Ref_To_Local'>wrapped</span></a> <span class='Operator'>= </span><a href="freelist.c.html#LN139"><span class='Ref_To_Local'>expected</span></a> <span class='Operator'>% </span><a href="../../utils/init/globals.c.html#LN122"><span class='Ref_to_Global_Var'>NBuffers</span></a><span class='Delimiter'>; 
</span> 
                <a href="freelist.c.html#LN141"><span class='Ref_To_Local'>success</span></a> <span class='Operator'>= </span><a href="../../../include/port/atomics.h.html#LN320"><span class='Ref_to_Func'>pg_atomic_compare_exchange_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="freelist.c.html#LN63"><span class='Ref_to_Global_Var'>StrategyControl</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN38"><span class='Ref_to_Member'>nextVictimBuffer</span></a><span class='Delimiter'>, 
</span>                                                         <span class='Operator'>&</span><a href="freelist.c.html#LN139"><span class='Ref_To_Local'>expected</span></a><span class='Delimiter'>, </span><a href="freelist.c.html#LN140"><span class='Ref_To_Local'>wrapped</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="freelist.c.html#LN141"><span class='Ref_To_Local'>success</span></a><span class='Parentheses'>) 
</span>                    <a href="freelist.c.html#LN63"><span class='Ref_to_Global_Var'>StrategyControl</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN52"><span class='Ref_to_Member'>completePasses</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>                <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="freelist.c.html#LN63"><span class='Ref_to_Global_Var'>StrategyControl</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN31"><span class='Ref_to_Member'>buffer_strategy_lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while !success &raquo; </span> 
        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if victim==0 &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if victim&GT;=NBuffers &raquo; </span> 
    <span class='Control'>return</span> <a href="freelist.c.html#LN114"><span class='Ref_To_Local'>victim</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ClockSweepTick &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * StrategyGetBuffer 
 * 
 *  Called by the bufmgr to get the next candidate buffer to use in 
 *  BufferAlloc(). The only hard requirement BufferAlloc() has is that 
 *  the selected buffer must not currently be pinned by anyone. 
 * 
 *  strategy is a BufferAccessStrategy object, or NULL for default strategy. 
 * 
 *  To ensure that no one else can pin the buffer before we do, we must 
 *  return the buffer with the buffer header spinlock still held. 
 */ 
</span><a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>* 
</span><a name="LN183"></a><span class='Declare_Function'>StrategyGetBuffer</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN43"><span class='Ref_to_Typedef'>BufferAccessStrategy</span></a> <span class='Declare_Parameter'>strategy</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>buf_state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN185"></a>    <a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>buf</span><span class='Delimiter'>; 
</span><a name="LN186"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>bgwprocno</span><span class='Delimiter'>; 
</span><a name="LN187"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>trycounter</span><span class='Delimiter'>; 
</span><a name="LN188"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>local_buf_state</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* to avoid repeated (de-)referencing */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If given a strategy object, see whether it can select a buffer. We 
     * assume strategy objects don't need buffer_strategy_lock. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="freelist.c.html#LN183"><span class='Ref_to_Parameter'>strategy</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="freelist.c.html#LN185"><span class='Ref_To_Local'>buf</span></a> <span class='Operator'>= </span><a href="freelist.c.html#LN100"><span class='Ref_to_Proto'>GetBufferFromRing</span></a><span class='Parentheses'>(</span><a href="freelist.c.html#LN183"><span class='Ref_to_Parameter'>strategy</span></a><span class='Delimiter'>, </span><a href="freelist.c.html#LN183"><span class='Ref_to_Parameter'>buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="freelist.c.html#LN185"><span class='Ref_To_Local'>buf</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <a href="freelist.c.html#LN185"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If asked, we need to waken the bgwriter. Since we don't want to rely on 
     * a spinlock for this we force a read from shared memory once, and then 
     * set the latch based on that value. We need to go through that length 
     * because otherwise bgprocno might be reset while/after we check because 
     * the compiler might just reread from memory. 
     * 
     * This can possibly set the latch of the wrong process if the bgwriter 
     * dies in the wrong moment. But since PGPROC-&GT;procLatch is never 
     * deallocated the worst consequence of that is that we set the latch of 
     * some arbitrary process. 
     */ 
</span>    <a href="freelist.c.html#LN186"><span class='Ref_To_Local'>bgwprocno</span></a> <span class='Operator'>= </span><a href="freelist.c.html#LN22"><span class='Ref_to_Macro'>INT_ACCESS_ONCE</span></a><span class='Parentheses'>(</span><a href="freelist.c.html#LN63"><span class='Ref_to_Global_Var'>StrategyControl</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN59"><span class='Ref_to_Member'>bgwprocno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="freelist.c.html#LN186"><span class='Ref_To_Local'>bgwprocno</span></a> <span class='Operator'>!= -</span><span class='Number'>1</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* reset bgwprocno first, before setting the latch */ 
</span>        <a href="freelist.c.html#LN63"><span class='Ref_to_Global_Var'>StrategyControl</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN59"><span class='Ref_to_Member'>bgwprocno</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Not acquiring ProcArrayLock here which is slightly icky. It's 
         * actually fine because procLatch isn't ever freed, so we just can 
         * potentially set the wrong process' (or no process') latch. 
         */ 
</span>        <a href="../../../include/storage/latch.h.html#LN151"><span class='Ref_to_Proto'>SetLatch</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="../lmgr/proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN231"><span class='Ref_to_Member'>allProcs</span></a><span class='Delimiter'>[</span><a href="freelist.c.html#LN186"><span class='Ref_To_Local'>bgwprocno</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/storage/proc.h.html#LN102"><span class='Ref_to_Member'>procLatch</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We count buffer allocation requests so that the bgwriter can estimate 
     * the rate of buffer consumption.  Note that buffers recycled by a 
     * strategy object are intentionally not counted here. 
     */ 
</span>    <a href="../../../include/port/atomics.h.html#LN337"><span class='Ref_to_Func'>pg_atomic_fetch_add_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="freelist.c.html#LN63"><span class='Ref_to_Global_Var'>StrategyControl</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN53"><span class='Ref_to_Member'>numBufferAllocs</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * First check, without acquiring the lock, whether there's buffers in the 
     * freelist. Since we otherwise don't require the spinlock in every 
     * StrategyGetBuffer() invocation, it'd be sad to acquire it here - 
     * uselessly in most cases. That obviously leaves a race where a buffer is 
     * put on the freelist but we don't see the store yet - but that's pretty 
     * harmless, it'll just get used during the next buffer acquisition. 
     * 
     * If there's buffers on the freelist, acquire the spinlock to pop one 
     * buffer of the freelist. Then check whether that buffer is usable and 
     * repeat if not. 
     * 
     * Note that the freeNext fields are considered to be protected by the 
     * buffer_strategy_lock not the individual buffer spinlocks, so it's OK to 
     * manipulate them without holding the spinlock. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="freelist.c.html#LN63"><span class='Ref_to_Global_Var'>StrategyControl</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN40"><span class='Ref_to_Member'>firstFreeBuffer</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>while</span> <span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Acquire the spinlock to remove element from the freelist */ 
</span>            <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="freelist.c.html#LN63"><span class='Ref_to_Global_Var'>StrategyControl</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN31"><span class='Ref_to_Member'>buffer_strategy_lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="freelist.c.html#LN63"><span class='Ref_to_Global_Var'>StrategyControl</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN40"><span class='Ref_to_Member'>firstFreeBuffer</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="freelist.c.html#LN63"><span class='Ref_to_Global_Var'>StrategyControl</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN31"><span class='Ref_to_Member'>buffer_strategy_lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <a href="freelist.c.html#LN185"><span class='Ref_To_Local'>buf</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN219"><span class='Ref_to_Macro'>GetBufferDescriptor</span></a><span class='Parentheses'>(</span><a href="freelist.c.html#LN63"><span class='Ref_to_Global_Var'>StrategyControl</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN40"><span class='Ref_to_Member'>firstFreeBuffer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="freelist.c.html#LN185"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN186"><span class='Ref_to_Member'>freeNext</span></a> <span class='Operator'>!= </span><a href="../../../include/storage/buf_internals.h.html#LN236"><span class='Ref_to_Const'>FREENEXT_NOT_IN_LIST</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Unconditionally remove buffer from freelist */ 
</span>            <a href="freelist.c.html#LN63"><span class='Ref_to_Global_Var'>StrategyControl</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN40"><span class='Ref_to_Member'>firstFreeBuffer</span></a> <span class='Operator'>= </span><a href="freelist.c.html#LN185"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN186"><span class='Ref_to_Member'>freeNext</span></a><span class='Delimiter'>; 
</span>            <a href="freelist.c.html#LN185"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN186"><span class='Ref_to_Member'>freeNext</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN236"><span class='Ref_to_Const'>FREENEXT_NOT_IN_LIST</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Release the lock so someone else can access the freelist while 
             * we check out this buffer. 
             */ 
</span>            <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="freelist.c.html#LN63"><span class='Ref_to_Global_Var'>StrategyControl</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN31"><span class='Ref_to_Member'>buffer_strategy_lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * If the buffer is pinned or has a nonzero usage_count, we cannot 
             * use it; discard it and retry.  (This can only happen if VACUUM 
             * put a valid buffer in the freelist and then someone else used 
             * it before we got to it.  It's probably impossible altogether as 
             * of 8.3, but we'd better check anyway.) 
             */ 
</span>            <a href="freelist.c.html#LN188"><span class='Ref_To_Local'>local_buf_state</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN242"><span class='Ref_to_Proto'>LockBufHdr</span></a><span class='Parentheses'>(</span><a href="freelist.c.html#LN185"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN48"><span class='Ref_to_Macro'>BUF_STATE_GET_REFCOUNT</span></a><span class='Parentheses'>(</span><a href="freelist.c.html#LN188"><span class='Ref_To_Local'>local_buf_state</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span> 
                <span class='Operator'>&& </span><a href="../../../include/storage/buf_internals.h.html#LN49"><span class='Ref_to_Macro'>BUF_STATE_GET_USAGECOUNT</span></a><span class='Parentheses'>(</span><a href="freelist.c.html#LN188"><span class='Ref_To_Local'>local_buf_state</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="freelist.c.html#LN183"><span class='Ref_to_Parameter'>strategy</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>                    <a href="freelist.c.html#LN102"><span class='Ref_to_Proto'>AddBufferToRing</span></a><span class='Parentheses'>(</span><a href="freelist.c.html#LN183"><span class='Ref_to_Parameter'>strategy</span></a><span class='Delimiter'>, </span><a href="freelist.c.html#LN185"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Operator'>*</span><a href="freelist.c.html#LN183"><span class='Ref_to_Parameter'>buf_state</span></a> <span class='Operator'>= </span><a href="freelist.c.html#LN188"><span class='Ref_To_Local'>local_buf_state</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <a href="freelist.c.html#LN185"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="freelist.c.html#LN185"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><a href="freelist.c.html#LN188"><span class='Ref_To_Local'>local_buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while true &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if StrategyControl-&GT;firs... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Nothing on the freelist, so run the "clock sweep" algorithm */ 
</span>    <a href="freelist.c.html#LN187"><span class='Ref_To_Local'>trycounter</span></a> <span class='Operator'>= </span><a href="../../utils/init/globals.c.html#LN122"><span class='Ref_to_Global_Var'>NBuffers</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="freelist.c.html#LN185"><span class='Ref_To_Local'>buf</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN219"><span class='Ref_to_Macro'>GetBufferDescriptor</span></a><span class='Parentheses'>(</span><a href="freelist.c.html#LN111"><span class='Ref_to_Func'>ClockSweepTick</span></a><span class='Parentheses'>())</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If the buffer is pinned or has a nonzero usage_count, we cannot use 
         * it; decrement the usage_count (unless pinned) and keep scanning. 
         */ 
</span>        <a href="freelist.c.html#LN188"><span class='Ref_To_Local'>local_buf_state</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN242"><span class='Ref_to_Proto'>LockBufHdr</span></a><span class='Parentheses'>(</span><a href="freelist.c.html#LN185"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN48"><span class='Ref_to_Macro'>BUF_STATE_GET_REFCOUNT</span></a><span class='Parentheses'>(</span><a href="freelist.c.html#LN188"><span class='Ref_To_Local'>local_buf_state</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN49"><span class='Ref_to_Macro'>BUF_STATE_GET_USAGECOUNT</span></a><span class='Parentheses'>(</span><a href="freelist.c.html#LN188"><span class='Ref_To_Local'>local_buf_state</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <span class='Delimiter'>{ 
</span>                <a href="freelist.c.html#LN188"><span class='Ref_To_Local'>local_buf_state</span></a> <span class='Operator'>-= </span><a href="../../../include/storage/buf_internals.h.html#LN43"><span class='Ref_to_Const'>BUF_USAGECOUNT_ONE</span></a><span class='Delimiter'>; 
</span> 
                <a href="freelist.c.html#LN187"><span class='Ref_To_Local'>trycounter</span></a> <span class='Operator'>= </span><a href="../../utils/init/globals.c.html#LN122"><span class='Ref_to_Global_Var'>NBuffers</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Found a usable buffer */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="freelist.c.html#LN183"><span class='Ref_to_Parameter'>strategy</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>                    <a href="freelist.c.html#LN102"><span class='Ref_to_Proto'>AddBufferToRing</span></a><span class='Parentheses'>(</span><a href="freelist.c.html#LN183"><span class='Ref_to_Parameter'>strategy</span></a><span class='Delimiter'>, </span><a href="freelist.c.html#LN185"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Operator'>*</span><a href="freelist.c.html#LN183"><span class='Ref_to_Parameter'>buf_state</span></a> <span class='Operator'>= </span><a href="freelist.c.html#LN188"><span class='Ref_To_Local'>local_buf_state</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <a href="freelist.c.html#LN185"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>--</span><a href="freelist.c.html#LN187"><span class='Ref_To_Local'>trycounter</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * We've scanned all the buffers without making any state changes, 
             * so all the buffers are pinned (or were when we looked at them). 
             * We could hope that someone will free one eventually, but it's 
             * probably better to fail than to risk getting stuck in an 
             * infinite loop. 
             */ 
</span>            <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="freelist.c.html#LN185"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><a href="freelist.c.html#LN188"><span class='Ref_To_Local'>local_buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"no unpinned buffers available"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="freelist.c.html#LN185"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><a href="freelist.c.html#LN188"><span class='Ref_To_Local'>local_buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for ;; &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end StrategyGetBuffer &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * StrategyFreeBuffer: put a buffer on the freelist 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN346"></a><span class='Declare_Function'>StrategyFreeBuffer</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>buf</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="freelist.c.html#LN63"><span class='Ref_to_Global_Var'>StrategyControl</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN31"><span class='Ref_to_Member'>buffer_strategy_lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * It is possible that we are told to put something in the freelist that 
     * is already in it; don't screw up the list if so. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="freelist.c.html#LN346"><span class='Ref_to_Parameter'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN186"><span class='Ref_to_Member'>freeNext</span></a> <span class='Operator'>== </span><a href="../../../include/storage/buf_internals.h.html#LN236"><span class='Ref_to_Const'>FREENEXT_NOT_IN_LIST</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="freelist.c.html#LN346"><span class='Ref_to_Parameter'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN186"><span class='Ref_to_Member'>freeNext</span></a> <span class='Operator'>= </span><a href="freelist.c.html#LN63"><span class='Ref_to_Global_Var'>StrategyControl</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN40"><span class='Ref_to_Member'>firstFreeBuffer</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="freelist.c.html#LN346"><span class='Ref_to_Parameter'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN186"><span class='Ref_to_Member'>freeNext</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <a href="freelist.c.html#LN63"><span class='Ref_to_Global_Var'>StrategyControl</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN41"><span class='Ref_to_Member'>lastFreeBuffer</span></a> <span class='Operator'>= </span><a href="freelist.c.html#LN346"><span class='Ref_to_Parameter'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN180"><span class='Ref_to_Member'>buf_id</span></a><span class='Delimiter'>; 
</span>        <a href="freelist.c.html#LN63"><span class='Ref_to_Global_Var'>StrategyControl</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN40"><span class='Ref_to_Member'>firstFreeBuffer</span></a> <span class='Operator'>= </span><a href="freelist.c.html#LN346"><span class='Ref_to_Parameter'>buf</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/buf_internals.h.html#LN180"><span class='Ref_to_Member'>buf_id</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="freelist.c.html#LN63"><span class='Ref_to_Global_Var'>StrategyControl</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN31"><span class='Ref_to_Member'>buffer_strategy_lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * StrategySyncStart -- tell BufferSync where to start syncing 
 * 
 * The result is the buffer index of the best buffer to sync first. 
 * BufferSync() will proceed circularly around the buffer array from there. 
 * 
 * In addition, we return the completed-pass count (which is effectively 
 * the higher-order bits of nextVictimBuffer) and the count of recent buffer 
 * allocs if non-NULL pointers are passed.  The alloc count is reset after 
 * being read. 
 */ 
</span><span class='Keyword'>int 
</span><a name="LN377"></a><span class='Declare_Function'>StrategySyncStart</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>complete_passes</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>num_buf_alloc</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN379"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>nextVictimBuffer</span><span class='Delimiter'>; 
</span><a name="LN380"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="freelist.c.html#LN63"><span class='Ref_to_Global_Var'>StrategyControl</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN31"><span class='Ref_to_Member'>buffer_strategy_lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="freelist.c.html#LN379"><span class='Ref_To_Local'>nextVictimBuffer</span></a> <span class='Operator'>= </span><a href="../../../include/port/atomics.h.html#LN250"><span class='Ref_to_Func'>pg_atomic_read_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="freelist.c.html#LN63"><span class='Ref_to_Global_Var'>StrategyControl</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN38"><span class='Ref_to_Member'>nextVictimBuffer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="freelist.c.html#LN380"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="freelist.c.html#LN379"><span class='Ref_To_Local'>nextVictimBuffer</span></a> <span class='Operator'>% </span><a href="../../utils/init/globals.c.html#LN122"><span class='Ref_to_Global_Var'>NBuffers</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="freelist.c.html#LN377"><span class='Ref_to_Parameter'>complete_passes</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Operator'>*</span><a href="freelist.c.html#LN377"><span class='Ref_to_Parameter'>complete_passes</span></a> <span class='Operator'>= </span><a href="freelist.c.html#LN63"><span class='Ref_to_Global_Var'>StrategyControl</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN52"><span class='Ref_to_Member'>completePasses</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Additionally add the number of wraparounds that happened before 
         * completePasses could be incremented. C.f. ClockSweepTick(). 
         */ 
</span>        <span class='Operator'>*</span><a href="freelist.c.html#LN377"><span class='Ref_to_Parameter'>complete_passes</span></a> <span class='Operator'>+= </span><a href="freelist.c.html#LN379"><span class='Ref_To_Local'>nextVictimBuffer</span></a> <span class='Operator'>/ </span><a href="../../utils/init/globals.c.html#LN122"><span class='Ref_to_Global_Var'>NBuffers</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="freelist.c.html#LN377"><span class='Ref_to_Parameter'>num_buf_alloc</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Operator'>*</span><a href="freelist.c.html#LN377"><span class='Ref_to_Parameter'>num_buf_alloc</span></a> <span class='Operator'>= </span><a href="../../../include/port/atomics.h.html#LN301"><span class='Ref_to_Func'>pg_atomic_exchange_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="freelist.c.html#LN63"><span class='Ref_to_Global_Var'>StrategyControl</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN53"><span class='Ref_to_Member'>numBufferAllocs</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="freelist.c.html#LN63"><span class='Ref_to_Global_Var'>StrategyControl</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN31"><span class='Ref_to_Member'>buffer_strategy_lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="freelist.c.html#LN380"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end StrategySyncStart &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * StrategyNotifyBgWriter -- set or clear allocation notification latch 
 * 
 * If bgwprocno isn't -1, the next invocation of StrategyGetBuffer will 
 * set that latch.  Pass -1 to clear the pending notification before it 
 * happens.  This feature is used by the bgwriter process to wake itself up 
 * from hibernation, and is not meant for anybody else to use. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN414"></a><span class='Declare_Function'>StrategyNotifyBgWriter</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>bgwprocno</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * We acquire buffer_strategy_lock just to ensure that the store appears 
     * atomic to StrategyGetBuffer.  The bgwriter should call this rather 
     * infrequently, so there's no performance penalty from being safe. 
     */ 
</span>    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="freelist.c.html#LN63"><span class='Ref_to_Global_Var'>StrategyControl</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN31"><span class='Ref_to_Member'>buffer_strategy_lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="freelist.c.html#LN63"><span class='Ref_to_Global_Var'>StrategyControl</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN59"><span class='Ref_to_Member'>bgwprocno</span></a> <span class='Operator'>= </span><a href="freelist.c.html#LN414"><span class='Ref_to_Parameter'>bgwprocno</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="freelist.c.html#LN63"><span class='Ref_to_Global_Var'>StrategyControl</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN31"><span class='Ref_to_Member'>buffer_strategy_lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * StrategyShmemSize 
 * 
 * estimate the size of shared memory used by the freelist-related structures. 
 * 
 * Note: for somewhat historical reasons, the buffer lookup hashtable size 
 * is also determined here. 
 */ 
</span><a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a> 
<a name="LN436"></a><span class='Declare_Function'>StrategyShmemSize</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN438"></a>    <a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Local'>size</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* size of lookup hash table ... see comment in StrategyInitialize */ 
</span>    <a href="freelist.c.html#LN438"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="freelist.c.html#LN438"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, </span><a href="buf_table.c.html#LN41"><span class='Ref_to_Func'>BufTableShmemSize</span></a><span class='Parentheses'>(</span><a href="../../utils/init/globals.c.html#LN122"><span class='Ref_to_Global_Var'>NBuffers</span></a> <span class='Operator'>+ </span><a href="../../../include/storage/lwlock.h.html#LN112"><span class='Ref_to_Const'>NUM_BUFFER_PARTITIONS</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* size of the shared replacement strategy control block */ 
</span>    <a href="freelist.c.html#LN438"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="freelist.c.html#LN438"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN587"><span class='Ref_to_Macro'>MAXALIGN</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="freelist.c.html#LN28"><span class='Ref_to_Typedef'>BufferStrategyControl</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="freelist.c.html#LN438"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * StrategyInitialize -- initialize the buffer cache replacement 
 *      strategy. 
 * 
 * Assumes: All of the buffers are already built into a linked list. 
 *      Only called by postmaster and only during initialization. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN457"></a><span class='Declare_Function'>StrategyInitialize</span><span class='Parentheses'>(</span><span class='Keyword'>bool </span><span class='Declare_Parameter'>init</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN459"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Initialize the shared buffer lookup hashtable. 
     * 
     * Since we can't tolerate running out of lookup table entries, we must be 
     * sure to specify an adequate table size here.  The maximum steady-state 
     * usage is of course NBuffers entries, but BufferAlloc() tries to insert 
     * a new entry before deleting the old.  In principle this could be 
     * happening in each partition concurrently, so we could need as many as 
     * NBuffers + NUM_BUFFER_PARTITIONS entries. 
     */ 
</span>    <a href="buf_table.c.html#LN51"><span class='Ref_to_Func'>InitBufTable</span></a><span class='Parentheses'>(</span><a href="../../utils/init/globals.c.html#LN122"><span class='Ref_to_Global_Var'>NBuffers</span></a> <span class='Operator'>+ </span><a href="../../../include/storage/lwlock.h.html#LN112"><span class='Ref_to_Const'>NUM_BUFFER_PARTITIONS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Get or create the shared strategy control block 
     */ 
</span>    <a href="freelist.c.html#LN63"><span class='Ref_to_Global_Var'>StrategyControl</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="freelist.c.html#LN28"><span class='Ref_to_Typedef'>BufferStrategyControl</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/shmem.h.html#LN43"><span class='Ref_to_Proto'>ShmemInitStruct</span></a><span class='Parentheses'>(</span><span class='String'>"Buffer Strategy Status"</span><span class='Delimiter'>, 
</span>                        <span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="freelist.c.html#LN28"><span class='Ref_to_Typedef'>BufferStrategyControl</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                        <span class='Operator'>&</span><a href="freelist.c.html#LN459"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="freelist.c.html#LN459"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Only done once, usually in postmaster 
         */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="freelist.c.html#LN457"><span class='Ref_to_Parameter'>init</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/storage/spin.h.html#LN59"><span class='Ref_to_Macro'>SpinLockInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="freelist.c.html#LN63"><span class='Ref_to_Global_Var'>StrategyControl</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN31"><span class='Ref_to_Member'>buffer_strategy_lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Grab the whole linked list of free buffers for our strategy. We 
         * assume it was previously set up by InitBufferPool(). 
         */ 
</span>        <a href="freelist.c.html#LN63"><span class='Ref_to_Global_Var'>StrategyControl</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN40"><span class='Ref_to_Member'>firstFreeBuffer</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="freelist.c.html#LN63"><span class='Ref_to_Global_Var'>StrategyControl</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN41"><span class='Ref_to_Member'>lastFreeBuffer</span></a> <span class='Operator'>= </span><a href="../../utils/init/globals.c.html#LN122"><span class='Ref_to_Global_Var'>NBuffers</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Initialize the clock sweep pointer */ 
</span>        <a href="../../../include/port/atomics.h.html#LN232"><span class='Ref_to_Func'>pg_atomic_init_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="freelist.c.html#LN63"><span class='Ref_to_Global_Var'>StrategyControl</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN38"><span class='Ref_to_Member'>nextVictimBuffer</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Clear statistics */ 
</span>        <a href="freelist.c.html#LN63"><span class='Ref_to_Global_Var'>StrategyControl</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN52"><span class='Ref_to_Member'>completePasses</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="../../../include/port/atomics.h.html#LN232"><span class='Ref_to_Func'>pg_atomic_init_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="freelist.c.html#LN63"><span class='Ref_to_Global_Var'>StrategyControl</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN53"><span class='Ref_to_Member'>numBufferAllocs</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* No pending notification */ 
</span>        <a href="freelist.c.html#LN63"><span class='Ref_to_Global_Var'>StrategyControl</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN59"><span class='Ref_to_Member'>bgwprocno</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !found &raquo; </span> 
    <span class='Control'>else</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="freelist.c.html#LN457"><span class='Ref_to_Parameter'>init</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end StrategyInitialize &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *              Backend-private buffer ring management 
 * ---------------------------------------------------------------- 
 */ 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * GetAccessStrategy -- create a BufferAccessStrategy object 
 * 
 * The object is allocated in the current memory context. 
 */ 
</span><a href="../../../include/storage/buf.h.html#LN43"><span class='Ref_to_Typedef'>BufferAccessStrategy</span></a> 
<a name="LN524"></a><span class='Declare_Function'>GetAccessStrategy</span><span class='Parentheses'>(</span><a href="../../../include/storage/bufmgr.h.html#LN27"><span class='Ref_to_Enum'>BufferAccessStrategyType</span></a> <span class='Declare_Parameter'>btype</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN526"></a>    <a href="../../../include/storage/buf.h.html#LN43"><span class='Ref_to_Typedef'>BufferAccessStrategy</span></a> <span class='Declare_Local'>strategy</span><span class='Delimiter'>; 
</span><a name="LN527"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>ring_size</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Select ring size to use.  See buffer/README for rationales. 
     * 
     * Note: if you change the ring size for BAS_BULKREAD, see also 
     * SYNC_SCAN_REPORT_INTERVAL in access/heap/syncscan.c. 
     */ 
</span>    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="freelist.c.html#LN524"><span class='Ref_to_Parameter'>btype</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../../include/storage/bufmgr.h.html#LN29"><span class='Ref_to_EnumConst'>BAS_NORMAL</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* if someone asks for NORMAL, just give 'em a "default" object */ 
</span>            <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="../../../include/storage/bufmgr.h.html#LN30"><span class='Ref_to_EnumConst'>BAS_BULKREAD</span></a><span class='Operator'>: 
</span>            <a href="freelist.c.html#LN527"><span class='Ref_To_Local'>ring_size</span></a> <span class='Operator'>= </span><span class='Number'>256</span> <span class='Operator'>* </span><span class='Number'>1024</span> <span class='Operator'>/ </span>BLCKSZ<span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/storage/bufmgr.h.html#LN32"><span class='Ref_to_EnumConst'>BAS_BULKWRITE</span></a><span class='Operator'>: 
</span>            <a href="freelist.c.html#LN527"><span class='Ref_To_Local'>ring_size</span></a> <span class='Operator'>= </span><span class='Number'>16</span> <span class='Operator'>* </span><span class='Number'>1024</span> <span class='Operator'>* </span><span class='Number'>1024</span> <span class='Operator'>/ </span>BLCKSZ<span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/storage/bufmgr.h.html#LN33"><span class='Ref_to_EnumConst'>BAS_VACUUM</span></a><span class='Operator'>: 
</span>            <a href="freelist.c.html#LN527"><span class='Ref_To_Local'>ring_size</span></a> <span class='Operator'>= </span><span class='Number'>256</span> <span class='Operator'>* </span><span class='Number'>1024</span> <span class='Operator'>/ </span>BLCKSZ<span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>default</span><span class='Operator'>: 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized buffer access strategy: %d"</span><span class='Delimiter'>, 
</span>                 <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="freelist.c.html#LN524"><span class='Ref_to_Parameter'>btype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch btype &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Make sure ring isn't an undue fraction of shared buffers */ 
</span>    <a href="freelist.c.html#LN527"><span class='Ref_To_Local'>ring_size</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN11"><span class='Ref_to_Macro'>Min</span></a><span class='Parentheses'>(</span><a href="../../utils/init/globals.c.html#LN122"><span class='Ref_to_Global_Var'>NBuffers</span></a> <span class='Operator'>/ </span><span class='Number'>8</span><span class='Delimiter'>, </span><a href="freelist.c.html#LN527"><span class='Ref_To_Local'>ring_size</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Allocate the object and initialize all elements to zeroes */ 
</span>    <a href="freelist.c.html#LN526"><span class='Ref_To_Local'>strategy</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN43"><span class='Ref_to_Typedef'>BufferAccessStrategy</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="freelist.c.html#LN70"><span class='Ref_to_Struct'>BufferAccessStrategyData</span></a><span class='Delimiter'>, </span>buffers<span class='Parentheses'>) </span><span class='Operator'>+ 
</span>                <a href="freelist.c.html#LN527"><span class='Ref_To_Local'>ring_size</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Set fields that don't start out zero */ 
</span>    <a href="freelist.c.html#LN526"><span class='Ref_To_Local'>strategy</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN73"><span class='Ref_to_Member'>btype</span></a> <span class='Operator'>= </span><a href="freelist.c.html#LN524"><span class='Ref_to_Parameter'>btype</span></a><span class='Delimiter'>; 
</span>    <a href="freelist.c.html#LN526"><span class='Ref_To_Local'>strategy</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN75"><span class='Ref_to_Member'>ring_size</span></a> <span class='Operator'>= </span><a href="freelist.c.html#LN527"><span class='Ref_To_Local'>ring_size</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="freelist.c.html#LN526"><span class='Ref_To_Local'>strategy</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end GetAccessStrategy &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * FreeAccessStrategy -- release a BufferAccessStrategy object 
 * 
 * A simple pfree would do at the moment, but we would prefer that callers 
 * don't assume that much about the representation of BufferAccessStrategy. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN579"></a><span class='Declare_Function'>FreeAccessStrategy</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN43"><span class='Ref_to_Typedef'>BufferAccessStrategy</span></a> <span class='Declare_Parameter'>strategy</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* don't crash if called on a "default" strategy */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="freelist.c.html#LN579"><span class='Ref_to_Parameter'>strategy</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="freelist.c.html#LN579"><span class='Ref_to_Parameter'>strategy</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * GetBufferFromRing -- returns a buffer from the ring, or NULL if the 
 *      ring is empty. 
 * 
 * The bufhdr spin lock is held on the returned buffer. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>* 
</span><a name="LN593"></a><span class='Declare_Function'>GetBufferFromRing</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN43"><span class='Ref_to_Typedef'>BufferAccessStrategy</span></a> <span class='Declare_Parameter'>strategy</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>buf_state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN595"></a>    <a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>buf</span><span class='Delimiter'>; 
</span><a name="LN596"></a>    <a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a>      <span class='Declare_Local'>bufnum</span><span class='Delimiter'>; 
</span><a name="LN597"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>local_buf_state</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* to avoid repeated (de-)referencing */ 
</span> 
 
    <span class='Comment_Multi_Line'>/* Advance to next ring slot */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>++</span><a href="freelist.c.html#LN593"><span class='Ref_to_Parameter'>strategy</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN81"><span class='Ref_to_Member'>current</span></a> <span class='Operator'>&GT;= </span><a href="freelist.c.html#LN593"><span class='Ref_to_Parameter'>strategy</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN75"><span class='Ref_to_Member'>ring_size</span></a><span class='Parentheses'>) 
</span>        <a href="freelist.c.html#LN593"><span class='Ref_to_Parameter'>strategy</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN81"><span class='Ref_to_Member'>current</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the slot hasn't been filled yet, tell the caller to allocate a new 
     * buffer with the normal allocation strategy.  He will then fill this 
     * slot by calling AddBufferToRing with the new buffer. 
     */ 
</span>    <a href="freelist.c.html#LN596"><span class='Ref_To_Local'>bufnum</span></a> <span class='Operator'>= </span><a href="freelist.c.html#LN593"><span class='Ref_to_Parameter'>strategy</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN95"><span class='Ref_to_Member'>buffers</span></a><span class='Delimiter'>[</span><a href="freelist.c.html#LN593"><span class='Ref_to_Parameter'>strategy</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN81"><span class='Ref_to_Member'>current</span></a><span class='Delimiter'>]; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="freelist.c.html#LN596"><span class='Ref_To_Local'>bufnum</span></a> <span class='Operator'>== </span><a href="../../../include/storage/buf.h.html#LN24"><span class='Ref_to_Const'>InvalidBuffer</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="freelist.c.html#LN593"><span class='Ref_to_Parameter'>strategy</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN87"><span class='Ref_to_Member'>current_was_in_ring</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the buffer is pinned we cannot use it under any circumstances. 
     * 
     * If usage_count is 0 or 1 then the buffer is fair game (we expect 1, 
     * since our own previous usage of the ring element would have left it 
     * there, but it might've been decremented by clock sweep since then). A 
     * higher usage_count indicates someone else has touched the buffer, so we 
     * shouldn't re-use it. 
     */ 
</span>    <a href="freelist.c.html#LN595"><span class='Ref_To_Local'>buf</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN219"><span class='Ref_to_Macro'>GetBufferDescriptor</span></a><span class='Parentheses'>(</span><a href="freelist.c.html#LN596"><span class='Ref_To_Local'>bufnum</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="freelist.c.html#LN597"><span class='Ref_To_Local'>local_buf_state</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN242"><span class='Ref_to_Proto'>LockBufHdr</span></a><span class='Parentheses'>(</span><a href="freelist.c.html#LN595"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buf_internals.h.html#LN48"><span class='Ref_to_Macro'>BUF_STATE_GET_REFCOUNT</span></a><span class='Parentheses'>(</span><a href="freelist.c.html#LN597"><span class='Ref_To_Local'>local_buf_state</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span> 
        <span class='Operator'>&& </span><a href="../../../include/storage/buf_internals.h.html#LN49"><span class='Ref_to_Macro'>BUF_STATE_GET_USAGECOUNT</span></a><span class='Parentheses'>(</span><a href="freelist.c.html#LN597"><span class='Ref_To_Local'>local_buf_state</span></a><span class='Parentheses'>) </span><span class='Operator'>&LT;= </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <a href="freelist.c.html#LN593"><span class='Ref_to_Parameter'>strategy</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN87"><span class='Ref_to_Member'>current_was_in_ring</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="freelist.c.html#LN593"><span class='Ref_to_Parameter'>buf_state</span></a> <span class='Operator'>= </span><a href="freelist.c.html#LN597"><span class='Ref_To_Local'>local_buf_state</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <a href="freelist.c.html#LN595"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../../include/storage/buf_internals.h.html#LN243"><span class='Ref_to_Macro'>UnlockBufHdr</span></a><span class='Parentheses'>(</span><a href="freelist.c.html#LN595"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><a href="freelist.c.html#LN597"><span class='Ref_To_Local'>local_buf_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Tell caller to allocate a new buffer with the normal allocation 
     * strategy.  He'll then replace this ring element via AddBufferToRing. 
     */ 
</span>    <a href="freelist.c.html#LN593"><span class='Ref_to_Parameter'>strategy</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN87"><span class='Ref_to_Member'>current_was_in_ring</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end GetBufferFromRing &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * AddBufferToRing -- add a buffer to the buffer ring 
 * 
 * Caller must hold the buffer header spinlock on the buffer.  Since this 
 * is called with the spinlock held, it had better be quite cheap. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN651"></a><span class='Declare_Function'>AddBufferToRing</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN43"><span class='Ref_to_Typedef'>BufferAccessStrategy</span></a> <span class='Declare_Parameter'>strategy</span><span class='Delimiter'>, </span><a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>buf</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="freelist.c.html#LN651"><span class='Ref_to_Parameter'>strategy</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN95"><span class='Ref_to_Member'>buffers</span></a><span class='Delimiter'>[</span><a href="freelist.c.html#LN651"><span class='Ref_to_Parameter'>strategy</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN81"><span class='Ref_to_Member'>current</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../../include/storage/buf_internals.h.html#LN222"><span class='Ref_to_Macro'>BufferDescriptorGetBuffer</span></a><span class='Parentheses'>(</span><a href="freelist.c.html#LN651"><span class='Ref_to_Parameter'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * StrategyRejectBuffer -- consider rejecting a dirty buffer 
 * 
 * When a nondefault strategy is used, the buffer manager calls this function 
 * when it turns out that the buffer selected by StrategyGetBuffer needs to 
 * be written out and doing so would require flushing WAL too.  This gives us 
 * a chance to choose a different victim. 
 * 
 * Returns true if buffer manager should ask for a new victim, and false 
 * if this buffer should be written and re-used. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN668"></a><span class='Declare_Function'>StrategyRejectBuffer</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN43"><span class='Ref_to_Typedef'>BufferAccessStrategy</span></a> <span class='Declare_Parameter'>strategy</span><span class='Delimiter'>, </span><a href="../../../include/storage/buf_internals.h.html#LN177"><span class='Ref_to_Struct'>BufferDesc</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>buf</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* We only do this in bulkread mode */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="freelist.c.html#LN668"><span class='Ref_to_Parameter'>strategy</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN73"><span class='Ref_to_Member'>btype</span></a> <span class='Operator'>!= </span><a href="../../../include/storage/bufmgr.h.html#LN30"><span class='Ref_to_EnumConst'>BAS_BULKREAD</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Don't muck with behavior of normal buffer-replacement strategy */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="freelist.c.html#LN668"><span class='Ref_to_Parameter'>strategy</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN87"><span class='Ref_to_Member'>current_was_in_ring</span></a> <span class='Operator'>|| 
</span>      <a href="freelist.c.html#LN668"><span class='Ref_to_Parameter'>strategy</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN95"><span class='Ref_to_Member'>buffers</span></a><span class='Delimiter'>[</span><a href="freelist.c.html#LN668"><span class='Ref_to_Parameter'>strategy</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN81"><span class='Ref_to_Member'>current</span></a><span class='Delimiter'>] </span><span class='Operator'>!= </span><a href="../../../include/storage/buf_internals.h.html#LN222"><span class='Ref_to_Macro'>BufferDescriptorGetBuffer</span></a><span class='Parentheses'>(</span><a href="freelist.c.html#LN668"><span class='Ref_to_Parameter'>buf</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Remove the dirty buffer from the ring; necessary to prevent infinite 
     * loop if all ring members are dirty. 
     */ 
</span>    <a href="freelist.c.html#LN668"><span class='Ref_to_Parameter'>strategy</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN95"><span class='Ref_to_Member'>buffers</span></a><span class='Delimiter'>[</span><a href="freelist.c.html#LN668"><span class='Ref_to_Parameter'>strategy</span></a><span class='Operator'>-&GT;</span><a href="freelist.c.html#LN81"><span class='Ref_to_Member'>current</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../../include/storage/buf.h.html#LN24"><span class='Ref_to_Const'>InvalidBuffer</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end StrategyRejectBuffer &raquo; </span> 
</pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>