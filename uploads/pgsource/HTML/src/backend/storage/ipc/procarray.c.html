<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\storage\ipc\procarray.c</title>
<LINK REL=StyleSheet HREF="../../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\storage\ipc\procarray.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:49 2017
</td></tr>
<tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * procarray.c 
 *    POSTGRES process array code. 
 * 
 * 
 * This module maintains arrays of the PGPROC and PGXACT structures for all 
 * active backends.  Although there are several uses for this, the principal 
 * one is as a means of determining the set of currently running transactions. 
 * 
 * Because of various subtle race conditions it is critical that a backend 
 * hold the correct locks while setting or clearing its MyPgXact-&GT;xid field. 
 * See notes in src/backend/access/transam/README. 
 * 
 * The process arrays now also include structures representing prepared 
 * transactions.  The xid and subxids fields of these are valid, as are the 
 * myProcLocks lists.  They can be distinguished from regular backend PGPROCs 
 * at need by checking for pid == 0. 
 * 
 * During hot standby, we also keep a list of XIDs representing transactions 
 * that are known to be running in the master (or more precisely, were running 
 * as of the current point in the WAL stream).  This list is kept in the 
 * KnownAssignedXids array, and is updated by watching the sequence of 
 * arriving XIDs.  This is necessary because if we leave those XIDs out of 
 * snapshots taken for standby queries, then they will appear to be already 
 * complete, leading to MVCC failures.  Note that in hot standby, the PGPROC 
 * array represents standby processes, which by definition are not running 
 * transactions that have XIDs. 
 * 
 * It is perhaps possible for a backend on the master to terminate without 
 * writing an abort record for its transaction.  While that shouldn't really 
 * happen, it would tie up KnownAssignedXids indefinitely, so we protect 
 * ourselves by pruning the array when a valid list of running XIDs arrives. 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * 
 * IDENTIFICATION 
 *    src/backend/storage/ipc/procarray.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>&LT;signal.h&GT;</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/clog.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/subtrans.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/transam.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/twophase.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/xact.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/xlog.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/catalog.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"miscadmin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"pgstat.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/proc.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/procarray.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/spin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/builtins.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/rel.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/snapmgr.h"</span> 
 
 
<span class='Comment_Multi_Line'>/* Our shared memory area */ 
</span><a name="LN65"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ProcArrayStruct</span> 
<span class='Delimiter'>{ 
</span><a name="LN67"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>numProcs</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* number of valid procs entries */ 
</span><a name="LN68"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>maxProcs</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* allocated size of procs array */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Known assigned XIDs handling 
     */ 
</span><a name="LN73"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>maxKnownAssignedXids</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* allocated size of array */ 
</span><a name="LN74"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>numKnownAssignedXids</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* current # of valid entries */ 
</span><a name="LN75"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>tailKnownAssignedXids</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* index of oldest valid element */ 
</span><a name="LN76"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>headKnownAssignedXids</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* index of newest element, + 1 */ 
</span><a name="LN77"></a>    <a href="../../../include/storage/s_lock.h.html#LN137"><span class='Ref_to_Typedef'>slock_t</span></a>     <span class='Declare_Member'>known_assigned_xids_lck</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* protects head/tail pointers */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Highest subxid that has been removed from KnownAssignedXids array to 
     * prevent overflow; or InvalidTransactionId if none.  We track this for 
     * similar reasons to tracking overflowing cached subxids in PGXACT 
     * entries.  Must hold exclusive ProcArrayLock to change this, and shared 
     * lock to read it. 
     */ 
</span><a name="LN86"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Member'>lastOverflowedXid</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* oldest xmin of any replication slot */ 
</span><a name="LN89"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Member'>replication_slot_xmin</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* oldest catalog xmin of any replication slot */ 
</span><a name="LN91"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Member'>replication_slot_catalog_xmin</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* indexes into allPgXact[], has PROCARRAY_MAXPROCS entries */ 
</span><a name="LN94"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>pgprocnos</span><span class='Delimiter'>[</span>FLEXIBLE_ARRAY_MEMBER<span class='Delimiter'>]; 
</span><a name="LN95"></a>}<span class='Auto_Annotations'> &laquo; end ProcArrayStruct &raquo; </span> <span class='Declare_Typedef'>ProcArrayStruct</span><span class='Delimiter'>; 
</span> 
<a name="LN97"></a><span class='Keyword'>static </span><a href="procarray.c.html#LN65"><span class='Ref_to_Struct'>ProcArrayStruct</span></a> <span class='Operator'>*</span><span class='Declare_Var'>procArray</span><span class='Delimiter'>; 
</span> 
<a name="LN99"></a><span class='Keyword'>static </span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Declare_Var'>allProcs</span><span class='Delimiter'>; 
</span><a name="LN100"></a><span class='Keyword'>static </span><a href="../../../include/storage/proc.h.html#LN206"><span class='Ref_to_Struct'>PGXACT</span></a> <span class='Operator'>*</span><span class='Declare_Var'>allPgXact</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Bookkeeping for tracking emulated transactions in recovery 
 */ 
</span><a name="LN105"></a><span class='Keyword'>static </span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Operator'>*</span><span class='Declare_Var'>KnownAssignedXids</span><span class='Delimiter'>; 
</span><a name="LN106"></a><span class='Keyword'>static bool </span><span class='Operator'>*</span><span class='Declare_Var'>KnownAssignedXidsValid</span><span class='Delimiter'>; 
</span><a name="LN107"></a><span class='Keyword'>static </span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Var'>latestObservedXid</span> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * If we're in STANDBY_SNAPSHOT_PENDING state, standbySnapshotPendingXmin is 
 * the highest xid that might still be running that we don't have in 
 * KnownAssignedXids. 
 */ 
</span><a name="LN114"></a><span class='Keyword'>static </span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Var'>standbySnapshotPendingXmin</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> XIDCACHE_DEBUG 
 
<span class='Comment_Multi_Line'>/* counters for XidCache measurement */ 
</span><a name="LN119"></a><span class='Keyword'>static long </span><span class='Declare_Var'>xc_by_recent_xmin</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN120"></a><span class='Keyword'>static long </span><span class='Declare_Var'>xc_by_known_xact</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN121"></a><span class='Keyword'>static long </span><span class='Declare_Var'>xc_by_my_xact</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN122"></a><span class='Keyword'>static long </span><span class='Declare_Var'>xc_by_latest_xid</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN123"></a><span class='Keyword'>static long </span><span class='Declare_Var'>xc_by_main_xid</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN124"></a><span class='Keyword'>static long </span><span class='Declare_Var'>xc_by_child_xid</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN125"></a><span class='Keyword'>static long </span><span class='Declare_Var'>xc_by_known_assigned</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN126"></a><span class='Keyword'>static long </span><span class='Declare_Var'>xc_no_overflow</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN127"></a><span class='Keyword'>static long </span><span class='Declare_Var'>xc_slow_answer</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
<a name="LN129"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>xc_by_recent_xmin_inc</span><span class='Parentheses'>()</span>     <span class='Parentheses'>(</span><a href="procarray.c.html#LN119"><span class='Ref_to_Global_Var'>xc_by_recent_xmin</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span><a name="LN130"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>xc_by_known_xact_inc</span><span class='Parentheses'>()</span>      <span class='Parentheses'>(</span><a href="procarray.c.html#LN120"><span class='Ref_to_Global_Var'>xc_by_known_xact</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span><a name="LN131"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>xc_by_my_xact_inc</span><span class='Parentheses'>()</span>         <span class='Parentheses'>(</span><a href="procarray.c.html#LN121"><span class='Ref_to_Global_Var'>xc_by_my_xact</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span><a name="LN132"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>xc_by_latest_xid_inc</span><span class='Parentheses'>()</span>      <span class='Parentheses'>(</span><a href="procarray.c.html#LN122"><span class='Ref_to_Global_Var'>xc_by_latest_xid</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span><a name="LN133"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>xc_by_main_xid_inc</span><span class='Parentheses'>()</span>        <span class='Parentheses'>(</span><a href="procarray.c.html#LN123"><span class='Ref_to_Global_Var'>xc_by_main_xid</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span><a name="LN134"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>xc_by_child_xid_inc</span><span class='Parentheses'>()</span>       <span class='Parentheses'>(</span><a href="procarray.c.html#LN124"><span class='Ref_to_Global_Var'>xc_by_child_xid</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span><a name="LN135"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>xc_by_known_assigned_inc</span><span class='Parentheses'>()</span>  <span class='Parentheses'>(</span><a href="procarray.c.html#LN125"><span class='Ref_to_Global_Var'>xc_by_known_assigned</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span><a name="LN136"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>xc_no_overflow_inc</span><span class='Parentheses'>()</span>        <span class='Parentheses'>(</span><a href="procarray.c.html#LN126"><span class='Ref_to_Global_Var'>xc_no_overflow</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span><a name="LN137"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>xc_slow_answer_inc</span><span class='Parentheses'>()</span>        <span class='Parentheses'>(</span><a href="procarray.c.html#LN127"><span class='Ref_to_Global_Var'>xc_slow_answer</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span> 
<a name="LN139"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>DisplayXidCache</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#else</span>                           <span class='Comment_Single_Line'>/* !XIDCACHE_DEBUG */ 
</span> 
<a name="LN142"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>xc_by_recent_xmin_inc</span><span class='Parentheses'>()</span>     <span class='Parentheses'>((</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
<a name="LN143"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>xc_by_known_xact_inc</span><span class='Parentheses'>()</span>      <span class='Parentheses'>((</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
<a name="LN144"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>xc_by_my_xact_inc</span><span class='Parentheses'>()</span>         <span class='Parentheses'>((</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
<a name="LN145"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>xc_by_latest_xid_inc</span><span class='Parentheses'>()</span>      <span class='Parentheses'>((</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
<a name="LN146"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>xc_by_main_xid_inc</span><span class='Parentheses'>()</span>        <span class='Parentheses'>((</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
<a name="LN147"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>xc_by_child_xid_inc</span><span class='Parentheses'>()</span>       <span class='Parentheses'>((</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
<a name="LN148"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>xc_by_known_assigned_inc</span><span class='Parentheses'>()</span>  <span class='Parentheses'>((</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
<a name="LN149"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>xc_no_overflow_inc</span><span class='Parentheses'>()</span>        <span class='Parentheses'>((</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
<a name="LN150"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>xc_slow_answer_inc</span><span class='Parentheses'>()</span>        <span class='Parentheses'>((</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
<span class='Directive'>#endif</span>   <span class='Comment_Single_Line'>/* XIDCACHE_DEBUG */ 
</span> 
<span class='Comment_Multi_Line'>/* Primitives for KnownAssignedXids array handling for standby */ 
</span><a name="LN154"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>KnownAssignedXidsCompress</span><span class='Parentheses'>(</span><span class='Keyword'>bool </span><span class='Declare_Parameter'>force</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN155"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>KnownAssignedXidsAdd</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>from_xid</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>to_xid</span><span class='Delimiter'>, 
</span><a name="LN156"></a>                     <span class='Keyword'>bool </span><span class='Declare_Parameter'>exclusive_lock</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN157"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>KnownAssignedXidsSearch</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xid</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>remove</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN158"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>KnownAssignedXidExists</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xid</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN159"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>KnownAssignedXidsRemove</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xid</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN160"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>KnownAssignedXidsRemoveTree</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xid</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>nsubxids</span><span class='Delimiter'>, 
</span><a name="LN161"></a>                            <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>subxids</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN162"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>KnownAssignedXidsRemovePreceding</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xid</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN163"></a><span class='Keyword'>static int</span>  <span class='Declare_Prototype'>KnownAssignedXidsGet</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>xarray</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xmax</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN164"></a><span class='Keyword'>static int </span><span class='Declare_Prototype'>KnownAssignedXidsGetAndSetXmin</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>xarray</span><span class='Delimiter'>, 
</span><a name="LN165"></a>                               <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>xmin</span><span class='Delimiter'>, 
</span><a name="LN166"></a>                               <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xmax</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN167"></a><span class='Keyword'>static </span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Prototype'>KnownAssignedXidsGetOldestXmin</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN168"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>KnownAssignedXidsDisplay</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>trace_level</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN169"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>KnownAssignedXidsReset</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN170"></a><span class='Keyword'>static inline void </span><span class='Declare_Prototype'>ProcArrayEndTransactionInternal</span><span class='Parentheses'>(</span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>proc</span><span class='Delimiter'>, 
</span><a name="LN171"></a>                                <a href="../../../include/storage/proc.h.html#LN206"><span class='Ref_to_Struct'>PGXACT</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pgxact</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>latestXid</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN172"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>ProcArrayGroupClearXid</span><span class='Parentheses'>(</span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>proc</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>latestXid</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Report shared-memory space needed by CreateSharedProcArray. 
 */ 
</span><a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a> 
<a name="LN178"></a><span class='Declare_Function'>ProcArrayShmemSize</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN180"></a>    <a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Local'>size</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Size of the ProcArray structure itself */ 
</span><a name="LN183"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PROCARRAY_MAXPROCS</span>  <span class='Parentheses'>(</span><a href="../../utils/init/globals.c.html#LN126"><span class='Ref_to_Global_Var'>MaxBackends</span></a> <span class='Operator'>+ </span><a href="../../access/transam/twophase.c.html#LN116"><span class='Ref_to_Global_Var'>max_prepared_xacts</span></a><span class='Parentheses'>) 
</span> 
    <a href="procarray.c.html#LN180"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN65"><span class='Ref_to_Struct'>ProcArrayStruct</span></a><span class='Delimiter'>, </span>pgprocnos<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN180"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN180"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/shmem.h.html#LN45"><span class='Ref_to_Proto'>mul_size</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="procarray.c.html#LN183"><span class='Ref_to_Const'>PROCARRAY_MAXPROCS</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * During Hot Standby processing we have a data structure called 
     * KnownAssignedXids, created in shared memory. Local data structures are 
     * also created in various backends during GetSnapshotData(), 
     * TransactionIdIsInProgress() and GetRunningTransactionData(). All of the 
     * main structures created in those functions must be identically sized, 
     * since we may at times copy the whole of the data structures around. We 
     * refer to this size as TOTAL_MAX_CACHED_SUBXIDS. 
     * 
     * Ideally we'd only create this structure if we were actually doing hot 
     * standby in the current run, but we don't know that yet at the time 
     * shared memory is being set up. 
     */ 
</span><a name="LN201"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>TOTAL_MAX_CACHED_SUBXIDS</span> <span class='Operator'>\ 
</span>    <span class='Parentheses'>((</span><a href="../../../include/storage/proc.h.html#LN34"><span class='Ref_to_Const'>PGPROC_MAX_CACHED_SUBXIDS</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="procarray.c.html#LN183"><span class='Ref_to_Const'>PROCARRAY_MAXPROCS</span></a><span class='Parentheses'>)</span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../access/transam/xlog.c.html#LN95"><span class='Ref_to_Global_Var'>EnableHotStandby</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="procarray.c.html#LN180"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN180"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, 
</span>                        <a href="../../../include/storage/shmem.h.html#LN45"><span class='Ref_to_Proto'>mul_size</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                 <a href="procarray.c.html#LN201"><span class='Ref_to_Const'>TOTAL_MAX_CACHED_SUBXIDS</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="procarray.c.html#LN180"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN180"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, 
</span>                        <a href="../../../include/storage/shmem.h.html#LN45"><span class='Ref_to_Proto'>mul_size</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>bool</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="procarray.c.html#LN201"><span class='Ref_to_Const'>TOTAL_MAX_CACHED_SUBXIDS</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="procarray.c.html#LN180"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ProcArrayShmemSize &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Initialize the shared PGPROC array during postmaster startup. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN220"></a><span class='Declare_Function'>CreateSharedProcArray</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN222"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Create or attach to the ProcArray shared structure */ 
</span>    <a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="procarray.c.html#LN65"><span class='Ref_to_Struct'>ProcArrayStruct</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/shmem.h.html#LN43"><span class='Ref_to_Proto'>ShmemInitStruct</span></a><span class='Parentheses'>(</span><span class='String'>"Proc Array"</span><span class='Delimiter'>, 
</span>                        <a href="../../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN65"><span class='Ref_to_Struct'>ProcArrayStruct</span></a><span class='Delimiter'>, </span>pgprocnos<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                 <a href="../../../include/storage/shmem.h.html#LN45"><span class='Ref_to_Proto'>mul_size</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                          <a href="procarray.c.html#LN183"><span class='Ref_to_Const'>PROCARRAY_MAXPROCS</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                        <span class='Operator'>&</span><a href="procarray.c.html#LN222"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="procarray.c.html#LN222"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We're the first - initialize. 
         */ 
</span>        <a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN67"><span class='Ref_to_Member'>numProcs</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN68"><span class='Ref_to_Member'>maxProcs</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN183"><span class='Ref_to_Const'>PROCARRAY_MAXPROCS</span></a><span class='Delimiter'>; 
</span>        <a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN89"><span class='Ref_to_Member'>replication_slot_xmin</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span>        <a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN73"><span class='Ref_to_Member'>maxKnownAssignedXids</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN201"><span class='Ref_to_Const'>TOTAL_MAX_CACHED_SUBXIDS</span></a><span class='Delimiter'>; 
</span>        <a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN74"><span class='Ref_to_Member'>numKnownAssignedXids</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN75"><span class='Ref_to_Member'>tailKnownAssignedXids</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN76"><span class='Ref_to_Member'>headKnownAssignedXids</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/spin.h.html#LN59"><span class='Ref_to_Macro'>SpinLockInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN77"><span class='Ref_to_Member'>known_assigned_xids_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN86"><span class='Ref_to_Member'>lastOverflowedXid</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="procarray.c.html#LN99"><span class='Ref_to_Global_Var'>allProcs</span></a> <span class='Operator'>= </span><a href="../lmgr/proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN231"><span class='Ref_to_Member'>allProcs</span></a><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN100"><span class='Ref_to_Global_Var'>allPgXact</span></a> <span class='Operator'>= </span><a href="../lmgr/proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN233"><span class='Ref_to_Member'>allPgXact</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Create or attach to the KnownAssignedXids arrays too, if needed */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../access/transam/xlog.c.html#LN95"><span class='Ref_to_Global_Var'>EnableHotStandby</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="procarray.c.html#LN105"><span class='Ref_to_Global_Var'>KnownAssignedXids</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../../include/storage/shmem.h.html#LN43"><span class='Ref_to_Proto'>ShmemInitStruct</span></a><span class='Parentheses'>(</span><span class='String'>"KnownAssignedXids"</span><span class='Delimiter'>, 
</span>                            <a href="../../../include/storage/shmem.h.html#LN45"><span class='Ref_to_Proto'>mul_size</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                     <a href="procarray.c.html#LN201"><span class='Ref_to_Const'>TOTAL_MAX_CACHED_SUBXIDS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                            <span class='Operator'>&</span><a href="procarray.c.html#LN222"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="procarray.c.html#LN106"><span class='Ref_to_Global_Var'>KnownAssignedXidsValid</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../../include/storage/shmem.h.html#LN43"><span class='Ref_to_Proto'>ShmemInitStruct</span></a><span class='Parentheses'>(</span><span class='String'>"KnownAssignedXidsValid"</span><span class='Delimiter'>, 
</span>                            <a href="../../../include/storage/shmem.h.html#LN45"><span class='Ref_to_Proto'>mul_size</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>bool</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="procarray.c.html#LN201"><span class='Ref_to_Const'>TOTAL_MAX_CACHED_SUBXIDS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                            <span class='Operator'>&</span><a href="procarray.c.html#LN222"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Register and initialize fields of ProcLWLockTranche */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN186"><span class='Ref_to_Proto'>LWLockRegisterTranche</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN209"><span class='Ref_to_EnumConst'>LWTRANCHE_PROC</span></a><span class='Delimiter'>, </span><span class='String'>"proc"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end CreateSharedProcArray &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Add the specified PGPROC to the shared array. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN273"></a><span class='Declare_Function'>ProcArrayAdd</span><span class='Parentheses'>(</span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>proc</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN275"></a>    <a href="procarray.c.html#LN65"><span class='Ref_to_Struct'>ProcArrayStruct</span></a> <span class='Operator'>*</span><span class='Declare_Local'>arrayP</span> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Delimiter'>; 
</span><a name="LN276"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>index</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN275"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN67"><span class='Ref_to_Member'>numProcs</span></a> <span class='Operator'>&GT;= </span><a href="procarray.c.html#LN275"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN68"><span class='Ref_to_Member'>maxProcs</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Oops, no room.  (This really shouldn't happen, since there is a 
         * fixed supply of PGPROC structs too, and so we should have failed 
         * earlier.) 
         */ 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_TOO_MANY_CONNECTIONS<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"sorry, too many clients already"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Keep the procs array sorted by (PGPROC *) so that we can utilize 
     * locality of references much better. This is useful while traversing the 
     * ProcArray because there is an increased likelihood of finding the next 
     * PGPROC structure in the cache. 
     * 
     * Since the occurrence of adding/removing a proc is much lower than the 
     * access to the ProcArray itself, the overhead should be marginal 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN276"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN276"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN275"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN67"><span class='Ref_to_Member'>numProcs</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN276"><span class='Ref_To_Local'>index</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * If we are the first PGPROC or if we have found our right position 
         * in the array, break 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="procarray.c.html#LN275"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN94"><span class='Ref_to_Member'>pgprocnos</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN276"><span class='Ref_To_Local'>index</span></a><span class='Delimiter'>] </span><span class='Operator'>== -</span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>|| </span><span class='Parentheses'>(</span><a href="procarray.c.html#LN275"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN94"><span class='Ref_to_Member'>pgprocnos</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN276"><span class='Ref_To_Local'>index</span></a><span class='Delimiter'>] </span><span class='Operator'>&GT; </span><a href="procarray.c.html#LN273"><span class='Ref_to_Parameter'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN108"><span class='Ref_to_Member'>pgprocno</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/c.h.html#LN1057"><span class='Ref_to_Macro'>memmove</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="procarray.c.html#LN275"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN94"><span class='Ref_to_Member'>pgprocnos</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN276"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>], </span><span class='Operator'>&</span><a href="procarray.c.html#LN275"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN94"><span class='Ref_to_Member'>pgprocnos</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN276"><span class='Ref_To_Local'>index</span></a><span class='Delimiter'>], 
</span>            <span class='Parentheses'>(</span><a href="procarray.c.html#LN275"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN67"><span class='Ref_to_Member'>numProcs</span></a> <span class='Operator'>- </span><a href="procarray.c.html#LN276"><span class='Ref_To_Local'>index</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN275"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN94"><span class='Ref_to_Member'>pgprocnos</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN276"><span class='Ref_To_Local'>index</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="procarray.c.html#LN273"><span class='Ref_to_Parameter'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN108"><span class='Ref_to_Member'>pgprocno</span></a><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN275"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN67"><span class='Ref_to_Member'>numProcs</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ProcArrayAdd &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Remove the specified PGPROC from the shared array. 
 * 
 * When latestXid is a valid XID, we are removing a live 2PC gxact from the 
 * array, and thus causing it to appear as "not running" anymore.  In this 
 * case we must advance latestCompletedXid.  (This is essentially the same 
 * as ProcArrayEndTransaction followed by removal of the PGPROC, but we take 
 * the ProcArrayLock only once, and don't damage the content of the PGPROC; 
 * twophase.c depends on the latter.) 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN331"></a><span class='Declare_Function'>ProcArrayRemove</span><span class='Parentheses'>(</span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>proc</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>latestXid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN333"></a>    <a href="procarray.c.html#LN65"><span class='Ref_to_Struct'>ProcArrayStruct</span></a> <span class='Operator'>*</span><span class='Declare_Local'>arrayP</span> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Delimiter'>; 
</span><a name="LN334"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>index</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> XIDCACHE_DEBUG 
    <span class='Comment_Multi_Line'>/* dump stats at backend shutdown, but not prepared-xact end */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN331"><span class='Ref_to_Parameter'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN107"><span class='Ref_to_Member'>pid</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="procarray.c.html#LN139"><span class='Ref_to_Proto'>DisplayXidCache</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN331"><span class='Ref_to_Parameter'>latestXid</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN100"><span class='Ref_to_Global_Var'>allPgXact</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN331"><span class='Ref_to_Parameter'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN108"><span class='Ref_to_Member'>pgprocno</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/storage/proc.h.html#LN208"><span class='Ref_to_Member'>xid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Advance global latestCompletedXid while holding the lock */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="../../access/transam/varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN134"><span class='Ref_to_Member'>latestCompletedXid</span></a><span class='Delimiter'>, 
</span>                                  <a href="procarray.c.html#LN331"><span class='Ref_to_Parameter'>latestXid</span></a><span class='Parentheses'>))</span> 
            <a href="../../access/transam/varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN134"><span class='Ref_to_Member'>latestCompletedXid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN331"><span class='Ref_to_Parameter'>latestXid</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Shouldn't be trying to remove a live transaction here */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN100"><span class='Ref_to_Global_Var'>allPgXact</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN331"><span class='Ref_to_Parameter'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN108"><span class='Ref_to_Member'>pgprocno</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/storage/proc.h.html#LN208"><span class='Ref_to_Member'>xid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN334"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN334"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN333"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN67"><span class='Ref_to_Member'>numProcs</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN334"><span class='Ref_To_Local'>index</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN333"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN94"><span class='Ref_to_Member'>pgprocnos</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN334"><span class='Ref_To_Local'>index</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><a href="procarray.c.html#LN331"><span class='Ref_to_Parameter'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN108"><span class='Ref_to_Member'>pgprocno</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Keep the PGPROC array sorted. See notes above */ 
</span>            <a href="../../../include/c.h.html#LN1057"><span class='Ref_to_Macro'>memmove</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="procarray.c.html#LN333"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN94"><span class='Ref_to_Member'>pgprocnos</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN334"><span class='Ref_To_Local'>index</span></a><span class='Delimiter'>], </span><span class='Operator'>&</span><a href="procarray.c.html#LN333"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN94"><span class='Ref_to_Member'>pgprocnos</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN334"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>], 
</span>                    <span class='Parentheses'>(</span><a href="procarray.c.html#LN333"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN67"><span class='Ref_to_Member'>numProcs</span></a> <span class='Operator'>- </span><a href="procarray.c.html#LN334"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="procarray.c.html#LN333"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN94"><span class='Ref_to_Member'>pgprocnos</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN333"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN67"><span class='Ref_to_Member'>numProcs</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* for debugging */ 
</span>            <a href="procarray.c.html#LN333"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN67"><span class='Ref_to_Member'>numProcs</span></a><span class='Operator'>--</span><span class='Delimiter'>; 
</span>            <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Oops */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, </span><span class='String'>"failed to find proc %p in ProcArray"</span><span class='Delimiter'>, </span><a href="procarray.c.html#LN331"><span class='Ref_to_Parameter'>proc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ProcArrayRemove &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * ProcArrayEndTransaction -- mark a transaction as no longer running 
 * 
 * This is used interchangeably for commit and abort cases.  The transaction 
 * commit/abort must already be reported to WAL and pg_xact. 
 * 
 * proc is currently always MyProc, but we pass it explicitly for flexibility. 
 * latestXid is the latest Xid among the transaction's main XID and 
 * subtransactions, or InvalidTransactionId if it has no XID.  (We must ask 
 * the caller to pass latestXid, instead of computing it from the PGPROC's 
 * contents, because the subxid information in the PGPROC might be 
 * incomplete.) 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN394"></a><span class='Declare_Function'>ProcArrayEndTransaction</span><span class='Parentheses'>(</span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>proc</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>latestXid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN396"></a>    <a href="../../../include/storage/proc.h.html#LN206"><span class='Ref_to_Struct'>PGXACT</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>pgxact</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN100"><span class='Ref_to_Global_Var'>allPgXact</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN394"><span class='Ref_to_Parameter'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN108"><span class='Ref_to_Member'>pgprocno</span></a><span class='Delimiter'>]; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN394"><span class='Ref_to_Parameter'>latestXid</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We must lock ProcArrayLock while clearing our advertised XID, so 
         * that we do not exit the set of "running" transactions while someone 
         * else is taking a snapshot.  See discussion in 
         * src/backend/access/transam/README. 
         */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN100"><span class='Ref_to_Global_Var'>allPgXact</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN394"><span class='Ref_to_Parameter'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN108"><span class='Ref_to_Member'>pgprocno</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/storage/proc.h.html#LN208"><span class='Ref_to_Member'>xid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If we can immediately acquire ProcArrayLock, we clear our own XID 
         * and release the lock.  If not, use group XID clearing to improve 
         * efficiency. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN146"><span class='Ref_to_Proto'>LWLockConditionalAcquire</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="procarray.c.html#LN170"><span class='Ref_to_Proto'>ProcArrayEndTransactionInternal</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN394"><span class='Ref_to_Parameter'>proc</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN396"><span class='Ref_To_Local'>pgxact</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN394"><span class='Ref_to_Parameter'>latestXid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <a href="procarray.c.html#LN172"><span class='Ref_to_Proto'>ProcArrayGroupClearXid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN394"><span class='Ref_to_Parameter'>proc</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN394"><span class='Ref_to_Parameter'>latestXid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if TransactionIdIsValid(... &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * If we have no XID, we don't need to lock, since we won't affect 
         * anyone else's calculation of a snapshot.  We might change their 
         * estimate of global xmin, but that's OK. 
         */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN100"><span class='Ref_to_Global_Var'>allPgXact</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN394"><span class='Ref_to_Parameter'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN108"><span class='Ref_to_Member'>pgprocno</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/storage/proc.h.html#LN208"><span class='Ref_to_Member'>xid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <a href="procarray.c.html#LN394"><span class='Ref_to_Parameter'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN104"><span class='Ref_to_Member'>lxid</span></a> <span class='Operator'>= </span><a href="../../../include/storage/lock.h.html#LN69"><span class='Ref_to_Const'>InvalidLocalTransactionId</span></a><span class='Delimiter'>; 
</span>        <a href="procarray.c.html#LN396"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN212"><span class='Ref_to_Member'>xmin</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* must be cleared with xid/xmin: */ 
</span>        <a href="procarray.c.html#LN396"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN217"><span class='Ref_to_Member'>vacuumFlags</span></a> <span class='Operator'>&= ~</span><a href="../../../include/storage/proc.h.html#LN60"><span class='Ref_to_Const'>PROC_VACUUM_STATE_MASK</span></a><span class='Delimiter'>; 
</span>        <a href="procarray.c.html#LN396"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN219"><span class='Ref_to_Member'>delayChkpt</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* be sure this is cleared in abort */ 
</span>        <a href="procarray.c.html#LN394"><span class='Ref_to_Parameter'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN122"><span class='Ref_to_Member'>recoveryConflictPending</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="procarray.c.html#LN396"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN222"><span class='Ref_to_Member'>nxids</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="procarray.c.html#LN396"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN218"><span class='Ref_to_Member'>overflowed</span></a> <span class='Operator'>== </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end ProcArrayEndTransaction &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Mark a write transaction as no longer running. 
 * 
 * We don't do any locking here; caller must handle that. 
 */ 
</span><span class='Keyword'>static inline void 
</span><a name="LN448"></a><span class='Declare_Function'>ProcArrayEndTransactionInternal</span><span class='Parentheses'>(</span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>proc</span><span class='Delimiter'>, </span><a href="../../../include/storage/proc.h.html#LN206"><span class='Ref_to_Struct'>PGXACT</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pgxact</span><span class='Delimiter'>, 
</span><a name="LN449"></a>                                <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>latestXid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="procarray.c.html#LN448"><span class='Ref_to_Parameter'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN208"><span class='Ref_to_Member'>xid</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN448"><span class='Ref_to_Parameter'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN104"><span class='Ref_to_Member'>lxid</span></a> <span class='Operator'>= </span><a href="../../../include/storage/lock.h.html#LN69"><span class='Ref_to_Const'>InvalidLocalTransactionId</span></a><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN448"><span class='Ref_to_Parameter'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN212"><span class='Ref_to_Member'>xmin</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* must be cleared with xid/xmin: */ 
</span>    <a href="procarray.c.html#LN448"><span class='Ref_to_Parameter'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN217"><span class='Ref_to_Member'>vacuumFlags</span></a> <span class='Operator'>&= ~</span><a href="../../../include/storage/proc.h.html#LN60"><span class='Ref_to_Const'>PROC_VACUUM_STATE_MASK</span></a><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN448"><span class='Ref_to_Parameter'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN219"><span class='Ref_to_Member'>delayChkpt</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* be sure this is cleared in abort */ 
</span>    <a href="procarray.c.html#LN448"><span class='Ref_to_Parameter'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN122"><span class='Ref_to_Member'>recoveryConflictPending</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Clear the subtransaction-XID cache too while holding the lock */ 
</span>    <a href="procarray.c.html#LN448"><span class='Ref_to_Parameter'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN222"><span class='Ref_to_Member'>nxids</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN448"><span class='Ref_to_Parameter'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN218"><span class='Ref_to_Member'>overflowed</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Also advance global latestCompletedXid while holding the lock */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="../../access/transam/varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN134"><span class='Ref_to_Member'>latestCompletedXid</span></a><span class='Delimiter'>, 
</span>                              <a href="procarray.c.html#LN449"><span class='Ref_to_Parameter'>latestXid</span></a><span class='Parentheses'>))</span> 
        <a href="../../access/transam/varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN134"><span class='Ref_to_Member'>latestCompletedXid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN449"><span class='Ref_to_Parameter'>latestXid</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ProcArrayEndTransactionInternal &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * ProcArrayGroupClearXid -- group XID clearing 
 * 
 * When we cannot immediately acquire ProcArrayLock in exclusive mode at 
 * commit time, add ourselves to a list of processes that need their XIDs 
 * cleared.  The first process to add itself to the list will acquire 
 * ProcArrayLock in exclusive mode and perform ProcArrayEndTransactionInternal 
 * on behalf of all group members.  This avoids a great deal of contention 
 * around ProcArrayLock when many processes are trying to commit at once, 
 * since the lock need not be repeatedly handed off from one committing 
 * process to the next. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN482"></a><span class='Declare_Function'>ProcArrayGroupClearXid</span><span class='Parentheses'>(</span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>proc</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>latestXid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN484"></a>    <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN228"><span class='Ref_to_Struct'>PROC_HDR</span></a> <span class='Operator'>*</span><span class='Declare_Local'>procglobal</span> <span class='Operator'>= </span><a href="../lmgr/proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Delimiter'>; 
</span><a name="LN485"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>nextidx</span><span class='Delimiter'>; 
</span><a name="LN486"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>wakeidx</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* We should definitely have an XID to clear. */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN100"><span class='Ref_to_Global_Var'>allPgXact</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN482"><span class='Ref_to_Parameter'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN108"><span class='Ref_to_Member'>pgprocno</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/storage/proc.h.html#LN208"><span class='Ref_to_Member'>xid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Add ourselves to the list of processes needing a group XID clear. */ 
</span>    <a href="procarray.c.html#LN482"><span class='Ref_to_Parameter'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN161"><span class='Ref_to_Member'>procArrayGroupMember</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN482"><span class='Ref_to_Parameter'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN169"><span class='Ref_to_Member'>procArrayGroupMemberXid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN482"><span class='Ref_to_Parameter'>latestXid</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="procarray.c.html#LN485"><span class='Ref_To_Local'>nextidx</span></a> <span class='Operator'>= </span><a href="../../../include/port/atomics.h.html#LN250"><span class='Ref_to_Func'>pg_atomic_read_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="procarray.c.html#LN484"><span class='Ref_To_Local'>procglobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN243"><span class='Ref_to_Member'>procArrayGroupFirst</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/port/atomics.h.html#LN267"><span class='Ref_to_Func'>pg_atomic_write_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="procarray.c.html#LN482"><span class='Ref_to_Parameter'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN163"><span class='Ref_to_Member'>procArrayGroupNext</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN485"><span class='Ref_To_Local'>nextidx</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/port/atomics.h.html#LN320"><span class='Ref_to_Func'>pg_atomic_compare_exchange_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="procarray.c.html#LN484"><span class='Ref_To_Local'>procglobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN243"><span class='Ref_to_Member'>procArrayGroupFirst</span></a><span class='Delimiter'>, 
</span>                                           <span class='Operator'>&</span><a href="procarray.c.html#LN485"><span class='Ref_To_Local'>nextidx</span></a><span class='Delimiter'>, 
</span>                                           <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="procarray.c.html#LN482"><span class='Ref_to_Parameter'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN108"><span class='Ref_to_Member'>pgprocno</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the list was not empty, the leader will clear our XID.  It is 
     * impossible to have followers without a leader because the first process 
     * that has added itself to the list will always have nextidx as 
     * INVALID_PGPROCNO. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN485"><span class='Ref_To_Local'>nextidx</span></a> <span class='Operator'>!= </span><a href="../../../include/storage/proc.h.html#LN75"><span class='Ref_to_Const'>INVALID_PGPROCNO</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN513"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>extraWaits</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Sleep until the leader clears our XID. */ 
</span>        <a href="../../../include/pgstat.h.html#LN1206"><span class='Ref_to_Func'>pgstat_report_wait_start</span></a><span class='Parentheses'>(</span><a href="../../../include/pgstat.h.html#LN810"><span class='Ref_to_EnumConst'>WAIT_EVENT_PROCARRAY_GROUP_UPDATE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* acts as a read barrier */ 
</span>            <a href="../../../include/storage/pg_sema.h.html#LN52"><span class='Ref_to_Proto'>PGSemaphoreLock</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN482"><span class='Ref_to_Parameter'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN99"><span class='Ref_to_Member'>sem</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="procarray.c.html#LN482"><span class='Ref_to_Parameter'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN161"><span class='Ref_to_Member'>procArrayGroupMember</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <a href="procarray.c.html#LN513"><span class='Ref_To_Local'>extraWaits</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="../../../include/pgstat.h.html#LN1230"><span class='Ref_to_Func'>pgstat_report_wait_end</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/port/atomics.h.html#LN250"><span class='Ref_to_Func'>pg_atomic_read_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="procarray.c.html#LN482"><span class='Ref_to_Parameter'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN163"><span class='Ref_to_Member'>procArrayGroupNext</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="../../../include/storage/proc.h.html#LN75"><span class='Ref_to_Const'>INVALID_PGPROCNO</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Fix semaphore count for any absorbed wakeups */ 
</span>        <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN513"><span class='Ref_To_Local'>extraWaits</span></a><span class='Operator'>-- &GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <a href="../../../include/storage/pg_sema.h.html#LN55"><span class='Ref_to_Proto'>PGSemaphoreUnlock</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN482"><span class='Ref_to_Parameter'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN99"><span class='Ref_to_Member'>sem</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if nextidx!=INVALID_PGPR... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* We are the leader.  Acquire the lock on behalf of everyone. */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now that we've got the lock, clear the list of processes waiting for 
     * group XID clearing, saving a pointer to the head of the list.  Trying 
     * to pop elements one at a time could lead to an ABA problem. 
     */ 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="procarray.c.html#LN485"><span class='Ref_To_Local'>nextidx</span></a> <span class='Operator'>= </span><a href="../../../include/port/atomics.h.html#LN250"><span class='Ref_to_Func'>pg_atomic_read_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="procarray.c.html#LN484"><span class='Ref_To_Local'>procglobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN243"><span class='Ref_to_Member'>procArrayGroupFirst</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/port/atomics.h.html#LN320"><span class='Ref_to_Func'>pg_atomic_compare_exchange_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="procarray.c.html#LN484"><span class='Ref_To_Local'>procglobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN243"><span class='Ref_to_Member'>procArrayGroupFirst</span></a><span class='Delimiter'>, 
</span>                                           <span class='Operator'>&</span><a href="procarray.c.html#LN485"><span class='Ref_To_Local'>nextidx</span></a><span class='Delimiter'>, 
</span>                                           <a href="../../../include/storage/proc.h.html#LN75"><span class='Ref_to_Const'>INVALID_PGPROCNO</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Remember head of list so we can perform wakeups after dropping lock. */ 
</span>    <a href="procarray.c.html#LN486"><span class='Ref_To_Local'>wakeidx</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN485"><span class='Ref_To_Local'>nextidx</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Walk the list and clear all XIDs. */ 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN485"><span class='Ref_To_Local'>nextidx</span></a> <span class='Operator'>!= </span><a href="../../../include/storage/proc.h.html#LN75"><span class='Ref_to_Const'>INVALID_PGPROCNO</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN558"></a>        <a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>proc</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN99"><span class='Ref_to_Global_Var'>allProcs</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN485"><span class='Ref_To_Local'>nextidx</span></a><span class='Delimiter'>]; 
</span><a name="LN559"></a>        <a href="../../../include/storage/proc.h.html#LN206"><span class='Ref_to_Struct'>PGXACT</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>pgxact</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN100"><span class='Ref_to_Global_Var'>allPgXact</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN485"><span class='Ref_To_Local'>nextidx</span></a><span class='Delimiter'>]; 
</span> 
        <a href="procarray.c.html#LN170"><span class='Ref_to_Proto'>ProcArrayEndTransactionInternal</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN558"><span class='Ref_To_Local'>proc</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN559"><span class='Ref_To_Local'>pgxact</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN558"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN169"><span class='Ref_to_Member'>procArrayGroupMemberXid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Move to next proc in list. */ 
</span>        <a href="procarray.c.html#LN485"><span class='Ref_To_Local'>nextidx</span></a> <span class='Operator'>= </span><a href="../../../include/port/atomics.h.html#LN250"><span class='Ref_to_Func'>pg_atomic_read_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="procarray.c.html#LN558"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN163"><span class='Ref_to_Member'>procArrayGroupNext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* We're done with the lock now. */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now that we've released the lock, go back and wake everybody up.  We 
     * don't do this under the lock so as to keep lock hold times to a 
     * minimum.  The system calls we need to perform to wake other processes 
     * up are probably much slower than the simple memory writes we did while 
     * holding the lock. 
     */ 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN486"><span class='Ref_To_Local'>wakeidx</span></a> <span class='Operator'>!= </span><a href="../../../include/storage/proc.h.html#LN75"><span class='Ref_to_Const'>INVALID_PGPROCNO</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN579"></a>        <a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>proc</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN99"><span class='Ref_to_Global_Var'>allProcs</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN486"><span class='Ref_To_Local'>wakeidx</span></a><span class='Delimiter'>]; 
</span> 
        <a href="procarray.c.html#LN486"><span class='Ref_To_Local'>wakeidx</span></a> <span class='Operator'>= </span><a href="../../../include/port/atomics.h.html#LN250"><span class='Ref_to_Func'>pg_atomic_read_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="procarray.c.html#LN579"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN163"><span class='Ref_to_Member'>procArrayGroupNext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/port/atomics.h.html#LN267"><span class='Ref_to_Func'>pg_atomic_write_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="procarray.c.html#LN579"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN163"><span class='Ref_to_Member'>procArrayGroupNext</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/proc.h.html#LN75"><span class='Ref_to_Const'>INVALID_PGPROCNO</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* ensure all previous writes are visible before follower continues. */ 
</span>        <a href="../../../include/port/atomics.h.html#LN161"><span class='Ref_to_Macro'>pg_write_barrier</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <a href="procarray.c.html#LN579"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN161"><span class='Ref_to_Member'>procArrayGroupMember</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN579"><span class='Ref_To_Local'>proc</span></a> <span class='Operator'>!= </span><a href="../lmgr/proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/storage/pg_sema.h.html#LN55"><span class='Ref_to_Proto'>PGSemaphoreUnlock</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN579"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN99"><span class='Ref_to_Member'>sem</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end ProcArrayGroupClearXid &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * ProcArrayClearTransaction -- clear the transaction fields 
 * 
 * This is used after successfully preparing a 2-phase transaction.  We are 
 * not actually reporting the transaction's XID as no longer running --- it 
 * will still appear as running because the 2PC's gxact is in the ProcArray 
 * too.  We just have to clear out our own PGXACT. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN603"></a><span class='Declare_Function'>ProcArrayClearTransaction</span><span class='Parentheses'>(</span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>proc</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN605"></a>    <a href="../../../include/storage/proc.h.html#LN206"><span class='Ref_to_Struct'>PGXACT</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>pgxact</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN100"><span class='Ref_to_Global_Var'>allPgXact</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN603"><span class='Ref_to_Parameter'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN108"><span class='Ref_to_Member'>pgprocno</span></a><span class='Delimiter'>]; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We can skip locking ProcArrayLock here, because this action does not 
     * actually change anyone's view of the set of running XIDs: our entry is 
     * duplicate with the gxact that has already been inserted into the 
     * ProcArray. 
     */ 
</span>    <a href="procarray.c.html#LN605"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN208"><span class='Ref_to_Member'>xid</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN603"><span class='Ref_to_Parameter'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN104"><span class='Ref_to_Member'>lxid</span></a> <span class='Operator'>= </span><a href="../../../include/storage/lock.h.html#LN69"><span class='Ref_to_Const'>InvalidLocalTransactionId</span></a><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN605"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN212"><span class='Ref_to_Member'>xmin</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN603"><span class='Ref_to_Parameter'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN122"><span class='Ref_to_Member'>recoveryConflictPending</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* redundant, but just in case */ 
</span>    <a href="procarray.c.html#LN605"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN217"><span class='Ref_to_Member'>vacuumFlags</span></a> <span class='Operator'>&= ~</span><a href="../../../include/storage/proc.h.html#LN60"><span class='Ref_to_Const'>PROC_VACUUM_STATE_MASK</span></a><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN605"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN219"><span class='Ref_to_Member'>delayChkpt</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Clear the subtransaction-XID cache too */ 
</span>    <a href="procarray.c.html#LN605"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN222"><span class='Ref_to_Member'>nxids</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN605"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN218"><span class='Ref_to_Member'>overflowed</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ProcArrayClearTransaction &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * ProcArrayInitRecovery -- initialize recovery xid mgmt environment 
 * 
 * Remember up to where the startup process initialized the CLOG and subtrans 
 * so we can ensure it's initialized gaplessly up to the point where necessary 
 * while in recovery. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN635"></a><span class='Declare_Function'>ProcArrayInitRecovery</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>initializedUptoXID</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../access/transam/xlog.c.html#LN194"><span class='Ref_to_Global_Var'>standbyState</span></a> <span class='Operator'>== </span><a href="../../../include/access/xlog.h.html#LN66"><span class='Ref_to_EnumConst'>STANDBY_INITIALIZED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN635"><span class='Ref_to_Parameter'>initializedUptoXID</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * we set latestObservedXid to the xid SUBTRANS has been initialized up 
     * to, so we can extend it from that point onwards in 
     * RecordKnownAssignedTransactionIds, and when we get consistent in 
     * ProcArrayApplyRecoveryInfo(). 
     */ 
</span>    <a href="procarray.c.html#LN107"><span class='Ref_to_Global_Var'>latestObservedXid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN635"><span class='Ref_to_Parameter'>initializedUptoXID</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/access/transam.h.html#LN55"><span class='Ref_to_Macro'>TransactionIdRetreat</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN107"><span class='Ref_to_Global_Var'>latestObservedXid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * ProcArrayApplyRecoveryInfo -- apply recovery info about xids 
 * 
 * Takes us through 3 states: Initialized, Pending and Ready. 
 * Normal case is to go all the way to Ready straight away, though there 
 * are atypical cases where we need to take it in steps. 
 * 
 * Use the data about running transactions on master to create the initial 
 * state of KnownAssignedXids. We also use these records to regularly prune 
 * KnownAssignedXids because we know it is possible that some transactions 
 * with FATAL errors fail to write abort records, which could cause eventual 
 * overflow. 
 * 
 * See comments for LogStandbySnapshot(). 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN666"></a><span class='Declare_Function'>ProcArrayApplyRecoveryInfo</span><span class='Parentheses'>(</span><a href="../../../include/storage/standby.h.html#LN81"><span class='Ref_to_Typedef'>RunningTransactions</span></a> <span class='Declare_Parameter'>running</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN668"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Operator'>*</span><span class='Declare_Local'>xids</span><span class='Delimiter'>; 
</span><a name="LN669"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>nxids</span><span class='Delimiter'>; 
</span><a name="LN670"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>nextXid</span><span class='Delimiter'>; 
</span><a name="LN671"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../access/transam/xlog.c.html#LN194"><span class='Ref_to_Global_Var'>standbyState</span></a> <span class='Operator'>&GT;= </span><a href="../../../include/access/xlog.h.html#LN66"><span class='Ref_to_EnumConst'>STANDBY_INITIALIZED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN666"><span class='Ref_to_Parameter'>running</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/standby.h.html#LN74"><span class='Ref_to_Member'>nextXid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN666"><span class='Ref_to_Parameter'>running</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/standby.h.html#LN75"><span class='Ref_to_Member'>oldestRunningXid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN666"><span class='Ref_to_Parameter'>running</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/standby.h.html#LN76"><span class='Ref_to_Member'>latestCompletedXid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Remove stale transactions, if any. 
     */ 
</span>    <a href="../../../include/storage/procarray.h.html#LN76"><span class='Ref_to_Proto'>ExpireOldKnownAssignedTransactionIds</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN666"><span class='Ref_to_Parameter'>running</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/standby.h.html#LN75"><span class='Ref_to_Member'>oldestRunningXid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Remove stale locks, if any. 
     * 
     * Locks are always assigned to the toplevel xid so we don't need to care 
     * about subxcnt/subxids (and by extension not about -&GT;suboverflowed). 
     */ 
</span>    <a href="../../../include/storage/standby.h.html#LN52"><span class='Ref_to_Proto'>StandbyReleaseOldLocks</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN666"><span class='Ref_to_Parameter'>running</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/standby.h.html#LN71"><span class='Ref_to_Member'>xcnt</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN666"><span class='Ref_to_Parameter'>running</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/standby.h.html#LN78"><span class='Ref_to_Member'>xids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If our snapshot is already valid, nothing else to do... 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../access/transam/xlog.c.html#LN194"><span class='Ref_to_Global_Var'>standbyState</span></a> <span class='Operator'>== </span><a href="../../../include/access/xlog.h.html#LN68"><span class='Ref_to_EnumConst'>STANDBY_SNAPSHOT_READY</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If our initial RunningTransactionsData had an overflowed snapshot then 
     * we knew we were missing some subxids from our snapshot. If we continue 
     * to see overflowed snapshots then we might never be able to start up, so 
     * we make another test to see if our snapshot is now valid. We know that 
     * the missing subxids are equal to or earlier than nextXid. After we 
     * initialise we continue to apply changes during recovery, so once the 
     * oldestRunningXid is later than the nextXid from the initial snapshot we 
     * know that we no longer have missing information and can mark the 
     * snapshot as valid. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../access/transam/xlog.c.html#LN194"><span class='Ref_to_Global_Var'>standbyState</span></a> <span class='Operator'>== </span><a href="../../../include/access/xlog.h.html#LN67"><span class='Ref_to_EnumConst'>STANDBY_SNAPSHOT_PENDING</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * If the snapshot isn't overflowed or if its empty we can reset our 
         * pending state and use this snapshot instead. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="procarray.c.html#LN666"><span class='Ref_to_Parameter'>running</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/standby.h.html#LN73"><span class='Ref_to_Member'>subxid_overflow</span></a> <span class='Operator'>|| </span><a href="procarray.c.html#LN666"><span class='Ref_to_Parameter'>running</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/standby.h.html#LN71"><span class='Ref_to_Member'>xcnt</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * If we have already collected known assigned xids, we need to 
             * throw them away before we apply the recovery snapshot. 
             */ 
</span>            <a href="procarray.c.html#LN169"><span class='Ref_to_Proto'>KnownAssignedXidsReset</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <a href="../../access/transam/xlog.c.html#LN194"><span class='Ref_to_Global_Var'>standbyState</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog.h.html#LN66"><span class='Ref_to_EnumConst'>STANDBY_INITIALIZED</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN114"><span class='Ref_to_Global_Var'>standbySnapshotPendingXmin</span></a><span class='Delimiter'>, 
</span>                                      <a href="procarray.c.html#LN666"><span class='Ref_to_Parameter'>running</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/standby.h.html#LN75"><span class='Ref_to_Member'>oldestRunningXid</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="../../access/transam/xlog.c.html#LN194"><span class='Ref_to_Global_Var'>standbyState</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog.h.html#LN68"><span class='Ref_to_EnumConst'>STANDBY_SNAPSHOT_READY</span></a><span class='Delimiter'>; 
</span>                <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/miscadmin.h.html#LN287"><span class='Ref_to_Proto'>trace_recovery</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <span class='String'>"recovery snapshots are now enabled"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
                <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/miscadmin.h.html#LN287"><span class='Ref_to_Proto'>trace_recovery</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                  <span class='String'>"recovery snapshot waiting for non-overflowed snapshot or "</span> 
                <span class='String'>"until oldest active xid on standby is at least %u (now %u)"</span><span class='Delimiter'>, 
</span>                     <a href="procarray.c.html#LN114"><span class='Ref_to_Global_Var'>standbySnapshotPendingXmin</span></a><span class='Delimiter'>, 
</span>                     <a href="procarray.c.html#LN666"><span class='Ref_to_Parameter'>running</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/standby.h.html#LN75"><span class='Ref_to_Member'>oldestRunningXid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if standbyState==STANDBY... &raquo; </span> 
 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../access/transam/xlog.c.html#LN194"><span class='Ref_to_Global_Var'>standbyState</span></a> <span class='Operator'>== </span><a href="../../../include/access/xlog.h.html#LN66"><span class='Ref_to_EnumConst'>STANDBY_INITIALIZED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * OK, we need to initialise from the RunningTransactionsData record. 
     * 
     * NB: this can be reached at least twice, so make sure new code can deal 
     * with that. 
     */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Nobody else is running yet, but take locks anyhow 
     */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * KnownAssignedXids is sorted so we cannot just add the xids, we have to 
     * sort them first. 
     * 
     * Some of the new xids are top-level xids and some are subtransactions. 
     * We don't call SubtransSetParent because it doesn't matter yet. If we 
     * aren't overflowed then all xids will fit in snapshot and so we don't 
     * need subtrans. If we later overflow, an xid assignment record will add 
     * xids to subtrans. If RunningXacts is overflowed then we don't have 
     * enough information to correctly update subtrans anyway. 
     */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Allocate a temporary array to avoid modifying the array passed as 
     * argument. 
     */ 
</span>    <a href="procarray.c.html#LN668"><span class='Ref_To_Local'>xids</span></a> <span class='Operator'>= </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Parentheses'>(</span><a href="procarray.c.html#LN666"><span class='Ref_to_Parameter'>running</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/standby.h.html#LN71"><span class='Ref_to_Member'>xcnt</span></a> <span class='Operator'>+ </span><a href="procarray.c.html#LN666"><span class='Ref_to_Parameter'>running</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/standby.h.html#LN72"><span class='Ref_to_Member'>subxcnt</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Add to the temp array any xids which have not already completed. 
     */ 
</span>    <a href="procarray.c.html#LN669"><span class='Ref_To_Local'>nxids</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN671"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN671"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN666"><span class='Ref_to_Parameter'>running</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/standby.h.html#LN71"><span class='Ref_to_Member'>xcnt</span></a> <span class='Operator'>+ </span><a href="procarray.c.html#LN666"><span class='Ref_to_Parameter'>running</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/standby.h.html#LN72"><span class='Ref_to_Member'>subxcnt</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN671"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN780"></a>        <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>xid</span> <span class='Operator'>= </span><a href="procarray.c.html#LN666"><span class='Ref_to_Parameter'>running</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/standby.h.html#LN78"><span class='Ref_to_Member'>xids</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN671"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * The running-xacts snapshot can contain xids that were still visible 
         * in the procarray when the snapshot was taken, but were already 
         * WAL-logged as completed. They're not running anymore, so ignore 
         * them. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../access/transam/transam.c.html#LN123"><span class='Ref_to_Func'>TransactionIdDidCommit</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN780"><span class='Ref_To_Local'>xid</span></a><span class='Parentheses'>) </span><span class='Operator'>|| </span><a href="../../../include/access/transam.h.html#LN162"><span class='Ref_to_Proto'>TransactionIdDidAbort</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN780"><span class='Ref_To_Local'>xid</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <a href="procarray.c.html#LN668"><span class='Ref_To_Local'>xids</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN669"><span class='Ref_To_Local'>nxids</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="procarray.c.html#LN780"><span class='Ref_To_Local'>xid</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN669"><span class='Ref_To_Local'>nxids</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN74"><span class='Ref_to_Member'>numKnownAssignedXids</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"KnownAssignedXids is not empty"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Sort the array so that we can add them safely into 
         * KnownAssignedXids. 
         */ 
</span>        <a href="../../../include/port.h.html#LN439"><span class='Ref_to_Macro'>qsort</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN668"><span class='Ref_To_Local'>xids</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN669"><span class='Ref_To_Local'>nxids</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="../../../include/utils/builtins.h.html#LN94"><span class='Ref_to_Proto'>xidComparator</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Add the sorted snapshot into KnownAssignedXids 
         */ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN671"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN671"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN669"><span class='Ref_To_Local'>nxids</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN671"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <a href="procarray.c.html#LN155"><span class='Ref_to_Proto'>KnownAssignedXidsAdd</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN668"><span class='Ref_To_Local'>xids</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN671"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], </span><a href="procarray.c.html#LN668"><span class='Ref_To_Local'>xids</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN671"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="procarray.c.html#LN168"><span class='Ref_to_Proto'>KnownAssignedXidsDisplay</span></a><span class='Parentheses'>(</span><a href="../../../include/miscadmin.h.html#LN287"><span class='Ref_to_Proto'>trace_recovery</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN22"><span class='Ref_to_Const'>DEBUG3</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if nxids&GT;0 &raquo; </span> 
 
    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN668"><span class='Ref_To_Local'>xids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * latestObservedXid is at least set to the point where SUBTRANS was 
     * started up to (c.f. ProcArrayInitRecovery()) or to the biggest xid 
     * RecordKnownAssignedTransactionIds() was called for.  Initialize 
     * subtrans from thereon, up to nextXid - 1. 
     * 
     * We need to duplicate parts of RecordKnownAssignedTransactionId() here, 
     * because we've just added xids to the known assigned xids machinery that 
     * haven't gone through RecordKnownAssignedTransactionId(). 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN107"><span class='Ref_to_Global_Var'>latestObservedXid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/transam.h.html#LN47"><span class='Ref_to_Macro'>TransactionIdAdvance</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN107"><span class='Ref_to_Global_Var'>latestObservedXid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN107"><span class='Ref_to_Global_Var'>latestObservedXid</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN666"><span class='Ref_to_Parameter'>running</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/standby.h.html#LN74"><span class='Ref_to_Member'>nextXid</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/access/subtrans.h.html#LN26"><span class='Ref_to_Proto'>ExtendSUBTRANS</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN107"><span class='Ref_to_Global_Var'>latestObservedXid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/access/transam.h.html#LN47"><span class='Ref_to_Macro'>TransactionIdAdvance</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN107"><span class='Ref_to_Global_Var'>latestObservedXid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../../include/access/transam.h.html#LN55"><span class='Ref_to_Macro'>TransactionIdRetreat</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN107"><span class='Ref_to_Global_Var'>latestObservedXid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* = running-&GT;nextXid - 1 */ 
</span> 
    <span class='Comment_Multi_Line'>/* ---------- 
     * Now we've got the running xids we need to set the global values that 
     * are used to track snapshots as they evolve further. 
     * 
     * - latestCompletedXid which will be the xmax for snapshots 
     * - lastOverflowedXid which shows whether snapshots overflow 
     * - nextXid 
     * 
     * If the snapshot overflowed, then we still initialise with what we know, 
     * but the recovery snapshot isn't fully valid yet because we know there 
     * are some subxids missing. We don't know the specific subxids that are 
     * missing, so conservatively assume the last one is latestObservedXid. 
     * ---------- 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN666"><span class='Ref_to_Parameter'>running</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/standby.h.html#LN73"><span class='Ref_to_Member'>subxid_overflow</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../access/transam/xlog.c.html#LN194"><span class='Ref_to_Global_Var'>standbyState</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog.h.html#LN67"><span class='Ref_to_EnumConst'>STANDBY_SNAPSHOT_PENDING</span></a><span class='Delimiter'>; 
</span> 
        <a href="procarray.c.html#LN114"><span class='Ref_to_Global_Var'>standbySnapshotPendingXmin</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN107"><span class='Ref_to_Global_Var'>latestObservedXid</span></a><span class='Delimiter'>; 
</span>        <a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN86"><span class='Ref_to_Member'>lastOverflowedXid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN107"><span class='Ref_to_Global_Var'>latestObservedXid</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../access/transam/xlog.c.html#LN194"><span class='Ref_to_Global_Var'>standbyState</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog.h.html#LN68"><span class='Ref_to_EnumConst'>STANDBY_SNAPSHOT_READY</span></a><span class='Delimiter'>; 
</span> 
        <a href="procarray.c.html#LN114"><span class='Ref_to_Global_Var'>standbySnapshotPendingXmin</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If a transaction wrote a commit record in the gap between taking and 
     * logging the snapshot then latestCompletedXid may already be higher than 
     * the value from the snapshot, so check before we use the incoming value. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="../../access/transam/varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN134"><span class='Ref_to_Member'>latestCompletedXid</span></a><span class='Delimiter'>, 
</span>                              <a href="procarray.c.html#LN666"><span class='Ref_to_Parameter'>running</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/standby.h.html#LN76"><span class='Ref_to_Member'>latestCompletedXid</span></a><span class='Parentheses'>))</span> 
        <a href="../../access/transam/varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN134"><span class='Ref_to_Member'>latestCompletedXid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN666"><span class='Ref_to_Parameter'>running</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/standby.h.html#LN76"><span class='Ref_to_Member'>latestCompletedXid</span></a><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="../../access/transam/varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN134"><span class='Ref_to_Member'>latestCompletedXid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * ShmemVariableCache-&GT;nextXid must be beyond any observed xid. 
     * 
     * We don't expect anyone else to modify nextXid, hence we don't need to 
     * hold a lock while examining it.  We still acquire the lock to modify 
     * it, though. 
     */ 
</span>    <a href="procarray.c.html#LN670"><span class='Ref_To_Local'>nextXid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN107"><span class='Ref_to_Global_Var'>latestObservedXid</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/access/transam.h.html#LN47"><span class='Ref_to_Macro'>TransactionIdAdvance</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN670"><span class='Ref_To_Local'>nextXid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN170"><span class='Ref_to_Proto'>TransactionIdFollows</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN670"><span class='Ref_To_Local'>nextXid</span></a><span class='Delimiter'>, </span><a href="../../access/transam/varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN116"><span class='Ref_to_Member'>nextXid</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>XidGenLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../access/transam/varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN116"><span class='Ref_to_Member'>nextXid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN670"><span class='Ref_To_Local'>nextXid</span></a><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>XidGenLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="../../access/transam/varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN116"><span class='Ref_to_Member'>nextXid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="procarray.c.html#LN168"><span class='Ref_to_Proto'>KnownAssignedXidsDisplay</span></a><span class='Parentheses'>(</span><a href="../../../include/miscadmin.h.html#LN287"><span class='Ref_to_Proto'>trace_recovery</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN22"><span class='Ref_to_Const'>DEBUG3</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../access/transam/xlog.c.html#LN194"><span class='Ref_to_Global_Var'>standbyState</span></a> <span class='Operator'>== </span><a href="../../../include/access/xlog.h.html#LN68"><span class='Ref_to_EnumConst'>STANDBY_SNAPSHOT_READY</span></a><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/miscadmin.h.html#LN287"><span class='Ref_to_Proto'>trace_recovery</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='String'>"recovery snapshots are now enabled"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/miscadmin.h.html#LN287"><span class='Ref_to_Proto'>trace_recovery</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>             <span class='String'>"recovery snapshot waiting for non-overflowed snapshot or "</span> 
             <span class='String'>"until oldest active xid on standby is at least %u (now %u)"</span><span class='Delimiter'>, 
</span>             <a href="procarray.c.html#LN114"><span class='Ref_to_Global_Var'>standbySnapshotPendingXmin</span></a><span class='Delimiter'>, 
</span>             <a href="procarray.c.html#LN666"><span class='Ref_to_Parameter'>running</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/standby.h.html#LN75"><span class='Ref_to_Member'>oldestRunningXid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ProcArrayApplyRecoveryInfo &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * ProcArrayApplyXidAssignment 
 *      Process an XLOG_XACT_ASSIGNMENT WAL record 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN913"></a><span class='Declare_Function'>ProcArrayApplyXidAssignment</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>topxid</span><span class='Delimiter'>, 
</span><a name="LN914"></a>                            <span class='Keyword'>int </span><span class='Declare_Parameter'>nsubxids</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>subxids</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN916"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>max_xid</span><span class='Delimiter'>; 
</span><a name="LN917"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../access/transam/xlog.c.html#LN194"><span class='Ref_to_Global_Var'>standbyState</span></a> <span class='Operator'>&GT;= </span><a href="../../../include/access/xlog.h.html#LN66"><span class='Ref_to_EnumConst'>STANDBY_INITIALIZED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="procarray.c.html#LN916"><span class='Ref_To_Local'>max_xid</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN172"><span class='Ref_to_Proto'>TransactionIdLatest</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN913"><span class='Ref_to_Parameter'>topxid</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN914"><span class='Ref_to_Parameter'>nsubxids</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN914"><span class='Ref_to_Parameter'>subxids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Mark all the subtransactions as observed. 
     * 
     * NOTE: This will fail if the subxid contains too many previously 
     * unobserved xids to fit into known-assigned-xids. That shouldn't happen 
     * as the code stands, because xid-assignment records should never contain 
     * more than PGPROC_MAX_CACHED_SUBXIDS entries. 
     */ 
</span>    <a href="../../../include/storage/procarray.h.html#LN71"><span class='Ref_to_Proto'>RecordKnownAssignedTransactionIds</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN916"><span class='Ref_To_Local'>max_xid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Notice that we update pg_subtrans with the top-level xid, rather than 
     * the parent xid. This is a difference between normal processing and 
     * recovery, yet is still correct in all cases. The reason is that 
     * subtransaction commit is not marked in clog until commit processing, so 
     * all aborted subtransactions have already been clearly marked in clog. 
     * As a result we are able to refer directly to the top-level 
     * transaction's state rather than skipping through all the intermediate 
     * states in the subtransaction tree. This should be the first time we 
     * have attempted to SubTransSetParent(). 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN917"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN917"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN914"><span class='Ref_to_Parameter'>nsubxids</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN917"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <a href="../../../include/access/subtrans.h.html#LN16"><span class='Ref_to_Proto'>SubTransSetParent</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN914"><span class='Ref_to_Parameter'>subxids</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN917"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], </span><a href="procarray.c.html#LN913"><span class='Ref_to_Parameter'>topxid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* KnownAssignedXids isn't maintained yet, so we're done for now */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../access/transam/xlog.c.html#LN194"><span class='Ref_to_Global_Var'>standbyState</span></a> <span class='Operator'>== </span><a href="../../../include/access/xlog.h.html#LN66"><span class='Ref_to_EnumConst'>STANDBY_INITIALIZED</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Uses same locking as transaction commit 
     */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Remove subxids from known-assigned-xacts. 
     */ 
</span>    <a href="procarray.c.html#LN160"><span class='Ref_to_Proto'>KnownAssignedXidsRemoveTree</span></a><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN914"><span class='Ref_to_Parameter'>nsubxids</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN914"><span class='Ref_to_Parameter'>subxids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Advance lastOverflowedXid to be at least the last of these subxids. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN86"><span class='Ref_to_Member'>lastOverflowedXid</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN916"><span class='Ref_To_Local'>max_xid</span></a><span class='Parentheses'>))</span> 
        <a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN86"><span class='Ref_to_Member'>lastOverflowedXid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN916"><span class='Ref_To_Local'>max_xid</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ProcArrayApplyXidAssignment &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * TransactionIdIsInProgress -- is given transaction running in some backend 
 * 
 * Aside from some shortcuts such as checking RecentXmin and our own Xid, 
 * there are four possibilities for finding a running transaction: 
 * 
 * 1. The given Xid is a main transaction Id.  We will find this out cheaply 
 * by looking at the PGXACT struct for each backend. 
 * 
 * 2. The given Xid is one of the cached subxact Xids in the PGPROC array. 
 * We can find this out cheaply too. 
 * 
 * 3. In Hot Standby mode, we must search the KnownAssignedXids list to see 
 * if the Xid is running on the master. 
 * 
 * 4. Search the SubTrans tree to find the Xid's topmost parent, and then see 
 * if that is running according to PGXACT or KnownAssignedXids.  This is the 
 * slowest way, but sadly it has to be done always if the others failed, 
 * unless we see that the cached subxact sets are complete (none have 
 * overflowed). 
 * 
 * ProcArrayLock has to be held while we do 1, 2, 3.  If we save the top Xids 
 * while doing 1 and 3, we can release the ProcArrayLock while we do 4. 
 * This buys back some concurrency (and we can't retrieve the main Xids from 
 * PGXACT again anyway; see GetNewTransactionId). 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN997"></a><span class='Declare_Function'>TransactionIdIsInProgress</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN999"></a>    <span class='Keyword'>static </span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Operator'>*</span><span class='Declare_Local'>xids</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN1000"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>nxids</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1001"></a>    <a href="procarray.c.html#LN65"><span class='Ref_to_Struct'>ProcArrayStruct</span></a> <span class='Operator'>*</span><span class='Declare_Local'>arrayP</span> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Delimiter'>; 
</span><a name="LN1002"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>topxid</span><span class='Delimiter'>; 
</span><a name="LN1003"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>, 
</span><a name="LN1004"></a>                <span class='Declare_Local'>j</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Don't bother checking a transaction older than RecentXmin; it could not 
     * possibly still be running.  (Note: in particular, this guarantees that 
     * we reject InvalidTransactionId, FrozenTransactionId, etc as not 
     * running.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN997"><span class='Ref_to_Parameter'>xid</span></a><span class='Delimiter'>, </span><a href="../../utils/time/snapmgr.c.html#LN164"><span class='Ref_to_Global_Var'>RecentXmin</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="procarray.c.html#LN129"><span class='Ref_to_Macro'>xc_by_recent_xmin_inc</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We may have just checked the status of this transaction, so if it is 
     * already known to be completed, we can fall out without any access to 
     * shared memory. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN163"><span class='Ref_to_Proto'>TransactionIdIsKnownCompleted</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN997"><span class='Ref_to_Parameter'>xid</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="procarray.c.html#LN130"><span class='Ref_to_Macro'>xc_by_known_xact_inc</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Also, we can handle our own transaction (and subtransactions) without 
     * any access to shared memory. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xact.h.html#LN345"><span class='Ref_to_Proto'>TransactionIdIsCurrentTransactionId</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN997"><span class='Ref_to_Parameter'>xid</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="procarray.c.html#LN131"><span class='Ref_to_Macro'>xc_by_my_xact_inc</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If first time through, get workspace to remember main XIDs in. We 
     * malloc it permanently to avoid repeated palloc/pfree overhead. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN999"><span class='Ref_To_Local'>xids</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * In hot standby mode, reserve enough space to hold all xids in the 
         * known-assigned list. If we later finish recovery, we no longer need 
         * the bigger array, but we don't bother to shrink it. 
         */ 
</span><a name="LN1050"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>maxxids</span> <span class='Operator'>= </span><a href="../../../include/access/xlog.h.html#LN242"><span class='Ref_to_Proto'>RecoveryInProgress</span></a><span class='Parentheses'>() </span><span class='Operator'>? </span><a href="procarray.c.html#LN201"><span class='Ref_to_Const'>TOTAL_MAX_CACHED_SUBXIDS</span></a> <span class='Operator'>: </span><a href="procarray.c.html#LN1001"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN68"><span class='Ref_to_Member'>maxProcs</span></a><span class='Delimiter'>; 
</span> 
        <a href="procarray.c.html#LN999"><span class='Ref_To_Local'>xids</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/snowball/header.h.html#LN49"><span class='Ref_to_Macro'>malloc</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1050"><span class='Ref_To_Local'>maxxids</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN999"><span class='Ref_To_Local'>xids</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OUT_OF_MEMORY<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"out of memory"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now that we have the lock, we can check latestCompletedXid; if the 
     * target Xid is after that, it's surely still running. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="../../access/transam/varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN134"><span class='Ref_to_Member'>latestCompletedXid</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN997"><span class='Ref_to_Parameter'>xid</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="procarray.c.html#LN132"><span class='Ref_to_Macro'>xc_by_latest_xid_inc</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* No shortcuts, gotta grovel through the array */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN1003"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN1003"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN1001"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN67"><span class='Ref_to_Member'>numProcs</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN1003"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1075"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>pgprocno</span> <span class='Operator'>= </span><a href="procarray.c.html#LN1001"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN94"><span class='Ref_to_Member'>pgprocnos</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN1003"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span><a name="LN1076"></a>        <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Declare_Local'>proc</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN99"><span class='Ref_to_Global_Var'>allProcs</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN1075"><span class='Ref_To_Local'>pgprocno</span></a><span class='Delimiter'>]; 
</span><a name="LN1077"></a>        <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN206"><span class='Ref_to_Struct'>PGXACT</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pgxact</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN100"><span class='Ref_to_Global_Var'>allPgXact</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN1075"><span class='Ref_To_Local'>pgprocno</span></a><span class='Delimiter'>]; 
</span><a name="LN1078"></a>        <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>pxid</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Ignore my own proc --- dealt with it above */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN1076"><span class='Ref_To_Local'>proc</span></a> <span class='Operator'>== </span><a href="../lmgr/proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Fetch xid just once - see GetNewTransactionId */ 
</span>        <a href="procarray.c.html#LN1078"><span class='Ref_To_Local'>pxid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1077"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN208"><span class='Ref_to_Member'>xid</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1078"><span class='Ref_To_Local'>pxid</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Step 1: check the main Xid 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN42"><span class='Ref_to_Macro'>TransactionIdEquals</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1078"><span class='Ref_To_Local'>pxid</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN997"><span class='Ref_to_Parameter'>xid</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="procarray.c.html#LN133"><span class='Ref_to_Macro'>xc_by_main_xid_inc</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We can ignore main Xids that are younger than the target Xid, since 
         * the target could not possibly be their child. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN997"><span class='Ref_to_Parameter'>xid</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN1078"><span class='Ref_To_Local'>pxid</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Step 2: check the cached child-Xids arrays 
         */ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN1004"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1077"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN222"><span class='Ref_to_Member'>nxids</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN1004"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN1004"><span class='Ref_To_Local'>j</span></a><span class='Operator'>--</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Fetch xid just once - see GetNewTransactionId */ 
</span><a name="LN1113"></a>            <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>cxid</span> <span class='Operator'>= </span><a href="procarray.c.html#LN1076"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN157"><span class='Ref_to_Member'>subxids</span></a><span class='Operator'>.</span><a href="../../../include/storage/proc.h.html#LN38"><span class='Ref_to_Member'>xids</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN1004"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN42"><span class='Ref_to_Macro'>TransactionIdEquals</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1113"><span class='Ref_To_Local'>cxid</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN997"><span class='Ref_to_Parameter'>xid</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="procarray.c.html#LN134"><span class='Ref_to_Macro'>xc_by_child_xid_inc</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Save the main Xid for step 4.  We only need to remember main Xids 
         * that have uncached children.  (Note: there is no race condition 
         * here because the overflowed flag cannot be cleared, only set, while 
         * we hold ProcArrayLock.  So we can't miss an Xid that we need to 
         * worry about.) 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN1077"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN218"><span class='Ref_to_Member'>overflowed</span></a><span class='Parentheses'>) 
</span>            <a href="procarray.c.html#LN999"><span class='Ref_To_Local'>xids</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN1000"><span class='Ref_To_Local'>nxids</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="procarray.c.html#LN1078"><span class='Ref_To_Local'>pxid</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;arrayP-&GT;numProc... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Step 3: in hot standby mode, check the known-assigned-xids list.  XIDs 
     * in the list must be treated as running. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN242"><span class='Ref_to_Proto'>RecoveryInProgress</span></a><span class='Parentheses'>())</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* none of the PGXACT entries should have XIDs in hot standby mode */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="procarray.c.html#LN1000"><span class='Ref_To_Local'>nxids</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN158"><span class='Ref_to_Proto'>KnownAssignedXidExists</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN997"><span class='Ref_to_Parameter'>xid</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="procarray.c.html#LN135"><span class='Ref_to_Macro'>xc_by_known_assigned_inc</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If the KnownAssignedXids overflowed, we have to check pg_subtrans 
         * too.  Fetch all xids from KnownAssignedXids that are lower than 
         * xid, since if xid is a subtransaction its parent will always have a 
         * lower value.  Note we will collect both main and subXIDs here, but 
         * there's no help for it. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN169"><span class='Ref_to_Proto'>TransactionIdPrecedesOrEquals</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN997"><span class='Ref_to_Parameter'>xid</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN86"><span class='Ref_to_Member'>lastOverflowedXid</span></a><span class='Parentheses'>))</span> 
            <a href="procarray.c.html#LN1000"><span class='Ref_To_Local'>nxids</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN163"><span class='Ref_to_Proto'>KnownAssignedXidsGet</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN999"><span class='Ref_To_Local'>xids</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN997"><span class='Ref_to_Parameter'>xid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if RecoveryInProgress() &raquo; </span> 
 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If none of the relevant caches overflowed, we know the Xid is not 
     * running without even looking at pg_subtrans. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN1000"><span class='Ref_To_Local'>nxids</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="procarray.c.html#LN136"><span class='Ref_to_Macro'>xc_no_overflow_inc</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Step 4: have to check pg_subtrans. 
     * 
     * At this point, we know it's either a subtransaction of one of the Xids 
     * in xids[], or it's not running.  If it's an already-failed 
     * subtransaction, we want to say "not running" even though its parent may 
     * still be running.  So first, check pg_xact to see if it's been aborted. 
     */ 
</span>    <a href="procarray.c.html#LN137"><span class='Ref_to_Macro'>xc_slow_answer_inc</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN162"><span class='Ref_to_Proto'>TransactionIdDidAbort</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN997"><span class='Ref_to_Parameter'>xid</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * It isn't aborted, so check whether the transaction tree it belongs to 
     * is still running (or, more precisely, whether it was running when we 
     * held ProcArrayLock). 
     */ 
</span>    <a href="procarray.c.html#LN1002"><span class='Ref_To_Local'>topxid</span></a> <span class='Operator'>= </span><a href="../../../include/access/subtrans.h.html#LN18"><span class='Ref_to_Proto'>SubTransGetTopmostTransaction</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN997"><span class='Ref_to_Parameter'>xid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1002"><span class='Ref_To_Local'>topxid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN42"><span class='Ref_to_Macro'>TransactionIdEquals</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1002"><span class='Ref_To_Local'>topxid</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN997"><span class='Ref_to_Parameter'>xid</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN1003"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN1003"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN1000"><span class='Ref_To_Local'>nxids</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN1003"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN42"><span class='Ref_to_Macro'>TransactionIdEquals</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN999"><span class='Ref_To_Local'>xids</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN1003"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], </span><a href="procarray.c.html#LN1002"><span class='Ref_To_Local'>topxid</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end TransactionIdIsInProgress &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * TransactionIdIsActive -- is xid the top-level XID of an active backend? 
 * 
 * This differs from TransactionIdIsInProgress in that it ignores prepared 
 * transactions, as well as transactions running on the master if we're in 
 * hot standby.  Also, we ignore subtransactions since that's not needed 
 * for current uses. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN1214"></a><span class='Declare_Function'>TransactionIdIsActive</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1216"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>result</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN1217"></a>    <a href="procarray.c.html#LN65"><span class='Ref_to_Struct'>ProcArrayStruct</span></a> <span class='Operator'>*</span><span class='Declare_Local'>arrayP</span> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Delimiter'>; 
</span><a name="LN1218"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Don't bother checking a transaction older than RecentXmin; it could not 
     * possibly still be running. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1214"><span class='Ref_to_Parameter'>xid</span></a><span class='Delimiter'>, </span><a href="../../utils/time/snapmgr.c.html#LN164"><span class='Ref_to_Global_Var'>RecentXmin</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN1218"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN1218"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN1217"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN67"><span class='Ref_to_Member'>numProcs</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN1218"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1231"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>pgprocno</span> <span class='Operator'>= </span><a href="procarray.c.html#LN1217"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN94"><span class='Ref_to_Member'>pgprocnos</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN1218"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span><a name="LN1232"></a>        <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Declare_Local'>proc</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN99"><span class='Ref_to_Global_Var'>allProcs</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN1231"><span class='Ref_To_Local'>pgprocno</span></a><span class='Delimiter'>]; 
</span><a name="LN1233"></a>        <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN206"><span class='Ref_to_Struct'>PGXACT</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pgxact</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN100"><span class='Ref_to_Global_Var'>allPgXact</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN1231"><span class='Ref_To_Local'>pgprocno</span></a><span class='Delimiter'>]; 
</span><a name="LN1234"></a>        <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>pxid</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Fetch xid just once - see GetNewTransactionId */ 
</span>        <a href="procarray.c.html#LN1234"><span class='Ref_To_Local'>pxid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1233"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN208"><span class='Ref_to_Member'>xid</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1234"><span class='Ref_To_Local'>pxid</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN1232"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN107"><span class='Ref_to_Member'>pid</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* ignore prepared transactions */ 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN42"><span class='Ref_to_Macro'>TransactionIdEquals</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1234"><span class='Ref_To_Local'>pxid</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN1214"><span class='Ref_to_Parameter'>xid</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="procarray.c.html#LN1216"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;arrayP-&GT;numProc... &raquo; </span> 
 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="procarray.c.html#LN1216"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end TransactionIdIsActive &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * GetOldestXmin -- returns oldest transaction that was running 
 *                  when any current transaction was started. 
 * 
 * If rel is NULL or a shared relation, all backends are considered, otherwise 
 * only backends running in this database are considered. 
 * 
 * The flags are used to ignore the backends in calculation when any of the 
 * corresponding flags is set. Typically, if you want to ignore ones with 
 * PROC_IN_VACUUM flag, you can use PROCARRAY_FLAGS_VACUUM. 
 * 
 * PROCARRAY_SLOTS_XMIN causes GetOldestXmin to ignore the xmin and 
 * catalog_xmin of any replication slots that exist in the system when 
 * calculating the oldest xmin. 
 * 
 * This is used by VACUUM to decide which deleted tuples must be preserved in 
 * the passed in table. For shared relations backends in all databases must be 
 * considered, but for non-shared relations that's not required, since only 
 * backends in my own database could ever see the tuples in them. Also, we can 
 * ignore concurrently running lazy VACUUMs because (a) they must be working 
 * on other tables, and (b) they don't need to do snapshot-based lookups. 
 * 
 * This is also used to determine where to truncate pg_subtrans.  For that 
 * backends in all databases have to be considered, so rel = NULL has to be 
 * passed in. 
 * 
 * Note: we include all currently running xids in the set of considered xids. 
 * This ensures that if a just-started xact has not yet set its snapshot, 
 * when it does set the snapshot it cannot set xmin less than what we compute. 
 * See notes in src/backend/access/transam/README. 
 * 
 * Note: despite the above, it's possible for the calculated value to move 
 * backwards on repeated calls. The calculated value is conservative, so that 
 * anything older is definitely not considered as running by anyone anymore, 
 * but the exact value calculated depends on a number of things. For example, 
 * if rel = NULL and there are no transactions running in the current 
 * database, GetOldestXmin() returns latestCompletedXid. If a transaction 
 * begins after that, its xmin will include in-progress transactions in other 
 * databases that started earlier, so another call will return a lower value. 
 * Nonetheless it is safe to vacuum a table in the current database with the 
 * first result.  There are also replication-related effects: a walsender 
 * process can set its xmin based on transactions that are no longer running 
 * in the master but are still being replayed on the standby, thus possibly 
 * making the GetOldestXmin reading go backwards.  In this case there is a 
 * possibility that we lose data that the standby would like to have, but 
 * unless the standby uses a replication slot to make its xmin persistent 
 * there is little we can do about that --- data is only protected if the 
 * walsender runs continuously while queries are executed on the standby. 
 * (The Hot Standby code deals with such cases by failing standby queries 
 * that needed to access already-removed data, so there's no integrity bug.) 
 * The return value is also adjusted with vacuum_defer_cleanup_age, so 
 * increasing that setting on the fly is another easy way to make 
 * GetOldestXmin() move backwards, with no consequences for data integrity. 
 */ 
</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> 
<a name="LN1313"></a><span class='Declare_Function'>GetOldestXmin</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>rel</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>flags</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1315"></a>    <a href="procarray.c.html#LN65"><span class='Ref_to_Struct'>ProcArrayStruct</span></a> <span class='Operator'>*</span><span class='Declare_Local'>arrayP</span> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Delimiter'>; 
</span><a name="LN1316"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span><a name="LN1317"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>index</span><span class='Delimiter'>; 
</span><a name="LN1318"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>allDbs</span><span class='Delimiter'>; 
</span> 
<a name="LN1320"></a>    <span class='Keyword'>volatile </span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>replication_slot_xmin</span> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span><a name="LN1321"></a>    <span class='Keyword'>volatile </span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>replication_slot_catalog_xmin</span> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we're not computing a relation specific limit, or if a shared 
     * relation has been passed in, backends in all databases have to be 
     * considered. 
     */ 
</span>    <a href="procarray.c.html#LN1318"><span class='Ref_To_Local'>allDbs</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1313"><span class='Ref_to_Parameter'>rel</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| </span><a href="procarray.c.html#LN1313"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relisshared<span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Cannot look for individual databases during recovery */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="procarray.c.html#LN1318"><span class='Ref_To_Local'>allDbs</span></a> <span class='Operator'>|| !</span><a href="../../../include/access/xlog.h.html#LN242"><span class='Ref_to_Proto'>RecoveryInProgress</span></a><span class='Parentheses'>())</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We initialize the MIN() calculation with latestCompletedXid + 1. This 
     * is a lower bound for the XIDs that might appear in the ProcArray later, 
     * and so protects us against overestimating the result due to future 
     * additions. 
     */ 
</span>    <a href="procarray.c.html#LN1316"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../access/transam/varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN134"><span class='Ref_to_Member'>latestCompletedXid</span></a><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1316"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/transam.h.html#LN47"><span class='Ref_to_Macro'>TransactionIdAdvance</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1316"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN1317"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN1317"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN1315"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN67"><span class='Ref_to_Member'>numProcs</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN1317"><span class='Ref_To_Local'>index</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1347"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>pgprocno</span> <span class='Operator'>= </span><a href="procarray.c.html#LN1315"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN94"><span class='Ref_to_Member'>pgprocnos</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN1317"><span class='Ref_To_Local'>index</span></a><span class='Delimiter'>]; 
</span><a name="LN1348"></a>        <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Declare_Local'>proc</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN99"><span class='Ref_to_Global_Var'>allProcs</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN1347"><span class='Ref_To_Local'>pgprocno</span></a><span class='Delimiter'>]; 
</span><a name="LN1349"></a>        <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN206"><span class='Ref_to_Struct'>PGXACT</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pgxact</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN100"><span class='Ref_to_Global_Var'>allPgXact</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN1347"><span class='Ref_To_Local'>pgprocno</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN1349"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN217"><span class='Ref_to_Member'>vacuumFlags</span></a> <span class='Operator'>& </span><span class='Parentheses'>(</span><a href="procarray.c.html#LN1313"><span class='Ref_to_Parameter'>flags</span></a> <span class='Operator'>& </span><a href="../../../include/storage/procarray.h.html#LN44"><span class='Ref_to_Const'>PROCARRAY_PROC_FLAGS_MASK</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN1318"><span class='Ref_To_Local'>allDbs</span></a> <span class='Operator'>|| 
</span>            <a href="procarray.c.html#LN1348"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN112"><span class='Ref_to_Member'>databaseId</span></a> <span class='Operator'>== </span><a href="../../utils/init/globals.c.html#LN76"><span class='Ref_to_Global_Var'>MyDatabaseId</span></a> <span class='Operator'>|| 
</span>            <a href="procarray.c.html#LN1348"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN112"><span class='Ref_to_Member'>databaseId</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span>      <span class='Comment_Single_Line'>/* always include WalSender */ 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Fetch xid just once - see GetNewTransactionId */ 
</span><a name="LN1359"></a>            <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>xid</span> <span class='Operator'>= </span><a href="procarray.c.html#LN1349"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN208"><span class='Ref_to_Member'>xid</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* First consider the transaction's own Xid, if any */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1359"><span class='Ref_To_Local'>xid</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                <a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1359"><span class='Ref_To_Local'>xid</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN1316"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>))</span> 
                <a href="procarray.c.html#LN1316"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1359"><span class='Ref_To_Local'>xid</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Also consider the transaction's Xmin, if set. 
             * 
             * We must check both Xid and Xmin because a transaction might 
             * have an Xmin but not (yet) an Xid; conversely, if it has an 
             * Xid, that could determine some not-yet-set Xmin. 
             */ 
</span>            <a href="procarray.c.html#LN1359"><span class='Ref_To_Local'>xid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1349"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN212"><span class='Ref_to_Member'>xmin</span></a><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* Fetch just once */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1359"><span class='Ref_To_Local'>xid</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                <a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1359"><span class='Ref_To_Local'>xid</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN1316"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>))</span> 
                <a href="procarray.c.html#LN1316"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1359"><span class='Ref_To_Local'>xid</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if allDbs||proc-&GT;databas... &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for index=0;index&LT;arrayP-... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* fetch into volatile var while ProcArrayLock is held */ 
</span>    <a href="procarray.c.html#LN1320"><span class='Ref_To_Local'>replication_slot_xmin</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN89"><span class='Ref_to_Member'>replication_slot_xmin</span></a><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN1321"><span class='Ref_To_Local'>replication_slot_catalog_xmin</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN91"><span class='Ref_to_Member'>replication_slot_catalog_xmin</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN242"><span class='Ref_to_Proto'>RecoveryInProgress</span></a><span class='Parentheses'>())</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Check to see whether KnownAssignedXids contains an xid value older 
         * than the main procarray. 
         */ 
</span><a name="LN1390"></a>        <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>kaxmin</span> <span class='Operator'>= </span><a href="procarray.c.html#LN167"><span class='Ref_to_Proto'>KnownAssignedXidsGetOldestXmin</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1390"><span class='Ref_To_Local'>kaxmin</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>            <a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1390"><span class='Ref_To_Local'>kaxmin</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN1316"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>))</span> 
            <a href="procarray.c.html#LN1316"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1390"><span class='Ref_To_Local'>kaxmin</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * No other information needed, so release the lock immediately. 
         */ 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Compute the cutoff XID by subtracting vacuum_defer_cleanup_age, 
         * being careful not to generate a "permanent" XID. 
         * 
         * vacuum_defer_cleanup_age provides some additional "slop" for the 
         * benefit of hot standby queries on slave servers.  This is quick and 
         * dirty, and perhaps not all that useful unless the master has a 
         * predictable transaction rate, but it offers some protection when 
         * there's no walsender connection.  Note that we are assuming 
         * vacuum_defer_cleanup_age isn't large enough to cause wraparound --- 
         * so guc.c should limit it to no more than the xidStopLimit threshold 
         * in varsup.c.  Also note that we intentionally don't apply 
         * vacuum_defer_cleanup_age on standby servers. 
         */ 
</span>        <a href="procarray.c.html#LN1316"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>-= </span><a href="standby.c.html#LN36"><span class='Ref_to_Global_Var'>vacuum_defer_cleanup_age</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1316"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>))</span> 
            <a href="procarray.c.html#LN1316"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN33"><span class='Ref_to_Const'>FirstNormalTransactionId</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Check whether there are replication slots requiring an older xmin. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="procarray.c.html#LN1313"><span class='Ref_to_Parameter'>flags</span></a> <span class='Operator'>& </span><a href="../../../include/storage/procarray.h.html#LN37"><span class='Ref_to_Const'>PROCARRAY_SLOTS_XMIN</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>        <a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1320"><span class='Ref_To_Local'>replication_slot_xmin</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>        <a href="../../../include/access/transam.h.html#LN61"><span class='Ref_to_Macro'>NormalTransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1320"><span class='Ref_To_Local'>replication_slot_xmin</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN1316"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>))</span> 
        <a href="procarray.c.html#LN1316"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1320"><span class='Ref_To_Local'>replication_slot_xmin</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * After locks have been released and defer_cleanup_age has been applied, 
     * check whether we need to back up further to make logical decoding 
     * possible. We need to do so if we're computing the global limit (rel = 
     * NULL) or if the passed relation is a catalog relation of some kind. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="procarray.c.html#LN1313"><span class='Ref_to_Parameter'>flags</span></a> <span class='Operator'>& </span><a href="../../../include/storage/procarray.h.html#LN37"><span class='Ref_to_Const'>PROCARRAY_SLOTS_XMIN</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>        <span class='Parentheses'>(</span><a href="procarray.c.html#LN1313"><span class='Ref_to_Parameter'>rel</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| 
</span>         <a href="../../../include/utils/rel.h.html#LN559"><span class='Ref_to_Macro'>RelationIsAccessibleInLogicalDecoding</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1313"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>))</span> <span class='Operator'>&& 
</span>        <a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1321"><span class='Ref_To_Local'>replication_slot_catalog_xmin</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>        <a href="../../../include/access/transam.h.html#LN61"><span class='Ref_to_Macro'>NormalTransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1321"><span class='Ref_To_Local'>replication_slot_catalog_xmin</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN1316"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>))</span> 
        <a href="procarray.c.html#LN1316"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1321"><span class='Ref_To_Local'>replication_slot_catalog_xmin</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="procarray.c.html#LN1316"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end GetOldestXmin &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * GetMaxSnapshotXidCount -- get max size for snapshot XID array 
 * 
 * We have to export this for use by snapmgr.c. 
 */ 
</span><span class='Keyword'>int 
</span><a name="LN1454"></a><span class='Declare_Function'>GetMaxSnapshotXidCount</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN68"><span class='Ref_to_Member'>maxProcs</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * GetMaxSnapshotSubxidCount -- get max size for snapshot sub-XID array 
 * 
 * We have to export this for use by snapmgr.c. 
 */ 
</span><span class='Keyword'>int 
</span><a name="LN1465"></a><span class='Declare_Function'>GetMaxSnapshotSubxidCount</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="procarray.c.html#LN201"><span class='Ref_to_Const'>TOTAL_MAX_CACHED_SUBXIDS</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * GetSnapshotData -- returns information about running transactions. 
 * 
 * The returned snapshot includes xmin (lowest still-running xact ID), 
 * xmax (highest completed xact ID + 1), and a list of running xact IDs 
 * in the range xmin &LT;= xid &LT; xmax.  It is used as follows: 
 *      All xact IDs &LT; xmin are considered finished. 
 *      All xact IDs &GT;= xmax are considered still running. 
 *      For an xact ID xmin &LT;= xid &LT; xmax, consult list to see whether 
 *      it is considered running or not. 
 * This ensures that the set of transactions seen as "running" by the 
 * current xact will not change after it takes the snapshot. 
 * 
 * All running top-level XIDs are included in the snapshot, except for lazy 
 * VACUUM processes.  We also try to include running subtransaction XIDs, 
 * but since PGPROC has only a limited cache area for subxact XIDs, full 
 * information may not be available.  If we find any overflowed subxid arrays, 
 * we have to mark the snapshot's subxid data as overflowed, and extra work 
 * *may* need to be done to determine what's running (see XidInMVCCSnapshot() 
 * in tqual.c). 
 * 
 * We also update the following backend-global variables: 
 *      TransactionXmin: the oldest xmin of any snapshot in use in the 
 *          current transaction (this is the same as MyPgXact-&GT;xmin). 
 *      RecentXmin: the xmin computed for the most recent snapshot.  XIDs 
 *          older than this are known not running any more. 
 *      RecentGlobalXmin: the global xmin (oldest TransactionXmin across all 
 *          running transactions, except those running LAZY VACUUM).  This is 
 *          the same computation done by 
 *          GetOldestXmin(NULL, PROCARRAY_FLAGS_VACUUM). 
 *      RecentGlobalDataXmin: the global xmin for non-catalog tables 
 *          &GT;= RecentGlobalXmin 
 * 
 * Note: this function should probably not be called with an argument that's 
 * not statically allocated (see xip allocation below). 
 */ 
</span><a href="../../../include/utils/snapshot.h.html#LN22"><span class='Ref_to_Typedef'>Snapshot</span></a> 
<a name="LN1507"></a><span class='Declare_Function'>GetSnapshotData</span><span class='Parentheses'>(</span><a href="../../../include/utils/snapshot.h.html#LN22"><span class='Ref_to_Typedef'>Snapshot</span></a> <span class='Declare_Parameter'>snapshot</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1509"></a>    <a href="procarray.c.html#LN65"><span class='Ref_to_Struct'>ProcArrayStruct</span></a> <span class='Operator'>*</span><span class='Declare_Local'>arrayP</span> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Delimiter'>; 
</span><a name="LN1510"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>xmin</span><span class='Delimiter'>; 
</span><a name="LN1511"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>xmax</span><span class='Delimiter'>; 
</span><a name="LN1512"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>globalxmin</span><span class='Delimiter'>; 
</span><a name="LN1513"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>index</span><span class='Delimiter'>; 
</span><a name="LN1514"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>count</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1515"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>subcount</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1516"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>suboverflowed</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN1517"></a>    <span class='Keyword'>volatile </span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>replication_slot_xmin</span> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span><a name="LN1518"></a>    <span class='Keyword'>volatile </span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>replication_slot_catalog_xmin</span> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="procarray.c.html#LN1507"><span class='Ref_to_Parameter'>snapshot</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Allocating space for maxProcs xids is usually overkill; numProcs would 
     * be sufficient.  But it seems better to do the malloc while not holding 
     * the lock, so we can't look at numProcs.  Likewise, we allocate much 
     * more subxip storage than is probably needed. 
     * 
     * This does open a possibility for avoiding repeated malloc/free: since 
     * maxProcs does not change at runtime, we can simply reuse the previous 
     * xip arrays if any.  (This relies on the fact that all callers pass 
     * static SnapshotData structs.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN1507"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/snapshot.h.html#LN76"><span class='Ref_to_Member'>xip</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * First call for this snapshot. Snapshot is same size whether or not 
         * we are in recovery, see later comments. 
         */ 
</span>        <a href="procarray.c.html#LN1507"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/snapshot.h.html#LN76"><span class='Ref_to_Member'>xip</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../../include/snowball/header.h.html#LN49"><span class='Ref_to_Macro'>malloc</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/procarray.h.html#LN78"><span class='Ref_to_Proto'>GetMaxSnapshotXidCount</span></a><span class='Parentheses'>() </span><span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN1507"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/snapshot.h.html#LN76"><span class='Ref_to_Member'>xip</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OUT_OF_MEMORY<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"out of memory"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="procarray.c.html#LN1507"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/snapshot.h.html#LN88"><span class='Ref_to_Member'>subxip</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="procarray.c.html#LN1507"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/snapshot.h.html#LN88"><span class='Ref_to_Member'>subxip</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../../include/snowball/header.h.html#LN49"><span class='Ref_to_Macro'>malloc</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/procarray.h.html#LN79"><span class='Ref_to_Proto'>GetMaxSnapshotSubxidCount</span></a><span class='Parentheses'>() </span><span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN1507"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/snapshot.h.html#LN88"><span class='Ref_to_Member'>subxip</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OUT_OF_MEMORY<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"out of memory"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if snapshot-&GT;xip==NULL &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * It is sufficient to get shared lock on ProcArrayLock, even if we are 
     * going to set MyPgXact-&GT;xmin. 
     */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* xmax is always latestCompletedXid + 1 */ 
</span>    <a href="procarray.c.html#LN1511"><span class='Ref_To_Local'>xmax</span></a> <span class='Operator'>= </span><a href="../../access/transam/varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN134"><span class='Ref_to_Member'>latestCompletedXid</span></a><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1511"><span class='Ref_To_Local'>xmax</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/transam.h.html#LN47"><span class='Ref_to_Macro'>TransactionIdAdvance</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1511"><span class='Ref_To_Local'>xmax</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* initialize xmin calculation with xmax */ 
</span>    <a href="procarray.c.html#LN1512"><span class='Ref_To_Local'>globalxmin</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1510"><span class='Ref_To_Local'>xmin</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1511"><span class='Ref_To_Local'>xmax</span></a><span class='Delimiter'>; 
</span> 
    <a href="procarray.c.html#LN1507"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/snapshot.h.html#LN92"><span class='Ref_to_Member'>takenDuringRecovery</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog.h.html#LN242"><span class='Ref_to_Proto'>RecoveryInProgress</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="procarray.c.html#LN1507"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/snapshot.h.html#LN92"><span class='Ref_to_Member'>takenDuringRecovery</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1572"></a>        <span class='Keyword'>int</span>        <span class='Operator'>*</span><span class='Declare_Local'>pgprocnos</span> <span class='Operator'>= </span><a href="procarray.c.html#LN1509"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN94"><span class='Ref_to_Member'>pgprocnos</span></a><span class='Delimiter'>; 
</span><a name="LN1573"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>numProcs</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Spin over procArray checking xid, xmin, and subxids.  The goal is 
         * to gather all active xids, find the lowest xmin, and try to record 
         * subxids. 
         */ 
</span>        <a href="procarray.c.html#LN1573"><span class='Ref_To_Local'>numProcs</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1509"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN67"><span class='Ref_to_Member'>numProcs</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN1513"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN1513"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN1573"><span class='Ref_To_Local'>numProcs</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN1513"><span class='Ref_To_Local'>index</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1583"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>pgprocno</span> <span class='Operator'>= </span><a href="procarray.c.html#LN1572"><span class='Ref_To_Local'>pgprocnos</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN1513"><span class='Ref_To_Local'>index</span></a><span class='Delimiter'>]; 
</span><a name="LN1584"></a>            <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN206"><span class='Ref_to_Struct'>PGXACT</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pgxact</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN100"><span class='Ref_to_Global_Var'>allPgXact</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN1583"><span class='Ref_To_Local'>pgprocno</span></a><span class='Delimiter'>]; 
</span><a name="LN1585"></a>            <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>xid</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Backend is doing logical decoding which manages xmin 
             * separately, check below. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN1584"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN217"><span class='Ref_to_Member'>vacuumFlags</span></a> <span class='Operator'>& </span><a href="../../../include/storage/proc.h.html#LN55"><span class='Ref_to_Const'>PROC_IN_LOGICAL_DECODING</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Ignore procs running LAZY VACUUM */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN1584"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN217"><span class='Ref_to_Member'>vacuumFlags</span></a> <span class='Operator'>& </span><a href="../../../include/storage/proc.h.html#LN52"><span class='Ref_to_Const'>PROC_IN_VACUUM</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Update globalxmin to be the smallest valid xmin */ 
</span>            <a href="procarray.c.html#LN1585"><span class='Ref_To_Local'>xid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1584"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN212"><span class='Ref_to_Member'>xmin</span></a><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* fetch just once */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1585"><span class='Ref_To_Local'>xid</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                <a href="../../../include/access/transam.h.html#LN61"><span class='Ref_to_Macro'>NormalTransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1585"><span class='Ref_To_Local'>xid</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN1512"><span class='Ref_To_Local'>globalxmin</span></a><span class='Parentheses'>))</span> 
                <a href="procarray.c.html#LN1512"><span class='Ref_To_Local'>globalxmin</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1585"><span class='Ref_To_Local'>xid</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Fetch xid just once - see GetNewTransactionId */ 
</span>            <a href="procarray.c.html#LN1585"><span class='Ref_To_Local'>xid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1584"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN208"><span class='Ref_to_Member'>xid</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * If the transaction has no XID assigned, we can skip it; it 
             * won't have sub-XIDs either.  If the XID is &GT;= xmax, we can also 
             * skip it; such transactions will be treated as running anyway 
             * (and any sub-XIDs will also be &GT;= xmax). 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1585"><span class='Ref_To_Local'>xid</span></a><span class='Parentheses'>) 
</span>                <span class='Operator'>|| !</span><a href="../../../include/access/transam.h.html#LN61"><span class='Ref_to_Macro'>NormalTransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1585"><span class='Ref_To_Local'>xid</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN1511"><span class='Ref_To_Local'>xmax</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * We don't include our own XIDs (if any) in the snapshot, but we 
             * must include them in xmin. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN61"><span class='Ref_to_Macro'>NormalTransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1585"><span class='Ref_To_Local'>xid</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN1510"><span class='Ref_To_Local'>xmin</span></a><span class='Parentheses'>))</span> 
                <a href="procarray.c.html#LN1510"><span class='Ref_To_Local'>xmin</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1585"><span class='Ref_To_Local'>xid</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN1584"><span class='Ref_To_Local'>pgxact</span></a> <span class='Operator'>== </span><a href="../lmgr/proc.c.html#LN67"><span class='Ref_to_Global_Var'>MyPgXact</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Add XID to snapshot. */ 
</span>            <a href="procarray.c.html#LN1507"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/snapshot.h.html#LN76"><span class='Ref_to_Member'>xip</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN1514"><span class='Ref_To_Local'>count</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="procarray.c.html#LN1585"><span class='Ref_To_Local'>xid</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Save subtransaction XIDs if possible (if we've already 
             * overflowed, there's no point).  Note that the subxact XIDs must 
             * be later than their parent, so no need to check them against 
             * xmin.  We could filter against xmax, but it seems better not to 
             * do that much work while holding the ProcArrayLock. 
             * 
             * The other backend can add more subxids concurrently, but cannot 
             * remove any.  Hence it's important to fetch nxids just once. 
             * Should be safe to use memcpy, though.  (We needn't worry about 
             * missing any xids added concurrently, because they must postdate 
             * xmax.) 
             * 
             * Again, our own XIDs are not included in the snapshot. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="procarray.c.html#LN1516"><span class='Ref_To_Local'>suboverflowed</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN1584"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN218"><span class='Ref_to_Member'>overflowed</span></a><span class='Parentheses'>) 
</span>                    <a href="procarray.c.html#LN1516"><span class='Ref_To_Local'>suboverflowed</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Control'>else</span> 
                <span class='Delimiter'>{ 
</span><a name="LN1650"></a>                    <span class='Keyword'>int</span>         <span class='Declare_Local'>nxids</span> <span class='Operator'>= </span><a href="procarray.c.html#LN1584"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN222"><span class='Ref_to_Member'>nxids</span></a><span class='Delimiter'>; 
</span> 
                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN1650"><span class='Ref_To_Local'>nxids</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span><a name="LN1654"></a>                        <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Declare_Local'>proc</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN99"><span class='Ref_to_Global_Var'>allProcs</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN1583"><span class='Ref_To_Local'>pgprocno</span></a><span class='Delimiter'>]; 
</span> 
                        memcpy<span class='Parentheses'>(</span><a href="procarray.c.html#LN1507"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/snapshot.h.html#LN88"><span class='Ref_to_Member'>subxip</span></a> <span class='Operator'>+ </span><a href="procarray.c.html#LN1515"><span class='Ref_To_Local'>subcount</span></a><span class='Delimiter'>, 
</span>                               <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="procarray.c.html#LN1654"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN157"><span class='Ref_to_Member'>subxids</span></a><span class='Operator'>.</span><a href="../../../include/storage/proc.h.html#LN38"><span class='Ref_to_Member'>xids</span></a><span class='Delimiter'>, 
</span>                               <a href="procarray.c.html#LN1650"><span class='Ref_To_Local'>nxids</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                        <a href="procarray.c.html#LN1515"><span class='Ref_To_Local'>subcount</span></a> <span class='Operator'>+= </span><a href="procarray.c.html#LN1650"><span class='Ref_To_Local'>nxids</span></a><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for index=0;index&LT;numProc... &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !snapshot-&GT;takenDurin... &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We're in hot standby, so get XIDs from KnownAssignedXids. 
         * 
         * We store all xids directly into subxip[]. Here's why: 
         * 
         * In recovery we don't know which xids are top-level and which are 
         * subxacts, a design choice that greatly simplifies xid processing. 
         * 
         * It seems like we would want to try to put xids into xip[] only, but 
         * that is fairly small. We would either need to make that bigger or 
         * to increase the rate at which we WAL-log xid assignment; neither is 
         * an appealing choice. 
         * 
         * We could try to store xids into xip[] first and then into subxip[] 
         * if there are too many xids. That only works if the snapshot doesn't 
         * overflow because we do not search subxip[] in that case. A simpler 
         * way is to just store all xids in the subxact array because this is 
         * by far the bigger array. We just leave the xip array empty. 
         * 
         * Either way we need to change the way XidInMVCCSnapshot() works 
         * depending upon when the snapshot was taken, or change normal 
         * snapshot processing so it matches. 
         * 
         * Note: It is possible for recovery to end before we finish taking 
         * the snapshot, and for newly assigned transaction ids to be added to 
         * the ProcArray.  xmax cannot change while we hold ProcArrayLock, so 
         * those newly added transaction ids would be filtered away, so we 
         * need not be concerned about them. 
         */ 
</span>        <a href="procarray.c.html#LN1515"><span class='Ref_To_Local'>subcount</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN164"><span class='Ref_to_Proto'>KnownAssignedXidsGetAndSetXmin</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1507"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/snapshot.h.html#LN88"><span class='Ref_to_Member'>subxip</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="procarray.c.html#LN1510"><span class='Ref_To_Local'>xmin</span></a><span class='Delimiter'>, 
</span>                                                  <a href="procarray.c.html#LN1511"><span class='Ref_To_Local'>xmax</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN169"><span class='Ref_to_Proto'>TransactionIdPrecedesOrEquals</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1510"><span class='Ref_To_Local'>xmin</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN86"><span class='Ref_to_Member'>lastOverflowedXid</span></a><span class='Parentheses'>))</span> 
            <a href="procarray.c.html#LN1516"><span class='Ref_To_Local'>suboverflowed</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
 
    <span class='Comment_Multi_Line'>/* fetch into volatile var while ProcArrayLock is held */ 
</span>    <a href="procarray.c.html#LN1517"><span class='Ref_To_Local'>replication_slot_xmin</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN89"><span class='Ref_to_Member'>replication_slot_xmin</span></a><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN1518"><span class='Ref_To_Local'>replication_slot_catalog_xmin</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN91"><span class='Ref_to_Member'>replication_slot_catalog_xmin</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="../lmgr/proc.c.html#LN67"><span class='Ref_to_Global_Var'>MyPgXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN212"><span class='Ref_to_Member'>xmin</span></a><span class='Parentheses'>))</span> 
        <a href="../lmgr/proc.c.html#LN67"><span class='Ref_to_Global_Var'>MyPgXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN212"><span class='Ref_to_Member'>xmin</span></a> <span class='Operator'>= </span><a href="../../utils/time/snapmgr.c.html#LN163"><span class='Ref_to_Global_Var'>TransactionXmin</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1510"><span class='Ref_To_Local'>xmin</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Update globalxmin to include actual process xids.  This is a slightly 
     * different way of computing it than GetOldestXmin uses, but should give 
     * the same result. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1510"><span class='Ref_To_Local'>xmin</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN1512"><span class='Ref_To_Local'>globalxmin</span></a><span class='Parentheses'>))</span> 
        <a href="procarray.c.html#LN1512"><span class='Ref_To_Local'>globalxmin</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1510"><span class='Ref_To_Local'>xmin</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Update global variables too */ 
</span>    <a href="../../utils/time/snapmgr.c.html#LN165"><span class='Ref_to_Global_Var'>RecentGlobalXmin</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1512"><span class='Ref_To_Local'>globalxmin</span></a> <span class='Operator'>- </span><a href="standby.c.html#LN36"><span class='Ref_to_Global_Var'>vacuum_defer_cleanup_age</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="../../utils/time/snapmgr.c.html#LN165"><span class='Ref_to_Global_Var'>RecentGlobalXmin</span></a><span class='Parentheses'>))</span> 
        <a href="../../utils/time/snapmgr.c.html#LN165"><span class='Ref_to_Global_Var'>RecentGlobalXmin</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN33"><span class='Ref_to_Const'>FirstNormalTransactionId</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Check whether there's a replication slot requiring an older xmin. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1517"><span class='Ref_To_Local'>replication_slot_xmin</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>        <a href="../../../include/access/transam.h.html#LN61"><span class='Ref_to_Macro'>NormalTransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1517"><span class='Ref_To_Local'>replication_slot_xmin</span></a><span class='Delimiter'>, </span><a href="../../utils/time/snapmgr.c.html#LN165"><span class='Ref_to_Global_Var'>RecentGlobalXmin</span></a><span class='Parentheses'>))</span> 
        <a href="../../utils/time/snapmgr.c.html#LN165"><span class='Ref_to_Global_Var'>RecentGlobalXmin</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1517"><span class='Ref_To_Local'>replication_slot_xmin</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Non-catalog tables can be vacuumed if older than this xid */ 
</span>    <a href="../../utils/time/snapmgr.c.html#LN166"><span class='Ref_to_Global_Var'>RecentGlobalDataXmin</span></a> <span class='Operator'>= </span><a href="../../utils/time/snapmgr.c.html#LN165"><span class='Ref_to_Global_Var'>RecentGlobalXmin</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Check whether there's a replication slot requiring an older catalog 
     * xmin. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1518"><span class='Ref_To_Local'>replication_slot_catalog_xmin</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>        <a href="../../../include/access/transam.h.html#LN61"><span class='Ref_to_Macro'>NormalTransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1518"><span class='Ref_To_Local'>replication_slot_catalog_xmin</span></a><span class='Delimiter'>, </span><a href="../../utils/time/snapmgr.c.html#LN165"><span class='Ref_to_Global_Var'>RecentGlobalXmin</span></a><span class='Parentheses'>))</span> 
        <a href="../../utils/time/snapmgr.c.html#LN165"><span class='Ref_to_Global_Var'>RecentGlobalXmin</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1518"><span class='Ref_To_Local'>replication_slot_catalog_xmin</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../utils/time/snapmgr.c.html#LN164"><span class='Ref_to_Global_Var'>RecentXmin</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1510"><span class='Ref_To_Local'>xmin</span></a><span class='Delimiter'>; 
</span> 
    <a href="procarray.c.html#LN1507"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/snapshot.h.html#LN65"><span class='Ref_to_Member'>xmin</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1510"><span class='Ref_To_Local'>xmin</span></a><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN1507"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/snapshot.h.html#LN66"><span class='Ref_to_Member'>xmax</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1511"><span class='Ref_To_Local'>xmax</span></a><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN1507"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/snapshot.h.html#LN77"><span class='Ref_to_Member'>xcnt</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1514"><span class='Ref_To_Local'>count</span></a><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN1507"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/snapshot.h.html#LN89"><span class='Ref_to_Member'>subxcnt</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1515"><span class='Ref_To_Local'>subcount</span></a><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN1507"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/snapshot.h.html#LN90"><span class='Ref_to_Member'>suboverflowed</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1516"><span class='Ref_To_Local'>suboverflowed</span></a><span class='Delimiter'>; 
</span> 
    <a href="procarray.c.html#LN1507"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/snapshot.h.html#LN95"><span class='Ref_to_Member'>curcid</span></a> <span class='Operator'>= </span><a href="../../../include/access/xact.h.html#LN339"><span class='Ref_to_Proto'>GetCurrentCommandId</span></a><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * This is a new snapshot, so set both refcounts are zero, and mark it as 
     * not copied in persistent memory. 
     */ 
</span>    <a href="procarray.c.html#LN1507"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/snapshot.h.html#LN106"><span class='Ref_to_Member'>active_count</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN1507"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/snapshot.h.html#LN107"><span class='Ref_to_Member'>regd_count</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN1507"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/snapshot.h.html#LN93"><span class='Ref_to_Member'>copied</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../utils/time/snapmgr.c.html#LN73"><span class='Ref_to_Global_Var'>old_snapshot_threshold</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * If not using "snapshot too old" feature, fill related fields with 
         * dummy values that don't require any locking. 
         */ 
</span>        <a href="procarray.c.html#LN1507"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/snapshot.h.html#LN111"><span class='Ref_to_Member'>lsn</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span>        <a href="procarray.c.html#LN1507"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/snapshot.h.html#LN110"><span class='Ref_to_Member'>whenTaken</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Capture the current time and WAL stream location in case this 
         * snapshot becomes old enough to need to fall back on the special 
         * "old snapshot" logic. 
         */ 
</span>        <a href="procarray.c.html#LN1507"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/snapshot.h.html#LN111"><span class='Ref_to_Member'>lsn</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog.h.html#LN248"><span class='Ref_to_Proto'>GetXLogInsertRecPtr</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <a href="procarray.c.html#LN1507"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/snapshot.h.html#LN110"><span class='Ref_to_Member'>whenTaken</span></a> <span class='Operator'>= </span><a href="../../../include/utils/snapmgr.h.html#LN53"><span class='Ref_to_Proto'>GetSnapshotCurrentTimestamp</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <a href="../../../include/utils/snapmgr.h.html#LN95"><span class='Ref_to_Proto'>MaintainOldSnapshotTimeMapping</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1507"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/snapshot.h.html#LN110"><span class='Ref_to_Member'>whenTaken</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN1510"><span class='Ref_To_Local'>xmin</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="procarray.c.html#LN1507"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end GetSnapshotData &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * ProcArrayInstallImportedXmin -- install imported xmin into MyPgXact-&GT;xmin 
 * 
 * This is called when installing a snapshot imported from another 
 * transaction.  To ensure that OldestXmin doesn't go backwards, we must 
 * check that the source transaction is still running, and we'd better do 
 * that atomically with installing the new xmin. 
 * 
 * Returns TRUE if successful, FALSE if source xact is no longer running. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN1795"></a><span class='Declare_Function'>ProcArrayInstallImportedXmin</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xmin</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>sourcexid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1797"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>result</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN1798"></a>    <a href="procarray.c.html#LN65"><span class='Ref_to_Struct'>ProcArrayStruct</span></a> <span class='Operator'>*</span><span class='Declare_Local'>arrayP</span> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Delimiter'>; 
</span><a name="LN1799"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>index</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1795"><span class='Ref_to_Parameter'>xmin</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1795"><span class='Ref_to_Parameter'>sourcexid</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Get lock so source xact can't end while we're doing this */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN1799"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN1799"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN1798"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN67"><span class='Ref_to_Member'>numProcs</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN1799"><span class='Ref_To_Local'>index</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1810"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>pgprocno</span> <span class='Operator'>= </span><a href="procarray.c.html#LN1798"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN94"><span class='Ref_to_Member'>pgprocnos</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN1799"><span class='Ref_To_Local'>index</span></a><span class='Delimiter'>]; 
</span><a name="LN1811"></a>        <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Declare_Local'>proc</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN99"><span class='Ref_to_Global_Var'>allProcs</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN1810"><span class='Ref_To_Local'>pgprocno</span></a><span class='Delimiter'>]; 
</span><a name="LN1812"></a>        <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN206"><span class='Ref_to_Struct'>PGXACT</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pgxact</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN100"><span class='Ref_to_Global_Var'>allPgXact</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN1810"><span class='Ref_To_Local'>pgprocno</span></a><span class='Delimiter'>]; 
</span><a name="LN1813"></a>        <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>xid</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Ignore procs running LAZY VACUUM */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN1812"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN217"><span class='Ref_to_Member'>vacuumFlags</span></a> <span class='Operator'>& </span><a href="../../../include/storage/proc.h.html#LN52"><span class='Ref_to_Const'>PROC_IN_VACUUM</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <a href="procarray.c.html#LN1813"><span class='Ref_To_Local'>xid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1812"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN208"><span class='Ref_to_Member'>xid</span></a><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* fetch just once */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN1813"><span class='Ref_To_Local'>xid</span></a> <span class='Operator'>!= </span><a href="procarray.c.html#LN1795"><span class='Ref_to_Parameter'>sourcexid</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We check the transaction's database ID for paranoia's sake: if it's 
         * in another DB then its xmin does not cover us.  Caller should have 
         * detected this already, so we just treat any funny cases as 
         * "transaction not found". 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN1811"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN112"><span class='Ref_to_Member'>databaseId</span></a> <span class='Operator'>!= </span><a href="../../utils/init/globals.c.html#LN76"><span class='Ref_to_Global_Var'>MyDatabaseId</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Likewise, let's just make real sure its xmin does cover us. 
         */ 
</span>        <a href="procarray.c.html#LN1813"><span class='Ref_To_Local'>xid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1812"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN212"><span class='Ref_to_Member'>xmin</span></a><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* fetch just once */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1813"><span class='Ref_To_Local'>xid</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>            <span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN169"><span class='Ref_to_Proto'>TransactionIdPrecedesOrEquals</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1813"><span class='Ref_To_Local'>xid</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN1795"><span class='Ref_to_Parameter'>xmin</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We're good.  Install the new xmin.  As in GetSnapshotData, set 
         * TransactionXmin too.  (Note that because snapmgr.c called 
         * GetSnapshotData first, we'll be overwriting a valid xmin here, so 
         * we don't check that.) 
         */ 
</span>        <a href="../lmgr/proc.c.html#LN67"><span class='Ref_to_Global_Var'>MyPgXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN212"><span class='Ref_to_Member'>xmin</span></a> <span class='Operator'>= </span><a href="../../utils/time/snapmgr.c.html#LN163"><span class='Ref_to_Global_Var'>TransactionXmin</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1795"><span class='Ref_to_Parameter'>xmin</span></a><span class='Delimiter'>; 
</span> 
        <a href="procarray.c.html#LN1797"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for index=0;index&LT;arrayP-... &raquo; </span> 
 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="procarray.c.html#LN1797"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ProcArrayInstallImportedXmin &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * ProcArrayInstallRestoredXmin -- install restored xmin into MyPgXact-&GT;xmin 
 * 
 * This is like ProcArrayInstallImportedXmin, but we have a pointer to the 
 * PGPROC of the transaction from which we imported the snapshot, rather than 
 * an XID. 
 * 
 * Returns TRUE if successful, FALSE if source xact is no longer running. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN1867"></a><span class='Declare_Function'>ProcArrayInstallRestoredXmin</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xmin</span><span class='Delimiter'>, </span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>proc</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1869"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>result</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN1870"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>xid</span><span class='Delimiter'>; 
</span><a name="LN1871"></a>    <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN206"><span class='Ref_to_Struct'>PGXACT</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pgxact</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1867"><span class='Ref_to_Parameter'>xmin</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="procarray.c.html#LN1867"><span class='Ref_to_Parameter'>proc</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Get lock so source xact can't end while we're doing this */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="procarray.c.html#LN1871"><span class='Ref_To_Local'>pgxact</span></a> <span class='Operator'>= &</span><a href="procarray.c.html#LN100"><span class='Ref_to_Global_Var'>allPgXact</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN1867"><span class='Ref_to_Parameter'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN108"><span class='Ref_to_Member'>pgprocno</span></a><span class='Delimiter'>]; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Be certain that the referenced PGPROC has an advertised xmin which is 
     * no later than the one we're installing, so that the system-wide xmin 
     * can't go backwards.  Also, make sure it's running in the same database, 
     * so that the per-database xmin cannot go backwards. 
     */ 
</span>    <a href="procarray.c.html#LN1870"><span class='Ref_To_Local'>xid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1871"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN212"><span class='Ref_to_Member'>xmin</span></a><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* fetch just once */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN1867"><span class='Ref_to_Parameter'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN112"><span class='Ref_to_Member'>databaseId</span></a> <span class='Operator'>== </span><a href="../../utils/init/globals.c.html#LN76"><span class='Ref_to_Global_Var'>MyDatabaseId</span></a> <span class='Operator'>&& 
</span>        <a href="../../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1870"><span class='Ref_To_Local'>xid</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>        <a href="../../../include/access/transam.h.html#LN169"><span class='Ref_to_Proto'>TransactionIdPrecedesOrEquals</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1870"><span class='Ref_To_Local'>xid</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN1867"><span class='Ref_to_Parameter'>xmin</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../lmgr/proc.c.html#LN67"><span class='Ref_to_Global_Var'>MyPgXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN212"><span class='Ref_to_Member'>xmin</span></a> <span class='Operator'>= </span><a href="../../utils/time/snapmgr.c.html#LN163"><span class='Ref_to_Global_Var'>TransactionXmin</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1867"><span class='Ref_to_Parameter'>xmin</span></a><span class='Delimiter'>; 
</span>        <a href="procarray.c.html#LN1869"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="procarray.c.html#LN1869"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ProcArrayInstallRestoredXmin &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * GetRunningTransactionData -- returns information about running transactions. 
 * 
 * Similar to GetSnapshotData but returns more information. We include 
 * all PGXACTs with an assigned TransactionId, even VACUUM processes. 
 * 
 * We acquire XidGenLock and ProcArrayLock, but the caller is responsible for 
 * releasing them. Acquiring XidGenLock ensures that no new XIDs enter the proc 
 * array until the caller has WAL-logged this snapshot, and releases the 
 * lock. Acquiring ProcArrayLock ensures that no transactions commit until the 
 * lock is released. 
 * 
 * The returned data structure is statically allocated; caller should not 
 * modify it, and must not assume it is valid past the next call. 
 * 
 * This is never executed during recovery so there is no need to look at 
 * KnownAssignedXids. 
 * 
 * We don't worry about updating other counters, we want to keep this as 
 * simple as possible and leave GetSnapshotData() as the primary code for 
 * that bookkeeping. 
 * 
 * Note that if any transaction has overflowed its cached subtransactions 
 * then there is no real need include any subtransactions. That isn't a 
 * common enough case to worry about optimising the size of the WAL record, 
 * and we may wish to see that data for diagnostic purposes anyway. 
 */ 
</span><a href="../../../include/storage/standby.h.html#LN81"><span class='Ref_to_Typedef'>RunningTransactions</span></a> 
<a name="LN1929"></a><span class='Declare_Function'>GetRunningTransactionData</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* result workspace */ 
</span><a name="LN1932"></a>    <span class='Keyword'>static </span><a href="../../../include/storage/standby.h.html#LN69"><span class='Ref_to_Struct'>RunningTransactionsData</span></a> <span class='Declare_Local'>CurrentRunningXactsData</span><span class='Delimiter'>; 
</span> 
<a name="LN1934"></a>    <a href="procarray.c.html#LN65"><span class='Ref_to_Struct'>ProcArrayStruct</span></a> <span class='Operator'>*</span><span class='Declare_Local'>arrayP</span> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Delimiter'>; 
</span><a name="LN1935"></a>    <a href="../../../include/storage/standby.h.html#LN81"><span class='Ref_to_Typedef'>RunningTransactions</span></a> <span class='Declare_Local'>CurrentRunningXacts</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN1932"><span class='Ref_To_Local'>CurrentRunningXactsData</span></a><span class='Delimiter'>; 
</span><a name="LN1936"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>latestCompletedXid</span><span class='Delimiter'>; 
</span><a name="LN1937"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>oldestRunningXid</span><span class='Delimiter'>; 
</span><a name="LN1938"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Operator'>*</span><span class='Declare_Local'>xids</span><span class='Delimiter'>; 
</span><a name="LN1939"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>index</span><span class='Delimiter'>; 
</span><a name="LN1940"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>count</span><span class='Delimiter'>; 
</span><a name="LN1941"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>subcount</span><span class='Delimiter'>; 
</span><a name="LN1942"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>suboverflowed</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/xlog.h.html#LN242"><span class='Ref_to_Proto'>RecoveryInProgress</span></a><span class='Parentheses'>())</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Allocating space for maxProcs xids is usually overkill; numProcs would 
     * be sufficient.  But it seems better to do the malloc while not holding 
     * the lock, so we can't look at numProcs.  Likewise, we allocate much 
     * more subxip storage than is probably needed. 
     * 
     * Should only be allocated in bgwriter, since only ever executed during 
     * checkpoints. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN1935"><span class='Ref_To_Local'>CurrentRunningXacts</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/standby.h.html#LN78"><span class='Ref_to_Member'>xids</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * First call 
         */ 
</span>        <a href="procarray.c.html#LN1935"><span class='Ref_To_Local'>CurrentRunningXacts</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/standby.h.html#LN78"><span class='Ref_to_Member'>xids</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../../include/snowball/header.h.html#LN49"><span class='Ref_to_Macro'>malloc</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN201"><span class='Ref_to_Const'>TOTAL_MAX_CACHED_SUBXIDS</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN1935"><span class='Ref_To_Local'>CurrentRunningXacts</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/standby.h.html#LN78"><span class='Ref_to_Member'>xids</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OUT_OF_MEMORY<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"out of memory"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="procarray.c.html#LN1938"><span class='Ref_To_Local'>xids</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1935"><span class='Ref_To_Local'>CurrentRunningXacts</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/standby.h.html#LN78"><span class='Ref_to_Member'>xids</span></a><span class='Delimiter'>; 
</span> 
    <a href="procarray.c.html#LN1940"><span class='Ref_To_Local'>count</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1941"><span class='Ref_To_Local'>subcount</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN1942"><span class='Ref_To_Local'>suboverflowed</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Ensure that no xids enter or leave the procarray while we obtain 
     * snapshot. 
     */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>XidGenLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="procarray.c.html#LN1936"><span class='Ref_To_Local'>latestCompletedXid</span></a> <span class='Operator'>= </span><a href="../../access/transam/varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN134"><span class='Ref_to_Member'>latestCompletedXid</span></a><span class='Delimiter'>; 
</span> 
    <a href="procarray.c.html#LN1937"><span class='Ref_To_Local'>oldestRunningXid</span></a> <span class='Operator'>= </span><a href="../../access/transam/varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN116"><span class='Ref_to_Member'>nextXid</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Spin over procArray collecting all xids 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN1939"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN1939"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN1934"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN67"><span class='Ref_to_Member'>numProcs</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN1939"><span class='Ref_To_Local'>index</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1989"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>pgprocno</span> <span class='Operator'>= </span><a href="procarray.c.html#LN1934"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN94"><span class='Ref_to_Member'>pgprocnos</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN1939"><span class='Ref_To_Local'>index</span></a><span class='Delimiter'>]; 
</span><a name="LN1990"></a>        <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN206"><span class='Ref_to_Struct'>PGXACT</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pgxact</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN100"><span class='Ref_to_Global_Var'>allPgXact</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN1989"><span class='Ref_To_Local'>pgprocno</span></a><span class='Delimiter'>]; 
</span><a name="LN1991"></a>        <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>xid</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Fetch xid just once - see GetNewTransactionId */ 
</span>        <a href="procarray.c.html#LN1991"><span class='Ref_To_Local'>xid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1990"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN208"><span class='Ref_to_Member'>xid</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We don't need to store transactions that don't have a TransactionId 
         * yet because they will not show as running on a standby server. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1991"><span class='Ref_To_Local'>xid</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <a href="procarray.c.html#LN1938"><span class='Ref_To_Local'>xids</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN1940"><span class='Ref_To_Local'>count</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="procarray.c.html#LN1991"><span class='Ref_To_Local'>xid</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1991"><span class='Ref_To_Local'>xid</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN1937"><span class='Ref_To_Local'>oldestRunningXid</span></a><span class='Parentheses'>))</span> 
            <a href="procarray.c.html#LN1937"><span class='Ref_To_Local'>oldestRunningXid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1991"><span class='Ref_To_Local'>xid</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN1990"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN218"><span class='Ref_to_Member'>overflowed</span></a><span class='Parentheses'>) 
</span>            <a href="procarray.c.html#LN1942"><span class='Ref_To_Local'>suboverflowed</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for index=0;index&LT;arrayP-... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Spin over procArray collecting all subxids, but only if there hasn't 
     * been a suboverflow. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="procarray.c.html#LN1942"><span class='Ref_To_Local'>suboverflowed</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN1939"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN1939"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN1934"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN67"><span class='Ref_to_Member'>numProcs</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN1939"><span class='Ref_To_Local'>index</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN2020"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>pgprocno</span> <span class='Operator'>= </span><a href="procarray.c.html#LN1934"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN94"><span class='Ref_to_Member'>pgprocnos</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN1939"><span class='Ref_To_Local'>index</span></a><span class='Delimiter'>]; 
</span><a name="LN2021"></a>            <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Declare_Local'>proc</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN99"><span class='Ref_to_Global_Var'>allProcs</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2020"><span class='Ref_To_Local'>pgprocno</span></a><span class='Delimiter'>]; 
</span><a name="LN2022"></a>            <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN206"><span class='Ref_to_Struct'>PGXACT</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pgxact</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN100"><span class='Ref_to_Global_Var'>allPgXact</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2020"><span class='Ref_To_Local'>pgprocno</span></a><span class='Delimiter'>]; 
</span><a name="LN2023"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>nxids</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Save subtransaction XIDs. Other backends can't add or remove 
             * entries while we're holding XidGenLock. 
             */ 
</span>            <a href="procarray.c.html#LN2023"><span class='Ref_To_Local'>nxids</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN2022"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN222"><span class='Ref_to_Member'>nxids</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2023"><span class='Ref_To_Local'>nxids</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                memcpy<span class='Parentheses'>(</span><span class='Operator'>&</span><a href="procarray.c.html#LN1938"><span class='Ref_To_Local'>xids</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN1940"><span class='Ref_To_Local'>count</span></a><span class='Delimiter'>], </span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="procarray.c.html#LN2021"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN157"><span class='Ref_to_Member'>subxids</span></a><span class='Operator'>.</span><a href="../../../include/storage/proc.h.html#LN38"><span class='Ref_to_Member'>xids</span></a><span class='Delimiter'>, 
</span>                       <a href="procarray.c.html#LN2023"><span class='Ref_To_Local'>nxids</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <a href="procarray.c.html#LN1940"><span class='Ref_To_Local'>count</span></a> <span class='Operator'>+= </span><a href="procarray.c.html#LN2023"><span class='Ref_To_Local'>nxids</span></a><span class='Delimiter'>; 
</span>                <a href="procarray.c.html#LN1941"><span class='Ref_To_Local'>subcount</span></a> <span class='Operator'>+= </span><a href="procarray.c.html#LN2023"><span class='Ref_To_Local'>nxids</span></a><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Top-level XID of a transaction is always less than any of 
                 * its subxids, so we don't need to check if any of the 
                 * subxids are smaller than oldestRunningXid 
                 */ 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for index=0;index&LT;arrayP-... &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !suboverflowed &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * It's important *not* to include the limits set by slots here because 
     * snapbuild.c uses oldestRunningXid to manage its xmin horizon. If those 
     * were to be included here the initial value could never increase because 
     * of a circular dependency where slots only increase their limits when 
     * running xacts increases oldestRunningXid and running xacts only 
     * increases if slots do. 
     */ 
</span> 
    <a href="procarray.c.html#LN1935"><span class='Ref_To_Local'>CurrentRunningXacts</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/standby.h.html#LN71"><span class='Ref_to_Member'>xcnt</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1940"><span class='Ref_To_Local'>count</span></a> <span class='Operator'>- </span><a href="procarray.c.html#LN1941"><span class='Ref_To_Local'>subcount</span></a><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN1935"><span class='Ref_To_Local'>CurrentRunningXacts</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/standby.h.html#LN72"><span class='Ref_to_Member'>subxcnt</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1941"><span class='Ref_To_Local'>subcount</span></a><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN1935"><span class='Ref_To_Local'>CurrentRunningXacts</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/standby.h.html#LN73"><span class='Ref_to_Member'>subxid_overflow</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1942"><span class='Ref_To_Local'>suboverflowed</span></a><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN1935"><span class='Ref_To_Local'>CurrentRunningXacts</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/standby.h.html#LN74"><span class='Ref_to_Member'>nextXid</span></a> <span class='Operator'>= </span><a href="../../access/transam/varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN116"><span class='Ref_to_Member'>nextXid</span></a><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN1935"><span class='Ref_To_Local'>CurrentRunningXacts</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/standby.h.html#LN75"><span class='Ref_to_Member'>oldestRunningXid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1937"><span class='Ref_To_Local'>oldestRunningXid</span></a><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN1935"><span class='Ref_To_Local'>CurrentRunningXacts</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/standby.h.html#LN76"><span class='Ref_to_Member'>latestCompletedXid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN1936"><span class='Ref_To_Local'>latestCompletedXid</span></a><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1935"><span class='Ref_To_Local'>CurrentRunningXacts</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/standby.h.html#LN74"><span class='Ref_to_Member'>nextXid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1935"><span class='Ref_To_Local'>CurrentRunningXacts</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/standby.h.html#LN75"><span class='Ref_to_Member'>oldestRunningXid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN1935"><span class='Ref_To_Local'>CurrentRunningXacts</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/standby.h.html#LN76"><span class='Ref_to_Member'>latestCompletedXid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* We don't release the locks here, the caller is responsible for that */ 
</span> 
    <span class='Control'>return</span> <a href="procarray.c.html#LN1935"><span class='Ref_To_Local'>CurrentRunningXacts</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end GetRunningTransactionData &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * GetOldestActiveTransactionId() 
 * 
 * Similar to GetSnapshotData but returns just oldestActiveXid. We include 
 * all PGXACTs with an assigned TransactionId, even VACUUM processes. 
 * We look at all databases, though there is no need to include WALSender 
 * since this has no effect on hot standby conflicts. 
 * 
 * This is never executed during recovery so there is no need to look at 
 * KnownAssignedXids. 
 * 
 * We don't worry about updating other counters, we want to keep this as 
 * simple as possible and leave GetSnapshotData() as the primary code for 
 * that bookkeeping. 
 */ 
</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> 
<a name="LN2087"></a><span class='Declare_Function'>GetOldestActiveTransactionId</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2089"></a>    <a href="procarray.c.html#LN65"><span class='Ref_to_Struct'>ProcArrayStruct</span></a> <span class='Operator'>*</span><span class='Declare_Local'>arrayP</span> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Delimiter'>; 
</span><a name="LN2090"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>oldestRunningXid</span><span class='Delimiter'>; 
</span><a name="LN2091"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>index</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/xlog.h.html#LN242"><span class='Ref_to_Proto'>RecoveryInProgress</span></a><span class='Parentheses'>())</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * It's okay to read nextXid without acquiring XidGenLock because (1) we 
     * assume TransactionIds can be read atomically and (2) we don't care if 
     * we get a slightly stale value.  It can't be very stale anyway, because 
     * the LWLockAcquire above will have done any necessary memory 
     * interlocking. 
     */ 
</span>    <a href="procarray.c.html#LN2090"><span class='Ref_To_Local'>oldestRunningXid</span></a> <span class='Operator'>= </span><a href="../../access/transam/varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN116"><span class='Ref_to_Member'>nextXid</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Spin over procArray collecting all xids and subxids. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2091"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN2091"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN2089"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN67"><span class='Ref_to_Member'>numProcs</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN2091"><span class='Ref_To_Local'>index</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2111"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>pgprocno</span> <span class='Operator'>= </span><a href="procarray.c.html#LN2089"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN94"><span class='Ref_to_Member'>pgprocnos</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2091"><span class='Ref_To_Local'>index</span></a><span class='Delimiter'>]; 
</span><a name="LN2112"></a>        <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN206"><span class='Ref_to_Struct'>PGXACT</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pgxact</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN100"><span class='Ref_to_Global_Var'>allPgXact</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2111"><span class='Ref_To_Local'>pgprocno</span></a><span class='Delimiter'>]; 
</span><a name="LN2113"></a>        <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>xid</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Fetch xid just once - see GetNewTransactionId */ 
</span>        <a href="procarray.c.html#LN2113"><span class='Ref_To_Local'>xid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN2112"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN208"><span class='Ref_to_Member'>xid</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN2113"><span class='Ref_To_Local'>xid</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN2113"><span class='Ref_To_Local'>xid</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN2090"><span class='Ref_To_Local'>oldestRunningXid</span></a><span class='Parentheses'>))</span> 
            <a href="procarray.c.html#LN2090"><span class='Ref_To_Local'>oldestRunningXid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN2113"><span class='Ref_To_Local'>xid</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Top-level XID of a transaction is always less than any of its 
         * subxids, so we don't need to check if any of the subxids are 
         * smaller than oldestRunningXid 
         */ 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for index=0;index&LT;arrayP-... &raquo; </span> 
 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="procarray.c.html#LN2090"><span class='Ref_To_Local'>oldestRunningXid</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end GetOldestActiveTransactionId &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * GetOldestSafeDecodingTransactionId -- lowest xid not affected by vacuum 
 * 
 * Returns the oldest xid that we can guarantee not to have been affected by 
 * vacuum, i.e. no rows &GT;= that xid have been vacuumed away unless the 
 * transaction aborted. Note that the value can (and most of the time will) be 
 * much more conservative than what really has been affected by vacuum, but we 
 * currently don't have better data available. 
 * 
 * This is useful to initialize the cutoff xid after which a new changeset 
 * extraction replication slot can start decoding changes. 
 * 
 * Must be called with ProcArrayLock held either shared or exclusively, 
 * although most callers will want to use exclusive mode since it is expected 
 * that the caller will immediately use the xid to peg the xmin horizon. 
 */ 
</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> 
<a name="LN2153"></a><span class='Declare_Function'>GetOldestSafeDecodingTransactionId</span><span class='Parentheses'>(</span><span class='Keyword'>bool </span><span class='Declare_Parameter'>catalogOnly</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2155"></a>    <a href="procarray.c.html#LN65"><span class='Ref_to_Struct'>ProcArrayStruct</span></a> <span class='Operator'>*</span><span class='Declare_Local'>arrayP</span> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Delimiter'>; 
</span><a name="LN2156"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>oldestSafeXid</span><span class='Delimiter'>; 
</span><a name="LN2157"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>index</span><span class='Delimiter'>; 
</span><a name="LN2158"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>recovery_in_progress</span> <span class='Operator'>= </span><a href="../../../include/access/xlog.h.html#LN242"><span class='Ref_to_Proto'>RecoveryInProgress</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN151"><span class='Ref_to_Proto'>LWLockHeldByMe</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Acquire XidGenLock, so no transactions can acquire an xid while we're 
     * running. If no transaction with xid were running concurrently a new xid 
     * could influence the RecentXmin et al. 
     * 
     * We initialize the computation to nextXid since that's guaranteed to be 
     * a safe, albeit pessimal, value. 
     */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>XidGenLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN2156"><span class='Ref_To_Local'>oldestSafeXid</span></a> <span class='Operator'>= </span><a href="../../access/transam/varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN116"><span class='Ref_to_Member'>nextXid</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If there's already a slot pegging the xmin horizon, we can start with 
     * that value, it's guaranteed to be safe since it's computed by this 
     * routine initially and has been enforced since.  We can always use the 
     * slot's general xmin horizon, but the catalog horizon is only usable 
     * when we only catalog data is going to be looked at. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN89"><span class='Ref_to_Member'>replication_slot_xmin</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>        <a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN89"><span class='Ref_to_Member'>replication_slot_xmin</span></a><span class='Delimiter'>, 
</span>                              <a href="procarray.c.html#LN2156"><span class='Ref_To_Local'>oldestSafeXid</span></a><span class='Parentheses'>))</span> 
        <a href="procarray.c.html#LN2156"><span class='Ref_To_Local'>oldestSafeXid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN89"><span class='Ref_to_Member'>replication_slot_xmin</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2153"><span class='Ref_to_Parameter'>catalogOnly</span></a> <span class='Operator'>&& 
</span>        <a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN91"><span class='Ref_to_Member'>replication_slot_catalog_xmin</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>        <a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN91"><span class='Ref_to_Member'>replication_slot_catalog_xmin</span></a><span class='Delimiter'>, 
</span>                              <a href="procarray.c.html#LN2156"><span class='Ref_To_Local'>oldestSafeXid</span></a><span class='Parentheses'>))</span> 
        <a href="procarray.c.html#LN2156"><span class='Ref_To_Local'>oldestSafeXid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN91"><span class='Ref_to_Member'>replication_slot_catalog_xmin</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we're not in recovery, we walk over the procarray and collect the 
     * lowest xid. Since we're called with ProcArrayLock held and have 
     * acquired XidGenLock, no entries can vanish concurrently, since 
     * PGXACT-&GT;xid is only set with XidGenLock held and only cleared with 
     * ProcArrayLock held. 
     * 
     * In recovery we can't lower the safe value besides what we've computed 
     * above, so we'll have to wait a bit longer there. We unfortunately can 
     * *not* use KnownAssignedXidsGetOldestXmin() since the KnownAssignedXids 
     * machinery can miss values and return an older value than is safe. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="procarray.c.html#LN2158"><span class='Ref_To_Local'>recovery_in_progress</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Spin over procArray collecting all min(PGXACT-&GT;xid) 
         */ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2157"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN2157"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN2155"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN67"><span class='Ref_to_Member'>numProcs</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN2157"><span class='Ref_To_Local'>index</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN2210"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>pgprocno</span> <span class='Operator'>= </span><a href="procarray.c.html#LN2155"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN94"><span class='Ref_to_Member'>pgprocnos</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2157"><span class='Ref_To_Local'>index</span></a><span class='Delimiter'>]; 
</span><a name="LN2211"></a>            <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN206"><span class='Ref_to_Struct'>PGXACT</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pgxact</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN100"><span class='Ref_to_Global_Var'>allPgXact</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2210"><span class='Ref_To_Local'>pgprocno</span></a><span class='Delimiter'>]; 
</span><a name="LN2212"></a>            <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>xid</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Fetch xid just once - see GetNewTransactionId */ 
</span>            <a href="procarray.c.html#LN2212"><span class='Ref_To_Local'>xid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN2211"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN208"><span class='Ref_to_Member'>xid</span></a><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN2212"><span class='Ref_To_Local'>xid</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN2212"><span class='Ref_To_Local'>xid</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN2156"><span class='Ref_To_Local'>oldestSafeXid</span></a><span class='Parentheses'>))</span> 
                <a href="procarray.c.html#LN2156"><span class='Ref_To_Local'>oldestSafeXid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN2212"><span class='Ref_To_Local'>xid</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !recovery_in_progress &raquo; </span> 
 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>XidGenLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="procarray.c.html#LN2156"><span class='Ref_To_Local'>oldestSafeXid</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end GetOldestSafeDecodingTransactionId &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * GetVirtualXIDsDelayingChkpt -- Get the VXIDs of transactions that are 
 * delaying checkpoint because they have critical actions in progress. 
 * 
 * Constructs an array of VXIDs of transactions that are currently in commit 
 * critical sections, as shown by having delayChkpt set in their PGXACT. 
 * 
 * Returns a palloc'd array that should be freed by the caller. 
 * *nvxids is the number of valid entries. 
 * 
 * Note that because backends set or clear delayChkpt without holding any lock, 
 * the result is somewhat indeterminate, but we don't really care.  Even in 
 * a multiprocessor with delayed writes to shared memory, it should be certain 
 * that setting of delayChkpt will propagate to shared memory when the backend 
 * takes a lock, so we cannot fail to see a virtual xact as delayChkpt if 
 * it's already inserted its commit record.  Whether it takes a little while 
 * for clearing of delayChkpt to propagate is unimportant for correctness. 
 */ 
</span><a href="../../../include/storage/lock.h.html#LN62"><span class='Ref_to_Typedef'>VirtualTransactionId</span></a> <span class='Operator'>* 
</span><a name="LN2249"></a><span class='Declare_Function'>GetVirtualXIDsDelayingChkpt</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Operator'>*</span><span class='Declare_Parameter'>nvxids</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2251"></a>    <a href="../../../include/storage/lock.h.html#LN62"><span class='Ref_to_Typedef'>VirtualTransactionId</span></a> <span class='Operator'>*</span><span class='Declare_Local'>vxids</span><span class='Delimiter'>; 
</span><a name="LN2252"></a>    <a href="procarray.c.html#LN65"><span class='Ref_to_Struct'>ProcArrayStruct</span></a> <span class='Operator'>*</span><span class='Declare_Local'>arrayP</span> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Delimiter'>; 
</span><a name="LN2253"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>count</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN2254"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>index</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* allocate what's certainly enough result space */ 
</span>    <a href="procarray.c.html#LN2251"><span class='Ref_To_Local'>vxids</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/lock.h.html#LN62"><span class='Ref_to_Typedef'>VirtualTransactionId</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>        <a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/lock.h.html#LN62"><span class='Ref_to_Typedef'>VirtualTransactionId</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="procarray.c.html#LN2252"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN68"><span class='Ref_to_Member'>maxProcs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2254"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN2254"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN2252"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN67"><span class='Ref_to_Member'>numProcs</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN2254"><span class='Ref_To_Local'>index</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2264"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>pgprocno</span> <span class='Operator'>= </span><a href="procarray.c.html#LN2252"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN94"><span class='Ref_to_Member'>pgprocnos</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2254"><span class='Ref_To_Local'>index</span></a><span class='Delimiter'>]; 
</span><a name="LN2265"></a>        <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Declare_Local'>proc</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN99"><span class='Ref_to_Global_Var'>allProcs</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2264"><span class='Ref_To_Local'>pgprocno</span></a><span class='Delimiter'>]; 
</span><a name="LN2266"></a>        <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN206"><span class='Ref_to_Struct'>PGXACT</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pgxact</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN100"><span class='Ref_to_Global_Var'>allPgXact</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2264"><span class='Ref_To_Local'>pgprocno</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2266"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN219"><span class='Ref_to_Member'>delayChkpt</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN2270"></a>            <a href="../../../include/storage/lock.h.html#LN62"><span class='Ref_to_Typedef'>VirtualTransactionId</span></a> <span class='Declare_Local'>vxid</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/storage/lock.h.html#LN80"><span class='Ref_to_Macro'>GET_VXID_FROM_PGPROC</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN2270"><span class='Ref_To_Local'>vxid</span></a><span class='Delimiter'>, </span><span class='Operator'>*</span><a href="procarray.c.html#LN2265"><span class='Ref_To_Local'>proc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/lock.h.html#LN71"><span class='Ref_to_Macro'>VirtualTransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN2270"><span class='Ref_To_Local'>vxid</span></a><span class='Parentheses'>))</span> 
                <a href="procarray.c.html#LN2251"><span class='Ref_To_Local'>vxids</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2253"><span class='Ref_To_Local'>count</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="procarray.c.html#LN2270"><span class='Ref_To_Local'>vxid</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Operator'>*</span><a href="procarray.c.html#LN2249"><span class='Ref_to_Parameter'>nvxids</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN2253"><span class='Ref_To_Local'>count</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="procarray.c.html#LN2251"><span class='Ref_To_Local'>vxids</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end GetVirtualXIDsDelayingChkpt &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * HaveVirtualXIDsDelayingChkpt -- Are any of the specified VXIDs delaying? 
 * 
 * This is used with the results of GetVirtualXIDsDelayingChkpt to see if any 
 * of the specified VXIDs are still in critical sections of code. 
 * 
 * Note: this is O(N^2) in the number of vxacts that are/were delaying, but 
 * those numbers should be small enough for it not to be a problem. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN2294"></a><span class='Declare_Function'>HaveVirtualXIDsDelayingChkpt</span><span class='Parentheses'>(</span><a href="../../../include/storage/lock.h.html#LN62"><span class='Ref_to_Typedef'>VirtualTransactionId</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vxids</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>nvxids</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2296"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>result</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN2297"></a>    <a href="procarray.c.html#LN65"><span class='Ref_to_Struct'>ProcArrayStruct</span></a> <span class='Operator'>*</span><span class='Declare_Local'>arrayP</span> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Delimiter'>; 
</span><a name="LN2298"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>index</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2298"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN2298"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN2297"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN67"><span class='Ref_to_Member'>numProcs</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN2298"><span class='Ref_To_Local'>index</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2304"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>pgprocno</span> <span class='Operator'>= </span><a href="procarray.c.html#LN2297"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN94"><span class='Ref_to_Member'>pgprocnos</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2298"><span class='Ref_To_Local'>index</span></a><span class='Delimiter'>]; 
</span><a name="LN2305"></a>        <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Declare_Local'>proc</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN99"><span class='Ref_to_Global_Var'>allProcs</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2304"><span class='Ref_To_Local'>pgprocno</span></a><span class='Delimiter'>]; 
</span><a name="LN2306"></a>        <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN206"><span class='Ref_to_Struct'>PGXACT</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pgxact</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN100"><span class='Ref_to_Global_Var'>allPgXact</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2304"><span class='Ref_To_Local'>pgprocno</span></a><span class='Delimiter'>]; 
</span><a name="LN2307"></a>        <a href="../../../include/storage/lock.h.html#LN62"><span class='Ref_to_Typedef'>VirtualTransactionId</span></a> <span class='Declare_Local'>vxid</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/storage/lock.h.html#LN80"><span class='Ref_to_Macro'>GET_VXID_FROM_PGPROC</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN2307"><span class='Ref_To_Local'>vxid</span></a><span class='Delimiter'>, </span><span class='Operator'>*</span><a href="procarray.c.html#LN2305"><span class='Ref_To_Local'>proc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2306"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN219"><span class='Ref_to_Member'>delayChkpt</span></a> <span class='Operator'>&& </span><a href="../../../include/storage/lock.h.html#LN71"><span class='Ref_to_Macro'>VirtualTransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN2307"><span class='Ref_To_Local'>vxid</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN2313"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2313"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN2313"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN2294"><span class='Ref_to_Parameter'>nvxids</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN2313"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/lock.h.html#LN74"><span class='Ref_to_Macro'>VirtualTransactionIdEquals</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN2307"><span class='Ref_To_Local'>vxid</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN2294"><span class='Ref_to_Parameter'>vxids</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2313"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <a href="procarray.c.html#LN2296"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2296"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for index=0;index&LT;arrayP-... &raquo; </span> 
 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="procarray.c.html#LN2296"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end HaveVirtualXIDsDelayingChkpt &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * BackendPidGetProc -- get a backend's PGPROC given its PID 
 * 
 * Returns NULL if not found.  Note that it is up to the caller to be 
 * sure that the question remains meaningful for long enough for the 
 * answer to be used ... 
 */ 
</span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>* 
</span><a name="LN2341"></a><span class='Declare_Function'>BackendPidGetProc</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>pid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2343"></a>    <a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2341"><span class='Ref_to_Parameter'>pid</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span>               <span class='Comment_Single_Line'>/* never match dummy PGPROCs */ 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="procarray.c.html#LN2343"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../../include/storage/procarray.h.html#LN99"><span class='Ref_to_Proto'>BackendPidGetProcWithLock</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN2341"><span class='Ref_to_Parameter'>pid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="procarray.c.html#LN2343"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * BackendPidGetProcWithLock -- get a backend's PGPROC given its PID 
 * 
 * Same as above, except caller must be holding ProcArrayLock.  The found 
 * entry, if any, can be assumed to be valid as long as the lock remains held. 
 */ 
</span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>* 
</span><a name="LN2364"></a><span class='Declare_Function'>BackendPidGetProcWithLock</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>pid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2366"></a>    <a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>result</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN2367"></a>    <a href="procarray.c.html#LN65"><span class='Ref_to_Struct'>ProcArrayStruct</span></a> <span class='Operator'>*</span><span class='Declare_Local'>arrayP</span> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Delimiter'>; 
</span><a name="LN2368"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>index</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2364"><span class='Ref_to_Parameter'>pid</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span>               <span class='Comment_Single_Line'>/* never match dummy PGPROCs */ 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2368"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN2368"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN2367"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN67"><span class='Ref_to_Member'>numProcs</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN2368"><span class='Ref_To_Local'>index</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2375"></a>        <a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>proc</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN99"><span class='Ref_to_Global_Var'>allProcs</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2367"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN94"><span class='Ref_to_Member'>pgprocnos</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2368"><span class='Ref_To_Local'>index</span></a><span class='Delimiter'>]]; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2375"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN107"><span class='Ref_to_Member'>pid</span></a> <span class='Operator'>== </span><a href="procarray.c.html#LN2364"><span class='Ref_to_Parameter'>pid</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="procarray.c.html#LN2366"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN2375"><span class='Ref_To_Local'>proc</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="procarray.c.html#LN2366"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end BackendPidGetProcWithLock &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * BackendXidGetPid -- get a backend's pid given its XID 
 * 
 * Returns 0 if not found or it's a prepared transaction.  Note that 
 * it is up to the caller to be sure that the question remains 
 * meaningful for long enough for the answer to be used ... 
 * 
 * Only main transaction Ids are considered.  This function is mainly 
 * useful for determining what backend owns a lock. 
 * 
 * Beware that not every xact has an XID assigned.  However, as long as you 
 * only call this using an XID found on disk, you're safe. 
 */ 
</span><span class='Keyword'>int 
</span><a name="LN2401"></a><span class='Declare_Function'>BackendXidGetPid</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2403"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>result</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN2404"></a>    <a href="procarray.c.html#LN65"><span class='Ref_to_Struct'>ProcArrayStruct</span></a> <span class='Operator'>*</span><span class='Declare_Local'>arrayP</span> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Delimiter'>; 
</span><a name="LN2405"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>index</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2401"><span class='Ref_to_Parameter'>xid</span></a> <span class='Operator'>== </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Parentheses'>)</span>    <span class='Comment_Single_Line'>/* never match invalid xid */ 
</span>        <span class='Control'>return</span> <span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2405"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN2405"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN2404"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN67"><span class='Ref_to_Member'>numProcs</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN2405"><span class='Ref_To_Local'>index</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2414"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>pgprocno</span> <span class='Operator'>= </span><a href="procarray.c.html#LN2404"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN94"><span class='Ref_to_Member'>pgprocnos</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2405"><span class='Ref_To_Local'>index</span></a><span class='Delimiter'>]; 
</span><a name="LN2415"></a>        <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Declare_Local'>proc</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN99"><span class='Ref_to_Global_Var'>allProcs</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2414"><span class='Ref_To_Local'>pgprocno</span></a><span class='Delimiter'>]; 
</span><a name="LN2416"></a>        <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN206"><span class='Ref_to_Struct'>PGXACT</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pgxact</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN100"><span class='Ref_to_Global_Var'>allPgXact</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2414"><span class='Ref_To_Local'>pgprocno</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2416"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN208"><span class='Ref_to_Member'>xid</span></a> <span class='Operator'>== </span><a href="procarray.c.html#LN2401"><span class='Ref_to_Parameter'>xid</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="procarray.c.html#LN2403"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN2415"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN107"><span class='Ref_to_Member'>pid</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="procarray.c.html#LN2403"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end BackendXidGetPid &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * IsBackendPid -- is a given pid a running backend 
 * 
 * This is not called by the backend, but is called by external modules. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN2436"></a><span class='Declare_Function'>IsBackendPid</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>pid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/storage/procarray.h.html#LN98"><span class='Ref_to_Proto'>BackendPidGetProc</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN2436"><span class='Ref_to_Parameter'>pid</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * GetCurrentVirtualXIDs -- returns an array of currently active VXIDs. 
 * 
 * The array is palloc'd. The number of valid entries is returned into *nvxids. 
 * 
 * The arguments allow filtering the set of VXIDs returned.  Our own process 
 * is always skipped.  In addition: 
 *  If limitXmin is not InvalidTransactionId, skip processes with 
 *      xmin &GT; limitXmin. 
 *  If excludeXmin0 is true, skip processes with xmin = 0. 
 *  If allDbs is false, skip processes attached to other databases. 
 *  If excludeVacuum isn't zero, skip processes for which 
 *      (vacuumFlags & excludeVacuum) is not zero. 
 * 
 * Note: the purpose of the limitXmin and excludeXmin0 parameters is to 
 * allow skipping backends whose oldest live snapshot is no older than 
 * some snapshot we have.  Since we examine the procarray with only shared 
 * lock, there are race conditions: a backend could set its xmin just after 
 * we look.  Indeed, on multiprocessors with weak memory ordering, the 
 * other backend could have set its xmin *before* we look.  We know however 
 * that such a backend must have held shared ProcArrayLock overlapping our 
 * own hold of ProcArrayLock, else we would see its xmin update.  Therefore, 
 * any snapshot the other backend is taking concurrently with our scan cannot 
 * consider any transactions as still running that we think are committed 
 * (since backends must hold ProcArrayLock exclusive to commit). 
 */ 
</span><a href="../../../include/storage/lock.h.html#LN62"><span class='Ref_to_Typedef'>VirtualTransactionId</span></a> <span class='Operator'>* 
</span><a name="LN2469"></a><span class='Declare_Function'>GetCurrentVirtualXIDs</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>limitXmin</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>excludeXmin0</span><span class='Delimiter'>, 
</span><a name="LN2470"></a>                      <span class='Keyword'>bool </span><span class='Declare_Parameter'>allDbs</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>excludeVacuum</span><span class='Delimiter'>, 
</span><a name="LN2471"></a>                      <span class='Keyword'>int </span><span class='Operator'>*</span><span class='Declare_Parameter'>nvxids</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2473"></a>    <a href="../../../include/storage/lock.h.html#LN62"><span class='Ref_to_Typedef'>VirtualTransactionId</span></a> <span class='Operator'>*</span><span class='Declare_Local'>vxids</span><span class='Delimiter'>; 
</span><a name="LN2474"></a>    <a href="procarray.c.html#LN65"><span class='Ref_to_Struct'>ProcArrayStruct</span></a> <span class='Operator'>*</span><span class='Declare_Local'>arrayP</span> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Delimiter'>; 
</span><a name="LN2475"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>count</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN2476"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>index</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* allocate what's certainly enough result space */ 
</span>    <a href="procarray.c.html#LN2473"><span class='Ref_To_Local'>vxids</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/lock.h.html#LN62"><span class='Ref_to_Typedef'>VirtualTransactionId</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>        <a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/lock.h.html#LN62"><span class='Ref_to_Typedef'>VirtualTransactionId</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="procarray.c.html#LN2474"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN68"><span class='Ref_to_Member'>maxProcs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2476"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN2476"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN2474"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN67"><span class='Ref_to_Member'>numProcs</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN2476"><span class='Ref_To_Local'>index</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2486"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>pgprocno</span> <span class='Operator'>= </span><a href="procarray.c.html#LN2474"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN94"><span class='Ref_to_Member'>pgprocnos</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2476"><span class='Ref_To_Local'>index</span></a><span class='Delimiter'>]; 
</span><a name="LN2487"></a>        <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Declare_Local'>proc</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN99"><span class='Ref_to_Global_Var'>allProcs</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2486"><span class='Ref_To_Local'>pgprocno</span></a><span class='Delimiter'>]; 
</span><a name="LN2488"></a>        <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN206"><span class='Ref_to_Struct'>PGXACT</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pgxact</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN100"><span class='Ref_to_Global_Var'>allPgXact</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2486"><span class='Ref_To_Local'>pgprocno</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2487"><span class='Ref_To_Local'>proc</span></a> <span class='Operator'>== </span><a href="../lmgr/proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2470"><span class='Ref_to_Parameter'>excludeVacuum</span></a> <span class='Operator'>& </span><a href="procarray.c.html#LN2488"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN217"><span class='Ref_to_Member'>vacuumFlags</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2470"><span class='Ref_to_Parameter'>allDbs</span></a> <span class='Operator'>|| </span><a href="procarray.c.html#LN2487"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN112"><span class='Ref_to_Member'>databaseId</span></a> <span class='Operator'>== </span><a href="../../utils/init/globals.c.html#LN76"><span class='Ref_to_Global_Var'>MyDatabaseId</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Fetch xmin just once - might change on us */ 
</span><a name="LN2499"></a>            <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>pxmin</span> <span class='Operator'>= </span><a href="procarray.c.html#LN2488"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN212"><span class='Ref_to_Member'>xmin</span></a><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2469"><span class='Ref_to_Parameter'>excludeXmin0</span></a> <span class='Operator'>&& !</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN2499"><span class='Ref_To_Local'>pxmin</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * InvalidTransactionId precedes all other XIDs, so a proc that 
             * hasn't set xmin yet will not be rejected by this test. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN2469"><span class='Ref_to_Parameter'>limitXmin</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>                <a href="../../../include/access/transam.h.html#LN169"><span class='Ref_to_Proto'>TransactionIdPrecedesOrEquals</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN2499"><span class='Ref_To_Local'>pxmin</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN2469"><span class='Ref_to_Parameter'>limitXmin</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span><a name="LN2511"></a>                <a href="../../../include/storage/lock.h.html#LN62"><span class='Ref_to_Typedef'>VirtualTransactionId</span></a> <span class='Declare_Local'>vxid</span><span class='Delimiter'>; 
</span> 
                <a href="../../../include/storage/lock.h.html#LN80"><span class='Ref_to_Macro'>GET_VXID_FROM_PGPROC</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN2511"><span class='Ref_To_Local'>vxid</span></a><span class='Delimiter'>, </span><span class='Operator'>*</span><a href="procarray.c.html#LN2487"><span class='Ref_To_Local'>proc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/lock.h.html#LN71"><span class='Ref_to_Macro'>VirtualTransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN2511"><span class='Ref_To_Local'>vxid</span></a><span class='Parentheses'>))</span> 
                    <a href="procarray.c.html#LN2473"><span class='Ref_To_Local'>vxids</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2475"><span class='Ref_To_Local'>count</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="procarray.c.html#LN2511"><span class='Ref_To_Local'>vxid</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if allDbs||proc-&GT;databas... &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for index=0;index&LT;arrayP-... &raquo; </span> 
 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Operator'>*</span><a href="procarray.c.html#LN2471"><span class='Ref_to_Parameter'>nvxids</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN2475"><span class='Ref_To_Local'>count</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="procarray.c.html#LN2473"><span class='Ref_To_Local'>vxids</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end GetCurrentVirtualXIDs &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * GetConflictingVirtualXIDs -- returns an array of currently active VXIDs. 
 * 
 * Usage is limited to conflict resolution during recovery on standby servers. 
 * limitXmin is supplied as either latestRemovedXid, or InvalidTransactionId 
 * in cases where we cannot accurately determine a value for latestRemovedXid. 
 * 
 * If limitXmin is InvalidTransactionId then we want to kill everybody, 
 * so we're not worried if they have a snapshot or not, nor does it really 
 * matter what type of lock we hold. 
 * 
 * All callers that are checking xmins always now supply a valid and useful 
 * value for limitXmin. The limitXmin is always lower than the lowest 
 * numbered KnownAssignedXid that is not already a FATAL error. This is 
 * because we only care about cleanup records that are cleaning up tuple 
 * versions from committed transactions. In that case they will only occur 
 * at the point where the record is less than the lowest running xid. That 
 * allows us to say that if any backend takes a snapshot concurrently with 
 * us then the conflict assessment made here would never include the snapshot 
 * that is being derived. So we take LW_SHARED on the ProcArray and allow 
 * concurrent snapshots when limitXmin is valid. We might think about adding 
 *   Assert(limitXmin &LT; lowest(KnownAssignedXids)) 
 * but that would not be true in the case of FATAL errors lagging in array, 
 * but we already know those are bogus anyway, so we skip that test. 
 * 
 * If dbOid is valid we skip backends attached to other databases. 
 * 
 * Be careful to *not* pfree the result from this function. We reuse 
 * this array sufficiently often that we use malloc for the result. 
 */ 
</span><a href="../../../include/storage/lock.h.html#LN62"><span class='Ref_to_Typedef'>VirtualTransactionId</span></a> <span class='Operator'>* 
</span><a name="LN2557"></a><span class='Declare_Function'>GetConflictingVirtualXIDs</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>limitXmin</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>dbOid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2559"></a>    <span class='Keyword'>static </span><a href="../../../include/storage/lock.h.html#LN62"><span class='Ref_to_Typedef'>VirtualTransactionId</span></a> <span class='Operator'>*</span><span class='Declare_Local'>vxids</span><span class='Delimiter'>; 
</span><a name="LN2560"></a>    <a href="procarray.c.html#LN65"><span class='Ref_to_Struct'>ProcArrayStruct</span></a> <span class='Operator'>*</span><span class='Declare_Local'>arrayP</span> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Delimiter'>; 
</span><a name="LN2561"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>count</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN2562"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>index</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If first time through, get workspace to remember main XIDs in. We 
     * malloc it permanently to avoid repeated palloc/pfree overhead. Allow 
     * result space, remembering room for a terminator. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2559"><span class='Ref_To_Local'>vxids</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="procarray.c.html#LN2559"><span class='Ref_To_Local'>vxids</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/lock.h.html#LN62"><span class='Ref_to_Typedef'>VirtualTransactionId</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../../include/snowball/header.h.html#LN49"><span class='Ref_to_Macro'>malloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/lock.h.html#LN62"><span class='Ref_to_Typedef'>VirtualTransactionId</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Parentheses'>(</span><a href="procarray.c.html#LN2560"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN68"><span class='Ref_to_Member'>maxProcs</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2559"><span class='Ref_To_Local'>vxids</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OUT_OF_MEMORY<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"out of memory"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2562"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN2562"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN2560"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN67"><span class='Ref_to_Member'>numProcs</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN2562"><span class='Ref_To_Local'>index</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2583"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>pgprocno</span> <span class='Operator'>= </span><a href="procarray.c.html#LN2560"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN94"><span class='Ref_to_Member'>pgprocnos</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2562"><span class='Ref_To_Local'>index</span></a><span class='Delimiter'>]; 
</span><a name="LN2584"></a>        <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Declare_Local'>proc</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN99"><span class='Ref_to_Global_Var'>allProcs</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2583"><span class='Ref_To_Local'>pgprocno</span></a><span class='Delimiter'>]; 
</span><a name="LN2585"></a>        <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN206"><span class='Ref_to_Struct'>PGXACT</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pgxact</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN100"><span class='Ref_to_Global_Var'>allPgXact</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2583"><span class='Ref_To_Local'>pgprocno</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Comment_Multi_Line'>/* Exclude prepared transactions */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2584"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN107"><span class='Ref_to_Member'>pid</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN2557"><span class='Ref_to_Parameter'>dbOid</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>            <a href="procarray.c.html#LN2584"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN112"><span class='Ref_to_Member'>databaseId</span></a> <span class='Operator'>== </span><a href="procarray.c.html#LN2557"><span class='Ref_to_Parameter'>dbOid</span></a><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Fetch xmin just once - can't change on us, but good coding */ 
</span><a name="LN2595"></a>            <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>pxmin</span> <span class='Operator'>= </span><a href="procarray.c.html#LN2585"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN212"><span class='Ref_to_Member'>xmin</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * We ignore an invalid pxmin because this means that backend has 
             * no snapshot currently. We hold a Share lock to avoid contention 
             * with users taking snapshots.  That is not a problem because the 
             * current xmin is always at least one higher than the latest 
             * removed xid, so any new snapshot would never conflict with the 
             * test here. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN2557"><span class='Ref_to_Parameter'>limitXmin</span></a><span class='Parentheses'>)</span> <span class='Operator'>|| 
</span>                <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN2595"><span class='Ref_To_Local'>pxmin</span></a><span class='Parentheses'>) </span><span class='Operator'>&& !</span><a href="../../../include/access/transam.h.html#LN170"><span class='Ref_to_Proto'>TransactionIdFollows</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN2595"><span class='Ref_To_Local'>pxmin</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN2557"><span class='Ref_to_Parameter'>limitXmin</span></a><span class='Parentheses'>)))</span> 
            <span class='Delimiter'>{ 
</span><a name="LN2608"></a>                <a href="../../../include/storage/lock.h.html#LN62"><span class='Ref_to_Typedef'>VirtualTransactionId</span></a> <span class='Declare_Local'>vxid</span><span class='Delimiter'>; 
</span> 
                <a href="../../../include/storage/lock.h.html#LN80"><span class='Ref_to_Macro'>GET_VXID_FROM_PGPROC</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN2608"><span class='Ref_To_Local'>vxid</span></a><span class='Delimiter'>, </span><span class='Operator'>*</span><a href="procarray.c.html#LN2584"><span class='Ref_To_Local'>proc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/lock.h.html#LN71"><span class='Ref_to_Macro'>VirtualTransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN2608"><span class='Ref_To_Local'>vxid</span></a><span class='Parentheses'>))</span> 
                    <a href="procarray.c.html#LN2559"><span class='Ref_To_Local'>vxids</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2561"><span class='Ref_To_Local'>count</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="procarray.c.html#LN2608"><span class='Ref_To_Local'>vxid</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !OidIsValid(dbOid)||p... &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for index=0;index&LT;arrayP-... &raquo; </span> 
 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* add the terminator */ 
</span>    <a href="procarray.c.html#LN2559"><span class='Ref_To_Local'>vxids</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2561"><span class='Ref_To_Local'>count</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/storage/lock.h.html#LN64"><span class='Ref_to_Member'>backendId</span></a> <span class='Operator'>= </span><a href="../../../include/storage/backendid.h.html#LN22"><span class='Ref_to_Const'>InvalidBackendId</span></a><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN2559"><span class='Ref_To_Local'>vxids</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2561"><span class='Ref_To_Local'>count</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/storage/lock.h.html#LN65"><span class='Ref_to_Member'>localTransactionId</span></a> <span class='Operator'>= </span><a href="../../../include/storage/lock.h.html#LN69"><span class='Ref_to_Const'>InvalidLocalTransactionId</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="procarray.c.html#LN2559"><span class='Ref_To_Local'>vxids</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end GetConflictingVirtualXIDs &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * CancelVirtualTransaction - used in recovery conflict processing 
 * 
 * Returns pid of the process signaled, or 0 if not found. 
 */ 
</span><a href="../../../include/port/win32.h.html#LN255"><span class='Ref_to_Typedef'>pid_t</span></a> 
<a name="LN2632"></a><span class='Declare_Function'>CancelVirtualTransaction</span><span class='Parentheses'>(</span><a href="../../../include/storage/lock.h.html#LN62"><span class='Ref_to_Typedef'>VirtualTransactionId</span></a> <span class='Declare_Parameter'>vxid</span><span class='Delimiter'>, </span><a href="../../../include/storage/procsignal.h.html#LN29"><span class='Ref_to_Typedef'>ProcSignalReason</span></a> <span class='Declare_Parameter'>sigmode</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2634"></a>    <a href="procarray.c.html#LN65"><span class='Ref_to_Struct'>ProcArrayStruct</span></a> <span class='Operator'>*</span><span class='Declare_Local'>arrayP</span> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Delimiter'>; 
</span><a name="LN2635"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>index</span><span class='Delimiter'>; 
</span><a name="LN2636"></a>    <a href="../../../include/port/win32.h.html#LN255"><span class='Ref_to_Typedef'>pid_t</span></a>       <span class='Declare_Local'>pid</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2635"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN2635"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN2634"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN67"><span class='Ref_to_Member'>numProcs</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN2635"><span class='Ref_To_Local'>index</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2642"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>pgprocno</span> <span class='Operator'>= </span><a href="procarray.c.html#LN2634"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN94"><span class='Ref_to_Member'>pgprocnos</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2635"><span class='Ref_To_Local'>index</span></a><span class='Delimiter'>]; 
</span><a name="LN2643"></a>        <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Declare_Local'>proc</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN99"><span class='Ref_to_Global_Var'>allProcs</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2642"><span class='Ref_To_Local'>pgprocno</span></a><span class='Delimiter'>]; 
</span><a name="LN2644"></a>        <a href="../../../include/storage/lock.h.html#LN62"><span class='Ref_to_Typedef'>VirtualTransactionId</span></a> <span class='Declare_Local'>procvxid</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/storage/lock.h.html#LN80"><span class='Ref_to_Macro'>GET_VXID_FROM_PGPROC</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN2644"><span class='Ref_To_Local'>procvxid</span></a><span class='Delimiter'>, </span><span class='Operator'>*</span><a href="procarray.c.html#LN2643"><span class='Ref_To_Local'>proc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2644"><span class='Ref_To_Local'>procvxid</span></a><span class='Operator'>.</span><a href="../../../include/storage/lock.h.html#LN64"><span class='Ref_to_Member'>backendId</span></a> <span class='Operator'>== </span><a href="procarray.c.html#LN2632"><span class='Ref_to_Parameter'>vxid</span></a><span class='Operator'>.</span><a href="../../../include/storage/lock.h.html#LN64"><span class='Ref_to_Member'>backendId</span></a> <span class='Operator'>&& 
</span>            <a href="procarray.c.html#LN2644"><span class='Ref_To_Local'>procvxid</span></a><span class='Operator'>.</span><a href="../../../include/storage/lock.h.html#LN65"><span class='Ref_to_Member'>localTransactionId</span></a> <span class='Operator'>== </span><a href="procarray.c.html#LN2632"><span class='Ref_to_Parameter'>vxid</span></a><span class='Operator'>.</span><a href="../../../include/storage/lock.h.html#LN65"><span class='Ref_to_Member'>localTransactionId</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="procarray.c.html#LN2643"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN122"><span class='Ref_to_Member'>recoveryConflictPending</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="procarray.c.html#LN2636"><span class='Ref_To_Local'>pid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN2643"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN107"><span class='Ref_to_Member'>pid</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2636"><span class='Ref_To_Local'>pid</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * Kill the pid if it's still here. If not, that's what we 
                 * wanted so ignore any errors. 
                 */ 
</span>                <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="../../../include/storage/procsignal.h.html#LN55"><span class='Ref_to_Proto'>SendProcSignal</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN2636"><span class='Ref_To_Local'>pid</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN2632"><span class='Ref_to_Parameter'>sigmode</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN2632"><span class='Ref_to_Parameter'>vxid</span></a><span class='Operator'>.</span><a href="../../../include/storage/lock.h.html#LN64"><span class='Ref_to_Member'>backendId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for index=0;index&LT;arrayP-... &raquo; </span> 
 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="procarray.c.html#LN2636"><span class='Ref_To_Local'>pid</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end CancelVirtualTransaction &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * MinimumActiveBackends --- count backends (other than myself) that are 
 *      in active transactions.  Return true if the count exceeds the 
 *      minimum threshold passed.  This is used as a heuristic to decide if 
 *      a pre-XLOG-flush delay is worthwhile during commit. 
 * 
 * Do not count backends that are blocked waiting for locks, since they are 
 * not going to get to run until someone else commits. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN2680"></a><span class='Declare_Function'>MinimumActiveBackends</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>min</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2682"></a>    <a href="procarray.c.html#LN65"><span class='Ref_to_Struct'>ProcArrayStruct</span></a> <span class='Operator'>*</span><span class='Declare_Local'>arrayP</span> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Delimiter'>; 
</span><a name="LN2683"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>count</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN2684"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>index</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Quick short-circuit if no minimum is specified */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2680"><span class='Ref_to_Parameter'>min</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Note: for speed, we don't acquire ProcArrayLock.  This is a little bit 
     * bogus, but since we are only testing fields for zero or nonzero, it 
     * should be OK.  The result is only used for heuristic purposes anyway... 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2684"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN2684"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN2682"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN67"><span class='Ref_to_Member'>numProcs</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN2684"><span class='Ref_To_Local'>index</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2697"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>pgprocno</span> <span class='Operator'>= </span><a href="procarray.c.html#LN2682"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN94"><span class='Ref_to_Member'>pgprocnos</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2684"><span class='Ref_To_Local'>index</span></a><span class='Delimiter'>]; 
</span><a name="LN2698"></a>        <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Declare_Local'>proc</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN99"><span class='Ref_to_Global_Var'>allProcs</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2697"><span class='Ref_To_Local'>pgprocno</span></a><span class='Delimiter'>]; 
</span><a name="LN2699"></a>        <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN206"><span class='Ref_to_Struct'>PGXACT</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pgxact</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN100"><span class='Ref_to_Global_Var'>allPgXact</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2697"><span class='Ref_To_Local'>pgprocno</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Since we're not holding a lock, need to be prepared to deal with 
         * garbage, as someone could have incremented numProcs but not yet 
         * filled the structure. 
         * 
         * If someone just decremented numProcs, 'proc' could also point to a 
         * PGPROC entry that's no longer in the array. It still points to a 
         * PGPROC struct, though, because freed PGPROC entries just go to the 
         * free list and are recycled. Its contents are nonsense in that case, 
         * but that's acceptable for this function. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2697"><span class='Ref_To_Local'>pgprocno</span></a> <span class='Operator'>== -</span><span class='Number'>1</span><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* do not count deleted entries */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2698"><span class='Ref_To_Local'>proc</span></a> <span class='Operator'>== </span><a href="../lmgr/proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* do not count myself */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2699"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN208"><span class='Ref_to_Member'>xid</span></a> <span class='Operator'>== </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* do not count if no XID assigned */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2698"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN107"><span class='Ref_to_Member'>pid</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* do not count prepared xacts */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2698"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN134"><span class='Ref_to_Member'>waitLock</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* do not count if blocked on a lock */ 
</span>        <a href="procarray.c.html#LN2683"><span class='Ref_To_Local'>count</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2683"><span class='Ref_To_Local'>count</span></a> <span class='Operator'>&GT;= </span><a href="procarray.c.html#LN2680"><span class='Ref_to_Parameter'>min</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for index=0;index&LT;arrayP-... &raquo; </span> 
 
    <span class='Control'>return</span> <a href="procarray.c.html#LN2683"><span class='Ref_To_Local'>count</span></a> <span class='Operator'>&GT;= </span><a href="procarray.c.html#LN2680"><span class='Ref_to_Parameter'>min</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end MinimumActiveBackends &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * CountDBBackends --- count backends that are using specified database 
 */ 
</span><span class='Keyword'>int 
</span><a name="LN2734"></a><span class='Declare_Function'>CountDBBackends</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>databaseid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2736"></a>    <a href="procarray.c.html#LN65"><span class='Ref_to_Struct'>ProcArrayStruct</span></a> <span class='Operator'>*</span><span class='Declare_Local'>arrayP</span> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Delimiter'>; 
</span><a name="LN2737"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>count</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN2738"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>index</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2738"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN2738"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN2736"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN67"><span class='Ref_to_Member'>numProcs</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN2738"><span class='Ref_To_Local'>index</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2744"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>pgprocno</span> <span class='Operator'>= </span><a href="procarray.c.html#LN2736"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN94"><span class='Ref_to_Member'>pgprocnos</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2738"><span class='Ref_To_Local'>index</span></a><span class='Delimiter'>]; 
</span><a name="LN2745"></a>        <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Declare_Local'>proc</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN99"><span class='Ref_to_Global_Var'>allProcs</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2744"><span class='Ref_To_Local'>pgprocno</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2745"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN107"><span class='Ref_to_Member'>pid</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* do not count prepared xacts */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN2734"><span class='Ref_to_Parameter'>databaseid</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>            <a href="procarray.c.html#LN2745"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN112"><span class='Ref_to_Member'>databaseId</span></a> <span class='Operator'>== </span><a href="procarray.c.html#LN2734"><span class='Ref_to_Parameter'>databaseid</span></a><span class='Parentheses'>)</span> 
            <a href="procarray.c.html#LN2737"><span class='Ref_To_Local'>count</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="procarray.c.html#LN2737"><span class='Ref_To_Local'>count</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end CountDBBackends &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * CountDBConnections --- counts database backends ignoring any background 
 *      worker processes 
 */ 
</span><span class='Keyword'>int 
</span><a name="LN2764"></a><span class='Declare_Function'>CountDBConnections</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>databaseid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2766"></a>    <a href="procarray.c.html#LN65"><span class='Ref_to_Struct'>ProcArrayStruct</span></a> <span class='Operator'>*</span><span class='Declare_Local'>arrayP</span> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Delimiter'>; 
</span><a name="LN2767"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>count</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN2768"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>index</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2768"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN2768"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN2766"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN67"><span class='Ref_to_Member'>numProcs</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN2768"><span class='Ref_To_Local'>index</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2774"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>pgprocno</span> <span class='Operator'>= </span><a href="procarray.c.html#LN2766"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN94"><span class='Ref_to_Member'>pgprocnos</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2768"><span class='Ref_To_Local'>index</span></a><span class='Delimiter'>]; 
</span><a name="LN2775"></a>        <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Declare_Local'>proc</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN99"><span class='Ref_to_Global_Var'>allProcs</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2774"><span class='Ref_To_Local'>pgprocno</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2775"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN107"><span class='Ref_to_Member'>pid</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* do not count prepared xacts */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2775"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN115"><span class='Ref_to_Member'>isBackgroundWorker</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* do not count background workers */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN2764"><span class='Ref_to_Parameter'>databaseid</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>            <a href="procarray.c.html#LN2775"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN112"><span class='Ref_to_Member'>databaseId</span></a> <span class='Operator'>== </span><a href="procarray.c.html#LN2764"><span class='Ref_to_Parameter'>databaseid</span></a><span class='Parentheses'>)</span> 
            <a href="procarray.c.html#LN2767"><span class='Ref_To_Local'>count</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="procarray.c.html#LN2767"><span class='Ref_To_Local'>count</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end CountDBConnections &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * CancelDBBackends --- cancel backends that are using specified database 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2795"></a><span class='Declare_Function'>CancelDBBackends</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>databaseid</span><span class='Delimiter'>, </span><a href="../../../include/storage/procsignal.h.html#LN29"><span class='Ref_to_Typedef'>ProcSignalReason</span></a> <span class='Declare_Parameter'>sigmode</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>conflictPending</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2797"></a>    <a href="procarray.c.html#LN65"><span class='Ref_to_Struct'>ProcArrayStruct</span></a> <span class='Operator'>*</span><span class='Declare_Local'>arrayP</span> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Delimiter'>; 
</span><a name="LN2798"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>index</span><span class='Delimiter'>; 
</span><a name="LN2799"></a>    <a href="../../../include/port/win32.h.html#LN255"><span class='Ref_to_Typedef'>pid_t</span></a>       <span class='Declare_Local'>pid</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* tell all backends to die */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2798"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN2798"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN2797"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN67"><span class='Ref_to_Member'>numProcs</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN2798"><span class='Ref_To_Local'>index</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2806"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>pgprocno</span> <span class='Operator'>= </span><a href="procarray.c.html#LN2797"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN94"><span class='Ref_to_Member'>pgprocnos</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2798"><span class='Ref_To_Local'>index</span></a><span class='Delimiter'>]; 
</span><a name="LN2807"></a>        <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Declare_Local'>proc</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN99"><span class='Ref_to_Global_Var'>allProcs</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2806"><span class='Ref_To_Local'>pgprocno</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2795"><span class='Ref_to_Parameter'>databaseid</span></a> <span class='Operator'>== </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a> <span class='Operator'>|| </span><a href="procarray.c.html#LN2807"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN112"><span class='Ref_to_Member'>databaseId</span></a> <span class='Operator'>== </span><a href="procarray.c.html#LN2795"><span class='Ref_to_Parameter'>databaseid</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN2811"></a>            <a href="../../../include/storage/lock.h.html#LN62"><span class='Ref_to_Typedef'>VirtualTransactionId</span></a> <span class='Declare_Local'>procvxid</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/storage/lock.h.html#LN80"><span class='Ref_to_Macro'>GET_VXID_FROM_PGPROC</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN2811"><span class='Ref_To_Local'>procvxid</span></a><span class='Delimiter'>, </span><span class='Operator'>*</span><a href="procarray.c.html#LN2807"><span class='Ref_To_Local'>proc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="procarray.c.html#LN2807"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN122"><span class='Ref_to_Member'>recoveryConflictPending</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN2795"><span class='Ref_to_Parameter'>conflictPending</span></a><span class='Delimiter'>; 
</span>            <a href="procarray.c.html#LN2799"><span class='Ref_To_Local'>pid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN2807"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN107"><span class='Ref_to_Member'>pid</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2799"><span class='Ref_To_Local'>pid</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * Kill the pid if it's still here. If not, that's what we 
                 * wanted so ignore any errors. 
                 */ 
</span>                <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="../../../include/storage/procsignal.h.html#LN55"><span class='Ref_to_Proto'>SendProcSignal</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN2799"><span class='Ref_To_Local'>pid</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN2795"><span class='Ref_to_Parameter'>sigmode</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN2811"><span class='Ref_To_Local'>procvxid</span></a><span class='Operator'>.</span><a href="../../../include/storage/lock.h.html#LN64"><span class='Ref_to_Member'>backendId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for index=0;index&LT;arrayP-... &raquo; </span> 
 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end CancelDBBackends &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * CountUserBackends --- count backends that are used by specified user 
 */ 
</span><span class='Keyword'>int 
</span><a name="LN2835"></a><span class='Declare_Function'>CountUserBackends</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>roleid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2837"></a>    <a href="procarray.c.html#LN65"><span class='Ref_to_Struct'>ProcArrayStruct</span></a> <span class='Operator'>*</span><span class='Declare_Local'>arrayP</span> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Delimiter'>; 
</span><a name="LN2838"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>count</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN2839"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>index</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2839"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN2839"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN2837"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN67"><span class='Ref_to_Member'>numProcs</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN2839"><span class='Ref_To_Local'>index</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2845"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>pgprocno</span> <span class='Operator'>= </span><a href="procarray.c.html#LN2837"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN94"><span class='Ref_to_Member'>pgprocnos</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2839"><span class='Ref_To_Local'>index</span></a><span class='Delimiter'>]; 
</span><a name="LN2846"></a>        <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Declare_Local'>proc</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN99"><span class='Ref_to_Global_Var'>allProcs</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2845"><span class='Ref_To_Local'>pgprocno</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2846"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN107"><span class='Ref_to_Member'>pid</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* do not count prepared xacts */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2846"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN115"><span class='Ref_to_Member'>isBackgroundWorker</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* do not count background workers */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2846"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN113"><span class='Ref_to_Member'>roleId</span></a> <span class='Operator'>== </span><a href="procarray.c.html#LN2835"><span class='Ref_to_Parameter'>roleid</span></a><span class='Parentheses'>) 
</span>            <a href="procarray.c.html#LN2838"><span class='Ref_To_Local'>count</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="procarray.c.html#LN2838"><span class='Ref_To_Local'>count</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end CountUserBackends &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * CountOtherDBBackends -- check for other backends running in the given DB 
 * 
 * If there are other backends in the DB, we will wait a maximum of 5 seconds 
 * for them to exit.  Autovacuum backends are encouraged to exit early by 
 * sending them SIGTERM, but normal user backends are just waited for. 
 * 
 * The current backend is always ignored; it is caller's responsibility to 
 * check whether the current backend uses the given DB, if it's important. 
 * 
 * Returns TRUE if there are (still) other backends in the DB, FALSE if not. 
 * Also, *nbackends and *nprepared are set to the number of other backends 
 * and prepared transactions in the DB, respectively. 
 * 
 * This function is used to interlock DROP DATABASE and related commands 
 * against there being any active backends in the target DB --- dropping the 
 * DB while active backends remain would be a Bad Thing.  Note that we cannot 
 * detect here the possibility of a newly-started backend that is trying to 
 * connect to the doomed database, so additional interlocking is needed during 
 * backend startup.  The caller should normally hold an exclusive lock on the 
 * target DB before calling this, which is one reason we mustn't wait 
 * indefinitely. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN2885"></a><span class='Declare_Function'>CountOtherDBBackends</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>databaseId</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Operator'>*</span><span class='Declare_Parameter'>nbackends</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Operator'>*</span><span class='Declare_Parameter'>nprepared</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2887"></a>    <a href="procarray.c.html#LN65"><span class='Ref_to_Struct'>ProcArrayStruct</span></a> <span class='Operator'>*</span><span class='Declare_Local'>arrayP</span> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Delimiter'>; 
</span> 
<a name="LN2889"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>MAXAUTOVACPIDS</span>  <span class='Number'>10</span>      <span class='Comment_Single_Line'>/* max autovacs to SIGTERM per iteration */ 
</span><a name="LN2890"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>autovac_pids</span><span class='Delimiter'>[</span><a href="procarray.c.html#LN2889"><span class='Ref_to_Const'>MAXAUTOVACPIDS</span></a><span class='Delimiter'>]; 
</span><a name="LN2891"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>tries</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 50 tries with 100ms sleep between tries makes 5 sec total wait */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2891"><span class='Ref_To_Local'>tries</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN2891"><span class='Ref_To_Local'>tries</span></a> <span class='Operator'>&LT; </span><span class='Number'>50</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN2891"><span class='Ref_To_Local'>tries</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2896"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>nautovacs</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN2897"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN2898"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>index</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/miscadmin.h.html#LN99"><span class='Ref_to_Macro'>CHECK_FOR_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Operator'>*</span><a href="procarray.c.html#LN2885"><span class='Ref_to_Parameter'>nbackends</span></a> <span class='Operator'>= *</span><a href="procarray.c.html#LN2885"><span class='Ref_to_Parameter'>nprepared</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2898"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN2898"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN2887"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN67"><span class='Ref_to_Member'>numProcs</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN2898"><span class='Ref_To_Local'>index</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN2908"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>pgprocno</span> <span class='Operator'>= </span><a href="procarray.c.html#LN2887"><span class='Ref_To_Local'>arrayP</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN94"><span class='Ref_to_Member'>pgprocnos</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2898"><span class='Ref_To_Local'>index</span></a><span class='Delimiter'>]; 
</span><a name="LN2909"></a>            <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Declare_Local'>proc</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN99"><span class='Ref_to_Global_Var'>allProcs</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2908"><span class='Ref_To_Local'>pgprocno</span></a><span class='Delimiter'>]; 
</span><a name="LN2910"></a>            <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN206"><span class='Ref_to_Struct'>PGXACT</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pgxact</span> <span class='Operator'>= &</span><a href="procarray.c.html#LN100"><span class='Ref_to_Global_Var'>allPgXact</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2908"><span class='Ref_To_Local'>pgprocno</span></a><span class='Delimiter'>]; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2909"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN112"><span class='Ref_to_Member'>databaseId</span></a> <span class='Operator'>!= </span><a href="procarray.c.html#LN2885"><span class='Ref_to_Parameter'>databaseId</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2909"><span class='Ref_To_Local'>proc</span></a> <span class='Operator'>== </span><a href="../lmgr/proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
            <a href="procarray.c.html#LN2897"><span class='Ref_To_Local'>found</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2909"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN107"><span class='Ref_to_Member'>pid</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="procarray.c.html#LN2885"><span class='Ref_to_Parameter'>nprepared</span></a><span class='Parentheses'>)</span><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="procarray.c.html#LN2885"><span class='Ref_to_Parameter'>nbackends</span></a><span class='Parentheses'>)</span><span class='Operator'>++</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="procarray.c.html#LN2910"><span class='Ref_To_Local'>pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN217"><span class='Ref_to_Member'>vacuumFlags</span></a> <span class='Operator'>& </span><a href="../../../include/storage/proc.h.html#LN51"><span class='Ref_to_Const'>PROC_IS_AUTOVACUUM</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                    <a href="procarray.c.html#LN2896"><span class='Ref_To_Local'>nautovacs</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN2889"><span class='Ref_to_Const'>MAXAUTOVACPIDS</span></a><span class='Parentheses'>)</span> 
                    <a href="procarray.c.html#LN2890"><span class='Ref_To_Local'>autovac_pids</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2896"><span class='Ref_To_Local'>nautovacs</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="procarray.c.html#LN2909"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN107"><span class='Ref_to_Member'>pid</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for index=0;index&LT;arrayP-... &raquo; </span> 
 
        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="procarray.c.html#LN2897"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* no conflicting backends, so done */ 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Send SIGTERM to any conflicting autovacuums before sleeping. We 
         * postpone this step until after the loop because we don't want to 
         * hold ProcArrayLock while issuing kill(). We have no idea what might 
         * block kill() inside the kernel... 
         */ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2898"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN2898"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN2896"><span class='Ref_To_Local'>nautovacs</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN2898"><span class='Ref_To_Local'>index</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="../../../include/port.h.html#LN210"><span class='Ref_to_Macro'>kill</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN2890"><span class='Ref_To_Local'>autovac_pids</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2898"><span class='Ref_To_Local'>index</span></a><span class='Delimiter'>], </span>SIGTERM<span class='Parentheses'>)</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* ignore any error */ 
</span> 
        <span class='Comment_Multi_Line'>/* sleep, then try again */ 
</span>        <a href="../../../port/pgsleep.c.html#LN45"><span class='Ref_to_Func'>pg_usleep</span></a><span class='Parentheses'>(</span><span class='Number'>100</span> <span class='Operator'>* </span><span class='Number'>1000L</span><span class='Parentheses'>)</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* 100ms */ 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for tries=0;tries&LT;50;trie... &raquo; </span> 
 
    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>;</span>                <span class='Comment_Single_Line'>/* timed out, still conflicts */ 
</span><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end CountOtherDBBackends &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * ProcArraySetReplicationSlotXmin 
 * 
 * Install limits to future computations of the xmin horizon to prevent vacuum 
 * and HOT pruning from removing affected rows still needed by clients with 
 * replicaton slots. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2959"></a><span class='Declare_Function'>ProcArraySetReplicationSlotXmin</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xmin</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>catalog_xmin</span><span class='Delimiter'>, 
</span><a name="LN2960"></a>                                <span class='Keyword'>bool </span><span class='Declare_Parameter'>already_locked</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="procarray.c.html#LN2960"><span class='Ref_to_Parameter'>already_locked</span></a> <span class='Operator'>|| </span><a href="../../../include/storage/lwlock.h.html#LN151"><span class='Ref_to_Proto'>LWLockHeldByMe</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="procarray.c.html#LN2960"><span class='Ref_to_Parameter'>already_locked</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN89"><span class='Ref_to_Member'>replication_slot_xmin</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN2959"><span class='Ref_to_Parameter'>xmin</span></a><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN91"><span class='Ref_to_Member'>replication_slot_catalog_xmin</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN2959"><span class='Ref_to_Parameter'>catalog_xmin</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="procarray.c.html#LN2960"><span class='Ref_to_Parameter'>already_locked</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * ProcArrayGetReplicationSlotXmin 
 * 
 * Return the current slot xmin limits. That's useful to be able to remove 
 * data that's older than those limits. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2981"></a><span class='Declare_Function'>ProcArrayGetReplicationSlotXmin</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>xmin</span><span class='Delimiter'>, 
</span><a name="LN2982"></a>                                <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>catalog_xmin</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2981"><span class='Ref_to_Parameter'>xmin</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Operator'>*</span><a href="procarray.c.html#LN2981"><span class='Ref_to_Parameter'>xmin</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN89"><span class='Ref_to_Member'>replication_slot_xmin</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN2982"><span class='Ref_to_Parameter'>catalog_xmin</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Operator'>*</span><a href="procarray.c.html#LN2982"><span class='Ref_to_Parameter'>catalog_xmin</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN91"><span class='Ref_to_Member'>replication_slot_catalog_xmin</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
 
<a name="LN2996"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>XidCacheRemove</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>i</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Control'>do</span> <span class='Delimiter'>{ </span><span class='Operator'>\ 
</span>        <a href="../lmgr/proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN157"><span class='Ref_to_Member'>subxids</span></a><span class='Operator'>.</span><a href="../../../include/storage/proc.h.html#LN38"><span class='Ref_to_Member'>xids</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN2996"><span class='Ref_to_Parameter'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../lmgr/proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN157"><span class='Ref_to_Member'>subxids</span></a><span class='Operator'>.</span><a href="../../../include/storage/proc.h.html#LN38"><span class='Ref_to_Member'>xids</span></a><span class='Delimiter'>[</span><a href="../lmgr/proc.c.html#LN67"><span class='Ref_to_Global_Var'>MyPgXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN222"><span class='Ref_to_Member'>nxids</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]; </span><span class='Operator'>\ 
</span>        <a href="../lmgr/proc.c.html#LN67"><span class='Ref_to_Global_Var'>MyPgXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN222"><span class='Ref_to_Member'>nxids</span></a><span class='Operator'>--</span><span class='Delimiter'>; </span><span class='Operator'>\ 
</span>    <span class='Delimiter'>} </span><span class='Control'>while</span> <span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>) 
</span> 
<span class='Comment_Multi_Line'>/* 
 * XidCacheRemoveRunningXids 
 * 
 * Remove a bunch of TransactionIds from the list of known-running 
 * subtransactions for my backend.  Both the specified xid and those in 
 * the xids[] array (of length nxids) are removed from the subxids cache. 
 * latestXid must be the latest XID among the group. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN3011"></a><span class='Declare_Function'>XidCacheRemoveRunningXids</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xid</span><span class='Delimiter'>, 
</span><a name="LN3012"></a>                          <span class='Keyword'>int </span><span class='Declare_Parameter'>nxids</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>xids</span><span class='Delimiter'>, 
</span><a name="LN3013"></a>                          <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>latestXid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3015"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>, 
</span><a name="LN3016"></a>                <span class='Declare_Local'>j</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN3011"><span class='Ref_to_Parameter'>xid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We must hold ProcArrayLock exclusively in order to remove transactions 
     * from the PGPROC array.  (See src/backend/access/transam/README.)  It's 
     * possible this could be relaxed since we know this routine is only used 
     * to abort subtransactions, but pending closer analysis we'd best be 
     * conservative. 
     */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Under normal circumstances xid and xids[] will be in increasing order, 
     * as will be the entries in subxids.  Scan backwards to avoid O(N^2) 
     * behavior when removing a lot of xids. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN3015"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3012"><span class='Ref_to_Parameter'>nxids</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN3015"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN3015"><span class='Ref_To_Local'>i</span></a><span class='Operator'>--</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3036"></a>        <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>anxid</span> <span class='Operator'>= </span><a href="procarray.c.html#LN3012"><span class='Ref_to_Parameter'>xids</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN3015"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN3016"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>= </span><a href="../lmgr/proc.c.html#LN67"><span class='Ref_to_Global_Var'>MyPgXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN222"><span class='Ref_to_Member'>nxids</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN3016"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN3016"><span class='Ref_To_Local'>j</span></a><span class='Operator'>--</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN42"><span class='Ref_to_Macro'>TransactionIdEquals</span></a><span class='Parentheses'>(</span><a href="../lmgr/proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN157"><span class='Ref_to_Member'>subxids</span></a><span class='Operator'>.</span><a href="../../../include/storage/proc.h.html#LN38"><span class='Ref_to_Member'>xids</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN3016"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>], </span><a href="procarray.c.html#LN3036"><span class='Ref_To_Local'>anxid</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="procarray.c.html#LN2996"><span class='Ref_to_Macro'>XidCacheRemove</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN3016"><span class='Ref_To_Local'>j</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Ordinarily we should have found it, unless the cache has 
         * overflowed. However it's also possible for this routine to be 
         * invoked multiple times for the same subtransaction, in case of an 
         * error during AbortSubTransaction.  So instead of Assert, emit a 
         * debug warning. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN3016"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span> <span class='Operator'>&& !</span><a href="../lmgr/proc.c.html#LN67"><span class='Ref_to_Global_Var'>MyPgXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN218"><span class='Ref_to_Member'>overflowed</span></a><span class='Parentheses'>) 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN39"><span class='Ref_to_Const'>WARNING</span></a><span class='Delimiter'>, </span><span class='String'>"did not find subXID %u in MyProc"</span><span class='Delimiter'>, </span><a href="procarray.c.html#LN3036"><span class='Ref_To_Local'>anxid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=nxids-1;i&GT;=0;i-- &raquo; </span> 
 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN3016"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>= </span><a href="../lmgr/proc.c.html#LN67"><span class='Ref_to_Global_Var'>MyPgXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN222"><span class='Ref_to_Member'>nxids</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN3016"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN3016"><span class='Ref_To_Local'>j</span></a><span class='Operator'>--</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN42"><span class='Ref_to_Macro'>TransactionIdEquals</span></a><span class='Parentheses'>(</span><a href="../lmgr/proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN157"><span class='Ref_to_Member'>subxids</span></a><span class='Operator'>.</span><a href="../../../include/storage/proc.h.html#LN38"><span class='Ref_to_Member'>xids</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN3016"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>], </span><a href="procarray.c.html#LN3011"><span class='Ref_to_Parameter'>xid</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="procarray.c.html#LN2996"><span class='Ref_to_Macro'>XidCacheRemove</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN3016"><span class='Ref_To_Local'>j</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <span class='Comment_Multi_Line'>/* Ordinarily we should have found it, unless the cache has overflowed */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN3016"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span> <span class='Operator'>&& !</span><a href="../lmgr/proc.c.html#LN67"><span class='Ref_to_Global_Var'>MyPgXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN218"><span class='Ref_to_Member'>overflowed</span></a><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN39"><span class='Ref_to_Const'>WARNING</span></a><span class='Delimiter'>, </span><span class='String'>"did not find subXID %u in MyProc"</span><span class='Delimiter'>, </span><a href="procarray.c.html#LN3011"><span class='Ref_to_Parameter'>xid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Also advance global latestCompletedXid while holding the lock */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="../../access/transam/varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN134"><span class='Ref_to_Member'>latestCompletedXid</span></a><span class='Delimiter'>, 
</span>                              <a href="procarray.c.html#LN3013"><span class='Ref_to_Parameter'>latestXid</span></a><span class='Parentheses'>))</span> 
        <a href="../../access/transam/varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN134"><span class='Ref_to_Member'>latestCompletedXid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3013"><span class='Ref_to_Parameter'>latestXid</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end XidCacheRemoveRunningXids &raquo; </span> 
 
<span class='Directive'>#ifdef</span> XIDCACHE_DEBUG 
 
<span class='Comment_Multi_Line'>/* 
 * Print stats about effectiveness of XID cache 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3084"></a><span class='Declare_Function'>DisplayXidCache</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../../contrib/seg/segscan.l.html#LN10"><span class='Ref_to_Macro'>fprintf</span></a><span class='Parentheses'>(</span>stderr<span class='Delimiter'>, 
</span>            <span class='String'>"XidCache: xmin: %ld, known: %ld, myxact: %ld, latest: %ld, mainxid: %ld, childxid: %ld, knownassigned: %ld, nooflo: %ld, slow: %ld\n"</span><span class='Delimiter'>, 
</span>            <a href="procarray.c.html#LN119"><span class='Ref_to_Global_Var'>xc_by_recent_xmin</span></a><span class='Delimiter'>, 
</span>            <a href="procarray.c.html#LN120"><span class='Ref_to_Global_Var'>xc_by_known_xact</span></a><span class='Delimiter'>, 
</span>            <a href="procarray.c.html#LN121"><span class='Ref_to_Global_Var'>xc_by_my_xact</span></a><span class='Delimiter'>, 
</span>            <a href="procarray.c.html#LN122"><span class='Ref_to_Global_Var'>xc_by_latest_xid</span></a><span class='Delimiter'>, 
</span>            <a href="procarray.c.html#LN123"><span class='Ref_to_Global_Var'>xc_by_main_xid</span></a><span class='Delimiter'>, 
</span>            <a href="procarray.c.html#LN124"><span class='Ref_to_Global_Var'>xc_by_child_xid</span></a><span class='Delimiter'>, 
</span>            <a href="procarray.c.html#LN125"><span class='Ref_to_Global_Var'>xc_by_known_assigned</span></a><span class='Delimiter'>, 
</span>            <a href="procarray.c.html#LN126"><span class='Ref_to_Global_Var'>xc_no_overflow</span></a><span class='Delimiter'>, 
</span>            <a href="procarray.c.html#LN127"><span class='Ref_to_Global_Var'>xc_slow_answer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span><span class='Directive'>#endif</span>   <span class='Comment_Single_Line'>/* XIDCACHE_DEBUG */ 
</span> 
 
<span class='Comment_Multi_Line'>/* ---------------------------------------------- 
 *      KnownAssignedTransactions sub-module 
 * ---------------------------------------------- 
 */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * In Hot Standby mode, we maintain a list of transactions that are (or were) 
 * running in the master at the current point in WAL.  These XIDs must be 
 * treated as running by standby transactions, even though they are not in 
 * the standby server's PGXACT array. 
 * 
 * We record all XIDs that we know have been assigned.  That includes all the 
 * XIDs seen in WAL records, plus all unobserved XIDs that we can deduce have 
 * been assigned.  We can deduce the existence of unobserved XIDs because we 
 * know XIDs are assigned in sequence, with no gaps.  The KnownAssignedXids 
 * list expands as new XIDs are observed or inferred, and contracts when 
 * transaction completion records arrive. 
 * 
 * During hot standby we do not fret too much about the distinction between 
 * top-level XIDs and subtransaction XIDs. We store both together in the 
 * KnownAssignedXids list.  In backends, this is copied into snapshots in 
 * GetSnapshotData(), taking advantage of the fact that XidInMVCCSnapshot() 
 * doesn't care about the distinction either.  Subtransaction XIDs are 
 * effectively treated as top-level XIDs and in the typical case pg_subtrans 
 * links are *not* maintained (which does not affect visibility). 
 * 
 * We have room in KnownAssignedXids and in snapshots to hold maxProcs * 
 * (1 + PGPROC_MAX_CACHED_SUBXIDS) XIDs, so every master transaction must 
 * report its subtransaction XIDs in a WAL XLOG_XACT_ASSIGNMENT record at 
 * least every PGPROC_MAX_CACHED_SUBXIDS.  When we receive one of these 
 * records, we mark the subXIDs as children of the top XID in pg_subtrans, 
 * and then remove them from KnownAssignedXids.  This prevents overflow of 
 * KnownAssignedXids and snapshots, at the cost that status checks for these 
 * subXIDs will take a slower path through TransactionIdIsInProgress(). 
 * This means that KnownAssignedXids is not necessarily complete for subXIDs, 
 * though it should be complete for top-level XIDs; this is the same situation 
 * that holds with respect to the PGPROC entries in normal running. 
 * 
 * When we throw away subXIDs from KnownAssignedXids, we need to keep track of 
 * that, similarly to tracking overflow of a PGPROC's subxids array.  We do 
 * that by remembering the lastOverflowedXID, ie the last thrown-away subXID. 
 * As long as that is within the range of interesting XIDs, we have to assume 
 * that subXIDs are missing from snapshots.  (Note that subXID overflow occurs 
 * on primary when 65th subXID arrives, whereas on standby it occurs when 64th 
 * subXID arrives - that is not an error.) 
 * 
 * Should a backend on primary somehow disappear before it can write an abort 
 * record, then we just leave those XIDs in KnownAssignedXids. They actually 
 * aborted but we think they were running; the distinction is irrelevant 
 * because either way any changes done by the transaction are not visible to 
 * backends in the standby.  We prune KnownAssignedXids when 
 * XLOG_RUNNING_XACTS arrives, to forestall possible overflow of the 
 * array due to such dead XIDs. 
 */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * RecordKnownAssignedTransactionIds 
 *      Record the given XID in KnownAssignedXids, as well as any preceding 
 *      unobserved XIDs. 
 * 
 * RecordKnownAssignedTransactionIds() should be run for *every* WAL record 
 * associated with a transaction. Must be called for each record after we 
 * have executed StartupCLOG() et al, since we must ExtendCLOG() etc.. 
 * 
 * Called during recovery in analogy with and in place of GetNewTransactionId() 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN3168"></a><span class='Declare_Function'>RecordKnownAssignedTransactionIds</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../access/transam/xlog.c.html#LN194"><span class='Ref_to_Global_Var'>standbyState</span></a> <span class='Operator'>&GT;= </span><a href="../../../include/access/xlog.h.html#LN66"><span class='Ref_to_EnumConst'>STANDBY_INITIALIZED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN3168"><span class='Ref_to_Parameter'>xid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN107"><span class='Ref_to_Global_Var'>latestObservedXid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/miscadmin.h.html#LN287"><span class='Ref_to_Proto'>trace_recovery</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN21"><span class='Ref_to_Const'>DEBUG4</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='String'>"record known xact %u latestObservedXid %u"</span><span class='Delimiter'>, 
</span>         <a href="procarray.c.html#LN3168"><span class='Ref_to_Parameter'>xid</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN107"><span class='Ref_to_Global_Var'>latestObservedXid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * When a newly observed xid arrives, it is frequently the case that it is 
     * *not* the next xid in sequence. When this occurs, we must treat the 
     * intervening xids as running also. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN170"><span class='Ref_to_Proto'>TransactionIdFollows</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN3168"><span class='Ref_to_Parameter'>xid</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN107"><span class='Ref_to_Global_Var'>latestObservedXid</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN3184"></a>        <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>next_expected_xid</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Extend subtrans like we do in GetNewTransactionId() during normal 
         * operation using individual extend steps. Note that we do not need 
         * to extend clog since its extensions are WAL logged. 
         * 
         * This part has to be done regardless of standbyState since we 
         * immediately start assigning subtransactions to their toplevel 
         * transactions. 
         */ 
</span>        <a href="procarray.c.html#LN3184"><span class='Ref_To_Local'>next_expected_xid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN107"><span class='Ref_to_Global_Var'>latestObservedXid</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN3184"><span class='Ref_To_Local'>next_expected_xid</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN3168"><span class='Ref_to_Parameter'>xid</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../../include/access/transam.h.html#LN47"><span class='Ref_to_Macro'>TransactionIdAdvance</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN3184"><span class='Ref_To_Local'>next_expected_xid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/access/subtrans.h.html#LN26"><span class='Ref_to_Proto'>ExtendSUBTRANS</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN3184"><span class='Ref_To_Local'>next_expected_xid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="procarray.c.html#LN3184"><span class='Ref_To_Local'>next_expected_xid</span></a> <span class='Operator'>== </span><a href="procarray.c.html#LN3168"><span class='Ref_to_Parameter'>xid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If the KnownAssignedXids machinery isn't up yet, there's nothing 
         * more to do since we don't track assigned xids yet. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../access/transam/xlog.c.html#LN194"><span class='Ref_to_Global_Var'>standbyState</span></a> <span class='Operator'>&LT;= </span><a href="../../../include/access/xlog.h.html#LN66"><span class='Ref_to_EnumConst'>STANDBY_INITIALIZED</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="procarray.c.html#LN107"><span class='Ref_to_Global_Var'>latestObservedXid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3168"><span class='Ref_to_Parameter'>xid</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>return</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Add (latestObservedXid, xid] onto the KnownAssignedXids array. 
         */ 
</span>        <a href="procarray.c.html#LN3184"><span class='Ref_To_Local'>next_expected_xid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN107"><span class='Ref_to_Global_Var'>latestObservedXid</span></a><span class='Delimiter'>; 
</span>        <a href="../../../include/access/transam.h.html#LN47"><span class='Ref_to_Macro'>TransactionIdAdvance</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN3184"><span class='Ref_To_Local'>next_expected_xid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="procarray.c.html#LN155"><span class='Ref_to_Proto'>KnownAssignedXidsAdd</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN3184"><span class='Ref_To_Local'>next_expected_xid</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN3168"><span class='Ref_to_Parameter'>xid</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Now we can advance latestObservedXid 
         */ 
</span>        <a href="procarray.c.html#LN107"><span class='Ref_to_Global_Var'>latestObservedXid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3168"><span class='Ref_to_Parameter'>xid</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* ShmemVariableCache-&GT;nextXid must be beyond any observed xid */ 
</span>        <a href="procarray.c.html#LN3184"><span class='Ref_To_Local'>next_expected_xid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN107"><span class='Ref_to_Global_Var'>latestObservedXid</span></a><span class='Delimiter'>; 
</span>        <a href="../../../include/access/transam.h.html#LN47"><span class='Ref_to_Macro'>TransactionIdAdvance</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN3184"><span class='Ref_To_Local'>next_expected_xid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>XidGenLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../access/transam/varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN116"><span class='Ref_to_Member'>nextXid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3184"><span class='Ref_To_Local'>next_expected_xid</span></a><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>XidGenLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if TransactionIdFollows(... &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end RecordKnownAssignedTransactionIds &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * ExpireTreeKnownAssignedTransactionIds 
 *      Remove the given XIDs from KnownAssignedXids. 
 * 
 * Called during recovery in analogy with and in place of ProcArrayEndTransaction() 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN3241"></a><span class='Declare_Function'>ExpireTreeKnownAssignedTransactionIds</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xid</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>nsubxids</span><span class='Delimiter'>, 
</span><a name="LN3242"></a>                               <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>subxids</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>max_xid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../access/transam/xlog.c.html#LN194"><span class='Ref_to_Global_Var'>standbyState</span></a> <span class='Operator'>&GT;= </span><a href="../../../include/access/xlog.h.html#LN66"><span class='Ref_to_EnumConst'>STANDBY_INITIALIZED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Uses same locking as transaction commit 
     */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="procarray.c.html#LN160"><span class='Ref_to_Proto'>KnownAssignedXidsRemoveTree</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN3241"><span class='Ref_to_Parameter'>xid</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN3241"><span class='Ref_to_Parameter'>nsubxids</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN3242"><span class='Ref_to_Parameter'>subxids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* As in ProcArrayEndTransaction, advance latestCompletedXid */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="../../access/transam/varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN134"><span class='Ref_to_Member'>latestCompletedXid</span></a><span class='Delimiter'>, 
</span>                              <a href="procarray.c.html#LN3242"><span class='Ref_to_Parameter'>max_xid</span></a><span class='Parentheses'>))</span> 
        <a href="../../access/transam/varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN134"><span class='Ref_to_Member'>latestCompletedXid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3242"><span class='Ref_to_Parameter'>max_xid</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ExpireTreeKnownAssignedTransactionIds &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * ExpireAllKnownAssignedTransactionIds 
 *      Remove all entries in KnownAssignedXids 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN3266"></a><span class='Declare_Function'>ExpireAllKnownAssignedTransactionIds</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN162"><span class='Ref_to_Proto'>KnownAssignedXidsRemovePreceding</span></a><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * ExpireOldKnownAssignedTransactionIds 
 *      Remove KnownAssignedXids entries preceding the given XID 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN3278"></a><span class='Declare_Function'>ExpireOldKnownAssignedTransactionIds</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN162"><span class='Ref_to_Proto'>KnownAssignedXidsRemovePreceding</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN3278"><span class='Ref_to_Parameter'>xid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Private module functions to manipulate KnownAssignedXids 
 * 
 * There are 5 main uses of the KnownAssignedXids data structure: 
 * 
 *  * backends taking snapshots - all valid XIDs need to be copied out 
 *  * backends seeking to determine presence of a specific XID 
 *  * startup process adding new known-assigned XIDs 
 *  * startup process removing specific XIDs as transactions end 
 *  * startup process pruning array when special WAL records arrive 
 * 
 * This data structure is known to be a hot spot during Hot Standby, so we 
 * go to some lengths to make these operations as efficient and as concurrent 
 * as possible. 
 * 
 * The XIDs are stored in an array in sorted order --- TransactionIdPrecedes 
 * order, to be exact --- to allow binary search for specific XIDs.  Note: 
 * in general TransactionIdPrecedes would not provide a total order, but 
 * we know that the entries present at any instant should not extend across 
 * a large enough fraction of XID space to wrap around (the master would 
 * shut down for fear of XID wrap long before that happens).  So it's OK to 
 * use TransactionIdPrecedes as a binary-search comparator. 
 * 
 * It's cheap to maintain the sortedness during insertions, since new known 
 * XIDs are always reported in XID order; we just append them at the right. 
 * 
 * To keep individual deletions cheap, we need to allow gaps in the array. 
 * This is implemented by marking array elements as valid or invalid using 
 * the parallel boolean array KnownAssignedXidsValid[].  A deletion is done 
 * by setting KnownAssignedXidsValid[i] to false, *without* clearing the 
 * XID entry itself.  This preserves the property that the XID entries are 
 * sorted, so we can do binary searches easily.  Periodically we compress 
 * out the unused entries; that's much cheaper than having to compress the 
 * array immediately on every deletion. 
 * 
 * The actually valid items in KnownAssignedXids[] and KnownAssignedXidsValid[] 
 * are those with indexes tail &LT;= i &LT; head; items outside this subscript range 
 * have unspecified contents.  When head reaches the end of the array, we 
 * force compression of unused entries rather than wrapping around, since 
 * allowing wraparound would greatly complicate the search logic.  We maintain 
 * an explicit tail pointer so that pruning of old XIDs can be done without 
 * immediately moving the array contents.  In most cases only a small fraction 
 * of the array contains valid entries at any instant. 
 * 
 * Although only the startup process can ever change the KnownAssignedXids 
 * data structure, we still need interlocking so that standby backends will 
 * not observe invalid intermediate states.  The convention is that backends 
 * must hold shared ProcArrayLock to examine the array.  To remove XIDs from 
 * the array, the startup process must hold ProcArrayLock exclusively, for 
 * the usual transactional reasons (compare commit/abort of a transaction 
 * during normal running).  Compressing unused entries out of the array 
 * likewise requires exclusive lock.  To add XIDs to the array, we just insert 
 * them into slots to the right of the head pointer and then advance the head 
 * pointer.  This wouldn't require any lock at all, except that on machines 
 * with weak memory ordering we need to be careful that other processors 
 * see the array element changes before they see the head pointer change. 
 * We handle this by using a spinlock to protect reads and writes of the 
 * head/tail pointers.  (We could dispense with the spinlock if we were to 
 * create suitable memory access barrier primitives and use those instead.) 
 * The spinlock must be taken to read or write the head/tail pointers unless 
 * the caller holds ProcArrayLock exclusively. 
 * 
 * Algorithmic analysis: 
 * 
 * If we have a maximum of M slots, with N XIDs currently spread across 
 * S elements then we have N &LT;= S &LT;= M always. 
 * 
 *  * Adding a new XID is O(1) and needs little locking (unless compression 
 *      must happen) 
 *  * Compressing the array is O(S) and requires exclusive lock 
 *  * Removing an XID is O(logS) and requires exclusive lock 
 *  * Taking a snapshot is O(S) and requires shared lock 
 *  * Checking for an XID is O(logS) and requires shared lock 
 * 
 * In comparison, using a hash table for KnownAssignedXids would mean that 
 * taking snapshots would be O(M). If we can maintain S &LT;&LT; M then the 
 * sorted array technique will deliver significantly faster snapshots. 
 * If we try to keep S too small then we will spend too much time compressing, 
 * so there is an optimal point for any workload mix. We use a heuristic to 
 * decide when to compress the array, though trimming also helps reduce 
 * frequency of compressing. The heuristic requires us to track the number of 
 * currently valid XIDs in the array. 
 */ 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Compress KnownAssignedXids by shifting valid data down to the start of the 
 * array, removing any gaps. 
 * 
 * A compression step is forced if "force" is true, otherwise we do it 
 * only if a heuristic indicates it's a good time to do it. 
 * 
 * Caller must hold ProcArrayLock in exclusive mode. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3381"></a><span class='Declare_Function'>KnownAssignedXidsCompress</span><span class='Parentheses'>(</span><span class='Keyword'>bool </span><span class='Declare_Parameter'>force</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* use volatile pointer to prevent code rearrangement */ 
</span><a name="LN3384"></a>    <span class='Keyword'>volatile </span><a href="procarray.c.html#LN65"><span class='Ref_to_Struct'>ProcArrayStruct</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pArray</span> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Delimiter'>; 
</span><a name="LN3385"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>head</span><span class='Delimiter'>, 
</span><a name="LN3386"></a>                <span class='Declare_Local'>tail</span><span class='Delimiter'>; 
</span><a name="LN3387"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>compress_index</span><span class='Delimiter'>; 
</span><a name="LN3388"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* no spinlock required since we hold ProcArrayLock exclusively */ 
</span>    <a href="procarray.c.html#LN3385"><span class='Ref_To_Local'>head</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3384"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN76"><span class='Ref_to_Member'>headKnownAssignedXids</span></a><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN3386"><span class='Ref_To_Local'>tail</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3384"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN75"><span class='Ref_to_Member'>tailKnownAssignedXids</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="procarray.c.html#LN3381"><span class='Ref_to_Parameter'>force</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * If we can choose how much to compress, use a heuristic to avoid 
         * compressing too often or not often enough. 
         * 
         * Heuristic is if we have a large enough current spread and less than 
         * 50% of the elements are currently in use, then compress. This 
         * should ensure we compress fairly infrequently. We could compress 
         * less often though the virtual array would spread out more and 
         * snapshots would become more expensive. 
         */ 
</span><a name="LN3406"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>nelements</span> <span class='Operator'>= </span><a href="procarray.c.html#LN3385"><span class='Ref_To_Local'>head</span></a> <span class='Operator'>- </span><a href="procarray.c.html#LN3386"><span class='Ref_To_Local'>tail</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN3406"><span class='Ref_To_Local'>nelements</span></a> <span class='Operator'>&LT; </span><span class='Number'>4</span> <span class='Operator'>* </span><a href="procarray.c.html#LN183"><span class='Ref_to_Const'>PROCARRAY_MAXPROCS</span></a> <span class='Operator'>|| 
</span>            <a href="procarray.c.html#LN3406"><span class='Ref_To_Local'>nelements</span></a> <span class='Operator'>&LT; </span><span class='Number'>2</span> <span class='Operator'>* </span><a href="procarray.c.html#LN3384"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN74"><span class='Ref_to_Member'>numKnownAssignedXids</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We compress the array by reading the valid values from tail to head, 
     * re-aligning data to 0th element. 
     */ 
</span>    <a href="procarray.c.html#LN3387"><span class='Ref_To_Local'>compress_index</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN3388"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3386"><span class='Ref_To_Local'>tail</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN3388"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN3385"><span class='Ref_To_Local'>head</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN3388"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN106"><span class='Ref_to_Global_Var'>KnownAssignedXidsValid</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN3388"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="procarray.c.html#LN105"><span class='Ref_to_Global_Var'>KnownAssignedXids</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN3387"><span class='Ref_To_Local'>compress_index</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="procarray.c.html#LN105"><span class='Ref_to_Global_Var'>KnownAssignedXids</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN3388"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>            <a href="procarray.c.html#LN106"><span class='Ref_to_Global_Var'>KnownAssignedXidsValid</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN3387"><span class='Ref_To_Local'>compress_index</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="procarray.c.html#LN3387"><span class='Ref_To_Local'>compress_index</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="procarray.c.html#LN3384"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN75"><span class='Ref_to_Member'>tailKnownAssignedXids</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN3384"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN76"><span class='Ref_to_Member'>headKnownAssignedXids</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3387"><span class='Ref_To_Local'>compress_index</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end KnownAssignedXidsCompress &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Add xids into KnownAssignedXids at the head of the array. 
 * 
 * xids from from_xid to to_xid, inclusive, are added to the array. 
 * 
 * If exclusive_lock is true then caller already holds ProcArrayLock in 
 * exclusive mode, so we need no extra locking here.  Else caller holds no 
 * lock, so we need to be sure we maintain sufficient interlocks against 
 * concurrent readers.  (Only the startup process ever calls this, so no need 
 * to worry about concurrent writers.) 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3444"></a><span class='Declare_Function'>KnownAssignedXidsAdd</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>from_xid</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>to_xid</span><span class='Delimiter'>, 
</span><a name="LN3445"></a>                     <span class='Keyword'>bool </span><span class='Declare_Parameter'>exclusive_lock</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* use volatile pointer to prevent code rearrangement */ 
</span><a name="LN3448"></a>    <span class='Keyword'>volatile </span><a href="procarray.c.html#LN65"><span class='Ref_to_Struct'>ProcArrayStruct</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pArray</span> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Delimiter'>; 
</span><a name="LN3449"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>next_xid</span><span class='Delimiter'>; 
</span><a name="LN3450"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>head</span><span class='Delimiter'>, 
</span><a name="LN3451"></a>                <span class='Declare_Local'>tail</span><span class='Delimiter'>; 
</span><a name="LN3452"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>nxids</span><span class='Delimiter'>; 
</span><a name="LN3453"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN169"><span class='Ref_to_Proto'>TransactionIdPrecedesOrEquals</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN3444"><span class='Ref_to_Parameter'>from_xid</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN3444"><span class='Ref_to_Parameter'>to_xid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Calculate how many array slots we'll need.  Normally this is cheap; in 
     * the unusual case where the XIDs cross the wrap point, we do it the hard 
     * way. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN3444"><span class='Ref_to_Parameter'>to_xid</span></a> <span class='Operator'>&GT;= </span><a href="procarray.c.html#LN3444"><span class='Ref_to_Parameter'>from_xid</span></a><span class='Parentheses'>) 
</span>        <a href="procarray.c.html#LN3452"><span class='Ref_To_Local'>nxids</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3444"><span class='Ref_to_Parameter'>to_xid</span></a> <span class='Operator'>- </span><a href="procarray.c.html#LN3444"><span class='Ref_to_Parameter'>from_xid</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="procarray.c.html#LN3452"><span class='Ref_To_Local'>nxids</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <a href="procarray.c.html#LN3449"><span class='Ref_To_Local'>next_xid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3444"><span class='Ref_to_Parameter'>from_xid</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN3449"><span class='Ref_To_Local'>next_xid</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN3444"><span class='Ref_to_Parameter'>to_xid</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="procarray.c.html#LN3452"><span class='Ref_To_Local'>nxids</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <a href="../../../include/access/transam.h.html#LN47"><span class='Ref_to_Macro'>TransactionIdAdvance</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN3449"><span class='Ref_To_Local'>next_xid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Since only the startup process modifies the head/tail pointers, we 
     * don't need a lock to read them here. 
     */ 
</span>    <a href="procarray.c.html#LN3450"><span class='Ref_To_Local'>head</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3448"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN76"><span class='Ref_to_Member'>headKnownAssignedXids</span></a><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN3451"><span class='Ref_To_Local'>tail</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3448"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN75"><span class='Ref_to_Member'>tailKnownAssignedXids</span></a><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="procarray.c.html#LN3450"><span class='Ref_To_Local'>head</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="procarray.c.html#LN3450"><span class='Ref_To_Local'>head</span></a> <span class='Operator'>&LT;= </span><a href="procarray.c.html#LN3448"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN73"><span class='Ref_to_Member'>maxKnownAssignedXids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="procarray.c.html#LN3451"><span class='Ref_To_Local'>tail</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="procarray.c.html#LN3451"><span class='Ref_To_Local'>tail</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN3448"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN73"><span class='Ref_to_Member'>maxKnownAssignedXids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Verify that insertions occur in TransactionId sequence.  Note that even 
     * if the last existing element is marked invalid, it must still have a 
     * correctly sequenced XID value. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN3450"><span class='Ref_To_Local'>head</span></a> <span class='Operator'>&GT; </span><a href="procarray.c.html#LN3451"><span class='Ref_To_Local'>tail</span></a> <span class='Operator'>&& 
</span>        <a href="../../../include/access/transam.h.html#LN171"><span class='Ref_to_Proto'>TransactionIdFollowsOrEquals</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN105"><span class='Ref_to_Global_Var'>KnownAssignedXids</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN3450"><span class='Ref_To_Local'>head</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>], </span><a href="procarray.c.html#LN3444"><span class='Ref_to_Parameter'>from_xid</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="procarray.c.html#LN168"><span class='Ref_to_Proto'>KnownAssignedXidsDisplay</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"out-of-order XID insertion in KnownAssignedXids"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If our xids won't fit in the remaining space, compress out free space 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN3450"><span class='Ref_To_Local'>head</span></a> <span class='Operator'>+ </span><a href="procarray.c.html#LN3452"><span class='Ref_To_Local'>nxids</span></a> <span class='Operator'>&GT; </span><a href="procarray.c.html#LN3448"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN73"><span class='Ref_to_Member'>maxKnownAssignedXids</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* must hold lock to compress */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="procarray.c.html#LN3445"><span class='Ref_to_Parameter'>exclusive_lock</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="procarray.c.html#LN154"><span class='Ref_to_Proto'>KnownAssignedXidsCompress</span></a><span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="procarray.c.html#LN3450"><span class='Ref_To_Local'>head</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3448"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN76"><span class='Ref_to_Member'>headKnownAssignedXids</span></a><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* note: we no longer care about the tail pointer */ 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="procarray.c.html#LN3445"><span class='Ref_to_Parameter'>exclusive_lock</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If it still won't fit then we're out of memory 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN3450"><span class='Ref_To_Local'>head</span></a> <span class='Operator'>+ </span><a href="procarray.c.html#LN3452"><span class='Ref_To_Local'>nxids</span></a> <span class='Operator'>&GT; </span><a href="procarray.c.html#LN3448"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN73"><span class='Ref_to_Member'>maxKnownAssignedXids</span></a><span class='Parentheses'>) 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"too many KnownAssignedXids"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if head+nxids&GT;pArray-&GT;ma... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Now we can insert the xids into the space starting at head */ 
</span>    <a href="procarray.c.html#LN3449"><span class='Ref_To_Local'>next_xid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3444"><span class='Ref_to_Parameter'>from_xid</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN3453"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN3453"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN3452"><span class='Ref_To_Local'>nxids</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN3453"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="procarray.c.html#LN105"><span class='Ref_to_Global_Var'>KnownAssignedXids</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN3450"><span class='Ref_To_Local'>head</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="procarray.c.html#LN3449"><span class='Ref_To_Local'>next_xid</span></a><span class='Delimiter'>; 
</span>        <a href="procarray.c.html#LN106"><span class='Ref_to_Global_Var'>KnownAssignedXidsValid</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN3450"><span class='Ref_To_Local'>head</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <a href="../../../include/access/transam.h.html#LN47"><span class='Ref_to_Macro'>TransactionIdAdvance</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN3449"><span class='Ref_To_Local'>next_xid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="procarray.c.html#LN3450"><span class='Ref_To_Local'>head</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Adjust count of number of valid entries */ 
</span>    <a href="procarray.c.html#LN3448"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN74"><span class='Ref_to_Member'>numKnownAssignedXids</span></a> <span class='Operator'>+= </span><a href="procarray.c.html#LN3452"><span class='Ref_To_Local'>nxids</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now update the head pointer.  We use a spinlock to protect this 
     * pointer, not because the update is likely to be non-atomic, but to 
     * ensure that other processors see the above array updates before they 
     * see the head pointer change. 
     * 
     * If we're holding ProcArrayLock exclusively, there's no need to take the 
     * spinlock. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN3445"><span class='Ref_to_Parameter'>exclusive_lock</span></a><span class='Parentheses'>) 
</span>        <a href="procarray.c.html#LN3448"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN76"><span class='Ref_to_Member'>headKnownAssignedXids</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3450"><span class='Ref_To_Local'>head</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="procarray.c.html#LN3448"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN77"><span class='Ref_to_Member'>known_assigned_xids_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="procarray.c.html#LN3448"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN76"><span class='Ref_to_Member'>headKnownAssignedXids</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3450"><span class='Ref_To_Local'>head</span></a><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="procarray.c.html#LN3448"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN77"><span class='Ref_to_Member'>known_assigned_xids_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end KnownAssignedXidsAdd &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * KnownAssignedXidsSearch 
 * 
 * Searches KnownAssignedXids for a specific xid and optionally removes it. 
 * Returns true if it was found, false if not. 
 * 
 * Caller must hold ProcArrayLock in shared or exclusive mode. 
 * Exclusive lock must be held for remove = true. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN3563"></a><span class='Declare_Function'>KnownAssignedXidsSearch</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xid</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>remove</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* use volatile pointer to prevent code rearrangement */ 
</span><a name="LN3566"></a>    <span class='Keyword'>volatile </span><a href="procarray.c.html#LN65"><span class='Ref_to_Struct'>ProcArrayStruct</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pArray</span> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Delimiter'>; 
</span><a name="LN3567"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>first</span><span class='Delimiter'>, 
</span><a name="LN3568"></a>                <span class='Declare_Local'>last</span><span class='Delimiter'>; 
</span><a name="LN3569"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>head</span><span class='Delimiter'>; 
</span><a name="LN3570"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>tail</span><span class='Delimiter'>; 
</span><a name="LN3571"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>result_index</span> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN3563"><span class='Ref_to_Parameter'>remove</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* we hold ProcArrayLock exclusively, so no need for spinlock */ 
</span>        <a href="procarray.c.html#LN3570"><span class='Ref_To_Local'>tail</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3566"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN75"><span class='Ref_to_Member'>tailKnownAssignedXids</span></a><span class='Delimiter'>; 
</span>        <a href="procarray.c.html#LN3569"><span class='Ref_To_Local'>head</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3566"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN76"><span class='Ref_to_Member'>headKnownAssignedXids</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* take spinlock to ensure we see up-to-date array contents */ 
</span>        <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="procarray.c.html#LN3566"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN77"><span class='Ref_to_Member'>known_assigned_xids_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="procarray.c.html#LN3570"><span class='Ref_To_Local'>tail</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3566"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN75"><span class='Ref_to_Member'>tailKnownAssignedXids</span></a><span class='Delimiter'>; 
</span>        <a href="procarray.c.html#LN3569"><span class='Ref_To_Local'>head</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3566"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN76"><span class='Ref_to_Member'>headKnownAssignedXids</span></a><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="procarray.c.html#LN3566"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN77"><span class='Ref_to_Member'>known_assigned_xids_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Standard binary search.  Note we can ignore the KnownAssignedXidsValid 
     * array here, since even invalid entries will contain sorted XIDs. 
     */ 
</span>    <a href="procarray.c.html#LN3567"><span class='Ref_To_Local'>first</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3570"><span class='Ref_To_Local'>tail</span></a><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN3568"><span class='Ref_To_Local'>last</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3569"><span class='Ref_To_Local'>head</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN3567"><span class='Ref_To_Local'>first</span></a> <span class='Operator'>&LT;= </span><a href="procarray.c.html#LN3568"><span class='Ref_To_Local'>last</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3596"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>mid_index</span><span class='Delimiter'>; 
</span><a name="LN3597"></a>        <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>mid_xid</span><span class='Delimiter'>; 
</span> 
        <a href="procarray.c.html#LN3596"><span class='Ref_To_Local'>mid_index</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="procarray.c.html#LN3567"><span class='Ref_To_Local'>first</span></a> <span class='Operator'>+ </span><a href="procarray.c.html#LN3568"><span class='Ref_To_Local'>last</span></a><span class='Parentheses'>) </span><span class='Operator'>/ </span><span class='Number'>2</span><span class='Delimiter'>; 
</span>        <a href="procarray.c.html#LN3597"><span class='Ref_To_Local'>mid_xid</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN105"><span class='Ref_to_Global_Var'>KnownAssignedXids</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN3596"><span class='Ref_To_Local'>mid_index</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN3563"><span class='Ref_to_Parameter'>xid</span></a> <span class='Operator'>== </span><a href="procarray.c.html#LN3597"><span class='Ref_To_Local'>mid_xid</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="procarray.c.html#LN3571"><span class='Ref_To_Local'>result_index</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3596"><span class='Ref_To_Local'>mid_index</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN3563"><span class='Ref_to_Parameter'>xid</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN3597"><span class='Ref_To_Local'>mid_xid</span></a><span class='Parentheses'>))</span> 
            <a href="procarray.c.html#LN3568"><span class='Ref_To_Local'>last</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3596"><span class='Ref_To_Local'>mid_index</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="procarray.c.html#LN3567"><span class='Ref_To_Local'>first</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3596"><span class='Ref_To_Local'>mid_index</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN3571"><span class='Ref_To_Local'>result_index</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* not in array */ 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="procarray.c.html#LN106"><span class='Ref_to_Global_Var'>KnownAssignedXidsValid</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN3571"><span class='Ref_To_Local'>result_index</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* in array, but invalid */ 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN3563"><span class='Ref_to_Parameter'>remove</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="procarray.c.html#LN106"><span class='Ref_to_Global_Var'>KnownAssignedXidsValid</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN3571"><span class='Ref_To_Local'>result_index</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
        <a href="procarray.c.html#LN3566"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN74"><span class='Ref_to_Member'>numKnownAssignedXids</span></a><span class='Operator'>--</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="procarray.c.html#LN3566"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN74"><span class='Ref_to_Member'>numKnownAssignedXids</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If we're removing the tail element then advance tail pointer over 
         * any invalid elements.  This will speed future searches. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN3571"><span class='Ref_To_Local'>result_index</span></a> <span class='Operator'>== </span><a href="procarray.c.html#LN3570"><span class='Ref_To_Local'>tail</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="procarray.c.html#LN3570"><span class='Ref_To_Local'>tail</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN3570"><span class='Ref_To_Local'>tail</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN3569"><span class='Ref_To_Local'>head</span></a> <span class='Operator'>&& !</span><a href="procarray.c.html#LN106"><span class='Ref_to_Global_Var'>KnownAssignedXidsValid</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN3570"><span class='Ref_To_Local'>tail</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>                <a href="procarray.c.html#LN3570"><span class='Ref_To_Local'>tail</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN3570"><span class='Ref_To_Local'>tail</span></a> <span class='Operator'>&GT;= </span><a href="procarray.c.html#LN3569"><span class='Ref_To_Local'>head</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Array is empty, so we can reset both pointers */ 
</span>                <a href="procarray.c.html#LN3566"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN76"><span class='Ref_to_Member'>headKnownAssignedXids</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>                <a href="procarray.c.html#LN3566"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN75"><span class='Ref_to_Member'>tailKnownAssignedXids</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <a href="procarray.c.html#LN3566"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN75"><span class='Ref_to_Member'>tailKnownAssignedXids</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3570"><span class='Ref_To_Local'>tail</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if remove &raquo; </span> 
 
    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end KnownAssignedXidsSearch &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Is the specified XID present in KnownAssignedXids[]? 
 * 
 * Caller must hold ProcArrayLock in shared or exclusive mode. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN3657"></a><span class='Declare_Function'>KnownAssignedXidExists</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN3657"><span class='Ref_to_Parameter'>xid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="procarray.c.html#LN157"><span class='Ref_to_Proto'>KnownAssignedXidsSearch</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN3657"><span class='Ref_to_Parameter'>xid</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Remove the specified XID from KnownAssignedXids[]. 
 * 
 * Caller must hold ProcArrayLock in exclusive mode. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3670"></a><span class='Declare_Function'>KnownAssignedXidsRemove</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN3670"><span class='Ref_to_Parameter'>xid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/miscadmin.h.html#LN287"><span class='Ref_to_Proto'>trace_recovery</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN21"><span class='Ref_to_Const'>DEBUG4</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='String'>"remove KnownAssignedXid %u"</span><span class='Delimiter'>, </span><a href="procarray.c.html#LN3670"><span class='Ref_to_Parameter'>xid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Note: we cannot consider it an error to remove an XID that's not 
     * present.  We intentionally remove subxact IDs while processing 
     * XLOG_XACT_ASSIGNMENT, to avoid array overflow.  Then those XIDs will be 
     * removed again when the top-level xact commits or aborts. 
     * 
     * It might be possible to track such XIDs to distinguish this case from 
     * actual errors, but it would be complicated and probably not worth it. 
     * So, just ignore the search result. 
     */ 
</span>    <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="procarray.c.html#LN157"><span class='Ref_to_Proto'>KnownAssignedXidsSearch</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN3670"><span class='Ref_to_Parameter'>xid</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * KnownAssignedXidsRemoveTree 
 *      Remove xid (if it's not InvalidTransactionId) and all the subxids. 
 * 
 * Caller must hold ProcArrayLock in exclusive mode. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3696"></a><span class='Declare_Function'>KnownAssignedXidsRemoveTree</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xid</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>nsubxids</span><span class='Delimiter'>, 
</span><a name="LN3697"></a>                            <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>subxids</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3699"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN3696"><span class='Ref_to_Parameter'>xid</span></a><span class='Parentheses'>))</span> 
        <a href="procarray.c.html#LN159"><span class='Ref_to_Proto'>KnownAssignedXidsRemove</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN3696"><span class='Ref_to_Parameter'>xid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN3699"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="procarray.c.html#LN3699"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN3696"><span class='Ref_to_Parameter'>nsubxids</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN3699"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <a href="procarray.c.html#LN159"><span class='Ref_to_Proto'>KnownAssignedXidsRemove</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN3697"><span class='Ref_to_Parameter'>subxids</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN3699"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Opportunistically compress the array */ 
</span>    <a href="procarray.c.html#LN154"><span class='Ref_to_Proto'>KnownAssignedXidsCompress</span></a><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Prune KnownAssignedXids up to, but *not* including xid. If xid is invalid 
 * then clear the whole table. 
 * 
 * Caller must hold ProcArrayLock in exclusive mode. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3718"></a><span class='Declare_Function'>KnownAssignedXidsRemovePreceding</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>removeXid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* use volatile pointer to prevent code rearrangement */ 
</span><a name="LN3721"></a>    <span class='Keyword'>volatile </span><a href="procarray.c.html#LN65"><span class='Ref_to_Struct'>ProcArrayStruct</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pArray</span> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Delimiter'>; 
</span><a name="LN3722"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>count</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN3723"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>head</span><span class='Delimiter'>, 
</span><a name="LN3724"></a>                <span class='Declare_Local'>tail</span><span class='Delimiter'>, 
</span><a name="LN3725"></a>                <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN3718"><span class='Ref_to_Parameter'>removeXid</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/miscadmin.h.html#LN287"><span class='Ref_to_Proto'>trace_recovery</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN21"><span class='Ref_to_Const'>DEBUG4</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='String'>"removing all KnownAssignedXids"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="procarray.c.html#LN3721"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN74"><span class='Ref_to_Member'>numKnownAssignedXids</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="procarray.c.html#LN3721"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN76"><span class='Ref_to_Member'>headKnownAssignedXids</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3721"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN75"><span class='Ref_to_Member'>tailKnownAssignedXids</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/miscadmin.h.html#LN287"><span class='Ref_to_Proto'>trace_recovery</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN21"><span class='Ref_to_Const'>DEBUG4</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='String'>"prune KnownAssignedXids to %u"</span><span class='Delimiter'>, </span><a href="procarray.c.html#LN3718"><span class='Ref_to_Parameter'>removeXid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Mark entries invalid starting at the tail.  Since array is sorted, we 
     * can stop as soon as we reach an entry &GT;= removeXid. 
     */ 
</span>    <a href="procarray.c.html#LN3724"><span class='Ref_To_Local'>tail</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3721"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN75"><span class='Ref_to_Member'>tailKnownAssignedXids</span></a><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN3723"><span class='Ref_To_Local'>head</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3721"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN76"><span class='Ref_to_Member'>headKnownAssignedXids</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN3725"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3724"><span class='Ref_To_Local'>tail</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN3725"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN3723"><span class='Ref_To_Local'>head</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN3725"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN106"><span class='Ref_to_Global_Var'>KnownAssignedXidsValid</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN3725"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN3748"></a>            <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>knownXid</span> <span class='Operator'>= </span><a href="procarray.c.html#LN105"><span class='Ref_to_Global_Var'>KnownAssignedXids</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN3725"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN171"><span class='Ref_to_Proto'>TransactionIdFollowsOrEquals</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN3748"><span class='Ref_To_Local'>knownXid</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN3718"><span class='Ref_to_Parameter'>removeXid</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/twophase.h.html#LN44"><span class='Ref_to_Proto'>StandbyTransactionIdIsPrepared</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN3748"><span class='Ref_To_Local'>knownXid</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="procarray.c.html#LN106"><span class='Ref_to_Global_Var'>KnownAssignedXidsValid</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN3725"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                <a href="procarray.c.html#LN3722"><span class='Ref_To_Local'>count</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="procarray.c.html#LN3721"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN74"><span class='Ref_to_Member'>numKnownAssignedXids</span></a> <span class='Operator'>-= </span><a href="procarray.c.html#LN3722"><span class='Ref_To_Local'>count</span></a><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="procarray.c.html#LN3721"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN74"><span class='Ref_to_Member'>numKnownAssignedXids</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Advance the tail pointer if we've marked the tail item invalid. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN3725"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3724"><span class='Ref_To_Local'>tail</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN3725"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN3723"><span class='Ref_To_Local'>head</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN3725"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN106"><span class='Ref_to_Global_Var'>KnownAssignedXidsValid</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN3725"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN3725"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&GT;= </span><a href="procarray.c.html#LN3723"><span class='Ref_To_Local'>head</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Array is empty, so we can reset both pointers */ 
</span>        <a href="procarray.c.html#LN3721"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN76"><span class='Ref_to_Member'>headKnownAssignedXids</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="procarray.c.html#LN3721"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN75"><span class='Ref_to_Member'>tailKnownAssignedXids</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="procarray.c.html#LN3721"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN75"><span class='Ref_to_Member'>tailKnownAssignedXids</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3725"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Opportunistically compress the array */ 
</span>    <a href="procarray.c.html#LN154"><span class='Ref_to_Proto'>KnownAssignedXidsCompress</span></a><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end KnownAssignedXidsRemovePreceding &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * KnownAssignedXidsGet - Get an array of xids by scanning KnownAssignedXids. 
 * We filter out anything &GT;= xmax. 
 * 
 * Returns the number of XIDs stored into xarray[].  Caller is responsible 
 * that array is large enough. 
 * 
 * Caller must hold ProcArrayLock in (at least) shared mode. 
 */ 
</span><span class='Keyword'>static int 
</span><a name="LN3797"></a><span class='Declare_Function'>KnownAssignedXidsGet</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>xarray</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xmax</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3799"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>xtmp</span> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="procarray.c.html#LN164"><span class='Ref_to_Proto'>KnownAssignedXidsGetAndSetXmin</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN3797"><span class='Ref_to_Parameter'>xarray</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="procarray.c.html#LN3799"><span class='Ref_To_Local'>xtmp</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN3797"><span class='Ref_to_Parameter'>xmax</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * KnownAssignedXidsGetAndSetXmin - as KnownAssignedXidsGet, plus 
 * we reduce *xmin to the lowest xid value seen if not already lower. 
 * 
 * Caller must hold ProcArrayLock in (at least) shared mode. 
 */ 
</span><span class='Keyword'>static int 
</span><a name="LN3811"></a><span class='Declare_Function'>KnownAssignedXidsGetAndSetXmin</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>xarray</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>xmin</span><span class='Delimiter'>, 
</span><a name="LN3812"></a>                               <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xmax</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3814"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>count</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN3815"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>head</span><span class='Delimiter'>, 
</span><a name="LN3816"></a>                <span class='Declare_Local'>tail</span><span class='Delimiter'>; 
</span><a name="LN3817"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Fetch head just once, since it may change while we loop. We can stop 
     * once we reach the initially seen head, since we are certain that an xid 
     * cannot enter and then leave the array while we hold ProcArrayLock.  We 
     * might miss newly-added xids, but they should be &GT;= xmax so irrelevant 
     * anyway. 
     * 
     * Must take spinlock to ensure we see up-to-date array contents. 
     */ 
</span>    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN77"><span class='Ref_to_Member'>known_assigned_xids_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN3816"><span class='Ref_To_Local'>tail</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN75"><span class='Ref_to_Member'>tailKnownAssignedXids</span></a><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN3815"><span class='Ref_To_Local'>head</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN76"><span class='Ref_to_Member'>headKnownAssignedXids</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN77"><span class='Ref_to_Member'>known_assigned_xids_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN3817"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3816"><span class='Ref_To_Local'>tail</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN3817"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN3815"><span class='Ref_To_Local'>head</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN3817"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Skip any gaps in the array */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN106"><span class='Ref_to_Global_Var'>KnownAssignedXidsValid</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN3817"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN3838"></a>            <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>knownXid</span> <span class='Operator'>= </span><a href="procarray.c.html#LN105"><span class='Ref_to_Global_Var'>KnownAssignedXids</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN3817"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Update xmin if required.  Only the first XID need be checked, 
             * since the array is sorted. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN3814"><span class='Ref_To_Local'>count</span></a> <span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>&& 
</span>                <a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN3838"><span class='Ref_To_Local'>knownXid</span></a><span class='Delimiter'>, </span><span class='Operator'>*</span><a href="procarray.c.html#LN3811"><span class='Ref_to_Parameter'>xmin</span></a><span class='Parentheses'>))</span> 
                <span class='Operator'>*</span><a href="procarray.c.html#LN3811"><span class='Ref_to_Parameter'>xmin</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3838"><span class='Ref_To_Local'>knownXid</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Filter out anything &GT;= xmax, again relying on sorted property 
             * of array. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN3812"><span class='Ref_to_Parameter'>xmax</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                <a href="../../../include/access/transam.h.html#LN171"><span class='Ref_to_Proto'>TransactionIdFollowsOrEquals</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN3838"><span class='Ref_To_Local'>knownXid</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN3812"><span class='Ref_to_Parameter'>xmax</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Add knownXid into output array */ 
</span>            <a href="procarray.c.html#LN3811"><span class='Ref_to_Parameter'>xarray</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN3814"><span class='Ref_To_Local'>count</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="procarray.c.html#LN3838"><span class='Ref_To_Local'>knownXid</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if KnownAssignedXidsVali... &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=tail;i&LT;head;i++ &raquo; </span> 
 
    <span class='Control'>return</span> <a href="procarray.c.html#LN3814"><span class='Ref_To_Local'>count</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end KnownAssignedXidsGetAndSetXmin &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Get oldest XID in the KnownAssignedXids array, or InvalidTransactionId 
 * if nothing there. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> 
<a name="LN3869"></a><span class='Declare_Function'>KnownAssignedXidsGetOldestXmin</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3871"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>head</span><span class='Delimiter'>, 
</span><a name="LN3872"></a>                <span class='Declare_Local'>tail</span><span class='Delimiter'>; 
</span><a name="LN3873"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Fetch head just once, since it may change while we loop. 
     */ 
</span>    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN77"><span class='Ref_to_Member'>known_assigned_xids_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN3872"><span class='Ref_To_Local'>tail</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN75"><span class='Ref_to_Member'>tailKnownAssignedXids</span></a><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN3871"><span class='Ref_To_Local'>head</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN76"><span class='Ref_to_Member'>headKnownAssignedXids</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN77"><span class='Ref_to_Member'>known_assigned_xids_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN3873"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3872"><span class='Ref_To_Local'>tail</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN3873"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN3871"><span class='Ref_To_Local'>head</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN3873"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Skip any gaps in the array */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN106"><span class='Ref_to_Global_Var'>KnownAssignedXidsValid</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN3873"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <a href="procarray.c.html#LN105"><span class='Ref_to_Global_Var'>KnownAssignedXids</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN3873"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end KnownAssignedXidsGetOldestXmin &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Display KnownAssignedXids to provide debug trail 
 * 
 * Currently this is only called within startup process, so we need no 
 * special locking. 
 * 
 * Note this is pretty expensive, and much of the expense will be incurred 
 * even if the elog message will get discarded.  It's not currently called 
 * in any performance-critical places, however, so no need to be tenser. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3904"></a><span class='Declare_Function'>KnownAssignedXidsDisplay</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>trace_level</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* use volatile pointer to prevent code rearrangement */ 
</span><a name="LN3907"></a>    <span class='Keyword'>volatile </span><a href="procarray.c.html#LN65"><span class='Ref_to_Struct'>ProcArrayStruct</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pArray</span> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Delimiter'>; 
</span><a name="LN3908"></a>    <a href="../../../include/lib/stringinfo.h.html#LN34"><span class='Ref_to_Struct'>StringInfoData</span></a> <span class='Declare_Local'>buf</span><span class='Delimiter'>; 
</span><a name="LN3909"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>head</span><span class='Delimiter'>, 
</span><a name="LN3910"></a>                <span class='Declare_Local'>tail</span><span class='Delimiter'>, 
</span><a name="LN3911"></a>                <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN3912"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>nxids</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <a href="procarray.c.html#LN3910"><span class='Ref_To_Local'>tail</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3907"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN75"><span class='Ref_to_Member'>tailKnownAssignedXids</span></a><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN3909"><span class='Ref_To_Local'>head</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3907"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN76"><span class='Ref_to_Member'>headKnownAssignedXids</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../lib/stringinfo.c.html#LN44"><span class='Ref_to_Func'>initStringInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="procarray.c.html#LN3908"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN3911"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><a href="procarray.c.html#LN3910"><span class='Ref_To_Local'>tail</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN3911"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="procarray.c.html#LN3909"><span class='Ref_To_Local'>head</span></a><span class='Delimiter'>; </span><a href="procarray.c.html#LN3911"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="procarray.c.html#LN106"><span class='Ref_to_Global_Var'>KnownAssignedXidsValid</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN3911"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="procarray.c.html#LN3912"><span class='Ref_To_Local'>nxids</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <a href="../../../bin/pg_waldump/compat.c.html#LN69"><span class='Ref_to_Func'>appendStringInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="procarray.c.html#LN3908"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='String'>"[%d]=%u "</span><span class='Delimiter'>, </span><a href="procarray.c.html#LN3911"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>, </span><a href="procarray.c.html#LN105"><span class='Ref_to_Global_Var'>KnownAssignedXids</span></a><span class='Delimiter'>[</span><a href="procarray.c.html#LN3911"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN3904"><span class='Ref_to_Parameter'>trace_level</span></a><span class='Delimiter'>, </span><span class='String'>"%d KnownAssignedXids (num=%d tail=%d head=%d) %s"</span><span class='Delimiter'>, 
</span>         <a href="procarray.c.html#LN3912"><span class='Ref_To_Local'>nxids</span></a><span class='Delimiter'>, 
</span>         <a href="procarray.c.html#LN3907"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN74"><span class='Ref_to_Member'>numKnownAssignedXids</span></a><span class='Delimiter'>, 
</span>         <a href="procarray.c.html#LN3907"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN75"><span class='Ref_to_Member'>tailKnownAssignedXids</span></a><span class='Delimiter'>, 
</span>         <a href="procarray.c.html#LN3907"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN76"><span class='Ref_to_Member'>headKnownAssignedXids</span></a><span class='Delimiter'>, 
</span>         <a href="procarray.c.html#LN3908"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>.</span><a href="../../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="procarray.c.html#LN3908"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>.</span><a href="../../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end KnownAssignedXidsDisplay &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * KnownAssignedXidsReset 
 *      Resets KnownAssignedXids to be empty 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3943"></a><span class='Declare_Function'>KnownAssignedXidsReset</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* use volatile pointer to prevent code rearrangement */ 
</span><a name="LN3946"></a>    <span class='Keyword'>volatile </span><a href="procarray.c.html#LN65"><span class='Ref_to_Struct'>ProcArrayStruct</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pArray</span> <span class='Operator'>= </span><a href="procarray.c.html#LN97"><span class='Ref_to_Global_Var'>procArray</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="procarray.c.html#LN3946"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN74"><span class='Ref_to_Member'>numKnownAssignedXids</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN3946"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN75"><span class='Ref_to_Member'>tailKnownAssignedXids</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="procarray.c.html#LN3946"><span class='Ref_To_Local'>pArray</span></a><span class='Operator'>-&GT;</span><a href="procarray.c.html#LN76"><span class='Ref_to_Member'>headKnownAssignedXids</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span></pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>