<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\storage\lmgr\lwlock.c</title>
<LINK REL=StyleSheet HREF="../../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\storage\lmgr\lwlock.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:49 2017
</td></tr>
<tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * lwlock.c 
 *    Lightweight lock manager 
 * 
 * Lightweight locks are intended primarily to provide mutual exclusion of 
 * access to shared-memory data structures.  Therefore, they offer both 
 * exclusive and shared lock modes (to support read/write and read-only 
 * access to a shared object).  There are few other frammishes.  User-level 
 * locking should be done with the full lock manager --- which depends on 
 * LWLocks to protect its shared state. 
 * 
 * In addition to exclusive and shared modes, lightweight locks can be used to 
 * wait until a variable changes value.  The variable is initially not set 
 * when the lock is acquired with LWLockAcquire, i.e. it remains set to the 
 * value it was set to when the lock was released last, and can be updated 
 * without releasing the lock by calling LWLockUpdateVar.  LWLockWaitForVar 
 * waits for the variable to be updated, or until the lock is free.  When 
 * releasing the lock with LWLockReleaseClearVar() the value can be set to an 
 * appropriate value for a free lock.  The meaning of the variable is up to 
 * the caller, the lightweight lock code just assigns and compares it. 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * IDENTIFICATION 
 *    src/backend/storage/lmgr/lwlock.c 
 * 
 * NOTES: 
 * 
 * This used to be a pretty straight forward reader-writer lock 
 * implementation, in which the internal state was protected by a 
 * spinlock. Unfortunately the overhead of taking the spinlock proved to be 
 * too high for workloads/locks that were taken in shared mode very 
 * frequently. Often we were spinning in the (obviously exclusive) spinlock, 
 * while trying to acquire a shared lock that was actually free. 
 * 
 * Thus a new implementation was devised that provides wait-free shared lock 
 * acquisition for locks that aren't exclusively locked. 
 * 
 * The basic idea is to have a single atomic variable 'lockcount' instead of 
 * the formerly separate shared and exclusive counters and to use atomic 
 * operations to acquire the lock. That's fairly easy to do for plain 
 * rw-spinlocks, but a lot harder for something like LWLocks that want to wait 
 * in the OS. 
 * 
 * For lock acquisition we use an atomic compare-and-exchange on the lockcount 
 * variable. For exclusive lock we swap in a sentinel value 
 * (LW_VAL_EXCLUSIVE), for shared locks we count the number of holders. 
 * 
 * To release the lock we use an atomic decrement to release the lock. If the 
 * new value is zero (we get that atomically), we know we can/have to release 
 * waiters. 
 * 
 * Obviously it is important that the sentinel value for exclusive locks 
 * doesn't conflict with the maximum number of possible share lockers - 
 * luckily MAX_BACKENDS makes that easily possible. 
 * 
 * 
 * The attentive reader might have noticed that naively doing the above has a 
 * glaring race condition: We try to lock using the atomic operations and 
 * notice that we have to wait. Unfortunately by the time we have finished 
 * queuing, the former locker very well might have already finished it's 
 * work. That's problematic because we're now stuck waiting inside the OS. 
 
 * To mitigate those races we use a two phased attempt at locking: 
 *   Phase 1: Try to do it atomically, if we succeed, nice 
 *   Phase 2: Add ourselves to the waitqueue of the lock 
 *   Phase 3: Try to grab the lock again, if we succeed, remove ourselves from 
 *            the queue 
 *   Phase 4: Sleep till wake-up, goto Phase 1 
 * 
 * This protects us against the problem from above as nobody can release too 
 *    quick, before we're queued, since after Phase 2 we're already queued. 
 * ------------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"miscadmin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"pgstat.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"pg_trace.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"postmaster/postmaster.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"replication/slot.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/ipc.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/predicate.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/proc.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/proclist.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/spin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/memutils.h"</span> 
 
<span class='Directive'>#ifdef</span> LWLOCK_STATS 
<span class='Keyword'>#include </span><span class='String'>"utils/hsearch.h"</span> 
<span class='Directive'>#endif</span> 
 
 
<span class='Comment_Multi_Line'>/* We use the ShmemLock spinlock to protect LWLockCounter */ 
</span><a name="LN96"></a><span class='Keyword'>extern </span><a href="../../../include/storage/s_lock.h.html#LN137"><span class='Ref_to_Typedef'>slock_t</span></a> <span class='Operator'>*</span><span class='Declare_Var'>ShmemLock</span><span class='Delimiter'>; 
</span> 
<a name="LN98"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>LW_FLAG_HAS_WAITERS</span>         <span class='Parentheses'>((</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><span class='Number'>1</span> <span class='Operator'>&LT;&LT; </span><span class='Number'>30</span><span class='Parentheses'>)</span> 
<a name="LN99"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>LW_FLAG_RELEASE_OK</span>          <span class='Parentheses'>((</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><span class='Number'>1</span> <span class='Operator'>&LT;&LT; </span><span class='Number'>29</span><span class='Parentheses'>)</span> 
<a name="LN100"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>LW_FLAG_LOCKED</span>              <span class='Parentheses'>((</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><span class='Number'>1</span> <span class='Operator'>&LT;&LT; </span><span class='Number'>28</span><span class='Parentheses'>)</span> 
 
<a name="LN102"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>LW_VAL_EXCLUSIVE</span>            <span class='Parentheses'>((</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><span class='Number'>1</span> <span class='Operator'>&LT;&LT; </span><span class='Number'>24</span><span class='Parentheses'>)</span> 
<a name="LN103"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>LW_VAL_SHARED</span>               <span class='Number'>1</span> 
 
<a name="LN105"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>LW_LOCK_MASK</span>                <span class='Parentheses'>((</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>)</span> <span class='Parentheses'>((</span><span class='Number'>1</span> <span class='Operator'>&LT;&LT; </span><span class='Number'>25</span><span class='Parentheses'>)</span><span class='Operator'>-</span><span class='Number'>1</span><span class='Parentheses'>))</span> 
<span class='Comment_Multi_Line'>/* Must be greater than MAX_BACKENDS - which is 2^23-1, so we're fine. */ 
</span><a name="LN107"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>LW_SHARED_MASK</span>              <span class='Parentheses'>((</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>)</span> <span class='Parentheses'>((</span><span class='Number'>1</span> <span class='Operator'>&LT;&LT; </span><span class='Number'>24</span><span class='Parentheses'>)</span><span class='Operator'>-</span><span class='Number'>1</span><span class='Parentheses'>))</span> 
 
<span class='Comment_Multi_Line'>/* 
 * This is indexed by tranche ID and stores the names of all tranches known 
 * to the current backend. 
 */ 
</span><a name="LN113"></a><span class='Keyword'>static char </span><span class='Operator'>**</span><span class='Declare_Var'>LWLockTrancheArray</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN114"></a><span class='Keyword'>static int</span>  <span class='Declare_Var'>LWLockTranchesAllocated</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
<a name="LN116"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>T_NAME</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>lock</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Parentheses'>(</span><a href="lwlock.c.html#LN113"><span class='Ref_to_Global_Var'>LWLockTrancheArray</span></a><span class='Delimiter'>[</span><span class='Parentheses'>(</span><a href="lwlock.c.html#LN116"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>tranche<span class='Delimiter'>]</span><span class='Parentheses'>)</span> 
 
<span class='Comment_Multi_Line'>/* 
 * This points to the main array of LWLocks in shared memory.  Backends inherit 
 * the pointer by fork from the postmaster (except in the EXEC_BACKEND case, 
 * where we have special measures to pass it down). 
 */ 
</span><a name="LN124"></a><a href="../../../include/storage/lwlock.h.html#LN76"><span class='Ref_to_Union'>LWLockPadded</span></a> <span class='Operator'>*</span><span class='Declare_Var'>MainLWLockArray</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * We use this structure to keep track of locked LWLocks for release 
 * during error recovery.  Normally, only a few will be held at once, but 
 * occasionally the number can be much higher; for example, the pg_buffercache 
 * extension locks all buffer partitions simultaneously. 
 */ 
</span><a name="LN132"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>MAX_SIMUL_LWLOCKS</span>   <span class='Number'>200</span> 
 
<span class='Comment_Multi_Line'>/* struct representing the LWLocks we're holding */ 
</span><a name="LN135"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>LWLockHandle</span> 
<span class='Delimiter'>{ 
</span><a name="LN137"></a>    <a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a>     <span class='Operator'>*</span><span class='Declare_Member'>lock</span><span class='Delimiter'>; 
</span><a name="LN138"></a>    <a href="../../../include/storage/lwlock.h.html#LN131"><span class='Ref_to_Enum'>LWLockMode</span></a>  <span class='Declare_Member'>mode</span><span class='Delimiter'>; 
</span><a name="LN139"></a>} <span class='Declare_Typedef'>LWLockHandle</span><span class='Delimiter'>; 
</span> 
<a name="LN141"></a><span class='Keyword'>static int</span>  <span class='Declare_Var'>num_held_lwlocks</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN142"></a><span class='Keyword'>static </span><a href="lwlock.c.html#LN135"><span class='Ref_to_Struct'>LWLockHandle</span></a> <span class='Declare_Var'>held_lwlocks</span><span class='Delimiter'>[</span><a href="lwlock.c.html#LN132"><span class='Ref_to_Const'>MAX_SIMUL_LWLOCKS</span></a><span class='Delimiter'>]; 
</span> 
<span class='Comment_Multi_Line'>/* struct representing the LWLock tranche request for named tranche */ 
</span><a name="LN145"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>NamedLWLockTrancheRequest</span> 
<span class='Delimiter'>{ 
</span><a name="LN147"></a>    <span class='Keyword'>char</span>        <span class='Declare_Member'>tranche_name</span><span class='Delimiter'>[</span><a href="../../../interfaces/ecpg/include/sqlda-native.h.html#LN15"><span class='Ref_to_Const'>NAMEDATALEN</span></a><span class='Delimiter'>]; 
</span><a name="LN148"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>num_lwlocks</span><span class='Delimiter'>; 
</span><a name="LN149"></a>} <span class='Declare_Typedef'>NamedLWLockTrancheRequest</span><span class='Delimiter'>; 
</span> 
<a name="LN151"></a><a href="lwlock.c.html#LN145"><span class='Ref_to_Struct'>NamedLWLockTrancheRequest</span></a> <span class='Operator'>*</span><span class='Declare_Var'>NamedLWLockTrancheRequestArray</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN152"></a><span class='Keyword'>static int</span>  <span class='Declare_Var'>NamedLWLockTrancheRequestsAllocated</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN153"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>NamedLWLockTrancheRequests</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
<a name="LN155"></a><a href="../../../include/storage/lwlock.h.html#LN93"><span class='Ref_to_Struct'>NamedLWLockTranche</span></a> <span class='Operator'>*</span><span class='Declare_Var'>NamedLWLockTrancheArray</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
<a name="LN157"></a><span class='Keyword'>static bool </span><span class='Declare_Var'>lock_named_request_allowed</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
<a name="LN159"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>InitializeLWLocks</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN160"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>RegisterLWLockTranches</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<a name="LN162"></a><span class='Keyword'>static inline void </span><span class='Declare_Prototype'>LWLockReportWaitStart</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>lock</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN163"></a><span class='Keyword'>static inline void </span><span class='Declare_Prototype'>LWLockReportWaitEnd</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> LWLOCK_STATS 
<a name="LN166"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>lwlock_stats_key</span> 
<span class='Delimiter'>{ 
</span><a name="LN168"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>tranche</span><span class='Delimiter'>; 
</span><a name="LN169"></a>    <span class='Keyword'>void</span>       <span class='Operator'>*</span><span class='Declare_Member'>instance</span><span class='Delimiter'>; 
</span><a name="LN170"></a>}   <span class='Declare_Typedef'>lwlock_stats_key</span><span class='Delimiter'>; 
</span> 
<a name="LN172"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>lwlock_stats</span> 
<span class='Delimiter'>{ 
</span><a name="LN174"></a>    <a href="lwlock.c.html#LN166"><span class='Ref_to_Struct'>lwlock_stats_key</span></a> <span class='Declare_Member'>key</span><span class='Delimiter'>; 
</span><a name="LN175"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>sh_acquire_count</span><span class='Delimiter'>; 
</span><a name="LN176"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>ex_acquire_count</span><span class='Delimiter'>; 
</span><a name="LN177"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>block_count</span><span class='Delimiter'>; 
</span><a name="LN178"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>dequeue_self_count</span><span class='Delimiter'>; 
</span><a name="LN179"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>spin_delay_count</span><span class='Delimiter'>; 
</span><a name="LN180"></a>}   <span class='Declare_Typedef'>lwlock_stats</span><span class='Delimiter'>; 
</span> 
<a name="LN182"></a><span class='Keyword'>static </span><a href="../../utils/hash/dynahash.c.html#LN192"><span class='Ref_to_Struct'>HTAB</span></a> <span class='Operator'>*</span><span class='Declare_Var'>lwlock_stats_htab</span><span class='Delimiter'>; 
</span><a name="LN183"></a><span class='Keyword'>static </span><a href="lwlock.c.html#LN172"><span class='Ref_to_Struct'>lwlock_stats</span></a> <span class='Declare_Var'>lwlock_stats_dummy</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
<span class='Directive'>#ifdef</span> LOCK_DEBUG 
<a name="LN187"></a><span class='Keyword'>bool</span>        <span class='Declare_Var'>Trace_lwlocks</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
<span class='Keyword'>inline static void 
</span><a name="LN190"></a><span class='Declare_Function'>PRINT_LWDEBUG</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>where</span><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>lock</span><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN131"><span class='Ref_to_Enum'>LWLockMode</span></a> <span class='Declare_Parameter'>mode</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* hide statement & context here, otherwise the log is just too verbose */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN187"><span class='Ref_to_Global_Var'>Trace_lwlocks</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN195"></a>        <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>state</span> <span class='Operator'>= </span><a href="../../../include/port/atomics.h.html#LN250"><span class='Ref_to_Func'>pg_atomic_read_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN190"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN34"><span class='Ref_to_Member'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN1066"><span class='Ref_to_Func'>errhidestmt</span></a><span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN1085"><span class='Ref_to_Func'>errhidecontext</span></a><span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN825"><span class='Ref_to_Func'>errmsg_internal</span></a><span class='Parentheses'>(</span><span class='String'>"%d: %s(%s %p): excl %u shared %u haswaiters %u waiters %u rOK %d"</span><span class='Delimiter'>, 
</span>                                 <a href="../../utils/init/globals.c.html#LN38"><span class='Ref_to_Global_Var'>MyProcPid</span></a><span class='Delimiter'>, 
</span>                                 <a href="lwlock.c.html#LN190"><span class='Ref_to_Parameter'>where</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN116"><span class='Ref_to_Macro'>T_NAME</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN190"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN190"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>, 
</span>                                 <span class='Parentheses'>(</span><a href="lwlock.c.html#LN195"><span class='Ref_To_Local'>state</span></a> <span class='Operator'>& </span><a href="lwlock.c.html#LN102"><span class='Ref_to_Const'>LW_VAL_EXCLUSIVE</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Delimiter'>, 
</span>                                 <a href="lwlock.c.html#LN195"><span class='Ref_To_Local'>state</span></a> <span class='Operator'>& </span><a href="lwlock.c.html#LN107"><span class='Ref_to_Const'>LW_SHARED_MASK</span></a><span class='Delimiter'>, 
</span>                                 <span class='Parentheses'>(</span><a href="lwlock.c.html#LN195"><span class='Ref_To_Local'>state</span></a> <span class='Operator'>& </span><a href="lwlock.c.html#LN98"><span class='Ref_to_Const'>LW_FLAG_HAS_WAITERS</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Delimiter'>, 
</span>                                 <a href="../../../include/port/atomics.h.html#LN250"><span class='Ref_to_Func'>pg_atomic_read_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN190"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN37"><span class='Ref_to_Member'>nwaiters</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                 <span class='Parentheses'>(</span><a href="lwlock.c.html#LN195"><span class='Ref_To_Local'>state</span></a> <span class='Operator'>& </span><a href="lwlock.c.html#LN99"><span class='Ref_to_Const'>LW_FLAG_RELEASE_OK</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end PRINT_LWDEBUG &raquo; </span> 
 
<span class='Keyword'>inline static void 
</span><a name="LN212"></a><span class='Declare_Function'>LOG_LWDEBUG</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>where</span><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>lock</span><span class='Delimiter'>, </span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>msg</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* hide statement & context here, otherwise the log is just too verbose */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN187"><span class='Ref_to_Global_Var'>Trace_lwlocks</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN1066"><span class='Ref_to_Func'>errhidestmt</span></a><span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN1085"><span class='Ref_to_Func'>errhidecontext</span></a><span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN825"><span class='Ref_to_Func'>errmsg_internal</span></a><span class='Parentheses'>(</span><span class='String'>"%s(%s %p): %s"</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN212"><span class='Ref_to_Parameter'>where</span></a><span class='Delimiter'>, 
</span>                                 <a href="lwlock.c.html#LN116"><span class='Ref_to_Macro'>T_NAME</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN212"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN212"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN212"><span class='Ref_to_Parameter'>msg</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
} 
</span> 
<span class='Directive'>#else</span>                           <span class='Comment_Single_Line'>/* not LOCK_DEBUG */ 
</span><a name="LN226"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>PRINT_LWDEBUG</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>a</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>b</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>c</span><span class='Parentheses'>) ((</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Number'>0</span><span class='Parentheses'>)</span> 
<a name="LN227"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>LOG_LWDEBUG</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>a</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>b</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>c</span><span class='Parentheses'>) ((</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Number'>0</span><span class='Parentheses'>)</span> 
<span class='Directive'>#endif</span>   <span class='Comment_Single_Line'>/* LOCK_DEBUG */ 
</span> 
<span class='Directive'>#ifdef</span> LWLOCK_STATS 
 
<a name="LN232"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>init_lwlock_stats</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN233"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>print_lwlock_stats</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>code</span><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>arg</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN234"></a><span class='Keyword'>static </span><a href="lwlock.c.html#LN172"><span class='Ref_to_Struct'>lwlock_stats</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>get_lwlock_stats_entry</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>lockid</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Keyword'>static void 
</span><a name="LN237"></a><span class='Declare_Function'>init_lwlock_stats</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN239"></a>    <a href="../../../include/utils/hsearch.h.html#LN64"><span class='Ref_to_Struct'>HASHCTL</span></a>     <span class='Declare_Local'>ctl</span><span class='Delimiter'>; 
</span><a name="LN240"></a>    <span class='Keyword'>static </span><a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>lwlock_stats_cxt</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN241"></a>    <span class='Keyword'>static bool </span><span class='Declare_Local'>exit_registered</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN240"><span class='Ref_To_Local'>lwlock_stats_cxt</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/memutils.h.html#LN74"><span class='Ref_to_Proto'>MemoryContextDelete</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN240"><span class='Ref_To_Local'>lwlock_stats_cxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The LWLock stats will be updated within a critical section, which 
     * requires allocating new hash entries. Allocations within a critical 
     * section are normally not allowed because running out of memory would 
     * lead to a PANIC, but LWLOCK_STATS is debugging code that's not normally 
     * turned on in production, so that's an acceptable risk. The hash entries 
     * are small, so the risk of running out of memory is minimal in practice. 
     */ 
</span>    <a href="lwlock.c.html#LN240"><span class='Ref_To_Local'>lwlock_stats_cxt</span></a> <span class='Operator'>= </span><a href="../../../include/utils/memutils.h.html#LN145"><span class='Ref_to_Proto'>AllocSetContextCreate</span></a><span class='Parentheses'>(</span><a href="../../utils/mmgr/mcxt.c.html#LN42"><span class='Ref_to_Global_Var'>TopMemoryContext</span></a><span class='Delimiter'>, 
</span>                                             <span class='String'>"LWLock stats"</span><span class='Delimiter'>, 
</span>                                             <a href="../../../include/utils/memutils.h.html#LN164"><span class='Ref_to_Const'>ALLOCSET_DEFAULT_SIZES</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/utils/memutils.h.html#LN85"><span class='Ref_to_Proto'>MemoryContextAllowInCriticalSection</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN240"><span class='Ref_To_Local'>lwlock_stats_cxt</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN239"><span class='Ref_To_Local'>ctl</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="lwlock.c.html#LN239"><span class='Ref_To_Local'>ctl</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="lwlock.c.html#LN239"><span class='Ref_To_Local'>ctl</span></a><span class='Operator'>.</span><a href="../../../include/utils/hsearch.h.html#LN71"><span class='Ref_to_Member'>keysize</span></a> <span class='Operator'>= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="lwlock.c.html#LN166"><span class='Ref_to_Struct'>lwlock_stats_key</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="lwlock.c.html#LN239"><span class='Ref_To_Local'>ctl</span></a><span class='Operator'>.</span><a href="../../../include/utils/hsearch.h.html#LN72"><span class='Ref_to_Member'>entrysize</span></a> <span class='Operator'>= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="lwlock.c.html#LN172"><span class='Ref_to_Struct'>lwlock_stats</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="lwlock.c.html#LN239"><span class='Ref_To_Local'>ctl</span></a><span class='Operator'>.</span><a href="../../../include/utils/hsearch.h.html#LN77"><span class='Ref_to_Member'>hcxt</span></a> <span class='Operator'>= </span><a href="lwlock.c.html#LN240"><span class='Ref_To_Local'>lwlock_stats_cxt</span></a><span class='Delimiter'>; 
</span>    <a href="lwlock.c.html#LN182"><span class='Ref_to_Global_Var'>lwlock_stats_htab</span></a> <span class='Operator'>= </span><a href="../../../include/utils/hsearch.h.html#LN121"><span class='Ref_to_Proto'>hash_create</span></a><span class='Parentheses'>(</span><span class='String'>"lwlock stats"</span><span class='Delimiter'>, </span><span class='Number'>16384</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="lwlock.c.html#LN239"><span class='Ref_To_Local'>ctl</span></a><span class='Delimiter'>, 
</span>                                    <a href="../../../include/utils/hsearch.h.html#LN86"><span class='Ref_to_Const'>HASH_ELEM</span></a> <span class='Operator'>| </span><a href="../../../include/utils/hsearch.h.html#LN87"><span class='Ref_to_Const'>HASH_BLOBS</span></a> <span class='Operator'>| </span><a href="../../../include/utils/hsearch.h.html#LN92"><span class='Ref_to_Const'>HASH_CONTEXT</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="lwlock.c.html#LN241"><span class='Ref_To_Local'>exit_registered</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/storage/ipc.h.html#LN69"><span class='Ref_to_Proto'>on_shmem_exit</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN233"><span class='Ref_to_Proto'>print_lwlock_stats</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="lwlock.c.html#LN241"><span class='Ref_To_Local'>exit_registered</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end init_lwlock_stats &raquo; </span> 
 
<span class='Keyword'>static void 
</span><a name="LN273"></a><span class='Declare_Function'>print_lwlock_stats</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>code</span><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>arg</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN275"></a>    <a href="../../../include/utils/hsearch.h.html#LN111"><span class='Ref_to_Typedef'>HASH_SEQ_STATUS</span></a> <span class='Declare_Local'>scan</span><span class='Delimiter'>; 
</span><a name="LN276"></a>    <a href="lwlock.c.html#LN172"><span class='Ref_to_Struct'>lwlock_stats</span></a> <span class='Operator'>*</span><span class='Declare_Local'>lwstats</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/hsearch.h.html#LN134"><span class='Ref_to_Proto'>hash_seq_init</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN275"><span class='Ref_To_Local'>scan</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN182"><span class='Ref_to_Global_Var'>lwlock_stats_htab</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Grab an LWLock to keep different backends from mixing reports */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN124"><span class='Ref_to_Global_Var'>MainLWLockArray</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/storage/lwlock.h.html#LN78"><span class='Ref_to_Member'>lock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>while</span> <span class='Parentheses'>((</span><a href="lwlock.c.html#LN276"><span class='Ref_To_Local'>lwstats</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="lwlock.c.html#LN172"><span class='Ref_to_Struct'>lwlock_stats</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/utils/hsearch.h.html#LN135"><span class='Ref_to_Proto'>hash_seq_search</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN275"><span class='Ref_To_Local'>scan</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../../contrib/seg/segscan.l.html#LN10"><span class='Ref_to_Macro'>fprintf</span></a><span class='Parentheses'>(</span>stderr<span class='Delimiter'>, 
</span>                <span class='String'>"PID %d lwlock %s %p: shacq %u exacq %u blk %u spindelay %u dequeue self %u\n"</span><span class='Delimiter'>, 
</span>                <a href="../../utils/init/globals.c.html#LN38"><span class='Ref_to_Global_Var'>MyProcPid</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN113"><span class='Ref_to_Global_Var'>LWLockTrancheArray</span></a><span class='Delimiter'>[</span><a href="lwlock.c.html#LN276"><span class='Ref_To_Local'>lwstats</span></a><span class='Operator'>-&GT;</span><a href="lwlock.c.html#LN174"><span class='Ref_to_Member'>key</span></a><span class='Operator'>.</span><a href="lwlock.c.html#LN168"><span class='Ref_to_Member'>tranche</span></a><span class='Delimiter'>], 
</span>                <a href="lwlock.c.html#LN276"><span class='Ref_To_Local'>lwstats</span></a><span class='Operator'>-&GT;</span><a href="lwlock.c.html#LN174"><span class='Ref_to_Member'>key</span></a><span class='Operator'>.</span><a href="lwlock.c.html#LN169"><span class='Ref_to_Member'>instance</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN276"><span class='Ref_To_Local'>lwstats</span></a><span class='Operator'>-&GT;</span><a href="lwlock.c.html#LN175"><span class='Ref_to_Member'>sh_acquire_count</span></a><span class='Delimiter'>, 
</span>                <a href="lwlock.c.html#LN276"><span class='Ref_To_Local'>lwstats</span></a><span class='Operator'>-&GT;</span><a href="lwlock.c.html#LN176"><span class='Ref_to_Member'>ex_acquire_count</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN276"><span class='Ref_To_Local'>lwstats</span></a><span class='Operator'>-&GT;</span><a href="lwlock.c.html#LN177"><span class='Ref_to_Member'>block_count</span></a><span class='Delimiter'>, 
</span>                <a href="lwlock.c.html#LN276"><span class='Ref_To_Local'>lwstats</span></a><span class='Operator'>-&GT;</span><a href="lwlock.c.html#LN179"><span class='Ref_to_Member'>spin_delay_count</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN276"><span class='Ref_To_Local'>lwstats</span></a><span class='Operator'>-&GT;</span><a href="lwlock.c.html#LN178"><span class='Ref_to_Member'>dequeue_self_count</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN124"><span class='Ref_to_Global_Var'>MainLWLockArray</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/storage/lwlock.h.html#LN78"><span class='Ref_to_Member'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end print_lwlock_stats &raquo; </span> 
 
<span class='Keyword'>static </span><a href="lwlock.c.html#LN172"><span class='Ref_to_Struct'>lwlock_stats</span></a> <span class='Operator'>* 
</span><a name="LN297"></a><span class='Declare_Function'>get_lwlock_stats_entry</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>lock</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN299"></a>    <a href="lwlock.c.html#LN166"><span class='Ref_to_Struct'>lwlock_stats_key</span></a> <span class='Declare_Local'>key</span><span class='Delimiter'>; 
</span><a name="LN300"></a>    <a href="lwlock.c.html#LN172"><span class='Ref_to_Struct'>lwlock_stats</span></a> <span class='Operator'>*</span><span class='Declare_Local'>lwstats</span><span class='Delimiter'>; 
</span><a name="LN301"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * During shared memory initialization, the hash table doesn't exist yet. 
     * Stats of that phase aren't very interesting, so just collect operations 
     * on all locks in a single dummy entry. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN182"><span class='Ref_to_Global_Var'>lwlock_stats_htab</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Operator'>&</span><a href="lwlock.c.html#LN183"><span class='Ref_to_Global_Var'>lwlock_stats_dummy</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Fetch or create the entry. */ 
</span>    <a href="lwlock.c.html#LN299"><span class='Ref_To_Local'>key</span></a><span class='Operator'>.</span><a href="lwlock.c.html#LN168"><span class='Ref_to_Member'>tranche</span></a> <span class='Operator'>= </span><a href="lwlock.c.html#LN297"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN33"><span class='Ref_to_Member'>tranche</span></a><span class='Delimiter'>; 
</span>    <a href="lwlock.c.html#LN299"><span class='Ref_To_Local'>key</span></a><span class='Operator'>.</span><a href="lwlock.c.html#LN169"><span class='Ref_to_Member'>instance</span></a> <span class='Operator'>= </span><a href="lwlock.c.html#LN297"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>; 
</span>    <a href="lwlock.c.html#LN300"><span class='Ref_To_Local'>lwstats</span></a> <span class='Operator'>= </span><a href="../../../include/utils/hsearch.h.html#LN125"><span class='Ref_to_Proto'>hash_search</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN182"><span class='Ref_to_Global_Var'>lwlock_stats_htab</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="lwlock.c.html#LN299"><span class='Ref_To_Local'>key</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/hsearch.h.html#LN105"><span class='Ref_to_EnumConst'>HASH_ENTER</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="lwlock.c.html#LN301"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="lwlock.c.html#LN301"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="lwlock.c.html#LN300"><span class='Ref_To_Local'>lwstats</span></a><span class='Operator'>-&GT;</span><a href="lwlock.c.html#LN175"><span class='Ref_to_Member'>sh_acquire_count</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="lwlock.c.html#LN300"><span class='Ref_To_Local'>lwstats</span></a><span class='Operator'>-&GT;</span><a href="lwlock.c.html#LN176"><span class='Ref_to_Member'>ex_acquire_count</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="lwlock.c.html#LN300"><span class='Ref_To_Local'>lwstats</span></a><span class='Operator'>-&GT;</span><a href="lwlock.c.html#LN177"><span class='Ref_to_Member'>block_count</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="lwlock.c.html#LN300"><span class='Ref_To_Local'>lwstats</span></a><span class='Operator'>-&GT;</span><a href="lwlock.c.html#LN178"><span class='Ref_to_Member'>dequeue_self_count</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="lwlock.c.html#LN300"><span class='Ref_To_Local'>lwstats</span></a><span class='Operator'>-&GT;</span><a href="lwlock.c.html#LN179"><span class='Ref_to_Member'>spin_delay_count</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <a href="lwlock.c.html#LN300"><span class='Ref_To_Local'>lwstats</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end get_lwlock_stats_entry &raquo; </span> 
<span class='Directive'>#endif</span>   <span class='Comment_Single_Line'>/* LWLOCK_STATS */ 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Compute number of LWLocks required by named tranches.  These will be 
 * allocated in the main array. 
 */ 
</span><span class='Keyword'>static int 
</span><a name="LN333"></a><span class='Declare_Function'>NumLWLocksByNamedTranches</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN335"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numLocks</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN336"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN336"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="lwlock.c.html#LN336"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="lwlock.c.html#LN153"><span class='Ref_to_Global_Var'>NamedLWLockTrancheRequests</span></a><span class='Delimiter'>; </span><a href="lwlock.c.html#LN336"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <a href="lwlock.c.html#LN335"><span class='Ref_To_Local'>numLocks</span></a> <span class='Operator'>+= </span><a href="lwlock.c.html#LN151"><span class='Ref_to_Global_Var'>NamedLWLockTrancheRequestArray</span></a><span class='Delimiter'>[</span><a href="lwlock.c.html#LN336"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="lwlock.c.html#LN148"><span class='Ref_to_Member'>num_lwlocks</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="lwlock.c.html#LN335"><span class='Ref_To_Local'>numLocks</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Compute shmem space needed for LWLocks and named tranches. 
 */ 
</span><a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a> 
<a name="LN348"></a><span class='Declare_Function'>LWLockShmemSize</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN350"></a>    <a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Local'>size</span><span class='Delimiter'>; 
</span><a name="LN351"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN352"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numLocks</span> <span class='Operator'>= </span><a href="../../../include/storage/lwlock.h.html#LN128"><span class='Ref_to_Const'>NUM_FIXED_LWLOCKS</span></a><span class='Delimiter'>; 
</span> 
    <a href="lwlock.c.html#LN352"><span class='Ref_To_Local'>numLocks</span></a> <span class='Operator'>+= </span><a href="lwlock.c.html#LN332"><span class='Ref_to_Func'>NumLWLocksByNamedTranches</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Space for the LWLock array. */ 
</span>    <a href="lwlock.c.html#LN350"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN45"><span class='Ref_to_Proto'>mul_size</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN352"><span class='Ref_To_Local'>numLocks</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN76"><span class='Ref_to_Union'>LWLockPadded</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Space for dynamic allocation counter, plus room for alignment. */ 
</span>    <a href="lwlock.c.html#LN350"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN350"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><span class='Operator'>+ </span><a href="../../../include/storage/lwlock.h.html#LN72"><span class='Ref_to_Const'>LWLOCK_PADDED_SIZE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* space for named tranches. */ 
</span>    <a href="lwlock.c.html#LN350"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN350"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/shmem.h.html#LN45"><span class='Ref_to_Proto'>mul_size</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN153"><span class='Ref_to_Global_Var'>NamedLWLockTrancheRequests</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN93"><span class='Ref_to_Struct'>NamedLWLockTranche</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* space for name of each tranche. */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN351"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="lwlock.c.html#LN351"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="lwlock.c.html#LN153"><span class='Ref_to_Global_Var'>NamedLWLockTrancheRequests</span></a><span class='Delimiter'>; </span><a href="lwlock.c.html#LN351"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <a href="lwlock.c.html#LN350"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN350"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, </span>strlen<span class='Parentheses'>(</span><a href="lwlock.c.html#LN151"><span class='Ref_to_Global_Var'>NamedLWLockTrancheRequestArray</span></a><span class='Delimiter'>[</span><a href="lwlock.c.html#LN351"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="lwlock.c.html#LN147"><span class='Ref_to_Member'>tranche_name</span></a><span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Disallow named LWLocks' requests after startup */ 
</span>    <a href="lwlock.c.html#LN157"><span class='Ref_to_Global_Var'>lock_named_request_allowed</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="lwlock.c.html#LN350"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end LWLockShmemSize &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Allocate shmem space for the main LWLock array and all tranches and 
 * initialize it.  We also register all the LWLock tranches here. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN380"></a><span class='Declare_Function'>CreateLWLocks</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/c.h.html#LN753"><span class='Ref_to_Macro'>StaticAssertExpr</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN102"><span class='Ref_to_Const'>LW_VAL_EXCLUSIVE</span></a> <span class='Operator'>&GT; </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="../../../include/postmaster/postmaster.h.html#LN74"><span class='Ref_to_Const'>MAX_BACKENDS</span></a><span class='Delimiter'>, 
</span>                     <span class='String'>"MAX_BACKENDS too big for lwlock.c"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/c.h.html#LN753"><span class='Ref_to_Macro'>StaticAssertExpr</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a><span class='Parentheses'>) </span><span class='Operator'>&LT;= </span><a href="../../../include/storage/lwlock.h.html#LN73"><span class='Ref_to_Const'>LWLOCK_MINIMAL_SIZE</span></a> <span class='Operator'>&& 
</span>                     <span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a><span class='Parentheses'>) </span><span class='Operator'>&LT;= </span><a href="../../../include/storage/lwlock.h.html#LN72"><span class='Ref_to_Const'>LWLOCK_PADDED_SIZE</span></a><span class='Delimiter'>, 
</span>                     <span class='String'>"Miscalculated LWLock padding"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../utils/init/globals.c.html#LN100"><span class='Ref_to_Global_Var'>IsUnderPostmaster</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN391"></a>        <a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Local'>spaceLocks</span> <span class='Operator'>= </span><a href="../../../include/storage/lwlock.h.html#LN157"><span class='Ref_to_Proto'>LWLockShmemSize</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span><a name="LN392"></a>        <span class='Keyword'>int</span>        <span class='Operator'>*</span><span class='Declare_Local'>LWLockCounter</span><span class='Delimiter'>; 
</span><a name="LN393"></a>        <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>ptr</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Allocate space */ 
</span>        <a href="lwlock.c.html#LN393"><span class='Ref_To_Local'>ptr</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/storage/shmem.h.html#LN36"><span class='Ref_to_Proto'>ShmemAlloc</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN391"><span class='Ref_To_Local'>spaceLocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Leave room for dynamic allocation of tranches */ 
</span>        <a href="lwlock.c.html#LN393"><span class='Ref_To_Local'>ptr</span></a> <span class='Operator'>+= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Ensure desired alignment of LWLock array */ 
</span>        <a href="lwlock.c.html#LN393"><span class='Ref_To_Local'>ptr</span></a> <span class='Operator'>+= </span><a href="../../../include/storage/lwlock.h.html#LN72"><span class='Ref_to_Const'>LWLOCK_PADDED_SIZE</span></a> <span class='Operator'>- </span><span class='Parentheses'>((</span>uintptr_t<span class='Parentheses'>) </span><a href="lwlock.c.html#LN393"><span class='Ref_To_Local'>ptr</span></a><span class='Parentheses'>)</span> <span class='Operator'>% </span><a href="../../../include/storage/lwlock.h.html#LN72"><span class='Ref_to_Const'>LWLOCK_PADDED_SIZE</span></a><span class='Delimiter'>; 
</span> 
        <a href="lwlock.c.html#LN124"><span class='Ref_to_Global_Var'>MainLWLockArray</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN76"><span class='Ref_to_Union'>LWLockPadded</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="lwlock.c.html#LN393"><span class='Ref_To_Local'>ptr</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Initialize the dynamic-allocation counter for tranches, which is 
         * stored just before the first LWLock. 
         */ 
</span>        <a href="lwlock.c.html#LN392"><span class='Ref_To_Local'>LWLockCounter</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Operator'>*</span><span class='Parentheses'>) ((</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="lwlock.c.html#LN124"><span class='Ref_to_Global_Var'>MainLWLockArray</span></a> <span class='Operator'>- </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="lwlock.c.html#LN392"><span class='Ref_To_Local'>LWLockCounter</span></a> <span class='Operator'>= </span><a href="../../../include/storage/lwlock.h.html#LN215"><span class='Ref_to_EnumConst'>LWTRANCHE_FIRST_USER_DEFINED</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Initialize all LWLocks */ 
</span>        <a href="lwlock.c.html#LN159"><span class='Ref_to_Proto'>InitializeLWLocks</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !IsUnderPostmaster &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Register all LWLock tranches */ 
</span>    <a href="lwlock.c.html#LN160"><span class='Ref_to_Proto'>RegisterLWLockTranches</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end CreateLWLocks &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Initialize LWLocks that are fixed and those belonging to named tranches. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN425"></a><span class='Declare_Function'>InitializeLWLocks</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN427"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numNamedLocks</span> <span class='Operator'>= </span><a href="lwlock.c.html#LN332"><span class='Ref_to_Func'>NumLWLocksByNamedTranches</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span><a name="LN428"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>id</span><span class='Delimiter'>; 
</span><a name="LN429"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN430"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>j</span><span class='Delimiter'>; 
</span><a name="LN431"></a>    <a href="../../../include/storage/lwlock.h.html#LN76"><span class='Ref_to_Union'>LWLockPadded</span></a> <span class='Operator'>*</span><span class='Declare_Local'>lock</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Initialize all individual LWLocks in main array */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN428"><span class='Ref_To_Local'>id</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN431"><span class='Ref_To_Local'>lock</span></a> <span class='Operator'>= </span><a href="lwlock.c.html#LN124"><span class='Ref_to_Global_Var'>MainLWLockArray</span></a><span class='Delimiter'>; </span><a href="lwlock.c.html#LN428"><span class='Ref_To_Local'>id</span></a> <span class='Operator'>&LT; </span>NUM_INDIVIDUAL_LWLOCKS<span class='Delimiter'>; </span><a href="lwlock.c.html#LN428"><span class='Ref_To_Local'>id</span></a><span class='Operator'>++</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN431"><span class='Ref_To_Local'>lock</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/lwlock.h.html#LN187"><span class='Ref_to_Proto'>LWLockInitialize</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN431"><span class='Ref_To_Local'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN78"><span class='Ref_to_Member'>lock</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN428"><span class='Ref_To_Local'>id</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Initialize buffer mapping LWLocks in main array */ 
</span>    <a href="lwlock.c.html#LN431"><span class='Ref_To_Local'>lock</span></a> <span class='Operator'>= </span><a href="lwlock.c.html#LN124"><span class='Ref_to_Global_Var'>MainLWLockArray</span></a> <span class='Operator'>+ </span>NUM_INDIVIDUAL_LWLOCKS<span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN428"><span class='Ref_To_Local'>id</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="lwlock.c.html#LN428"><span class='Ref_To_Local'>id</span></a> <span class='Operator'>&LT; </span><a href="../../../include/storage/lwlock.h.html#LN112"><span class='Ref_to_Const'>NUM_BUFFER_PARTITIONS</span></a><span class='Delimiter'>; </span><a href="lwlock.c.html#LN428"><span class='Ref_To_Local'>id</span></a><span class='Operator'>++</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN431"><span class='Ref_To_Local'>lock</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/lwlock.h.html#LN187"><span class='Ref_to_Proto'>LWLockInitialize</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN431"><span class='Ref_To_Local'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN78"><span class='Ref_to_Member'>lock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN210"><span class='Ref_to_EnumConst'>LWTRANCHE_BUFFER_MAPPING</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Initialize lmgrs' LWLocks in main array */ 
</span>    <a href="lwlock.c.html#LN431"><span class='Ref_To_Local'>lock</span></a> <span class='Operator'>= </span><a href="lwlock.c.html#LN124"><span class='Ref_to_Global_Var'>MainLWLockArray</span></a> <span class='Operator'>+ </span>NUM_INDIVIDUAL_LWLOCKS <span class='Operator'>+ </span><a href="../../../include/storage/lwlock.h.html#LN112"><span class='Ref_to_Const'>NUM_BUFFER_PARTITIONS</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN428"><span class='Ref_To_Local'>id</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="lwlock.c.html#LN428"><span class='Ref_To_Local'>id</span></a> <span class='Operator'>&LT; </span><a href="../../../include/storage/lwlock.h.html#LN116"><span class='Ref_to_Const'>NUM_LOCK_PARTITIONS</span></a><span class='Delimiter'>; </span><a href="lwlock.c.html#LN428"><span class='Ref_To_Local'>id</span></a><span class='Operator'>++</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN431"><span class='Ref_To_Local'>lock</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/lwlock.h.html#LN187"><span class='Ref_to_Proto'>LWLockInitialize</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN431"><span class='Ref_To_Local'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN78"><span class='Ref_to_Member'>lock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN211"><span class='Ref_to_EnumConst'>LWTRANCHE_LOCK_MANAGER</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Initialize predicate lmgrs' LWLocks in main array */ 
</span>    <a href="lwlock.c.html#LN431"><span class='Ref_To_Local'>lock</span></a> <span class='Operator'>= </span><a href="lwlock.c.html#LN124"><span class='Ref_to_Global_Var'>MainLWLockArray</span></a> <span class='Operator'>+ </span>NUM_INDIVIDUAL_LWLOCKS <span class='Operator'>+ 
</span>        <a href="../../../include/storage/lwlock.h.html#LN112"><span class='Ref_to_Const'>NUM_BUFFER_PARTITIONS</span></a> <span class='Operator'>+ </span><a href="../../../include/storage/lwlock.h.html#LN116"><span class='Ref_to_Const'>NUM_LOCK_PARTITIONS</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN428"><span class='Ref_To_Local'>id</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="lwlock.c.html#LN428"><span class='Ref_To_Local'>id</span></a> <span class='Operator'>&LT; </span><a href="../../../include/storage/lwlock.h.html#LN120"><span class='Ref_to_Const'>NUM_PREDICATELOCK_PARTITIONS</span></a><span class='Delimiter'>; </span><a href="lwlock.c.html#LN428"><span class='Ref_To_Local'>id</span></a><span class='Operator'>++</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN431"><span class='Ref_To_Local'>lock</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/lwlock.h.html#LN187"><span class='Ref_to_Proto'>LWLockInitialize</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN431"><span class='Ref_To_Local'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN78"><span class='Ref_to_Member'>lock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN212"><span class='Ref_to_EnumConst'>LWTRANCHE_PREDICATE_LOCK_MANAGER</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Initialize named tranches. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN153"><span class='Ref_to_Global_Var'>NamedLWLockTrancheRequests</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN456"></a>        <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>trancheNames</span><span class='Delimiter'>; 
</span> 
        <a href="lwlock.c.html#LN155"><span class='Ref_to_Global_Var'>NamedLWLockTrancheArray</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN93"><span class='Ref_to_Struct'>NamedLWLockTranche</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <span class='Operator'>&</span><a href="lwlock.c.html#LN124"><span class='Ref_to_Global_Var'>MainLWLockArray</span></a><span class='Delimiter'>[</span><a href="../../../include/storage/lwlock.h.html#LN128"><span class='Ref_to_Const'>NUM_FIXED_LWLOCKS</span></a> <span class='Operator'>+ </span><a href="lwlock.c.html#LN427"><span class='Ref_To_Local'>numNamedLocks</span></a><span class='Delimiter'>]; 
</span> 
        <a href="lwlock.c.html#LN456"><span class='Ref_To_Local'>trancheNames</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="lwlock.c.html#LN155"><span class='Ref_to_Global_Var'>NamedLWLockTrancheArray</span></a> <span class='Operator'>+ 
</span>            <span class='Parentheses'>(</span><a href="lwlock.c.html#LN153"><span class='Ref_to_Global_Var'>NamedLWLockTrancheRequests</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN93"><span class='Ref_to_Struct'>NamedLWLockTranche</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="lwlock.c.html#LN431"><span class='Ref_To_Local'>lock</span></a> <span class='Operator'>= &</span><a href="lwlock.c.html#LN124"><span class='Ref_to_Global_Var'>MainLWLockArray</span></a><span class='Delimiter'>[</span><a href="../../../include/storage/lwlock.h.html#LN128"><span class='Ref_to_Const'>NUM_FIXED_LWLOCKS</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN429"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="lwlock.c.html#LN429"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="lwlock.c.html#LN153"><span class='Ref_to_Global_Var'>NamedLWLockTrancheRequests</span></a><span class='Delimiter'>; </span><a href="lwlock.c.html#LN429"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN467"></a>            <a href="lwlock.c.html#LN145"><span class='Ref_to_Struct'>NamedLWLockTrancheRequest</span></a> <span class='Operator'>*</span><span class='Declare_Local'>request</span><span class='Delimiter'>; 
</span><a name="LN468"></a>            <a href="../../../include/storage/lwlock.h.html#LN93"><span class='Ref_to_Struct'>NamedLWLockTranche</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tranche</span><span class='Delimiter'>; 
</span><a name="LN469"></a>            <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>name</span><span class='Delimiter'>; 
</span> 
            <a href="lwlock.c.html#LN467"><span class='Ref_To_Local'>request</span></a> <span class='Operator'>= &</span><a href="lwlock.c.html#LN151"><span class='Ref_to_Global_Var'>NamedLWLockTrancheRequestArray</span></a><span class='Delimiter'>[</span><a href="lwlock.c.html#LN429"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>            <a href="lwlock.c.html#LN468"><span class='Ref_To_Local'>tranche</span></a> <span class='Operator'>= &</span><a href="lwlock.c.html#LN155"><span class='Ref_to_Global_Var'>NamedLWLockTrancheArray</span></a><span class='Delimiter'>[</span><a href="lwlock.c.html#LN429"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
            <a href="lwlock.c.html#LN469"><span class='Ref_To_Local'>name</span></a> <span class='Operator'>= </span><a href="lwlock.c.html#LN456"><span class='Ref_To_Local'>trancheNames</span></a><span class='Delimiter'>; 
</span>            <a href="lwlock.c.html#LN456"><span class='Ref_To_Local'>trancheNames</span></a> <span class='Operator'>+= </span>strlen<span class='Parentheses'>(</span><a href="lwlock.c.html#LN467"><span class='Ref_To_Local'>request</span></a><span class='Operator'>-&GT;</span><a href="lwlock.c.html#LN147"><span class='Ref_to_Member'>tranche_name</span></a><span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>            <a href="../../../../contrib/cube/cubeparse.y.html#LN150"><span class='Ref_to_Proto'>strcpy</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN469"><span class='Ref_To_Local'>name</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN467"><span class='Ref_To_Local'>request</span></a><span class='Operator'>-&GT;</span><a href="lwlock.c.html#LN147"><span class='Ref_to_Member'>tranche_name</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="lwlock.c.html#LN468"><span class='Ref_To_Local'>tranche</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN95"><span class='Ref_to_Member'>trancheId</span></a> <span class='Operator'>= </span><a href="../../../include/storage/lwlock.h.html#LN185"><span class='Ref_to_Proto'>LWLockNewTrancheId</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <a href="lwlock.c.html#LN468"><span class='Ref_To_Local'>tranche</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN96"><span class='Ref_to_Member'>trancheName</span></a> <span class='Operator'>= </span><a href="lwlock.c.html#LN469"><span class='Ref_To_Local'>name</span></a><span class='Delimiter'>; 
</span> 
            <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN430"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="lwlock.c.html#LN430"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>&LT; </span><a href="lwlock.c.html#LN467"><span class='Ref_To_Local'>request</span></a><span class='Operator'>-&GT;</span><a href="lwlock.c.html#LN148"><span class='Ref_to_Member'>num_lwlocks</span></a><span class='Delimiter'>; </span><a href="lwlock.c.html#LN430"><span class='Ref_To_Local'>j</span></a><span class='Operator'>++</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN431"><span class='Ref_To_Local'>lock</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>                <a href="../../../include/storage/lwlock.h.html#LN187"><span class='Ref_to_Proto'>LWLockInitialize</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN431"><span class='Ref_To_Local'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN78"><span class='Ref_to_Member'>lock</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN468"><span class='Ref_To_Local'>tranche</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN95"><span class='Ref_to_Member'>trancheId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if NamedLWLockTrancheReq... &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end InitializeLWLocks &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Register named tranches and tranches for fixed LWLocks. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN490"></a><span class='Declare_Function'>RegisterLWLockTranches</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN492"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN113"><span class='Ref_to_Global_Var'>LWLockTrancheArray</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="lwlock.c.html#LN114"><span class='Ref_to_Global_Var'>LWLockTranchesAllocated</span></a> <span class='Operator'>= </span><span class='Number'>64</span><span class='Delimiter'>; 
</span>        <a href="lwlock.c.html#LN113"><span class='Ref_to_Global_Var'>LWLockTrancheArray</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>**</span><span class='Parentheses'>) 
</span>            <a href="../../../include/utils/palloc.h.html#LN71"><span class='Ref_to_Proto'>MemoryContextAllocZero</span></a><span class='Parentheses'>(</span><a href="../../utils/mmgr/mcxt.c.html#LN42"><span class='Ref_to_Global_Var'>TopMemoryContext</span></a><span class='Delimiter'>, 
</span>                                   <a href="lwlock.c.html#LN114"><span class='Ref_to_Global_Var'>LWLockTranchesAllocated</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="lwlock.c.html#LN114"><span class='Ref_to_Global_Var'>LWLockTranchesAllocated</span></a> <span class='Operator'>&GT;= </span><a href="../../../include/storage/lwlock.h.html#LN215"><span class='Ref_to_EnumConst'>LWTRANCHE_FIRST_USER_DEFINED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN492"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="lwlock.c.html#LN492"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span>NUM_INDIVIDUAL_LWLOCKS<span class='Delimiter'>; </span><span class='Operator'>++</span><a href="lwlock.c.html#LN492"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/lwlock.h.html#LN186"><span class='Ref_to_Proto'>LWLockRegisterTranche</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN492"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN90"><span class='Ref_to_Global_Var'>MainLWLockNames</span></a><span class='Delimiter'>[</span><a href="lwlock.c.html#LN492"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN186"><span class='Ref_to_Proto'>LWLockRegisterTranche</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN210"><span class='Ref_to_EnumConst'>LWTRANCHE_BUFFER_MAPPING</span></a><span class='Delimiter'>, </span><span class='String'>"buffer_mapping"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN186"><span class='Ref_to_Proto'>LWLockRegisterTranche</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN211"><span class='Ref_to_EnumConst'>LWTRANCHE_LOCK_MANAGER</span></a><span class='Delimiter'>, </span><span class='String'>"lock_manager"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN186"><span class='Ref_to_Proto'>LWLockRegisterTranche</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN212"><span class='Ref_to_EnumConst'>LWTRANCHE_PREDICATE_LOCK_MANAGER</span></a><span class='Delimiter'>, 
</span>                          <span class='String'>"predicate_lock_manager"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN186"><span class='Ref_to_Proto'>LWLockRegisterTranche</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN213"><span class='Ref_to_EnumConst'>LWTRANCHE_PARALLEL_QUERY_DSA</span></a><span class='Delimiter'>, 
</span>                          <span class='String'>"parallel_query_dsa"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN186"><span class='Ref_to_Proto'>LWLockRegisterTranche</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN214"><span class='Ref_to_EnumConst'>LWTRANCHE_TBM</span></a><span class='Delimiter'>, </span><span class='String'>"tbm"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Register named tranches. */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN492"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="lwlock.c.html#LN492"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="lwlock.c.html#LN153"><span class='Ref_to_Global_Var'>NamedLWLockTrancheRequests</span></a><span class='Delimiter'>; </span><a href="lwlock.c.html#LN492"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/lwlock.h.html#LN186"><span class='Ref_to_Proto'>LWLockRegisterTranche</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN155"><span class='Ref_to_Global_Var'>NamedLWLockTrancheArray</span></a><span class='Delimiter'>[</span><a href="lwlock.c.html#LN492"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/storage/lwlock.h.html#LN95"><span class='Ref_to_Member'>trancheId</span></a><span class='Delimiter'>, 
</span>                              <a href="lwlock.c.html#LN155"><span class='Ref_to_Global_Var'>NamedLWLockTrancheArray</span></a><span class='Delimiter'>[</span><a href="lwlock.c.html#LN492"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/storage/lwlock.h.html#LN96"><span class='Ref_to_Member'>trancheName</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end RegisterLWLockTranches &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * InitLWLockAccess - initialize backend-local state needed to hold LWLocks 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN524"></a><span class='Declare_Function'>InitLWLockAccess</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><span class='Directive'>#ifdef</span> LWLOCK_STATS 
    <a href="lwlock.c.html#LN232"><span class='Ref_to_Proto'>init_lwlock_stats</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
<span class='Delimiter'>} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * GetNamedLWLockTranche - returns the base address of LWLock from the 
 *      specified tranche. 
 * 
 * Caller needs to retrieve the requested number of LWLocks starting from 
 * the base lock address returned by this API.  This can be used for 
 * tranches that are requested by using RequestNamedLWLockTranche() API. 
 */ 
</span><a href="../../../include/storage/lwlock.h.html#LN76"><span class='Ref_to_Union'>LWLockPadded</span></a> <span class='Operator'>* 
</span><a name="LN540"></a><span class='Declare_Function'>GetNamedLWLockTranche</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>tranche_name</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN542"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>lock_pos</span><span class='Delimiter'>; 
</span><a name="LN543"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Obtain the position of base address of LWLock belonging to requested 
     * tranche_name in MainLWLockArray.  LWLocks for named tranches are placed 
     * in MainLWLockArray after fixed locks. 
     */ 
</span>    <a href="lwlock.c.html#LN542"><span class='Ref_To_Local'>lock_pos</span></a> <span class='Operator'>= </span><a href="../../../include/storage/lwlock.h.html#LN128"><span class='Ref_to_Const'>NUM_FIXED_LWLOCKS</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN543"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="lwlock.c.html#LN543"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="lwlock.c.html#LN153"><span class='Ref_to_Global_Var'>NamedLWLockTrancheRequests</span></a><span class='Delimiter'>; </span><a href="lwlock.c.html#LN543"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="lwlock.c.html#LN151"><span class='Ref_to_Global_Var'>NamedLWLockTrancheRequestArray</span></a><span class='Delimiter'>[</span><a href="lwlock.c.html#LN543"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="lwlock.c.html#LN147"><span class='Ref_to_Member'>tranche_name</span></a><span class='Delimiter'>, 
</span>                   <a href="lwlock.c.html#LN540"><span class='Ref_to_Parameter'>tranche_name</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <span class='Control'>return</span> <span class='Operator'>&</span><a href="lwlock.c.html#LN124"><span class='Ref_to_Global_Var'>MainLWLockArray</span></a><span class='Delimiter'>[</span><a href="lwlock.c.html#LN542"><span class='Ref_To_Local'>lock_pos</span></a><span class='Delimiter'>]; 
</span> 
        <a href="lwlock.c.html#LN542"><span class='Ref_To_Local'>lock_pos</span></a> <span class='Operator'>+= </span><a href="lwlock.c.html#LN151"><span class='Ref_to_Global_Var'>NamedLWLockTrancheRequestArray</span></a><span class='Delimiter'>[</span><a href="lwlock.c.html#LN543"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="lwlock.c.html#LN148"><span class='Ref_to_Member'>num_lwlocks</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN543"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&GT;= </span><a href="lwlock.c.html#LN153"><span class='Ref_to_Global_Var'>NamedLWLockTrancheRequests</span></a><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"requested tranche is not registered"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* just to keep compiler quiet */ 
</span>    <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end GetNamedLWLockTranche &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Allocate a new tranche ID. 
 */ 
</span><span class='Keyword'>int 
</span><a name="LN571"></a><span class='Declare_Function'>LWLockNewTrancheId</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN573"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span><a name="LN574"></a>    <span class='Keyword'>int</span>        <span class='Operator'>*</span><span class='Declare_Local'>LWLockCounter</span><span class='Delimiter'>; 
</span> 
    <a href="lwlock.c.html#LN574"><span class='Ref_To_Local'>LWLockCounter</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Operator'>*</span><span class='Parentheses'>) ((</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="lwlock.c.html#LN124"><span class='Ref_to_Global_Var'>MainLWLockArray</span></a> <span class='Operator'>- </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><a href="../ipc/shmem.c.html#LN83"><span class='Ref_to_Global_Var'>ShmemLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="lwlock.c.html#LN573"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="lwlock.c.html#LN574"><span class='Ref_To_Local'>LWLockCounter</span></a><span class='Parentheses'>)</span><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><a href="../ipc/shmem.c.html#LN83"><span class='Ref_to_Global_Var'>ShmemLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="lwlock.c.html#LN573"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Register a tranche ID in the lookup table for the current process.  This 
 * routine will save a pointer to the tranche name passed as an argument, 
 * so the name should be allocated in a backend-lifetime context 
 * (TopMemoryContext, static variable, or similar). 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN591"></a><span class='Declare_Function'>LWLockRegisterTranche</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>tranche_id</span><span class='Delimiter'>, </span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Declare_Parameter'>tranche_name</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="lwlock.c.html#LN113"><span class='Ref_to_Global_Var'>LWLockTrancheArray</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN591"><span class='Ref_to_Parameter'>tranche_id</span></a> <span class='Operator'>&GT;= </span><a href="lwlock.c.html#LN114"><span class='Ref_to_Global_Var'>LWLockTranchesAllocated</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN597"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span> <span class='Operator'>= </span><a href="lwlock.c.html#LN114"><span class='Ref_to_Global_Var'>LWLockTranchesAllocated</span></a><span class='Delimiter'>; 
</span><a name="LN598"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>j</span> <span class='Operator'>= </span><a href="lwlock.c.html#LN114"><span class='Ref_to_Global_Var'>LWLockTranchesAllocated</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN597"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT;= </span><a href="lwlock.c.html#LN591"><span class='Ref_to_Parameter'>tranche_id</span></a><span class='Parentheses'>) 
</span>            <a href="lwlock.c.html#LN597"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>*= </span><span class='Number'>2</span><span class='Delimiter'>; 
</span> 
        <a href="lwlock.c.html#LN113"><span class='Ref_to_Global_Var'>LWLockTrancheArray</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>**</span><span class='Parentheses'>) 
</span>            <a href="../../../include/common/fe_memutils.h.html#LN36"><span class='Ref_to_Proto'>repalloc</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN113"><span class='Ref_to_Global_Var'>LWLockTrancheArray</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN597"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="lwlock.c.html#LN114"><span class='Ref_to_Global_Var'>LWLockTranchesAllocated</span></a> <span class='Operator'>= </span><a href="lwlock.c.html#LN597"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN598"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>&LT; </span><a href="lwlock.c.html#LN114"><span class='Ref_to_Global_Var'>LWLockTranchesAllocated</span></a><span class='Parentheses'>) 
</span>            <a href="lwlock.c.html#LN113"><span class='Ref_to_Global_Var'>LWLockTrancheArray</span></a><span class='Delimiter'>[</span><a href="lwlock.c.html#LN598"><span class='Ref_To_Local'>j</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="lwlock.c.html#LN113"><span class='Ref_to_Global_Var'>LWLockTrancheArray</span></a><span class='Delimiter'>[</span><a href="lwlock.c.html#LN591"><span class='Ref_to_Parameter'>tranche_id</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="lwlock.c.html#LN591"><span class='Ref_to_Parameter'>tranche_name</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end LWLockRegisterTranche &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * RequestNamedLWLockTranche 
 *      Request that extra LWLocks be allocated during postmaster 
 *      startup. 
 * 
 * This is only useful for extensions if called from the _PG_init hook 
 * of a library that is loaded into the postmaster via 
 * shared_preload_libraries.  Once shared memory has been allocated, calls 
 * will be ignored.  (We could raise an error, but it seems better to make 
 * it a no-op, so that libraries containing such calls can be reloaded if 
 * needed.) 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN626"></a><span class='Declare_Function'>RequestNamedLWLockTranche</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>tranche_name</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>num_lwlocks</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN628"></a>    <a href="lwlock.c.html#LN145"><span class='Ref_to_Struct'>NamedLWLockTrancheRequest</span></a> <span class='Operator'>*</span><span class='Declare_Local'>request</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../utils/init/globals.c.html#LN100"><span class='Ref_to_Global_Var'>IsUnderPostmaster</span></a> <span class='Operator'>|| !</span><a href="lwlock.c.html#LN157"><span class='Ref_to_Global_Var'>lock_named_request_allowed</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>;</span>                 <span class='Comment_Single_Line'>/* too late */ 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN151"><span class='Ref_to_Global_Var'>NamedLWLockTrancheRequestArray</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="lwlock.c.html#LN152"><span class='Ref_to_Global_Var'>NamedLWLockTrancheRequestsAllocated</span></a> <span class='Operator'>= </span><span class='Number'>16</span><span class='Delimiter'>; 
</span>        <a href="lwlock.c.html#LN151"><span class='Ref_to_Global_Var'>NamedLWLockTrancheRequestArray</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="lwlock.c.html#LN145"><span class='Ref_to_Struct'>NamedLWLockTrancheRequest</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../../include/utils/palloc.h.html#LN70"><span class='Ref_to_Proto'>MemoryContextAlloc</span></a><span class='Parentheses'>(</span><a href="../../utils/mmgr/mcxt.c.html#LN42"><span class='Ref_to_Global_Var'>TopMemoryContext</span></a><span class='Delimiter'>, 
</span>                               <a href="lwlock.c.html#LN152"><span class='Ref_to_Global_Var'>NamedLWLockTrancheRequestsAllocated</span></a> 
                               <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="lwlock.c.html#LN145"><span class='Ref_to_Struct'>NamedLWLockTrancheRequest</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN153"><span class='Ref_to_Global_Var'>NamedLWLockTrancheRequests</span></a> <span class='Operator'>&GT;= </span><a href="lwlock.c.html#LN152"><span class='Ref_to_Global_Var'>NamedLWLockTrancheRequestsAllocated</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN644"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span> <span class='Operator'>= </span><a href="lwlock.c.html#LN152"><span class='Ref_to_Global_Var'>NamedLWLockTrancheRequestsAllocated</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN644"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT;= </span><a href="lwlock.c.html#LN153"><span class='Ref_to_Global_Var'>NamedLWLockTrancheRequests</span></a><span class='Parentheses'>) 
</span>            <a href="lwlock.c.html#LN644"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>*= </span><span class='Number'>2</span><span class='Delimiter'>; 
</span> 
        <a href="lwlock.c.html#LN151"><span class='Ref_to_Global_Var'>NamedLWLockTrancheRequestArray</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="lwlock.c.html#LN145"><span class='Ref_to_Struct'>NamedLWLockTrancheRequest</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../../include/common/fe_memutils.h.html#LN36"><span class='Ref_to_Proto'>repalloc</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN151"><span class='Ref_to_Global_Var'>NamedLWLockTrancheRequestArray</span></a><span class='Delimiter'>, 
</span>                     <a href="lwlock.c.html#LN644"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="lwlock.c.html#LN145"><span class='Ref_to_Struct'>NamedLWLockTrancheRequest</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="lwlock.c.html#LN152"><span class='Ref_to_Global_Var'>NamedLWLockTrancheRequestsAllocated</span></a> <span class='Operator'>= </span><a href="lwlock.c.html#LN644"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="lwlock.c.html#LN628"><span class='Ref_To_Local'>request</span></a> <span class='Operator'>= &</span><a href="lwlock.c.html#LN151"><span class='Ref_to_Global_Var'>NamedLWLockTrancheRequestArray</span></a><span class='Delimiter'>[</span><a href="lwlock.c.html#LN153"><span class='Ref_to_Global_Var'>NamedLWLockTrancheRequests</span></a><span class='Delimiter'>]; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span>strlen<span class='Parentheses'>(</span><a href="lwlock.c.html#LN626"><span class='Ref_to_Parameter'>tranche_name</span></a><span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Number'>1</span> <span class='Operator'>&LT; </span><a href="../../../interfaces/ecpg/include/sqlda-native.h.html#LN15"><span class='Ref_to_Const'>NAMEDATALEN</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/c.h.html#LN829"><span class='Ref_to_Macro'>StrNCpy</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN628"><span class='Ref_To_Local'>request</span></a><span class='Operator'>-&GT;</span><a href="lwlock.c.html#LN147"><span class='Ref_to_Member'>tranche_name</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN626"><span class='Ref_to_Parameter'>tranche_name</span></a><span class='Delimiter'>, </span><a href="../../../interfaces/ecpg/include/sqlda-native.h.html#LN15"><span class='Ref_to_Const'>NAMEDATALEN</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="lwlock.c.html#LN628"><span class='Ref_To_Local'>request</span></a><span class='Operator'>-&GT;</span><a href="lwlock.c.html#LN148"><span class='Ref_to_Member'>num_lwlocks</span></a> <span class='Operator'>= </span><a href="lwlock.c.html#LN626"><span class='Ref_to_Parameter'>num_lwlocks</span></a><span class='Delimiter'>; 
</span>    <a href="lwlock.c.html#LN153"><span class='Ref_to_Global_Var'>NamedLWLockTrancheRequests</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end RequestNamedLWLockTranche &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * LWLockInitialize - initialize a new lwlock; it's initially unlocked 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN666"></a><span class='Declare_Function'>LWLockInitialize</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>lock</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>tranche_id</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/port/atomics.h.html#LN232"><span class='Ref_to_Func'>pg_atomic_init_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN666"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN34"><span class='Ref_to_Member'>state</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN99"><span class='Ref_to_Const'>LW_FLAG_RELEASE_OK</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#ifdef</span> LOCK_DEBUG 
    <a href="../../../include/port/atomics.h.html#LN232"><span class='Ref_to_Func'>pg_atomic_init_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN666"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN37"><span class='Ref_to_Member'>nwaiters</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
    <a href="lwlock.c.html#LN666"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN33"><span class='Ref_to_Member'>tranche</span></a> <span class='Operator'>= </span><a href="lwlock.c.html#LN666"><span class='Ref_to_Parameter'>tranche_id</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/proclist.h.html#LN27"><span class='Ref_to_Func'>proclist_init</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN666"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN35"><span class='Ref_to_Member'>waiters</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Report start of wait event for light-weight locks. 
 * 
 * This function will be used by all the light-weight lock calls which 
 * needs to wait to acquire the lock.  This function distinguishes wait 
 * event based on tranche and lock id. 
 */ 
</span><span class='Keyword'>static inline void 
</span><a name="LN684"></a><span class='Declare_Function'>LWLockReportWaitStart</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>lock</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/pgstat.h.html#LN1206"><span class='Ref_to_Func'>pgstat_report_wait_start</span></a><span class='Parentheses'>(</span><a href="../../../include/pgstat.h.html#LN736"><span class='Ref_to_Const'>PG_WAIT_LWLOCK</span></a> <span class='Operator'>| </span><a href="lwlock.c.html#LN684"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN33"><span class='Ref_to_Member'>tranche</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Report end of wait event for light-weight locks. 
 */ 
</span><span class='Keyword'>static inline void 
</span><a name="LN693"></a><span class='Declare_Function'>LWLockReportWaitEnd</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/pgstat.h.html#LN1230"><span class='Ref_to_Func'>pgstat_report_wait_end</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Return an identifier for an LWLock based on the wait class and event. 
 */ 
</span><span class='Keyword'>const char </span><span class='Operator'>* 
</span><a name="LN702"></a><span class='Declare_Function'>GetLWLockIdentifier</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Parameter'>classId</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN266"><span class='Ref_to_Typedef'>uint16</span></a> <span class='Declare_Parameter'>eventId</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="lwlock.c.html#LN702"><span class='Ref_to_Parameter'>classId</span></a> <span class='Operator'>== </span><a href="../../../include/pgstat.h.html#LN736"><span class='Ref_to_Const'>PG_WAIT_LWLOCK</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * It is quite possible that user has registered tranche in one of the 
     * backends (e.g. by allocating lwlocks in dynamic shared memory) but not 
     * all of them, so we can't assume the tranche is registered here. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN702"><span class='Ref_to_Parameter'>eventId</span></a> <span class='Operator'>&GT;= </span><a href="lwlock.c.html#LN114"><span class='Ref_to_Global_Var'>LWLockTranchesAllocated</span></a> <span class='Operator'>|| 
</span>        <a href="lwlock.c.html#LN113"><span class='Ref_to_Global_Var'>LWLockTrancheArray</span></a><span class='Delimiter'>[</span><a href="lwlock.c.html#LN702"><span class='Ref_to_Parameter'>eventId</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='String'>"extension"</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="lwlock.c.html#LN113"><span class='Ref_to_Global_Var'>LWLockTrancheArray</span></a><span class='Delimiter'>[</span><a href="lwlock.c.html#LN702"><span class='Ref_to_Parameter'>eventId</span></a><span class='Delimiter'>]; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Internal function that tries to atomically acquire the lwlock in the passed 
 * in mode. 
 * 
 * This function will not block waiting for a lock to become free - that's the 
 * callers job. 
 * 
 * Returns true if the lock isn't free and we need to wait. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN728"></a><span class='Declare_Function'>LWLockAttemptLock</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>lock</span><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN131"><span class='Ref_to_Enum'>LWLockMode</span></a> <span class='Declare_Parameter'>mode</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN730"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>old_state</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/c.h.html#LN676"><span class='Ref_to_Macro'>AssertArg</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN728"><span class='Ref_to_Parameter'>mode</span></a> <span class='Operator'>== </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a> <span class='Operator'>|| </span><a href="lwlock.c.html#LN728"><span class='Ref_to_Parameter'>mode</span></a> <span class='Operator'>== </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Read once outside the loop, later iterations will get the newer value 
     * via compare & exchange. 
     */ 
</span>    <a href="lwlock.c.html#LN730"><span class='Ref_To_Local'>old_state</span></a> <span class='Operator'>= </span><a href="../../../include/port/atomics.h.html#LN250"><span class='Ref_to_Func'>pg_atomic_read_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN728"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN34"><span class='Ref_to_Member'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* loop until we've determined whether we could acquire the lock or not */ 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN743"></a>        <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>desired_state</span><span class='Delimiter'>; 
</span><a name="LN744"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>lock_free</span><span class='Delimiter'>; 
</span> 
        <a href="lwlock.c.html#LN743"><span class='Ref_To_Local'>desired_state</span></a> <span class='Operator'>= </span><a href="lwlock.c.html#LN730"><span class='Ref_To_Local'>old_state</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN728"><span class='Ref_to_Parameter'>mode</span></a> <span class='Operator'>== </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="lwlock.c.html#LN744"><span class='Ref_To_Local'>lock_free</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="lwlock.c.html#LN730"><span class='Ref_To_Local'>old_state</span></a> <span class='Operator'>& </span><a href="lwlock.c.html#LN105"><span class='Ref_to_Const'>LW_LOCK_MASK</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN744"><span class='Ref_To_Local'>lock_free</span></a><span class='Parentheses'>) 
</span>                <a href="lwlock.c.html#LN743"><span class='Ref_To_Local'>desired_state</span></a> <span class='Operator'>+= </span><a href="lwlock.c.html#LN102"><span class='Ref_to_Const'>LW_VAL_EXCLUSIVE</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="lwlock.c.html#LN744"><span class='Ref_To_Local'>lock_free</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="lwlock.c.html#LN730"><span class='Ref_To_Local'>old_state</span></a> <span class='Operator'>& </span><a href="lwlock.c.html#LN102"><span class='Ref_to_Const'>LW_VAL_EXCLUSIVE</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN744"><span class='Ref_To_Local'>lock_free</span></a><span class='Parentheses'>) 
</span>                <a href="lwlock.c.html#LN743"><span class='Ref_To_Local'>desired_state</span></a> <span class='Operator'>+= </span><a href="lwlock.c.html#LN103"><span class='Ref_to_Const'>LW_VAL_SHARED</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Attempt to swap in the state we are expecting. If we didn't see 
         * lock to be free, that's just the old value. If we saw it as free, 
         * we'll attempt to mark it acquired. The reason that we always swap 
         * in the value is that this doubles as a memory barrier. We could try 
         * to be smarter and only swap in values if we saw the lock as free, 
         * but benchmark haven't shown it as beneficial so far. 
         * 
         * Retry if the value changed since we last looked at it. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/port/atomics.h.html#LN320"><span class='Ref_to_Func'>pg_atomic_compare_exchange_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN728"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN34"><span class='Ref_to_Member'>state</span></a><span class='Delimiter'>, 
</span>                                           <span class='Operator'>&</span><a href="lwlock.c.html#LN730"><span class='Ref_To_Local'>old_state</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN743"><span class='Ref_To_Local'>desired_state</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN744"><span class='Ref_To_Local'>lock_free</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Great! Got the lock. */ 
</span><span class='Directive'>#ifdef</span> LOCK_DEBUG 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN728"><span class='Ref_to_Parameter'>mode</span></a> <span class='Operator'>== </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>) 
</span>                    <a href="lwlock.c.html#LN728"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN38"><span class='Ref_to_Member'>owner</span></a> <span class='Operator'>= </span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
                <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* somebody else has the lock */ 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while true &raquo; </span> 
    <a href="../../../include/c.h.html#LN941"><span class='Ref_to_Macro'>pg_unreachable</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end LWLockAttemptLock &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Lock the LWLock's wait list against concurrent activity. 
 * 
 * NB: even though the wait list is locked, non-conflicting lock operations 
 * may still happen concurrently. 
 * 
 * Time spent holding mutex should be short! 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN799"></a><span class='Declare_Function'>LWLockWaitListLock</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>lock</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN801"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>old_state</span><span class='Delimiter'>; 
</span><span class='Directive'>#ifdef</span> LWLOCK_STATS 
<a name="LN803"></a>    <a href="lwlock.c.html#LN172"><span class='Ref_to_Struct'>lwlock_stats</span></a> <span class='Operator'>*</span><span class='Declare_Local'>lwstats</span><span class='Delimiter'>; 
</span><a name="LN804"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>delays</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <a href="lwlock.c.html#LN803"><span class='Ref_To_Local'>lwstats</span></a> <span class='Operator'>= </span><a href="lwlock.c.html#LN234"><span class='Ref_to_Proto'>get_lwlock_stats_entry</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN799"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
    <span class='Control'>while</span> <span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* always try once to acquire lock directly */ 
</span>        <a href="lwlock.c.html#LN801"><span class='Ref_To_Local'>old_state</span></a> <span class='Operator'>= </span><a href="../../../include/port/atomics.h.html#LN381"><span class='Ref_to_Func'>pg_atomic_fetch_or_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN799"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN34"><span class='Ref_to_Member'>state</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN100"><span class='Ref_to_Const'>LW_FLAG_LOCKED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="lwlock.c.html#LN801"><span class='Ref_To_Local'>old_state</span></a> <span class='Operator'>& </span><a href="lwlock.c.html#LN100"><span class='Ref_to_Const'>LW_FLAG_LOCKED</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>break</span><span class='Delimiter'>;</span>              <span class='Comment_Single_Line'>/* got lock */ 
</span> 
        <span class='Comment_Multi_Line'>/* and then spin without atomic operations until lock is released */ 
</span>        <span class='Delimiter'>{ 
</span><a name="LN818"></a>            <a href="../../../include/storage/s_lock.h.html#LN974"><span class='Ref_to_Typedef'>SpinDelayStatus</span></a> <span class='Declare_Local'>delayStatus</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/storage/s_lock.h.html#LN996"><span class='Ref_to_Macro'>init_local_spin_delay</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN818"><span class='Ref_To_Local'>delayStatus</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN801"><span class='Ref_To_Local'>old_state</span></a> <span class='Operator'>& </span><a href="lwlock.c.html#LN100"><span class='Ref_to_Const'>LW_FLAG_LOCKED</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="s_lock.c.html#LN123"><span class='Ref_to_Func'>perform_spin_delay</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN818"><span class='Ref_To_Local'>delayStatus</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="lwlock.c.html#LN801"><span class='Ref_To_Local'>old_state</span></a> <span class='Operator'>= </span><a href="../../../include/port/atomics.h.html#LN250"><span class='Ref_to_Func'>pg_atomic_read_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN799"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN34"><span class='Ref_to_Member'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span><span class='Directive'>#ifdef</span> LWLOCK_STATS 
            <a href="lwlock.c.html#LN804"><span class='Ref_To_Local'>delays</span></a> <span class='Operator'>+= </span><a href="lwlock.c.html#LN818"><span class='Ref_To_Local'>delayStatus</span></a><span class='Operator'>.</span><a href="../../../include/storage/s_lock.h.html#LN977"><span class='Ref_to_Member'>delays</span></a><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
            <a href="s_lock.c.html#LN173"><span class='Ref_to_Func'>finish_spin_delay</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN818"><span class='Ref_To_Local'>delayStatus</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Retry. The lock might obviously already be re-acquired by the time 
         * we're attempting to get it again. 
         */ 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while true &raquo; </span> 
 
<span class='Directive'>#ifdef</span> LWLOCK_STATS 
    <a href="lwlock.c.html#LN803"><span class='Ref_To_Local'>lwstats</span></a><span class='Operator'>-&GT;</span><a href="lwlock.c.html#LN179"><span class='Ref_to_Member'>spin_delay_count</span></a> <span class='Operator'>+= </span><a href="lwlock.c.html#LN804"><span class='Ref_To_Local'>delays</span></a><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end LWLockWaitListLock &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Unlock the LWLock's wait list. 
 * 
 * Note that it can be more efficient to manipulate flags and release the 
 * locks in a single atomic operation. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN851"></a><span class='Declare_Function'>LWLockWaitListUnlock</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>lock</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN853"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> old_state <span class='Declare_Local'>PG_USED_FOR_ASSERTS_ONLY</span><span class='Delimiter'>; 
</span> 
    old_state <span class='Operator'>= </span><a href="../../../include/port/atomics.h.html#LN367"><span class='Ref_to_Func'>pg_atomic_fetch_and_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN851"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN34"><span class='Ref_to_Member'>state</span></a><span class='Delimiter'>, </span><span class='Operator'>~</span><a href="lwlock.c.html#LN100"><span class='Ref_to_Const'>LW_FLAG_LOCKED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span>old_state <span class='Operator'>& </span><a href="lwlock.c.html#LN100"><span class='Ref_to_Const'>LW_FLAG_LOCKED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Wakeup all the lockers that currently have a chance to acquire the lock. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN864"></a><span class='Declare_Function'>LWLockWakeup</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>lock</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN866"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>new_release_ok</span><span class='Delimiter'>; 
</span><a name="LN867"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>wokeup_somebody</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN868"></a>    <a href="../../../include/storage/proclist_types.h.html#LN29"><span class='Ref_to_Struct'>proclist_head</span></a> <span class='Declare_Local'>wakeup</span><span class='Delimiter'>; 
</span><a name="LN869"></a>    <a href="../../../include/storage/proclist_types.h.html#LN38"><span class='Ref_to_Struct'>proclist_mutable_iter</span></a> <span class='Declare_Local'>iter</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/proclist.h.html#LN27"><span class='Ref_to_Func'>proclist_init</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN868"><span class='Ref_To_Local'>wakeup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="lwlock.c.html#LN866"><span class='Ref_To_Local'>new_release_ok</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* lock wait list while collecting backends to wake up */ 
</span>    <a href="lwlock.c.html#LN798"><span class='Ref_to_Func'>LWLockWaitListLock</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN864"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/proclist.h.html#LN194"><span class='Ref_to_Macro'>proclist_foreach_modify</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN869"><span class='Ref_To_Local'>iter</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="lwlock.c.html#LN864"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN35"><span class='Ref_to_Member'>waiters</span></a><span class='Delimiter'>, </span>lwWaitLink<span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN880"></a>        <a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>waiter</span> <span class='Operator'>= </span><a href="../../../include/storage/proc.h.html#LN262"><span class='Ref_to_Macro'>GetPGProcByNumber</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN869"><span class='Ref_To_Local'>iter</span></a><span class='Operator'>.</span><a href="../../../include/storage/proclist_types.h.html#LN40"><span class='Ref_to_Member'>cur</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN867"><span class='Ref_To_Local'>wokeup_somebody</span></a> <span class='Operator'>&& </span><a href="lwlock.c.html#LN880"><span class='Ref_To_Local'>waiter</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN126"><span class='Ref_to_Member'>lwWaitMode</span></a> <span class='Operator'>== </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/storage/proclist.h.html#LN175"><span class='Ref_to_Macro'>proclist_delete</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN864"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN35"><span class='Ref_to_Member'>waiters</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN869"><span class='Ref_To_Local'>iter</span></a><span class='Operator'>.</span><a href="../../../include/storage/proclist_types.h.html#LN40"><span class='Ref_to_Member'>cur</span></a><span class='Delimiter'>, </span>lwWaitLink<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/proclist.h.html#LN179"><span class='Ref_to_Macro'>proclist_push_tail</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN868"><span class='Ref_To_Local'>wakeup</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN869"><span class='Ref_To_Local'>iter</span></a><span class='Operator'>.</span><a href="../../../include/storage/proclist_types.h.html#LN40"><span class='Ref_to_Member'>cur</span></a><span class='Delimiter'>, </span>lwWaitLink<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN880"><span class='Ref_To_Local'>waiter</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN126"><span class='Ref_to_Member'>lwWaitMode</span></a> <span class='Operator'>!= </span><a href="../../../include/storage/lwlock.h.html#LN135"><span class='Ref_to_EnumConst'>LW_WAIT_UNTIL_FREE</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Prevent additional wakeups until retryer gets to run. Backends 
             * that are just waiting for the lock to become free don't retry 
             * automatically. 
             */ 
</span>            <a href="lwlock.c.html#LN866"><span class='Ref_To_Local'>new_release_ok</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Don't wakeup (further) exclusive locks. 
             */ 
</span>            <a href="lwlock.c.html#LN867"><span class='Ref_To_Local'>wokeup_somebody</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Once we've woken up an exclusive lock, there's no point in waking 
         * up anybody else. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN880"><span class='Ref_To_Local'>waiter</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN126"><span class='Ref_to_Member'>lwWaitMode</span></a> <span class='Operator'>== </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/proclist.h.html#LN36"><span class='Ref_to_Func'>proclist_is_empty</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN868"><span class='Ref_To_Local'>wakeup</span></a><span class='Parentheses'>) </span><span class='Operator'>|| </span><a href="../../../include/port/atomics.h.html#LN250"><span class='Ref_to_Func'>pg_atomic_read_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN864"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN34"><span class='Ref_to_Member'>state</span></a><span class='Parentheses'>) </span><span class='Operator'>& </span><a href="lwlock.c.html#LN98"><span class='Ref_to_Const'>LW_FLAG_HAS_WAITERS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* unset required flags, and release lock, in one fell swoop */ 
</span>    <span class='Delimiter'>{ 
</span><a name="LN915"></a>        <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>old_state</span><span class='Delimiter'>; 
</span><a name="LN916"></a>        <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>desired_state</span><span class='Delimiter'>; 
</span> 
        <a href="lwlock.c.html#LN915"><span class='Ref_To_Local'>old_state</span></a> <span class='Operator'>= </span><a href="../../../include/port/atomics.h.html#LN250"><span class='Ref_to_Func'>pg_atomic_read_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN864"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN34"><span class='Ref_to_Member'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>while</span> <span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="lwlock.c.html#LN916"><span class='Ref_To_Local'>desired_state</span></a> <span class='Operator'>= </span><a href="lwlock.c.html#LN915"><span class='Ref_To_Local'>old_state</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* compute desired flags */ 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN866"><span class='Ref_To_Local'>new_release_ok</span></a><span class='Parentheses'>) 
</span>                <a href="lwlock.c.html#LN916"><span class='Ref_To_Local'>desired_state</span></a> <span class='Operator'>|= </span><a href="lwlock.c.html#LN99"><span class='Ref_to_Const'>LW_FLAG_RELEASE_OK</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="lwlock.c.html#LN916"><span class='Ref_To_Local'>desired_state</span></a> <span class='Operator'>&= ~</span><a href="lwlock.c.html#LN99"><span class='Ref_to_Const'>LW_FLAG_RELEASE_OK</span></a><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/proclist.h.html#LN36"><span class='Ref_to_Func'>proclist_is_empty</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN868"><span class='Ref_To_Local'>wakeup</span></a><span class='Parentheses'>))</span> 
                <a href="lwlock.c.html#LN916"><span class='Ref_To_Local'>desired_state</span></a> <span class='Operator'>&= ~</span><a href="lwlock.c.html#LN98"><span class='Ref_to_Const'>LW_FLAG_HAS_WAITERS</span></a><span class='Delimiter'>; 
</span> 
            <a href="lwlock.c.html#LN916"><span class='Ref_To_Local'>desired_state</span></a> <span class='Operator'>&= ~</span><a href="lwlock.c.html#LN100"><span class='Ref_to_Const'>LW_FLAG_LOCKED</span></a><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* release lock */ 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/port/atomics.h.html#LN320"><span class='Ref_to_Func'>pg_atomic_compare_exchange_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN864"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN34"><span class='Ref_to_Member'>state</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="lwlock.c.html#LN915"><span class='Ref_To_Local'>old_state</span></a><span class='Delimiter'>, 
</span>                                               <a href="lwlock.c.html#LN916"><span class='Ref_To_Local'>desired_state</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while true &raquo; </span> 
    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Awaken any waiters I removed from the queue. */ 
</span>    <a href="../../../include/storage/proclist.h.html#LN194"><span class='Ref_to_Macro'>proclist_foreach_modify</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN869"><span class='Ref_To_Local'>iter</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="lwlock.c.html#LN868"><span class='Ref_To_Local'>wakeup</span></a><span class='Delimiter'>, </span>lwWaitLink<span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN944"></a>        <a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>waiter</span> <span class='Operator'>= </span><a href="../../../include/storage/proc.h.html#LN262"><span class='Ref_to_Macro'>GetPGProcByNumber</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN869"><span class='Ref_To_Local'>iter</span></a><span class='Operator'>.</span><a href="../../../include/storage/proclist_types.h.html#LN40"><span class='Ref_to_Member'>cur</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="lwlock.c.html#LN211"><span class='Ref_to_Func'>LOG_LWDEBUG</span></a><span class='Parentheses'>(</span><span class='String'>"LWLockRelease"</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN864"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>, </span><span class='String'>"release waiter"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/proclist.h.html#LN175"><span class='Ref_to_Macro'>proclist_delete</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN868"><span class='Ref_To_Local'>wakeup</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN869"><span class='Ref_To_Local'>iter</span></a><span class='Operator'>.</span><a href="../../../include/storage/proclist_types.h.html#LN40"><span class='Ref_to_Member'>cur</span></a><span class='Delimiter'>, </span>lwWaitLink<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Guarantee that lwWaiting being unset only becomes visible once the 
         * unlink from the link has completed. Otherwise the target backend 
         * could be woken up for other reason and enqueue for a new lock - if 
         * that happens before the list unlink happens, the list would end up 
         * being corrupted. 
         * 
         * The barrier pairs with the LWLockWaitListLock() when enqueuing for 
         * another lock. 
         */ 
</span>        <a href="../../../include/port/atomics.h.html#LN161"><span class='Ref_to_Macro'>pg_write_barrier</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <a href="lwlock.c.html#LN944"><span class='Ref_To_Local'>waiter</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN125"><span class='Ref_to_Member'>lwWaiting</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/pg_sema.h.html#LN55"><span class='Ref_to_Proto'>PGSemaphoreUnlock</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN944"><span class='Ref_To_Local'>waiter</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN99"><span class='Ref_to_Member'>sem</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end LWLockWakeup &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Add ourselves to the end of the queue. 
 * 
 * NB: Mode can be LW_WAIT_UNTIL_FREE here! 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN971"></a><span class='Declare_Function'>LWLockQueueSelf</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>lock</span><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN131"><span class='Ref_to_Enum'>LWLockMode</span></a> <span class='Declare_Parameter'>mode</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * If we don't have a PGPROC structure, there's no way to wait. This 
     * should never occur, since MyProc should only be null during shared 
     * memory initialization. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, </span><span class='String'>"cannot wait without a PGPROC structure"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN125"><span class='Ref_to_Member'>lwWaiting</span></a><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, </span><span class='String'>"queueing for lock while waiting on another one"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="lwlock.c.html#LN798"><span class='Ref_to_Func'>LWLockWaitListLock</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN971"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* setting the flag is protected by the spinlock */ 
</span>    <a href="../../../include/port/atomics.h.html#LN381"><span class='Ref_to_Func'>pg_atomic_fetch_or_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN971"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN34"><span class='Ref_to_Member'>state</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN98"><span class='Ref_to_Const'>LW_FLAG_HAS_WAITERS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN125"><span class='Ref_to_Member'>lwWaiting</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN126"><span class='Ref_to_Member'>lwWaitMode</span></a> <span class='Operator'>= </span><a href="lwlock.c.html#LN971"><span class='Ref_to_Parameter'>mode</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* LW_WAIT_UNTIL_FREE waiters are always at the front of the queue */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN971"><span class='Ref_to_Parameter'>mode</span></a> <span class='Operator'>== </span><a href="../../../include/storage/lwlock.h.html#LN135"><span class='Ref_to_EnumConst'>LW_WAIT_UNTIL_FREE</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/proclist.h.html#LN177"><span class='Ref_to_Macro'>proclist_push_head</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN971"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN35"><span class='Ref_to_Member'>waiters</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN108"><span class='Ref_to_Member'>pgprocno</span></a><span class='Delimiter'>, </span>lwWaitLink<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="../../../include/storage/proclist.h.html#LN179"><span class='Ref_to_Macro'>proclist_push_tail</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN971"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN35"><span class='Ref_to_Member'>waiters</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN108"><span class='Ref_to_Member'>pgprocno</span></a><span class='Delimiter'>, </span>lwWaitLink<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Can release the mutex now */ 
</span>    <a href="lwlock.c.html#LN850"><span class='Ref_to_Func'>LWLockWaitListUnlock</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN971"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> LOCK_DEBUG 
    <a href="../../../include/port/atomics.h.html#LN337"><span class='Ref_to_Func'>pg_atomic_fetch_add_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN971"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN37"><span class='Ref_to_Member'>nwaiters</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end LWLockQueueSelf &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Remove ourselves from the waitlist. 
 * 
 * This is used if we queued ourselves because we thought we needed to sleep 
 * but, after further checking, we discovered that we don't actually need to 
 * do so. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1015"></a><span class='Declare_Function'>LWLockDequeueSelf</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>lock</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1017"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN1018"></a>    <a href="../../../include/storage/proclist_types.h.html#LN38"><span class='Ref_to_Struct'>proclist_mutable_iter</span></a> <span class='Declare_Local'>iter</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> LWLOCK_STATS 
<a name="LN1021"></a>    <a href="lwlock.c.html#LN172"><span class='Ref_to_Struct'>lwlock_stats</span></a> <span class='Operator'>*</span><span class='Declare_Local'>lwstats</span><span class='Delimiter'>; 
</span> 
    <a href="lwlock.c.html#LN1021"><span class='Ref_To_Local'>lwstats</span></a> <span class='Operator'>= </span><a href="lwlock.c.html#LN234"><span class='Ref_to_Proto'>get_lwlock_stats_entry</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1015"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="lwlock.c.html#LN1021"><span class='Ref_To_Local'>lwstats</span></a><span class='Operator'>-&GT;</span><a href="lwlock.c.html#LN178"><span class='Ref_to_Member'>dequeue_self_count</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
    <a href="lwlock.c.html#LN798"><span class='Ref_to_Func'>LWLockWaitListLock</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1015"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Can't just remove ourselves from the list, but we need to iterate over 
     * all entries as somebody else could have dequeued us. 
     */ 
</span>    <a href="../../../include/storage/proclist.h.html#LN194"><span class='Ref_to_Macro'>proclist_foreach_modify</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1018"><span class='Ref_To_Local'>iter</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="lwlock.c.html#LN1015"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN35"><span class='Ref_to_Member'>waiters</span></a><span class='Delimiter'>, </span>lwWaitLink<span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN1018"><span class='Ref_To_Local'>iter</span></a><span class='Operator'>.</span><a href="../../../include/storage/proclist_types.h.html#LN40"><span class='Ref_to_Member'>cur</span></a> <span class='Operator'>== </span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN108"><span class='Ref_to_Member'>pgprocno</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="lwlock.c.html#LN1017"><span class='Ref_To_Local'>found</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="../../../include/storage/proclist.h.html#LN175"><span class='Ref_to_Macro'>proclist_delete</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN1015"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN35"><span class='Ref_to_Member'>waiters</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1018"><span class='Ref_To_Local'>iter</span></a><span class='Operator'>.</span><a href="../../../include/storage/proclist_types.h.html#LN40"><span class='Ref_to_Member'>cur</span></a><span class='Delimiter'>, </span>lwWaitLink<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/proclist.h.html#LN36"><span class='Ref_to_Func'>proclist_is_empty</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN1015"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN35"><span class='Ref_to_Member'>waiters</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>        <span class='Parentheses'>(</span><a href="../../../include/port/atomics.h.html#LN250"><span class='Ref_to_Func'>pg_atomic_read_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN1015"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN34"><span class='Ref_to_Member'>state</span></a><span class='Parentheses'>) </span><span class='Operator'>& </span><a href="lwlock.c.html#LN98"><span class='Ref_to_Const'>LW_FLAG_HAS_WAITERS</span></a><span class='Parentheses'>)</span> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/port/atomics.h.html#LN367"><span class='Ref_to_Func'>pg_atomic_fetch_and_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN1015"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN34"><span class='Ref_to_Member'>state</span></a><span class='Delimiter'>, </span><span class='Operator'>~</span><a href="lwlock.c.html#LN98"><span class='Ref_to_Const'>LW_FLAG_HAS_WAITERS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* XXX: combine with fetch_and above? */ 
</span>    <a href="lwlock.c.html#LN850"><span class='Ref_to_Func'>LWLockWaitListUnlock</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1015"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* clear waiting state again, nice for debugging */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN1017"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>        <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN125"><span class='Ref_to_Member'>lwWaiting</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1058"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>extraWaits</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Somebody else dequeued us and has or will wake us up. Deal with the 
         * superfluous absorption of a wakeup. 
         */ 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Reset releaseOk if somebody woke us before we removed ourselves - 
         * they'll have set it to false. 
         */ 
</span>        <a href="../../../include/port/atomics.h.html#LN381"><span class='Ref_to_Func'>pg_atomic_fetch_or_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN1015"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN34"><span class='Ref_to_Member'>state</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN99"><span class='Ref_to_Const'>LW_FLAG_RELEASE_OK</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Now wait for the scheduled wakeup, otherwise our -&GT;lwWaiting would 
         * get reset at some inconvenient point later. Most of the time this 
         * will immediately return. 
         */ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../../include/storage/pg_sema.h.html#LN52"><span class='Ref_to_Proto'>PGSemaphoreLock</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN99"><span class='Ref_to_Member'>sem</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN125"><span class='Ref_to_Member'>lwWaiting</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <a href="lwlock.c.html#LN1058"><span class='Ref_To_Local'>extraWaits</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Fix the process wait semaphore's count for any absorbed wakeups. 
         */ 
</span>        <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN1058"><span class='Ref_To_Local'>extraWaits</span></a><span class='Operator'>-- &GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <a href="../../../include/storage/pg_sema.h.html#LN55"><span class='Ref_to_Proto'>PGSemaphoreUnlock</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN99"><span class='Ref_to_Member'>sem</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
<span class='Directive'>#ifdef</span> LOCK_DEBUG 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* not waiting anymore */ 
</span><a name="LN1094"></a>        <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> nwaiters <span class='Declare_Local'>PG_USED_FOR_ASSERTS_ONLY</span> <span class='Operator'>= </span><a href="../../../include/port/atomics.h.html#LN352"><span class='Ref_to_Func'>pg_atomic_fetch_sub_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN1015"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN37"><span class='Ref_to_Member'>nwaiters</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span>nwaiters <span class='Operator'>&LT; </span><a href="../../../include/postmaster/postmaster.h.html#LN74"><span class='Ref_to_Const'>MAX_BACKENDS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span><span class='Directive'>#endif</span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end LWLockDequeueSelf &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * LWLockAcquire - acquire a lightweight lock in the specified mode 
 * 
 * If the lock is not available, sleep until it is.  Returns true if the lock 
 * was available immediately, false if we had to sleep. 
 * 
 * Side effect: cancel/die interrupts are held off until lock release. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN1110"></a><span class='Declare_Function'>LWLockAcquire</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>lock</span><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN131"><span class='Ref_to_Enum'>LWLockMode</span></a> <span class='Declare_Parameter'>mode</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1112"></a>    <a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>proc</span> <span class='Operator'>= </span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Delimiter'>; 
</span><a name="LN1113"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>result</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span><a name="LN1114"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>extraWaits</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><span class='Directive'>#ifdef</span> LWLOCK_STATS 
<a name="LN1116"></a>    <a href="lwlock.c.html#LN172"><span class='Ref_to_Struct'>lwlock_stats</span></a> <span class='Operator'>*</span><span class='Declare_Local'>lwstats</span><span class='Delimiter'>; 
</span> 
    <a href="lwlock.c.html#LN1116"><span class='Ref_To_Local'>lwstats</span></a> <span class='Operator'>= </span><a href="lwlock.c.html#LN234"><span class='Ref_to_Proto'>get_lwlock_stats_entry</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1110"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
    <a href="../../../include/c.h.html#LN676"><span class='Ref_to_Macro'>AssertArg</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1110"><span class='Ref_to_Parameter'>mode</span></a> <span class='Operator'>== </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a> <span class='Operator'>|| </span><a href="lwlock.c.html#LN1110"><span class='Ref_to_Parameter'>mode</span></a> <span class='Operator'>== </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="lwlock.c.html#LN189"><span class='Ref_to_Func'>PRINT_LWDEBUG</span></a><span class='Parentheses'>(</span><span class='String'>"LWLockAcquire"</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1110"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1110"><span class='Ref_to_Parameter'>mode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> LWLOCK_STATS 
    <span class='Comment_Multi_Line'>/* Count lock acquisition attempts */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN1110"><span class='Ref_to_Parameter'>mode</span></a> <span class='Operator'>== </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>) 
</span>        <a href="lwlock.c.html#LN1116"><span class='Ref_To_Local'>lwstats</span></a><span class='Operator'>-&GT;</span><a href="lwlock.c.html#LN176"><span class='Ref_to_Member'>ex_acquire_count</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="lwlock.c.html#LN1116"><span class='Ref_To_Local'>lwstats</span></a><span class='Operator'>-&GT;</span><a href="lwlock.c.html#LN175"><span class='Ref_to_Member'>sh_acquire_count</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span>   <span class='Comment_Single_Line'>/* LWLOCK_STATS */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We can't wait if we haven't got a PGPROC.  This should only occur 
     * during bootstrap or shared memory initialization.  Put an Assert here 
     * to catch unsafe coding practices. 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1112"><span class='Ref_To_Local'>proc</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>&& </span><a href="../../utils/init/globals.c.html#LN100"><span class='Ref_to_Global_Var'>IsUnderPostmaster</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Ensure we will have room to remember the lock */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN141"><span class='Ref_to_Global_Var'>num_held_lwlocks</span></a> <span class='Operator'>&GT;= </span><a href="lwlock.c.html#LN132"><span class='Ref_to_Const'>MAX_SIMUL_LWLOCKS</span></a><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"too many LWLocks taken"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Lock out cancel/die interrupts until we exit the code section protected 
     * by the LWLock.  This ensures that interrupts will not interfere with 
     * manipulations of data structures in shared memory. 
     */ 
</span>    <a href="../../../include/miscadmin.h.html#LN116"><span class='Ref_to_Macro'>HOLD_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Loop here to try to acquire lock after each time we are signaled by 
     * LWLockRelease. 
     * 
     * NOTE: it might seem better to have LWLockRelease actually grant us the 
     * lock, rather than retrying and possibly having to go back to sleep. But 
     * in practice that is no good because it means a process swap for every 
     * lock acquisition when two or more processes are contending for the same 
     * lock.  Since LWLocks are normally used to protect not-very-long 
     * sections of computation, a process needs to be able to acquire and 
     * release the same lock many times during a single CPU time slice, even 
     * in the presence of contention.  The efficiency of being able to do that 
     * outweighs the inefficiency of sometimes wasting a process dispatch 
     * cycle because the lock is not free when a released waiter finally gets 
     * to run.  See pgsql-hackers archives for 29-Dec-01. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1169"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>mustwait</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Try to grab the lock the first time, we're not in the waitqueue 
         * yet/anymore. 
         */ 
</span>        <a href="lwlock.c.html#LN1169"><span class='Ref_To_Local'>mustwait</span></a> <span class='Operator'>= </span><a href="lwlock.c.html#LN727"><span class='Ref_to_Func'>LWLockAttemptLock</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1110"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1110"><span class='Ref_to_Parameter'>mode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="lwlock.c.html#LN1169"><span class='Ref_To_Local'>mustwait</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="lwlock.c.html#LN211"><span class='Ref_to_Func'>LOG_LWDEBUG</span></a><span class='Parentheses'>(</span><span class='String'>"LWLockAcquire"</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1110"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>, </span><span class='String'>"immediately acquired lock"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>;</span>              <span class='Comment_Single_Line'>/* got the lock */ 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Ok, at this point we couldn't grab the lock on the first try. We 
         * cannot simply queue ourselves to the end of the list and wait to be 
         * woken up because by now the lock could long have been released. 
         * Instead add us to the queue and try to grab the lock again. If we 
         * succeed we need to revert the queuing and be happy, otherwise we 
         * recheck the lock. If we still couldn't grab it, we know that the 
         * other locker will see our queue entries when releasing since they 
         * existed before we checked for the lock. 
         */ 
</span> 
        <span class='Comment_Multi_Line'>/* add to the queue */ 
</span>        <a href="lwlock.c.html#LN970"><span class='Ref_to_Func'>LWLockQueueSelf</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1110"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1110"><span class='Ref_to_Parameter'>mode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* we're now guaranteed to be woken up if necessary */ 
</span>        <a href="lwlock.c.html#LN1169"><span class='Ref_To_Local'>mustwait</span></a> <span class='Operator'>= </span><a href="lwlock.c.html#LN727"><span class='Ref_to_Func'>LWLockAttemptLock</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1110"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1110"><span class='Ref_to_Parameter'>mode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* ok, grabbed the lock the second time round, need to undo queueing */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="lwlock.c.html#LN1169"><span class='Ref_To_Local'>mustwait</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="lwlock.c.html#LN211"><span class='Ref_to_Func'>LOG_LWDEBUG</span></a><span class='Parentheses'>(</span><span class='String'>"LWLockAcquire"</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1110"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>, </span><span class='String'>"acquired, undoing queue"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="lwlock.c.html#LN1014"><span class='Ref_to_Func'>LWLockDequeueSelf</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1110"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Wait until awakened. 
         * 
         * Since we share the process wait semaphore with the regular lock 
         * manager and ProcWaitForSignal, and we may need to acquire an LWLock 
         * while one of those is pending, it is possible that we get awakened 
         * for a reason other than being signaled by LWLockRelease. If so, 
         * loop back and wait again.  Once we've gotten the LWLock, 
         * re-increment the sema by the number of additional signals received, 
         * so that the lock manager or signal manager will see the received 
         * signal when it next waits. 
         */ 
</span>        <a href="lwlock.c.html#LN211"><span class='Ref_to_Func'>LOG_LWDEBUG</span></a><span class='Parentheses'>(</span><span class='String'>"LWLockAcquire"</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1110"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>, </span><span class='String'>"waiting"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> LWLOCK_STATS 
        <a href="lwlock.c.html#LN1116"><span class='Ref_To_Local'>lwstats</span></a><span class='Operator'>-&GT;</span><a href="lwlock.c.html#LN177"><span class='Ref_to_Member'>block_count</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
        <a href="lwlock.c.html#LN162"><span class='Ref_to_Proto'>LWLockReportWaitStart</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1110"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        TRACE_POSTGRESQL_LWLOCK_WAIT_START<span class='Parentheses'>(</span><a href="lwlock.c.html#LN116"><span class='Ref_to_Macro'>T_NAME</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1110"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1110"><span class='Ref_to_Parameter'>mode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../../include/storage/pg_sema.h.html#LN52"><span class='Ref_to_Proto'>PGSemaphoreLock</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1112"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN99"><span class='Ref_to_Member'>sem</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="lwlock.c.html#LN1112"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN125"><span class='Ref_to_Member'>lwWaiting</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <a href="lwlock.c.html#LN1114"><span class='Ref_To_Local'>extraWaits</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Retrying, allow LWLockRelease to release waiters again. */ 
</span>        <a href="../../../include/port/atomics.h.html#LN381"><span class='Ref_to_Func'>pg_atomic_fetch_or_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN1110"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN34"><span class='Ref_to_Member'>state</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN99"><span class='Ref_to_Const'>LW_FLAG_RELEASE_OK</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> LOCK_DEBUG 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* not waiting anymore */ 
</span><a name="LN1244"></a>            <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> nwaiters <span class='Declare_Local'>PG_USED_FOR_ASSERTS_ONLY</span> <span class='Operator'>= </span><a href="../../../include/port/atomics.h.html#LN352"><span class='Ref_to_Func'>pg_atomic_fetch_sub_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN1110"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN37"><span class='Ref_to_Member'>nwaiters</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Debug'>Assert</span><span class='Parentheses'>(</span>nwaiters <span class='Operator'>&LT; </span><a href="../../../include/postmaster/postmaster.h.html#LN74"><span class='Ref_to_Const'>MAX_BACKENDS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span><span class='Directive'>#endif</span> 
 
        TRACE_POSTGRESQL_LWLOCK_WAIT_DONE<span class='Parentheses'>(</span><a href="lwlock.c.html#LN116"><span class='Ref_to_Macro'>T_NAME</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1110"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1110"><span class='Ref_to_Parameter'>mode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="lwlock.c.html#LN163"><span class='Ref_to_Proto'>LWLockReportWaitEnd</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <a href="lwlock.c.html#LN211"><span class='Ref_to_Func'>LOG_LWDEBUG</span></a><span class='Parentheses'>(</span><span class='String'>"LWLockAcquire"</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1110"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>, </span><span class='String'>"awakened"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Now loop back and try to acquire lock again. */ 
</span>        <a href="lwlock.c.html#LN1113"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for ;; &raquo; </span> 
 
    TRACE_POSTGRESQL_LWLOCK_ACQUIRE<span class='Parentheses'>(</span><a href="lwlock.c.html#LN116"><span class='Ref_to_Macro'>T_NAME</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1110"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1110"><span class='Ref_to_Parameter'>mode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Add lock to list of locks held by this backend */ 
</span>    <a href="lwlock.c.html#LN142"><span class='Ref_to_Global_Var'>held_lwlocks</span></a><span class='Delimiter'>[</span><a href="lwlock.c.html#LN141"><span class='Ref_to_Global_Var'>num_held_lwlocks</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="lwlock.c.html#LN137"><span class='Ref_to_Member'>lock</span></a> <span class='Operator'>= </span><a href="lwlock.c.html#LN1110"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>; 
</span>    <a href="lwlock.c.html#LN142"><span class='Ref_to_Global_Var'>held_lwlocks</span></a><span class='Delimiter'>[</span><a href="lwlock.c.html#LN141"><span class='Ref_to_Global_Var'>num_held_lwlocks</span></a><span class='Operator'>++</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="lwlock.c.html#LN138"><span class='Ref_to_Member'>mode</span></a> <span class='Operator'>= </span><a href="lwlock.c.html#LN1110"><span class='Ref_to_Parameter'>mode</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Fix the process wait semaphore's count for any absorbed wakeups. 
     */ 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN1114"><span class='Ref_To_Local'>extraWaits</span></a><span class='Operator'>-- &GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/pg_sema.h.html#LN55"><span class='Ref_to_Proto'>PGSemaphoreUnlock</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1112"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN99"><span class='Ref_to_Member'>sem</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="lwlock.c.html#LN1113"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end LWLockAcquire &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * LWLockConditionalAcquire - acquire a lightweight lock in the specified mode 
 * 
 * If the lock is not available, return FALSE with no side-effects. 
 * 
 * If successful, cancel/die interrupts are held off until lock release. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN1282"></a><span class='Declare_Function'>LWLockConditionalAcquire</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>lock</span><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN131"><span class='Ref_to_Enum'>LWLockMode</span></a> <span class='Declare_Parameter'>mode</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1284"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>mustwait</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/c.h.html#LN676"><span class='Ref_to_Macro'>AssertArg</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1282"><span class='Ref_to_Parameter'>mode</span></a> <span class='Operator'>== </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a> <span class='Operator'>|| </span><a href="lwlock.c.html#LN1282"><span class='Ref_to_Parameter'>mode</span></a> <span class='Operator'>== </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="lwlock.c.html#LN189"><span class='Ref_to_Func'>PRINT_LWDEBUG</span></a><span class='Parentheses'>(</span><span class='String'>"LWLockConditionalAcquire"</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1282"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1282"><span class='Ref_to_Parameter'>mode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Ensure we will have room to remember the lock */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN141"><span class='Ref_to_Global_Var'>num_held_lwlocks</span></a> <span class='Operator'>&GT;= </span><a href="lwlock.c.html#LN132"><span class='Ref_to_Const'>MAX_SIMUL_LWLOCKS</span></a><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"too many LWLocks taken"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Lock out cancel/die interrupts until we exit the code section protected 
     * by the LWLock.  This ensures that interrupts will not interfere with 
     * manipulations of data structures in shared memory. 
     */ 
</span>    <a href="../../../include/miscadmin.h.html#LN116"><span class='Ref_to_Macro'>HOLD_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Check for the lock */ 
</span>    <a href="lwlock.c.html#LN1284"><span class='Ref_To_Local'>mustwait</span></a> <span class='Operator'>= </span><a href="lwlock.c.html#LN727"><span class='Ref_to_Func'>LWLockAttemptLock</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1282"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1282"><span class='Ref_to_Parameter'>mode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN1284"><span class='Ref_To_Local'>mustwait</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Failed to get lock, so release interrupt holdoff */ 
</span>        <a href="../../../include/miscadmin.h.html#LN118"><span class='Ref_to_Macro'>RESUME_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <a href="lwlock.c.html#LN211"><span class='Ref_to_Func'>LOG_LWDEBUG</span></a><span class='Parentheses'>(</span><span class='String'>"LWLockConditionalAcquire"</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1282"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>, </span><span class='String'>"failed"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        TRACE_POSTGRESQL_LWLOCK_CONDACQUIRE_FAIL<span class='Parentheses'>(</span><a href="lwlock.c.html#LN116"><span class='Ref_to_Macro'>T_NAME</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1282"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1282"><span class='Ref_to_Parameter'>mode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Add lock to list of locks held by this backend */ 
</span>        <a href="lwlock.c.html#LN142"><span class='Ref_to_Global_Var'>held_lwlocks</span></a><span class='Delimiter'>[</span><a href="lwlock.c.html#LN141"><span class='Ref_to_Global_Var'>num_held_lwlocks</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="lwlock.c.html#LN137"><span class='Ref_to_Member'>lock</span></a> <span class='Operator'>= </span><a href="lwlock.c.html#LN1282"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>; 
</span>        <a href="lwlock.c.html#LN142"><span class='Ref_to_Global_Var'>held_lwlocks</span></a><span class='Delimiter'>[</span><a href="lwlock.c.html#LN141"><span class='Ref_to_Global_Var'>num_held_lwlocks</span></a><span class='Operator'>++</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="lwlock.c.html#LN138"><span class='Ref_to_Member'>mode</span></a> <span class='Operator'>= </span><a href="lwlock.c.html#LN1282"><span class='Ref_to_Parameter'>mode</span></a><span class='Delimiter'>; 
</span>        TRACE_POSTGRESQL_LWLOCK_CONDACQUIRE<span class='Parentheses'>(</span><a href="lwlock.c.html#LN116"><span class='Ref_to_Macro'>T_NAME</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1282"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1282"><span class='Ref_to_Parameter'>mode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <span class='Operator'>!</span><a href="lwlock.c.html#LN1284"><span class='Ref_To_Local'>mustwait</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end LWLockConditionalAcquire &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * LWLockAcquireOrWait - Acquire lock, or wait until it's free 
 * 
 * The semantics of this function are a bit funky.  If the lock is currently 
 * free, it is acquired in the given mode, and the function returns true.  If 
 * the lock isn't immediately free, the function waits until it is released 
 * and returns false, but does not acquire the lock. 
 * 
 * This is currently used for WALWriteLock: when a backend flushes the WAL, 
 * holding WALWriteLock, it can flush the commit records of many other 
 * backends as a side-effect.  Those other backends need to wait until the 
 * flush finishes, but don't need to acquire the lock anymore.  They can just 
 * wake up, observe that their records have already been flushed, and return. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN1337"></a><span class='Declare_Function'>LWLockAcquireOrWait</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>lock</span><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN131"><span class='Ref_to_Enum'>LWLockMode</span></a> <span class='Declare_Parameter'>mode</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1339"></a>    <a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>proc</span> <span class='Operator'>= </span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Delimiter'>; 
</span><a name="LN1340"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>mustwait</span><span class='Delimiter'>; 
</span><a name="LN1341"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>extraWaits</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><span class='Directive'>#ifdef</span> LWLOCK_STATS 
<a name="LN1343"></a>    <a href="lwlock.c.html#LN172"><span class='Ref_to_Struct'>lwlock_stats</span></a> <span class='Operator'>*</span><span class='Declare_Local'>lwstats</span><span class='Delimiter'>; 
</span> 
    <a href="lwlock.c.html#LN1343"><span class='Ref_To_Local'>lwstats</span></a> <span class='Operator'>= </span><a href="lwlock.c.html#LN234"><span class='Ref_to_Proto'>get_lwlock_stats_entry</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1337"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1337"><span class='Ref_to_Parameter'>mode</span></a> <span class='Operator'>== </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a> <span class='Operator'>|| </span><a href="lwlock.c.html#LN1337"><span class='Ref_to_Parameter'>mode</span></a> <span class='Operator'>== </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="lwlock.c.html#LN189"><span class='Ref_to_Func'>PRINT_LWDEBUG</span></a><span class='Parentheses'>(</span><span class='String'>"LWLockAcquireOrWait"</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1337"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1337"><span class='Ref_to_Parameter'>mode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Ensure we will have room to remember the lock */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN141"><span class='Ref_to_Global_Var'>num_held_lwlocks</span></a> <span class='Operator'>&GT;= </span><a href="lwlock.c.html#LN132"><span class='Ref_to_Const'>MAX_SIMUL_LWLOCKS</span></a><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"too many LWLocks taken"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Lock out cancel/die interrupts until we exit the code section protected 
     * by the LWLock.  This ensures that interrupts will not interfere with 
     * manipulations of data structures in shared memory. 
     */ 
</span>    <a href="../../../include/miscadmin.h.html#LN116"><span class='Ref_to_Macro'>HOLD_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * NB: We're using nearly the same twice-in-a-row lock acquisition 
     * protocol as LWLockAcquire(). Check its comments for details. 
     */ 
</span>    <a href="lwlock.c.html#LN1340"><span class='Ref_To_Local'>mustwait</span></a> <span class='Operator'>= </span><a href="lwlock.c.html#LN727"><span class='Ref_to_Func'>LWLockAttemptLock</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1337"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1337"><span class='Ref_to_Parameter'>mode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN1340"><span class='Ref_To_Local'>mustwait</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="lwlock.c.html#LN970"><span class='Ref_to_Func'>LWLockQueueSelf</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1337"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN135"><span class='Ref_to_EnumConst'>LW_WAIT_UNTIL_FREE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="lwlock.c.html#LN1340"><span class='Ref_To_Local'>mustwait</span></a> <span class='Operator'>= </span><a href="lwlock.c.html#LN727"><span class='Ref_to_Func'>LWLockAttemptLock</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1337"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1337"><span class='Ref_to_Parameter'>mode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN1340"><span class='Ref_To_Local'>mustwait</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Wait until awakened.  Like in LWLockAcquire, be prepared for 
             * bogus wakeups, because we share the semaphore with 
             * ProcWaitForSignal. 
             */ 
</span>            <a href="lwlock.c.html#LN211"><span class='Ref_to_Func'>LOG_LWDEBUG</span></a><span class='Parentheses'>(</span><span class='String'>"LWLockAcquireOrWait"</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1337"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>, </span><span class='String'>"waiting"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> LWLOCK_STATS 
            <a href="lwlock.c.html#LN1343"><span class='Ref_To_Local'>lwstats</span></a><span class='Operator'>-&GT;</span><a href="lwlock.c.html#LN177"><span class='Ref_to_Member'>block_count</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
            <a href="lwlock.c.html#LN162"><span class='Ref_to_Proto'>LWLockReportWaitStart</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1337"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            TRACE_POSTGRESQL_LWLOCK_WAIT_START<span class='Parentheses'>(</span><a href="lwlock.c.html#LN116"><span class='Ref_to_Macro'>T_NAME</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1337"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1337"><span class='Ref_to_Parameter'>mode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="../../../include/storage/pg_sema.h.html#LN52"><span class='Ref_to_Proto'>PGSemaphoreLock</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1339"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN99"><span class='Ref_to_Member'>sem</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="lwlock.c.html#LN1339"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN125"><span class='Ref_to_Member'>lwWaiting</span></a><span class='Parentheses'>) 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <a href="lwlock.c.html#LN1341"><span class='Ref_To_Local'>extraWaits</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
<span class='Directive'>#ifdef</span> LOCK_DEBUG 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* not waiting anymore */ 
</span><a name="LN1402"></a>                <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> nwaiters <span class='Declare_Local'>PG_USED_FOR_ASSERTS_ONLY</span> <span class='Operator'>= </span><a href="../../../include/port/atomics.h.html#LN352"><span class='Ref_to_Func'>pg_atomic_fetch_sub_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN1337"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN37"><span class='Ref_to_Member'>nwaiters</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Debug'>Assert</span><span class='Parentheses'>(</span>nwaiters <span class='Operator'>&LT; </span><a href="../../../include/postmaster/postmaster.h.html#LN74"><span class='Ref_to_Const'>MAX_BACKENDS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span><span class='Directive'>#endif</span> 
            TRACE_POSTGRESQL_LWLOCK_WAIT_DONE<span class='Parentheses'>(</span><a href="lwlock.c.html#LN116"><span class='Ref_to_Macro'>T_NAME</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1337"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1337"><span class='Ref_to_Parameter'>mode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="lwlock.c.html#LN163"><span class='Ref_to_Proto'>LWLockReportWaitEnd</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
            <a href="lwlock.c.html#LN211"><span class='Ref_to_Func'>LOG_LWDEBUG</span></a><span class='Parentheses'>(</span><span class='String'>"LWLockAcquireOrWait"</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1337"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>, </span><span class='String'>"awakened"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if mustwait &raquo; </span> 
        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="lwlock.c.html#LN211"><span class='Ref_to_Func'>LOG_LWDEBUG</span></a><span class='Parentheses'>(</span><span class='String'>"LWLockAcquireOrWait"</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1337"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>, </span><span class='String'>"acquired, undoing queue"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Got lock in the second attempt, undo queueing. We need to treat 
             * this as having successfully acquired the lock, otherwise we'd 
             * not necessarily wake up people we've prevented from acquiring 
             * the lock. 
             */ 
</span>            <a href="lwlock.c.html#LN1014"><span class='Ref_to_Func'>LWLockDequeueSelf</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1337"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if mustwait &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Fix the process wait semaphore's count for any absorbed wakeups. 
     */ 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN1341"><span class='Ref_To_Local'>extraWaits</span></a><span class='Operator'>-- &GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/pg_sema.h.html#LN55"><span class='Ref_to_Proto'>PGSemaphoreUnlock</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1339"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN99"><span class='Ref_to_Member'>sem</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN1340"><span class='Ref_To_Local'>mustwait</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Failed to get lock, so release interrupt holdoff */ 
</span>        <a href="../../../include/miscadmin.h.html#LN118"><span class='Ref_to_Macro'>RESUME_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <a href="lwlock.c.html#LN211"><span class='Ref_to_Func'>LOG_LWDEBUG</span></a><span class='Parentheses'>(</span><span class='String'>"LWLockAcquireOrWait"</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1337"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>, </span><span class='String'>"failed"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        TRACE_POSTGRESQL_LWLOCK_ACQUIRE_OR_WAIT_FAIL<span class='Parentheses'>(</span><a href="lwlock.c.html#LN116"><span class='Ref_to_Macro'>T_NAME</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1337"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1337"><span class='Ref_to_Parameter'>mode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="lwlock.c.html#LN211"><span class='Ref_to_Func'>LOG_LWDEBUG</span></a><span class='Parentheses'>(</span><span class='String'>"LWLockAcquireOrWait"</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1337"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>, </span><span class='String'>"succeeded"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Add lock to list of locks held by this backend */ 
</span>        <a href="lwlock.c.html#LN142"><span class='Ref_to_Global_Var'>held_lwlocks</span></a><span class='Delimiter'>[</span><a href="lwlock.c.html#LN141"><span class='Ref_to_Global_Var'>num_held_lwlocks</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="lwlock.c.html#LN137"><span class='Ref_to_Member'>lock</span></a> <span class='Operator'>= </span><a href="lwlock.c.html#LN1337"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>; 
</span>        <a href="lwlock.c.html#LN142"><span class='Ref_to_Global_Var'>held_lwlocks</span></a><span class='Delimiter'>[</span><a href="lwlock.c.html#LN141"><span class='Ref_to_Global_Var'>num_held_lwlocks</span></a><span class='Operator'>++</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="lwlock.c.html#LN138"><span class='Ref_to_Member'>mode</span></a> <span class='Operator'>= </span><a href="lwlock.c.html#LN1337"><span class='Ref_to_Parameter'>mode</span></a><span class='Delimiter'>; 
</span>        TRACE_POSTGRESQL_LWLOCK_ACQUIRE_OR_WAIT<span class='Parentheses'>(</span><a href="lwlock.c.html#LN116"><span class='Ref_to_Macro'>T_NAME</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1337"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1337"><span class='Ref_to_Parameter'>mode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <span class='Operator'>!</span><a href="lwlock.c.html#LN1340"><span class='Ref_To_Local'>mustwait</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end LWLockAcquireOrWait &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Does the lwlock in its current state need to wait for the variable value to 
 * change? 
 * 
 * If we don't need to wait, and it's because the value of the variable has 
 * changed, store the current value in newval. 
 * 
 * *result is set to true if the lock was free, and false otherwise. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN1461"></a><span class='Declare_Function'>LWLockConflictsWithVar</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>lock</span><span class='Delimiter'>, 
</span><a name="LN1462"></a>                       <a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>valptr</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a> <span class='Declare_Parameter'>oldval</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>newval</span><span class='Delimiter'>, 
</span><a name="LN1463"></a>                       <span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>result</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1465"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>mustwait</span><span class='Delimiter'>; 
</span><a name="LN1466"></a>    <a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a>      <span class='Declare_Local'>value</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Test first to see if it the slot is free right now. 
     * 
     * XXX: the caller uses a spinlock before this, so we don't need a memory 
     * barrier here as far as the current usage is concerned.  But that might 
     * not be safe in general. 
     */ 
</span>    <a href="lwlock.c.html#LN1465"><span class='Ref_To_Local'>mustwait</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/port/atomics.h.html#LN250"><span class='Ref_to_Func'>pg_atomic_read_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN1461"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN34"><span class='Ref_to_Member'>state</span></a><span class='Parentheses'>) </span><span class='Operator'>& </span><a href="lwlock.c.html#LN102"><span class='Ref_to_Const'>LW_VAL_EXCLUSIVE</span></a><span class='Parentheses'>)</span> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="lwlock.c.html#LN1465"><span class='Ref_To_Local'>mustwait</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Operator'>*</span><a href="lwlock.c.html#LN1463"><span class='Ref_to_Parameter'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Operator'>*</span><a href="lwlock.c.html#LN1463"><span class='Ref_to_Parameter'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Read value using the lwlock's wait list lock, as we can't generally 
     * rely on atomic 64 bit reads/stores.  TODO: On platforms with a way to 
     * do atomic 64 bit reads/writes the spinlock should be optimized away. 
     */ 
</span>    <a href="lwlock.c.html#LN798"><span class='Ref_to_Func'>LWLockWaitListLock</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1461"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Keyword'>value </span><span class='Operator'>= *</span><a href="lwlock.c.html#LN1462"><span class='Ref_to_Parameter'>valptr</span></a><span class='Delimiter'>; 
</span>    <a href="lwlock.c.html#LN850"><span class='Ref_to_Func'>LWLockWaitListUnlock</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1461"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Keyword'>value </span><span class='Operator'>!= </span><a href="lwlock.c.html#LN1462"><span class='Ref_to_Parameter'>oldval</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="lwlock.c.html#LN1465"><span class='Ref_To_Local'>mustwait</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="lwlock.c.html#LN1462"><span class='Ref_to_Parameter'>newval</span></a> <span class='Operator'>= </span><span class='Keyword'>value</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="lwlock.c.html#LN1465"><span class='Ref_To_Local'>mustwait</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="lwlock.c.html#LN1465"><span class='Ref_To_Local'>mustwait</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end LWLockConflictsWithVar &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * LWLockWaitForVar - Wait until lock is free, or a variable is updated. 
 * 
 * If the lock is held and *valptr equals oldval, waits until the lock is 
 * either freed, or the lock holder updates *valptr by calling 
 * LWLockUpdateVar.  If the lock is free on exit (immediately or after 
 * waiting), returns true.  If the lock is still held, but *valptr no longer 
 * matches oldval, returns false and sets *newval to the current value in 
 * *valptr. 
 * 
 * Note: this function ignores shared lock holders; if the lock is held 
 * in shared mode, returns 'true'. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN1521"></a><span class='Declare_Function'>LWLockWaitForVar</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>lock</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>valptr</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a> <span class='Declare_Parameter'>oldval</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>newval</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1523"></a>    <a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>proc</span> <span class='Operator'>= </span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Delimiter'>; 
</span><a name="LN1524"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>extraWaits</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1525"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>result</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><span class='Directive'>#ifdef</span> LWLOCK_STATS 
<a name="LN1527"></a>    <a href="lwlock.c.html#LN172"><span class='Ref_to_Struct'>lwlock_stats</span></a> <span class='Operator'>*</span><span class='Declare_Local'>lwstats</span><span class='Delimiter'>; 
</span> 
    <a href="lwlock.c.html#LN1527"><span class='Ref_To_Local'>lwstats</span></a> <span class='Operator'>= </span><a href="lwlock.c.html#LN234"><span class='Ref_to_Proto'>get_lwlock_stats_entry</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1521"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
    <a href="lwlock.c.html#LN189"><span class='Ref_to_Func'>PRINT_LWDEBUG</span></a><span class='Parentheses'>(</span><span class='String'>"LWLockWaitForVar"</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1521"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN135"><span class='Ref_to_EnumConst'>LW_WAIT_UNTIL_FREE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Lock out cancel/die interrupts while we sleep on the lock.  There is no 
     * cleanup mechanism to remove us from the wait queue if we got 
     * interrupted. 
     */ 
</span>    <a href="../../../include/miscadmin.h.html#LN116"><span class='Ref_to_Macro'>HOLD_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Loop here to check the lock's status after each time we are signaled. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1546"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>mustwait</span><span class='Delimiter'>; 
</span> 
        <a href="lwlock.c.html#LN1546"><span class='Ref_To_Local'>mustwait</span></a> <span class='Operator'>= </span><a href="lwlock.c.html#LN1460"><span class='Ref_to_Func'>LWLockConflictsWithVar</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1521"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1521"><span class='Ref_to_Parameter'>valptr</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1521"><span class='Ref_to_Parameter'>oldval</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1521"><span class='Ref_to_Parameter'>newval</span></a><span class='Delimiter'>, 
</span>                                          <span class='Operator'>&</span><a href="lwlock.c.html#LN1525"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="lwlock.c.html#LN1546"><span class='Ref_To_Local'>mustwait</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>break</span><span class='Delimiter'>;</span>              <span class='Comment_Single_Line'>/* the lock was free or value didn't match */ 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Add myself to wait queue. Note that this is racy, somebody else 
         * could wakeup before we're finished queuing. NB: We're using nearly 
         * the same twice-in-a-row lock acquisition protocol as 
         * LWLockAcquire(). Check its comments for details. The only 
         * difference is that we also have to check the variable's values when 
         * checking the state of the lock. 
         */ 
</span>        <a href="lwlock.c.html#LN970"><span class='Ref_to_Func'>LWLockQueueSelf</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1521"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN135"><span class='Ref_to_EnumConst'>LW_WAIT_UNTIL_FREE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Set RELEASE_OK flag, to make sure we get woken up as soon as the 
         * lock is released. 
         */ 
</span>        <a href="../../../include/port/atomics.h.html#LN381"><span class='Ref_to_Func'>pg_atomic_fetch_or_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN1521"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN34"><span class='Ref_to_Member'>state</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN99"><span class='Ref_to_Const'>LW_FLAG_RELEASE_OK</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We're now guaranteed to be woken up if necessary. Recheck the lock 
         * and variables state. 
         */ 
</span>        <a href="lwlock.c.html#LN1546"><span class='Ref_To_Local'>mustwait</span></a> <span class='Operator'>= </span><a href="lwlock.c.html#LN1460"><span class='Ref_to_Func'>LWLockConflictsWithVar</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1521"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1521"><span class='Ref_to_Parameter'>valptr</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1521"><span class='Ref_to_Parameter'>oldval</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1521"><span class='Ref_to_Parameter'>newval</span></a><span class='Delimiter'>, 
</span>                                          <span class='Operator'>&</span><a href="lwlock.c.html#LN1525"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Ok, no conflict after we queued ourselves. Undo queueing. */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="lwlock.c.html#LN1546"><span class='Ref_To_Local'>mustwait</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="lwlock.c.html#LN211"><span class='Ref_to_Func'>LOG_LWDEBUG</span></a><span class='Parentheses'>(</span><span class='String'>"LWLockWaitForVar"</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1521"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>, </span><span class='String'>"free, undoing queue"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="lwlock.c.html#LN1014"><span class='Ref_to_Func'>LWLockDequeueSelf</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1521"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Wait until awakened. 
         * 
         * Since we share the process wait semaphore with the regular lock 
         * manager and ProcWaitForSignal, and we may need to acquire an LWLock 
         * while one of those is pending, it is possible that we get awakened 
         * for a reason other than being signaled by LWLockRelease. If so, 
         * loop back and wait again.  Once we've gotten the LWLock, 
         * re-increment the sema by the number of additional signals received, 
         * so that the lock manager or signal manager will see the received 
         * signal when it next waits. 
         */ 
</span>        <a href="lwlock.c.html#LN211"><span class='Ref_to_Func'>LOG_LWDEBUG</span></a><span class='Parentheses'>(</span><span class='String'>"LWLockWaitForVar"</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1521"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>, </span><span class='String'>"waiting"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> LWLOCK_STATS 
        <a href="lwlock.c.html#LN1527"><span class='Ref_To_Local'>lwstats</span></a><span class='Operator'>-&GT;</span><a href="lwlock.c.html#LN177"><span class='Ref_to_Member'>block_count</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
        <a href="lwlock.c.html#LN162"><span class='Ref_to_Proto'>LWLockReportWaitStart</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1521"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        TRACE_POSTGRESQL_LWLOCK_WAIT_START<span class='Parentheses'>(</span><a href="lwlock.c.html#LN116"><span class='Ref_to_Macro'>T_NAME</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1521"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../../include/storage/pg_sema.h.html#LN52"><span class='Ref_to_Proto'>PGSemaphoreLock</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1523"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN99"><span class='Ref_to_Member'>sem</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="lwlock.c.html#LN1523"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN125"><span class='Ref_to_Member'>lwWaiting</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <a href="lwlock.c.html#LN1524"><span class='Ref_To_Local'>extraWaits</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
<span class='Directive'>#ifdef</span> LOCK_DEBUG 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* not waiting anymore */ 
</span><a name="LN1618"></a>            <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> nwaiters <span class='Declare_Local'>PG_USED_FOR_ASSERTS_ONLY</span> <span class='Operator'>= </span><a href="../../../include/port/atomics.h.html#LN352"><span class='Ref_to_Func'>pg_atomic_fetch_sub_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN1521"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN37"><span class='Ref_to_Member'>nwaiters</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Debug'>Assert</span><span class='Parentheses'>(</span>nwaiters <span class='Operator'>&LT; </span><a href="../../../include/postmaster/postmaster.h.html#LN74"><span class='Ref_to_Const'>MAX_BACKENDS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span><span class='Directive'>#endif</span> 
 
        TRACE_POSTGRESQL_LWLOCK_WAIT_DONE<span class='Parentheses'>(</span><a href="lwlock.c.html#LN116"><span class='Ref_to_Macro'>T_NAME</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1521"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="lwlock.c.html#LN163"><span class='Ref_to_Proto'>LWLockReportWaitEnd</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <a href="lwlock.c.html#LN211"><span class='Ref_to_Func'>LOG_LWDEBUG</span></a><span class='Parentheses'>(</span><span class='String'>"LWLockWaitForVar"</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1521"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>, </span><span class='String'>"awakened"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Now loop back and check the status of the lock again. */ 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for ;; &raquo; </span> 
 
    TRACE_POSTGRESQL_LWLOCK_ACQUIRE<span class='Parentheses'>(</span><a href="lwlock.c.html#LN116"><span class='Ref_to_Macro'>T_NAME</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1521"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Fix the process wait semaphore's count for any absorbed wakeups. 
     */ 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN1524"><span class='Ref_To_Local'>extraWaits</span></a><span class='Operator'>-- &GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/pg_sema.h.html#LN55"><span class='Ref_to_Proto'>PGSemaphoreUnlock</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1523"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN99"><span class='Ref_to_Member'>sem</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now okay to allow cancel/die interrupts. 
     */ 
</span>    <a href="../../../include/miscadmin.h.html#LN118"><span class='Ref_to_Macro'>RESUME_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="lwlock.c.html#LN1525"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end LWLockWaitForVar &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * LWLockUpdateVar - Update a variable and wake up waiters atomically 
 * 
 * Sets *valptr to 'val', and wakes up all processes waiting for us with 
 * LWLockWaitForVar().  Setting the value and waking up the processes happen 
 * atomically so that any process calling LWLockWaitForVar() on the same lock 
 * is guaranteed to see the new value, and act accordingly. 
 * 
 * The caller must be holding the lock in exclusive mode. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1660"></a><span class='Declare_Function'>LWLockUpdateVar</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>lock</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>valptr</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a> <span class='Declare_Parameter'>val</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1662"></a>    <a href="../../../include/storage/proclist_types.h.html#LN29"><span class='Ref_to_Struct'>proclist_head</span></a> <span class='Declare_Local'>wakeup</span><span class='Delimiter'>; 
</span><a name="LN1663"></a>    <a href="../../../include/storage/proclist_types.h.html#LN38"><span class='Ref_to_Struct'>proclist_mutable_iter</span></a> <span class='Declare_Local'>iter</span><span class='Delimiter'>; 
</span> 
    <a href="lwlock.c.html#LN189"><span class='Ref_to_Func'>PRINT_LWDEBUG</span></a><span class='Parentheses'>(</span><span class='String'>"LWLockUpdateVar"</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1660"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/proclist.h.html#LN27"><span class='Ref_to_Func'>proclist_init</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN1662"><span class='Ref_To_Local'>wakeup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="lwlock.c.html#LN798"><span class='Ref_to_Func'>LWLockWaitListLock</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1660"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/port/atomics.h.html#LN250"><span class='Ref_to_Func'>pg_atomic_read_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN1660"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN34"><span class='Ref_to_Member'>state</span></a><span class='Parentheses'>) </span><span class='Operator'>& </span><a href="lwlock.c.html#LN102"><span class='Ref_to_Const'>LW_VAL_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Update the lock's value */ 
</span>    <span class='Operator'>*</span><a href="lwlock.c.html#LN1660"><span class='Ref_to_Parameter'>valptr</span></a> <span class='Operator'>= </span><a href="lwlock.c.html#LN1660"><span class='Ref_to_Parameter'>val</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * See if there are any LW_WAIT_UNTIL_FREE waiters that need to be woken 
     * up. They are always in the front of the queue. 
     */ 
</span>    <a href="../../../include/storage/proclist.h.html#LN194"><span class='Ref_to_Macro'>proclist_foreach_modify</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1663"><span class='Ref_To_Local'>iter</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="lwlock.c.html#LN1660"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN35"><span class='Ref_to_Member'>waiters</span></a><span class='Delimiter'>, </span>lwWaitLink<span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1682"></a>        <a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>waiter</span> <span class='Operator'>= </span><a href="../../../include/storage/proc.h.html#LN262"><span class='Ref_to_Macro'>GetPGProcByNumber</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1663"><span class='Ref_To_Local'>iter</span></a><span class='Operator'>.</span><a href="../../../include/storage/proclist_types.h.html#LN40"><span class='Ref_to_Member'>cur</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN1682"><span class='Ref_To_Local'>waiter</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN126"><span class='Ref_to_Member'>lwWaitMode</span></a> <span class='Operator'>!= </span><a href="../../../include/storage/lwlock.h.html#LN135"><span class='Ref_to_EnumConst'>LW_WAIT_UNTIL_FREE</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/storage/proclist.h.html#LN175"><span class='Ref_to_Macro'>proclist_delete</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN1660"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN35"><span class='Ref_to_Member'>waiters</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1663"><span class='Ref_To_Local'>iter</span></a><span class='Operator'>.</span><a href="../../../include/storage/proclist_types.h.html#LN40"><span class='Ref_to_Member'>cur</span></a><span class='Delimiter'>, </span>lwWaitLink<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/proclist.h.html#LN179"><span class='Ref_to_Macro'>proclist_push_tail</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN1662"><span class='Ref_To_Local'>wakeup</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1663"><span class='Ref_To_Local'>iter</span></a><span class='Operator'>.</span><a href="../../../include/storage/proclist_types.h.html#LN40"><span class='Ref_to_Member'>cur</span></a><span class='Delimiter'>, </span>lwWaitLink<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* We are done updating shared state of the lock itself. */ 
</span>    <a href="lwlock.c.html#LN850"><span class='Ref_to_Func'>LWLockWaitListUnlock</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1660"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Awaken any waiters I removed from the queue. 
     */ 
</span>    <a href="../../../include/storage/proclist.h.html#LN194"><span class='Ref_to_Macro'>proclist_foreach_modify</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1663"><span class='Ref_To_Local'>iter</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="lwlock.c.html#LN1662"><span class='Ref_To_Local'>wakeup</span></a><span class='Delimiter'>, </span>lwWaitLink<span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1699"></a>        <a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>waiter</span> <span class='Operator'>= </span><a href="../../../include/storage/proc.h.html#LN262"><span class='Ref_to_Macro'>GetPGProcByNumber</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1663"><span class='Ref_To_Local'>iter</span></a><span class='Operator'>.</span><a href="../../../include/storage/proclist_types.h.html#LN40"><span class='Ref_to_Member'>cur</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/storage/proclist.h.html#LN175"><span class='Ref_to_Macro'>proclist_delete</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN1662"><span class='Ref_To_Local'>wakeup</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1663"><span class='Ref_To_Local'>iter</span></a><span class='Operator'>.</span><a href="../../../include/storage/proclist_types.h.html#LN40"><span class='Ref_to_Member'>cur</span></a><span class='Delimiter'>, </span>lwWaitLink<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* check comment in LWLockWakeup() about this barrier */ 
</span>        <a href="../../../include/port/atomics.h.html#LN161"><span class='Ref_to_Macro'>pg_write_barrier</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <a href="lwlock.c.html#LN1699"><span class='Ref_To_Local'>waiter</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN125"><span class='Ref_to_Member'>lwWaiting</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/pg_sema.h.html#LN55"><span class='Ref_to_Proto'>PGSemaphoreUnlock</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1699"><span class='Ref_To_Local'>waiter</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN99"><span class='Ref_to_Member'>sem</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end LWLockUpdateVar &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * LWLockRelease - release a previously acquired lock 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1714"></a><span class='Declare_Function'>LWLockRelease</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>lock</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1716"></a>    <a href="../../../include/storage/lwlock.h.html#LN131"><span class='Ref_to_Enum'>LWLockMode</span></a>  <span class='Declare_Local'>mode</span><span class='Delimiter'>; 
</span><a name="LN1717"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>oldstate</span><span class='Delimiter'>; 
</span><a name="LN1718"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>check_waiters</span><span class='Delimiter'>; 
</span><a name="LN1719"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Remove lock from list of locks held.  Usually, but not always, it will 
     * be the latest-acquired lock; so search array backwards. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN1719"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><a href="lwlock.c.html#LN141"><span class='Ref_to_Global_Var'>num_held_lwlocks</span></a><span class='Delimiter'>; </span><span class='Operator'>--</span><a href="lwlock.c.html#LN1719"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Delimiter'>;</span><span class='Parentheses'>) 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN1714"><span class='Ref_to_Parameter'>lock</span></a> <span class='Operator'>== </span><a href="lwlock.c.html#LN142"><span class='Ref_to_Global_Var'>held_lwlocks</span></a><span class='Delimiter'>[</span><a href="lwlock.c.html#LN1719"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="lwlock.c.html#LN137"><span class='Ref_to_Member'>lock</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN1719"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"lock %s is not held"</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN116"><span class='Ref_to_Macro'>T_NAME</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1714"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="lwlock.c.html#LN1716"><span class='Ref_To_Local'>mode</span></a> <span class='Operator'>= </span><a href="lwlock.c.html#LN142"><span class='Ref_to_Global_Var'>held_lwlocks</span></a><span class='Delimiter'>[</span><a href="lwlock.c.html#LN1719"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="lwlock.c.html#LN138"><span class='Ref_to_Member'>mode</span></a><span class='Delimiter'>; 
</span> 
    <a href="lwlock.c.html#LN141"><span class='Ref_to_Global_Var'>num_held_lwlocks</span></a><span class='Operator'>--</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>; </span><a href="lwlock.c.html#LN1719"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="lwlock.c.html#LN141"><span class='Ref_to_Global_Var'>num_held_lwlocks</span></a><span class='Delimiter'>; </span><a href="lwlock.c.html#LN1719"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <a href="lwlock.c.html#LN142"><span class='Ref_to_Global_Var'>held_lwlocks</span></a><span class='Delimiter'>[</span><a href="lwlock.c.html#LN1719"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="lwlock.c.html#LN142"><span class='Ref_to_Global_Var'>held_lwlocks</span></a><span class='Delimiter'>[</span><a href="lwlock.c.html#LN1719"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span> 
    <a href="lwlock.c.html#LN189"><span class='Ref_to_Func'>PRINT_LWDEBUG</span></a><span class='Parentheses'>(</span><span class='String'>"LWLockRelease"</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1714"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1716"><span class='Ref_To_Local'>mode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Release my hold on lock, after that it can immediately be acquired by 
     * others, even if we still have to wakeup other waiters. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN1716"><span class='Ref_To_Local'>mode</span></a> <span class='Operator'>== </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>) 
</span>        <a href="lwlock.c.html#LN1717"><span class='Ref_To_Local'>oldstate</span></a> <span class='Operator'>= </span><a href="../../../include/port/atomics.h.html#LN410"><span class='Ref_to_Func'>pg_atomic_sub_fetch_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN1714"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN34"><span class='Ref_to_Member'>state</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN102"><span class='Ref_to_Const'>LW_VAL_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="lwlock.c.html#LN1717"><span class='Ref_To_Local'>oldstate</span></a> <span class='Operator'>= </span><a href="../../../include/port/atomics.h.html#LN410"><span class='Ref_to_Func'>pg_atomic_sub_fetch_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN1714"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lwlock.h.html#LN34"><span class='Ref_to_Member'>state</span></a><span class='Delimiter'>, </span><a href="lwlock.c.html#LN103"><span class='Ref_to_Const'>LW_VAL_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* nobody else can have that kind of lock */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1717"><span class='Ref_To_Local'>oldstate</span></a> <span class='Operator'>& </span><a href="lwlock.c.html#LN102"><span class='Ref_to_Const'>LW_VAL_EXCLUSIVE</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
 
    <span class='Comment_Multi_Line'>/* 
     * We're still waiting for backends to get scheduled, don't wake them up 
     * again. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="lwlock.c.html#LN1717"><span class='Ref_To_Local'>oldstate</span></a> <span class='Operator'>& </span><span class='Parentheses'>(</span><a href="lwlock.c.html#LN98"><span class='Ref_to_Const'>LW_FLAG_HAS_WAITERS</span></a> <span class='Operator'>| </span><a href="lwlock.c.html#LN99"><span class='Ref_to_Const'>LW_FLAG_RELEASE_OK</span></a><span class='Parentheses'>))</span> <span class='Operator'>== 
</span>        <span class='Parentheses'>(</span><a href="lwlock.c.html#LN98"><span class='Ref_to_Const'>LW_FLAG_HAS_WAITERS</span></a> <span class='Operator'>| </span><a href="lwlock.c.html#LN99"><span class='Ref_to_Const'>LW_FLAG_RELEASE_OK</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>        <span class='Parentheses'>(</span><a href="lwlock.c.html#LN1717"><span class='Ref_To_Local'>oldstate</span></a> <span class='Operator'>& </span><a href="lwlock.c.html#LN105"><span class='Ref_to_Const'>LW_LOCK_MASK</span></a><span class='Parentheses'>)</span> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <a href="lwlock.c.html#LN1718"><span class='Ref_To_Local'>check_waiters</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="lwlock.c.html#LN1718"><span class='Ref_To_Local'>check_waiters</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * As waking up waiters requires the spinlock to be acquired, only do so 
     * if necessary. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN1718"><span class='Ref_To_Local'>check_waiters</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* XXX: remove before commit? */ 
</span>        <a href="lwlock.c.html#LN211"><span class='Ref_to_Func'>LOG_LWDEBUG</span></a><span class='Parentheses'>(</span><span class='String'>"LWLockRelease"</span><span class='Delimiter'>, </span><a href="lwlock.c.html#LN1714"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>, </span><span class='String'>"releasing waiters"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="lwlock.c.html#LN863"><span class='Ref_to_Func'>LWLockWakeup</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1714"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    TRACE_POSTGRESQL_LWLOCK_RELEASE<span class='Parentheses'>(</span><a href="lwlock.c.html#LN116"><span class='Ref_to_Macro'>T_NAME</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1714"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now okay to allow cancel/die interrupts. 
     */ 
</span>    <a href="../../../include/miscadmin.h.html#LN118"><span class='Ref_to_Macro'>RESUME_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end LWLockRelease &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * LWLockReleaseClearVar - release a previously acquired lock, reset variable 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1787"></a><span class='Declare_Function'>LWLockReleaseClearVar</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>lock</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>valptr</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a> <span class='Declare_Parameter'>val</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="lwlock.c.html#LN798"><span class='Ref_to_Func'>LWLockWaitListLock</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1787"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Set the variable's value before releasing the lock, that prevents race 
     * a race condition wherein a new locker acquires the lock, but hasn't yet 
     * set the variables value. 
     */ 
</span>    <span class='Operator'>*</span><a href="lwlock.c.html#LN1787"><span class='Ref_to_Parameter'>valptr</span></a> <span class='Operator'>= </span><a href="lwlock.c.html#LN1787"><span class='Ref_to_Parameter'>val</span></a><span class='Delimiter'>; 
</span>    <a href="lwlock.c.html#LN850"><span class='Ref_to_Func'>LWLockWaitListUnlock</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1787"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN1787"><span class='Ref_to_Parameter'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * LWLockReleaseAll - release all currently-held locks 
 * 
 * Used to clean up after ereport(ERROR). An important difference between this 
 * function and retail LWLockRelease calls is that InterruptHoldoffCount is 
 * unchanged by this operation.  This is necessary since InterruptHoldoffCount 
 * has been set to an appropriate level earlier in error recovery. We could 
 * decrement it below zero if we allow it to drop for each released lock! 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1813"></a><span class='Declare_Function'>LWLockReleaseAll</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN141"><span class='Ref_to_Global_Var'>num_held_lwlocks</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/miscadmin.h.html#LN116"><span class='Ref_to_Macro'>HOLD_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* match the upcoming RESUME_INTERRUPTS */ 
</span> 
        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="lwlock.c.html#LN142"><span class='Ref_to_Global_Var'>held_lwlocks</span></a><span class='Delimiter'>[</span><a href="lwlock.c.html#LN141"><span class='Ref_to_Global_Var'>num_held_lwlocks</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="lwlock.c.html#LN137"><span class='Ref_to_Member'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * LWLockHeldByMe - test whether my process holds a lock in any mode 
 * 
 * This is meant as debug support only. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN1830"></a><span class='Declare_Function'>LWLockHeldByMe</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>l</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1832"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN1832"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="lwlock.c.html#LN1832"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="lwlock.c.html#LN141"><span class='Ref_to_Global_Var'>num_held_lwlocks</span></a><span class='Delimiter'>; </span><a href="lwlock.c.html#LN1832"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN142"><span class='Ref_to_Global_Var'>held_lwlocks</span></a><span class='Delimiter'>[</span><a href="lwlock.c.html#LN1832"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="lwlock.c.html#LN137"><span class='Ref_to_Member'>lock</span></a> <span class='Operator'>== </span><a href="lwlock.c.html#LN1830"><span class='Ref_to_Parameter'>l</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * LWLockHeldByMeInMode - test whether my process holds a lock in given mode 
 * 
 * This is meant as debug support only. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN1848"></a><span class='Declare_Function'>LWLockHeldByMeInMode</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>l</span><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN131"><span class='Ref_to_Enum'>LWLockMode</span></a> <span class='Declare_Parameter'>mode</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1850"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN1850"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="lwlock.c.html#LN1850"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="lwlock.c.html#LN141"><span class='Ref_to_Global_Var'>num_held_lwlocks</span></a><span class='Delimiter'>; </span><a href="lwlock.c.html#LN1850"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lwlock.c.html#LN142"><span class='Ref_to_Global_Var'>held_lwlocks</span></a><span class='Delimiter'>[</span><a href="lwlock.c.html#LN1850"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="lwlock.c.html#LN137"><span class='Ref_to_Member'>lock</span></a> <span class='Operator'>== </span><a href="lwlock.c.html#LN1848"><span class='Ref_to_Parameter'>l</span></a> <span class='Operator'>&& </span><a href="lwlock.c.html#LN142"><span class='Ref_to_Global_Var'>held_lwlocks</span></a><span class='Delimiter'>[</span><a href="lwlock.c.html#LN1850"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="lwlock.c.html#LN138"><span class='Ref_to_Member'>mode</span></a> <span class='Operator'>== </span><a href="lwlock.c.html#LN1848"><span class='Ref_to_Parameter'>mode</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
} 
</span></pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>