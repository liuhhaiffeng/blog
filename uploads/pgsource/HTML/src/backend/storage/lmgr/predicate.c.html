<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\storage\lmgr\predicate.c</title>
<LINK REL=StyleSheet HREF="../../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\storage\lmgr\predicate.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:49 2017
</td></tr>
<tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * predicate.c 
 *    POSTGRES predicate locking 
 *    to support full serializable transaction isolation 
 * 
 * 
 * The approach taken is to implement Serializable Snapshot Isolation (SSI) 
 * as initially described in this paper: 
 * 
 *  Michael J. Cahill, Uwe RÃ¶hm, and Alan D. Fekete. 2008. 
 *  Serializable isolation for snapshot databases. 
 *  In SIGMOD '08: Proceedings of the 2008 ACM SIGMOD 
 *  international conference on Management of data, 
 *  pages 729-738, New York, NY, USA. ACM. 
 *  http://doi.acm.org/10.1145/1376616.1376690 
 * 
 * and further elaborated in Cahill's doctoral thesis: 
 * 
 *  Michael James Cahill. 2009. 
 *  Serializable Isolation for Snapshot Databases. 
 *  Sydney Digital Theses. 
 *  University of Sydney, School of Information Technologies. 
 *  http://hdl.handle.net/2123/5353 
 * 
 * 
 * Predicate locks for Serializable Snapshot Isolation (SSI) are SIREAD 
 * locks, which are so different from normal locks that a distinct set of 
 * structures is required to handle them.  They are needed to detect 
 * rw-conflicts when the read happens before the write.  (When the write 
 * occurs first, the reading transaction can check for a conflict by 
 * examining the MVCC data.) 
 * 
 * (1)  Besides tuples actually read, they must cover ranges of tuples 
 *      which would have been read based on the predicate.  This will 
 *      require modelling the predicates through locks against database 
 *      objects such as pages, index ranges, or entire tables. 
 * 
 * (2)  They must be kept in RAM for quick access.  Because of this, it 
 *      isn't possible to always maintain tuple-level granularity -- when 
 *      the space allocated to store these approaches exhaustion, a 
 *      request for a lock may need to scan for situations where a single 
 *      transaction holds many fine-grained locks which can be coalesced 
 *      into a single coarser-grained lock. 
 * 
 * (3)  They never block anything; they are more like flags than locks 
 *      in that regard; although they refer to database objects and are 
 *      used to identify rw-conflicts with normal write locks. 
 * 
 * (4)  While they are associated with a transaction, they must survive 
 *      a successful COMMIT of that transaction, and remain until all 
 *      overlapping transactions complete.  This even means that they 
 *      must survive termination of the transaction's process.  If a 
 *      top level transaction is rolled back, however, it is immediately 
 *      flagged so that it can be ignored, and its SIREAD locks can be 
 *      released any time after that. 
 * 
 * (5)  The only transactions which create SIREAD locks or check for 
 *      conflicts with them are serializable transactions. 
 * 
 * (6)  When a write lock for a top level transaction is found to cover 
 *      an existing SIREAD lock for the same transaction, the SIREAD lock 
 *      can be deleted. 
 * 
 * (7)  A write from a serializable transaction must ensure that an xact 
 *      record exists for the transaction, with the same lifespan (until 
 *      all concurrent transaction complete or the transaction is rolled 
 *      back) so that rw-dependencies to that transaction can be 
 *      detected. 
 * 
 * We use an optimization for read-only transactions. Under certain 
 * circumstances, a read-only transaction's snapshot can be shown to 
 * never have conflicts with other transactions.  This is referred to 
 * as a "safe" snapshot (and one known not to be is "unsafe"). 
 * However, it can't be determined whether a snapshot is safe until 
 * all concurrent read/write transactions complete. 
 * 
 * Once a read-only transaction is known to have a safe snapshot, it 
 * can release its predicate locks and exempt itself from further 
 * predicate lock tracking. READ ONLY DEFERRABLE transactions run only 
 * on safe snapshots, waiting as necessary for one to be available. 
 * 
 * 
 * Lightweight locks to manage access to the predicate locking shared 
 * memory objects must be taken in this order, and should be released in 
 * reverse order: 
 * 
 *  SerializableFinishedListLock 
 *      - Protects the list of transactions which have completed but which 
 *          may yet matter because they overlap still-active transactions. 
 * 
 *  SerializablePredicateLockListLock 
 *      - Protects the linked list of locks held by a transaction.  Note 
 *          that the locks themselves are also covered by the partition 
 *          locks of their respective lock targets; this lock only affects 
 *          the linked list connecting the locks related to a transaction. 
 *      - All transactions share this single lock (with no partitioning). 
 *      - There is never a need for a process other than the one running 
 *          an active transaction to walk the list of locks held by that 
 *          transaction. 
 *      - It is relatively infrequent that another process needs to 
 *          modify the list for a transaction, but it does happen for such 
 *          things as index page splits for pages with predicate locks and 
 *          freeing of predicate locked pages by a vacuum process.  When 
 *          removing a lock in such cases, the lock itself contains the 
 *          pointers needed to remove it from the list.  When adding a 
 *          lock in such cases, the lock can be added using the anchor in 
 *          the transaction structure.  Neither requires walking the list. 
 *      - Cleaning up the list for a terminated transaction is sometimes 
 *          not done on a retail basis, in which case no lock is required. 
 *      - Due to the above, a process accessing its active transaction's 
 *          list always uses a shared lock, regardless of whether it is 
 *          walking or maintaining the list.  This improves concurrency 
 *          for the common access patterns. 
 *      - A process which needs to alter the list of a transaction other 
 *          than its own active transaction must acquire an exclusive 
 *          lock. 
 * 
 *  FirstPredicateLockMgrLock based partition locks 
 *      - The same lock protects a target, all locks on that target, and 
 *          the linked list of locks on the target.. 
 *      - When more than one is needed, acquire in ascending order. 
 * 
 *  SerializableXactHashLock 
 *      - Protects both PredXact and SerializableXidHash. 
 * 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * 
 * IDENTIFICATION 
 *    src/backend/storage/lmgr/predicate.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
/* 
 * INTERFACE ROUTINES 
 * 
 * housekeeping for setting up shared memory predicate lock structures 
 *      InitPredicateLocks(void) 
 *      PredicateLockShmemSize(void) 
 * 
 * predicate lock reporting 
 *      GetPredicateLockStatusData(void) 
 *      PageIsPredicateLocked(Relation relation, BlockNumber blkno) 
 * 
 * predicate lock maintenance 
 *      GetSerializableTransactionSnapshot(Snapshot snapshot) 
 *      SetSerializableTransactionSnapshot(Snapshot snapshot, 
 *                                         TransactionId sourcexid) 
 *      RegisterPredicateLockingXid(void) 
 *      PredicateLockRelation(Relation relation, Snapshot snapshot) 
 *      PredicateLockPage(Relation relation, BlockNumber blkno, 
 *                      Snapshot snapshot) 
 *      PredicateLockTuple(Relation relation, HeapTuple tuple, 
 *                      Snapshot snapshot) 
 *      PredicateLockPageSplit(Relation relation, BlockNumber oldblkno, 
 *                             BlockNumber newblkno) 
 *      PredicateLockPageCombine(Relation relation, BlockNumber oldblkno, 
 *                               BlockNumber newblkno) 
 *      TransferPredicateLocksToHeapRelation(Relation relation) 
 *      ReleasePredicateLocks(bool isCommit) 
 * 
 * conflict detection (may also trigger rollback) 
 *      CheckForSerializableConflictOut(bool visible, Relation relation, 
 *                                      HeapTupleData *tup, Buffer buffer, 
 *                                      Snapshot snapshot) 
 *      CheckForSerializableConflictIn(Relation relation, HeapTupleData *tup, 
 *                                     Buffer buffer) 
 *      CheckTableForSerializableConflictIn(Relation relation) 
 * 
 * final rollback checking 
 *      PreCommit_CheckForSerializationFailure(void) 
 * 
 * two-phase commit support 
 *      AtPrepare_PredicateLocks(void); 
 *      PostPrepare_PredicateLocks(TransactionId xid); 
 *      PredicateLockTwoPhaseFinish(TransactionId xid, bool isCommit); 
 *      predicatelock_twophase_recover(TransactionId xid, uint16 info, 
 *                                     void *recdata, uint32 len); 
 */ 
</span> 
<span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/htup_details.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/slru.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/subtrans.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/transam.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/twophase.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/twophase_rmgr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/xact.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/xlog.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"miscadmin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"pgstat.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/bufmgr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/predicate.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/predicate_internals.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/proc.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/procarray.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/rel.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/snapmgr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/tqual.h"</span> 
 
<span class='Comment_Multi_Line'>/* Uncomment the next line to test the graceful degradation code. */ 
/* #define TEST_OLDSERXID */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Test the most selective fields first, for performance. 
 * 
 * a is covered by b if all of the following hold: 
 *  1) a.database = b.database 
 *  2) a.relation = b.relation 
 *  3) b.offset is invalid (b is page-granularity or higher) 
 *  4) either of the following: 
 *      4a) a.offset is valid (a is tuple-granularity) and a.page = b.page 
 *   or 4b) a.offset is invalid and b.page is invalid (a is 
 *          page-granularity and b is relation-granularity 
 */ 
</span><a name="LN219"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>TargetTagIsCoveredBy</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>covered_target</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>covering_target</span><span class='Parentheses'>)</span>           <span class='Operator'>\ 
</span>    <span class='Parentheses'>((</span><a href="../../../include/storage/predicate_internals.h.html#LN409"><span class='Ref_to_Macro'>GET_PREDICATELOCKTARGETTAG_RELATION</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN219"><span class='Ref_to_Parameter'>covered_target</span></a><span class='Parentheses'>)</span> <span class='Operator'>== </span><span class='Comment_Multi_Line'>/* (2) */</span>  <span class='Operator'>\ 
</span>      <a href="../../../include/storage/predicate_internals.h.html#LN409"><span class='Ref_to_Macro'>GET_PREDICATELOCKTARGETTAG_RELATION</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN219"><span class='Ref_to_Parameter'>covering_target</span></a><span class='Parentheses'>))</span>             <span class='Operator'>\ 
</span>     <span class='Operator'>&& </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN413"><span class='Ref_to_Macro'>GET_PREDICATELOCKTARGETTAG_OFFSET</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN219"><span class='Ref_to_Parameter'>covering_target</span></a><span class='Parentheses'>)</span> <span class='Operator'>==</span>          <span class='Operator'>\ 
</span>         <a href="../../../include/storage/off.h.html#LN25"><span class='Ref_to_Const'>InvalidOffsetNumber</span></a><span class='Parentheses'>)</span>                                <span class='Comment_Multi_Line'>/* (3) */</span>  <span class='Operator'>\ 
</span>     <span class='Operator'>&& </span><span class='Parentheses'>(((</span><a href="../../../include/storage/predicate_internals.h.html#LN413"><span class='Ref_to_Macro'>GET_PREDICATELOCKTARGETTAG_OFFSET</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN219"><span class='Ref_to_Parameter'>covered_target</span></a><span class='Parentheses'>) </span><span class='Operator'>!=</span>         <span class='Operator'>\ 
</span>           <a href="../../../include/storage/off.h.html#LN25"><span class='Ref_to_Const'>InvalidOffsetNumber</span></a><span class='Parentheses'>)</span>                              <span class='Comment_Multi_Line'>/* (4a) */ </span><span class='Operator'>\ 
</span>          <span class='Operator'>&& </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN411"><span class='Ref_to_Macro'>GET_PREDICATELOCKTARGETTAG_PAGE</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN219"><span class='Ref_to_Parameter'>covering_target</span></a><span class='Parentheses'>) </span><span class='Operator'>==</span>       <span class='Operator'>\ 
</span>              <a href="../../../include/storage/predicate_internals.h.html#LN411"><span class='Ref_to_Macro'>GET_PREDICATELOCKTARGETTAG_PAGE</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN219"><span class='Ref_to_Parameter'>covered_target</span></a><span class='Parentheses'>)))</span>         <span class='Operator'>\ 
</span>         <span class='Operator'>|| </span><span class='Parentheses'>((</span><a href="../../../include/storage/predicate_internals.h.html#LN411"><span class='Ref_to_Macro'>GET_PREDICATELOCKTARGETTAG_PAGE</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN219"><span class='Ref_to_Parameter'>covering_target</span></a><span class='Parentheses'>) </span><span class='Operator'>==</span>       <span class='Operator'>\ 
</span>              <a href="../../../include/storage/block.h.html#LN32"><span class='Ref_to_Const'>InvalidBlockNumber</span></a><span class='Parentheses'>)</span>                            <span class='Comment_Multi_Line'>/* (4b) */ </span><span class='Operator'>\ 
</span>             <span class='Operator'>&& </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN411"><span class='Ref_to_Macro'>GET_PREDICATELOCKTARGETTAG_PAGE</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN219"><span class='Ref_to_Parameter'>covered_target</span></a><span class='Parentheses'>)</span>        <span class='Operator'>\ 
</span>                 <span class='Operator'>!= </span><a href="../../../include/storage/block.h.html#LN32"><span class='Ref_to_Const'>InvalidBlockNumber</span></a><span class='Parentheses'>)))</span>                               <span class='Operator'>\ 
</span>     <span class='Operator'>&& </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN407"><span class='Ref_to_Macro'>GET_PREDICATELOCKTARGETTAG_DB</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN219"><span class='Ref_to_Parameter'>covered_target</span></a><span class='Parentheses'>)</span> <span class='Operator'>==</span>    <span class='Comment_Multi_Line'>/* (1) */</span>  <span class='Operator'>\ 
</span>         <a href="../../../include/storage/predicate_internals.h.html#LN407"><span class='Ref_to_Macro'>GET_PREDICATELOCKTARGETTAG_DB</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN219"><span class='Ref_to_Parameter'>covering_target</span></a><span class='Parentheses'>)))</span> 
 
<span class='Comment_Multi_Line'>/* 
 * The predicate locking target and lock shared hash tables are partitioned to 
 * reduce contention.  To determine which partition a given target belongs to, 
 * compute the tag's hash code with PredicateLockTargetTagHashCode(), then 
 * apply one of these macros. 
 * NB: NUM_PREDICATELOCK_PARTITIONS must be a power of 2! 
 */ 
</span><a name="LN242"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>PredicateLockHashPartition</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>hashcode</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Parentheses'>((</span><a href="predicate.c.html#LN242"><span class='Ref_to_Parameter'>hashcode</span></a><span class='Parentheses'>) </span><span class='Operator'>% </span><a href="../../../include/storage/lwlock.h.html#LN120"><span class='Ref_to_Const'>NUM_PREDICATELOCK_PARTITIONS</span></a><span class='Parentheses'>)</span> 
<a name="LN244"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>PredicateLockHashPartitionLock</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>hashcode</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN124"><span class='Ref_to_Global_Var'>MainLWLockArray</span></a><span class='Delimiter'>[</span><a href="../../../include/storage/lwlock.h.html#LN126"><span class='Ref_to_Const'>PREDICATELOCK_MANAGER_LWLOCK_OFFSET</span></a> <span class='Operator'>+ \ 
</span>        <a href="predicate.c.html#LN242"><span class='Ref_to_Macro'>PredicateLockHashPartition</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN244"><span class='Ref_to_Parameter'>hashcode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>]</span><span class='Operator'>.</span>lock<span class='Parentheses'>)</span> 
<a name="LN247"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>PredicateLockHashPartitionLockByIndex</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>i</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Parentheses'>(</span><span class='Operator'>&</span><a href="lwlock.c.html#LN124"><span class='Ref_to_Global_Var'>MainLWLockArray</span></a><span class='Delimiter'>[</span><a href="../../../include/storage/lwlock.h.html#LN126"><span class='Ref_to_Const'>PREDICATELOCK_MANAGER_LWLOCK_OFFSET</span></a> <span class='Operator'>+ </span><span class='Parentheses'>(</span><a href="predicate.c.html#LN247"><span class='Ref_to_Parameter'>i</span></a><span class='Parentheses'>)</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/storage/lwlock.h.html#LN78"><span class='Ref_to_Member'>lock</span></a><span class='Parentheses'>)</span> 
 
<a name="LN250"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>NPREDICATELOCKTARGETENTS</span><span class='Parentheses'>() </span><span class='Operator'>\ 
</span>    <a href="../../../include/storage/shmem.h.html#LN45"><span class='Ref_to_Proto'>mul_size</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN360"><span class='Ref_to_Global_Var'>max_predicate_locks_per_xact</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="../../utils/init/globals.c.html#LN126"><span class='Ref_to_Global_Var'>MaxBackends</span></a><span class='Delimiter'>, </span><a href="../../access/transam/twophase.c.html#LN116"><span class='Ref_to_Global_Var'>max_prepared_xacts</span></a><span class='Parentheses'>))</span> 
 
<a name="LN253"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>SxactIsOnFinishedList</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>sxact</span><span class='Parentheses'>) (</span><span class='Operator'>!</span><a href="../ipc/shmqueue.c.html#LN45"><span class='Ref_to_Func'>SHMQueueIsDetached</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>((</span><a href="predicate.c.html#LN253"><span class='Ref_to_Parameter'>sxact</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>finishedLink<span class='Parentheses'>)))</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Note that a sxact is marked "prepared" once it has passed 
 * PreCommit_CheckForSerializationFailure, even if it isn't using 
 * 2PC. This is the point at which it can no longer be aborted. 
 * 
 * The PREPARED flag remains set after commit, so SxactIsCommitted 
 * implies SxactIsPrepared. 
 */ 
</span><a name="LN263"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>SxactIsCommitted</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>sxact</span><span class='Parentheses'>) (((</span><a href="predicate.c.html#LN263"><span class='Ref_to_Parameter'>sxact</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>flags <span class='Operator'>& </span><a href="../../../include/storage/predicate_internals.h.html#LN109"><span class='Ref_to_Const'>SXACT_FLAG_COMMITTED</span></a><span class='Parentheses'>)</span> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
<a name="LN264"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>SxactIsPrepared</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>sxact</span><span class='Parentheses'>) (((</span><a href="predicate.c.html#LN264"><span class='Ref_to_Parameter'>sxact</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>flags <span class='Operator'>& </span><a href="../../../include/storage/predicate_internals.h.html#LN110"><span class='Ref_to_Const'>SXACT_FLAG_PREPARED</span></a><span class='Parentheses'>)</span> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
<a name="LN265"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>SxactIsRolledBack</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>sxact</span><span class='Parentheses'>) (((</span><a href="predicate.c.html#LN265"><span class='Ref_to_Parameter'>sxact</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>flags <span class='Operator'>& </span><a href="../../../include/storage/predicate_internals.h.html#LN111"><span class='Ref_to_Const'>SXACT_FLAG_ROLLED_BACK</span></a><span class='Parentheses'>)</span> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
<a name="LN266"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>SxactIsDoomed</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>sxact</span><span class='Parentheses'>) (((</span><a href="predicate.c.html#LN266"><span class='Ref_to_Parameter'>sxact</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>flags <span class='Operator'>& </span><a href="../../../include/storage/predicate_internals.h.html#LN112"><span class='Ref_to_Const'>SXACT_FLAG_DOOMED</span></a><span class='Parentheses'>)</span> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
<a name="LN267"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>SxactIsReadOnly</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>sxact</span><span class='Parentheses'>) (((</span><a href="predicate.c.html#LN267"><span class='Ref_to_Parameter'>sxact</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>flags <span class='Operator'>& </span><a href="../../../include/storage/predicate_internals.h.html#LN119"><span class='Ref_to_Const'>SXACT_FLAG_READ_ONLY</span></a><span class='Parentheses'>)</span> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
<a name="LN268"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>SxactHasSummaryConflictIn</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>sxact</span><span class='Parentheses'>) (((</span><a href="predicate.c.html#LN268"><span class='Ref_to_Parameter'>sxact</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>flags <span class='Operator'>& </span><a href="../../../include/storage/predicate_internals.h.html#LN123"><span class='Ref_to_Const'>SXACT_FLAG_SUMMARY_CONFLICT_IN</span></a><span class='Parentheses'>)</span> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
<a name="LN269"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>SxactHasSummaryConflictOut</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>sxact</span><span class='Parentheses'>) (((</span><a href="predicate.c.html#LN269"><span class='Ref_to_Parameter'>sxact</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>flags <span class='Operator'>& </span><a href="../../../include/storage/predicate_internals.h.html#LN124"><span class='Ref_to_Const'>SXACT_FLAG_SUMMARY_CONFLICT_OUT</span></a><span class='Parentheses'>)</span> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
<span class='Comment_Multi_Line'>/* 
 * The following macro actually means that the specified transaction has a 
 * conflict out *to a transaction which committed ahead of it*.  It's hard 
 * to get that into a name of a reasonable length. 
 */ 
</span><a name="LN275"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>SxactHasConflictOut</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>sxact</span><span class='Parentheses'>) (((</span><a href="predicate.c.html#LN275"><span class='Ref_to_Parameter'>sxact</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>flags <span class='Operator'>& </span><a href="../../../include/storage/predicate_internals.h.html#LN118"><span class='Ref_to_Const'>SXACT_FLAG_CONFLICT_OUT</span></a><span class='Parentheses'>)</span> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
<a name="LN276"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>SxactIsDeferrableWaiting</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>sxact</span><span class='Parentheses'>) (((</span><a href="predicate.c.html#LN276"><span class='Ref_to_Parameter'>sxact</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>flags <span class='Operator'>& </span><a href="../../../include/storage/predicate_internals.h.html#LN120"><span class='Ref_to_Const'>SXACT_FLAG_DEFERRABLE_WAITING</span></a><span class='Parentheses'>)</span> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
<a name="LN277"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>SxactIsROSafe</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>sxact</span><span class='Parentheses'>) (((</span><a href="predicate.c.html#LN277"><span class='Ref_to_Parameter'>sxact</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>flags <span class='Operator'>& </span><a href="../../../include/storage/predicate_internals.h.html#LN121"><span class='Ref_to_Const'>SXACT_FLAG_RO_SAFE</span></a><span class='Parentheses'>)</span> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
<a name="LN278"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>SxactIsROUnsafe</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>sxact</span><span class='Parentheses'>) (((</span><a href="predicate.c.html#LN278"><span class='Ref_to_Parameter'>sxact</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>flags <span class='Operator'>& </span><a href="../../../include/storage/predicate_internals.h.html#LN122"><span class='Ref_to_Const'>SXACT_FLAG_RO_UNSAFE</span></a><span class='Parentheses'>)</span> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Compute the hash code associated with a PREDICATELOCKTARGETTAG. 
 * 
 * To avoid unnecessary recomputations of the hash code, we try to do this 
 * just once per function, and then pass it around as needed.  Aside from 
 * passing the hashcode to hash_search_with_hash_value(), we can extract 
 * the lock partition number from the hashcode. 
 */ 
</span><a name="LN288"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>PredicateLockTargetTagHashCode</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>predicatelocktargettag</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <a href="../../../include/utils/hsearch.h.html#LN127"><span class='Ref_to_Proto'>get_hash_value</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN386"><span class='Ref_to_Global_Var'>PredicateLockTargetHash</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN288"><span class='Ref_to_Parameter'>predicatelocktargettag</span></a><span class='Parentheses'>) 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Given a predicate lock tag, and the hash for its target, 
 * compute the lock hash. 
 * 
 * To make the hash code also depend on the transaction, we xor the sxid 
 * struct's address into the hash code, left-shifted so that the 
 * partition-number bits don't change.  Since this is only a hash, we 
 * don't care if we lose high-order bits of the address; use an 
 * intermediate variable to suppress cast-pointer-to-int warnings. 
 */ 
</span><a name="LN301"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>PredicateLockHashCodeFromTargetHashCode</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>predicatelocktag</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>targethash</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Parentheses'>((</span><a href="predicate.c.html#LN301"><span class='Ref_to_Parameter'>targethash</span></a><span class='Parentheses'>)</span> <span class='Operator'>^ </span><span class='Parentheses'>((</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>)</span> <a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>((</span><a href="predicate.c.html#LN301"><span class='Ref_to_Parameter'>predicatelocktag</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>myXact<span class='Parentheses'>))</span> <span class='Operator'>\ 
</span>     <span class='Operator'>&LT;&LT; </span><a href="../../../include/storage/lwlock.h.html#LN119"><span class='Ref_to_Const'>LOG2_NUM_PREDICATELOCK_PARTITIONS</span></a><span class='Parentheses'>)</span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * The SLRU buffer area through which we access the old xids. 
 */ 
</span><a name="LN309"></a><span class='Keyword'>static </span><a href="../../../include/access/slru.h.html#LN116"><span class='Ref_to_Struct'>SlruCtlData</span></a> <span class='Declare_Var'>OldSerXidSlruCtlData</span><span class='Delimiter'>; 
</span> 
<a name="LN311"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>OldSerXidSlruCtl</span>            <span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN309"><span class='Ref_to_Global_Var'>OldSerXidSlruCtlData</span></a><span class='Parentheses'>) 
</span> 
<a name="LN313"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>OLDSERXID_PAGESIZE</span>          BLCKSZ 
<a name="LN314"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>OLDSERXID_ENTRYSIZE</span>         <span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN21"><span class='Ref_to_Typedef'>SerCommitSeqNo</span></a><span class='Parentheses'>) 
</span><a name="LN315"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>OLDSERXID_ENTRIESPERPAGE</span>    <span class='Parentheses'>(</span><a href="predicate.c.html#LN313"><span class='Ref_to_Const'>OLDSERXID_PAGESIZE</span></a> <span class='Operator'>/ </span><a href="predicate.c.html#LN314"><span class='Ref_to_Const'>OLDSERXID_ENTRYSIZE</span></a><span class='Parentheses'>) 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Set maximum pages based on the lesser of the number needed to track all 
 * transactions and the maximum that SLRU supports. 
 */ 
</span><a name="LN321"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>OLDSERXID_MAX_PAGE</span>          <a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN11"><span class='Ref_to_Macro'>Min</span></a><span class='Parentheses'>(</span><a href="../../../include/access/slru.h.html#LN36"><span class='Ref_to_Const'>SLRU_PAGES_PER_SEGMENT</span></a> <span class='Operator'>* </span><span class='Number'>0x10000</span> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Operator'>\ 
</span>                                        <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN34"><span class='Ref_to_Const'>MaxTransactionId</span></a><span class='Parentheses'>) </span><span class='Operator'>/ </span><a href="predicate.c.html#LN315"><span class='Ref_to_Const'>OLDSERXID_ENTRIESPERPAGE</span></a><span class='Parentheses'>)</span> 
 
<a name="LN324"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>OldSerXidNextPage</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>page</span><span class='Parentheses'>) (((</span><a href="predicate.c.html#LN324"><span class='Ref_to_Parameter'>page</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT;= </span><a href="predicate.c.html#LN321"><span class='Ref_to_Const'>OLDSERXID_MAX_PAGE</span></a><span class='Parentheses'>)</span> <span class='Operator'>? </span><span class='Number'>0</span> <span class='Operator'>: </span><span class='Parentheses'>(</span><a href="predicate.c.html#LN324"><span class='Ref_to_Parameter'>page</span></a><span class='Parentheses'>)</span> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
 
<a name="LN326"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>OldSerXidValue</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>slotno</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>xid</span><span class='Parentheses'>) (</span><span class='Operator'>*</span><span class='Parentheses'>((</span><a href="../../../include/storage/predicate_internals.h.html#LN21"><span class='Ref_to_Typedef'>SerCommitSeqNo</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> <span class='Operator'>\ 
</span>    <span class='Parentheses'>(</span><a href="predicate.c.html#LN311"><span class='Ref_to_Const'>OldSerXidSlruCtl</span></a><span class='Operator'>-&GT;</span>shared<span class='Operator'>-&GT;</span>page_buffer<span class='Delimiter'>[</span><a href="predicate.c.html#LN326"><span class='Ref_to_Parameter'>slotno</span></a><span class='Delimiter'>] </span><span class='Operator'>+ \ 
</span>    <span class='Parentheses'>((((</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="predicate.c.html#LN326"><span class='Ref_to_Parameter'>xid</span></a><span class='Parentheses'>))</span> <span class='Operator'>% </span><a href="predicate.c.html#LN315"><span class='Ref_to_Const'>OLDSERXID_ENTRIESPERPAGE</span></a><span class='Parentheses'>)</span> <span class='Operator'>* </span><a href="predicate.c.html#LN314"><span class='Ref_to_Const'>OLDSERXID_ENTRYSIZE</span></a><span class='Parentheses'>))))</span> 
 
<a name="LN330"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>OldSerXidPage</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>xid</span><span class='Parentheses'>)</span>  <span class='Parentheses'>((((</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="predicate.c.html#LN330"><span class='Ref_to_Parameter'>xid</span></a><span class='Parentheses'>))</span> <span class='Operator'>/ </span><a href="predicate.c.html#LN315"><span class='Ref_to_Const'>OLDSERXID_ENTRIESPERPAGE</span></a><span class='Parentheses'>)</span> <span class='Operator'>% </span><span class='Parentheses'>(</span><a href="predicate.c.html#LN321"><span class='Ref_to_Const'>OLDSERXID_MAX_PAGE</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>))</span> 
<a name="LN331"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>OldSerXidSegment</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>page</span><span class='Parentheses'>)</span>  <span class='Parentheses'>((</span><a href="predicate.c.html#LN331"><span class='Ref_to_Parameter'>page</span></a><span class='Parentheses'>) </span><span class='Operator'>/ </span><a href="../../../include/access/slru.h.html#LN36"><span class='Ref_to_Const'>SLRU_PAGES_PER_SEGMENT</span></a><span class='Parentheses'>)</span> 
 
<a name="LN333"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>OldSerXidControlData</span> 
<span class='Delimiter'>{ 
</span><a name="LN335"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>headPage</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* newest initialized page */ 
</span><a name="LN336"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Member'>headXid</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* newest valid Xid in the SLRU */ 
</span><a name="LN337"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Member'>tailXid</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* oldest xmin we might be interested in */ 
</span><a name="LN338"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>warningIssued</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* have we issued SLRU wrap-around warning? */ 
</span><a name="LN339"></a><span class='Delimiter'>}</span>   <span class='Declare_Typedef'>OldSerXidControlData</span><span class='Delimiter'>; 
</span> 
<a name="LN341"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <a href="predicate.c.html#LN333"><span class='Ref_to_Struct'>OldSerXidControlData</span></a> <span class='Operator'>*</span><span class='Declare_Typedef'>OldSerXidControl</span><span class='Delimiter'>; 
</span> 
<a name="LN343"></a><span class='Keyword'>static </span><a href="predicate.c.html#LN341"><span class='Ref_to_Typedef'>OldSerXidControl</span></a> <span class='Declare_Var'>oldSerXidControl</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * When the oldest committed transaction on the "finished" list is moved to 
 * SLRU, its predicate locks will be moved to this "dummy" transaction, 
 * collapsing duplicate targets.  When a duplicate is found, the later 
 * commitSeqNo is used. 
 */ 
</span><a name="LN351"></a><span class='Keyword'>static </span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Var'>OldCommittedSxact</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * These configuration variables are used to set the predicate lock table size 
 * and to control promotion of predicate locks to coarser granularity in an 
 * attempt to degrade performance (mostly as false positive serialization 
 * failure) gracefully in the face of memory pressurel 
 */ 
</span><a name="LN360"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>max_predicate_locks_per_xact</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* set by guc.c */ 
</span><a name="LN361"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>max_predicate_locks_per_relation</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* set by guc.c */ 
</span><a name="LN362"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>max_predicate_locks_per_page</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* set by guc.c */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * This provides a list of objects in order to track transactions 
 * participating in predicate locking.  Entries in the list are fixed size, 
 * and reside in shared memory.  The memory address of an entry must remain 
 * fixed during its lifetime.  The list will be protected from concurrent 
 * update externally; no provision is made in this code to manage that.  The 
 * number of entries in the list, and the size allowed for each entry is 
 * fixed upon creation. 
 */ 
</span><a name="LN373"></a><span class='Keyword'>static </span><a href="../../../include/storage/predicate_internals.h.html#LN178"><span class='Ref_to_Typedef'>PredXactList</span></a> <span class='Declare_Var'>PredXact</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * This provides a pool of RWConflict data elements to use in conflict lists 
 * between transactions. 
 */ 
</span><a name="LN379"></a><span class='Keyword'>static </span><a href="../../../include/storage/predicate_internals.h.html#LN213"><span class='Ref_to_Typedef'>RWConflictPoolHeader</span></a> <span class='Declare_Var'>RWConflictPool</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * The predicate locking hash tables are in shared memory. 
 * Each backend keeps pointers to them. 
 */ 
</span><a name="LN385"></a><span class='Keyword'>static </span><a href="../../utils/hash/dynahash.c.html#LN192"><span class='Ref_to_Struct'>HTAB</span></a> <span class='Operator'>*</span><span class='Declare_Var'>SerializableXidHash</span><span class='Delimiter'>; 
</span><a name="LN386"></a><span class='Keyword'>static </span><a href="../../utils/hash/dynahash.c.html#LN192"><span class='Ref_to_Struct'>HTAB</span></a> <span class='Operator'>*</span><span class='Declare_Var'>PredicateLockTargetHash</span><span class='Delimiter'>; 
</span><a name="LN387"></a><span class='Keyword'>static </span><a href="../../utils/hash/dynahash.c.html#LN192"><span class='Ref_to_Struct'>HTAB</span></a> <span class='Operator'>*</span><span class='Declare_Var'>PredicateLockHash</span><span class='Delimiter'>; 
</span><a name="LN388"></a><span class='Keyword'>static </span><a href="../../../include/storage/shmem.h.html#LN27"><span class='Ref_to_Struct'>SHM_QUEUE</span></a> <span class='Operator'>*</span><span class='Declare_Var'>FinishedSerializableTransactions</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Tag for a dummy entry in PredicateLockTargetHash. By temporarily removing 
 * this entry, you can ensure that there's enough scratch space available for 
 * inserting one entry in the hash table. This is an otherwise-invalid tag. 
 */ 
</span><a name="LN395"></a><span class='Keyword'>static const </span><a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Declare_Var'>ScratchTargetTag</span> <span class='Operator'>= </span><span class='Delimiter'>{</span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>}; 
</span><a name="LN396"></a><span class='Keyword'>static </span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Var'>ScratchTargetTagHash</span><span class='Delimiter'>; 
</span><a name="LN397"></a><span class='Keyword'>static </span><a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a> <span class='Operator'>*</span><span class='Declare_Var'>ScratchPartitionLock</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * The local hash table used to determine when to combine multiple fine- 
 * grained locks into a single courser-grained lock. 
 */ 
</span><a name="LN403"></a><span class='Keyword'>static </span><a href="../../utils/hash/dynahash.c.html#LN192"><span class='Ref_to_Struct'>HTAB</span></a> <span class='Operator'>*</span><span class='Declare_Var'>LocalPredicateLockHash</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Keep a pointer to the currently-running serializable transaction (if any) 
 * for quick reference. Also, remember if we have written anything that could 
 * cause a rw-conflict. 
 */ 
</span><a name="LN410"></a><span class='Keyword'>static </span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Var'>MySerializableXact</span> <span class='Operator'>= </span><a href="../../../include/storage/predicate_internals.h.html#LN468"><span class='Ref_to_Const'>InvalidSerializableXact</span></a><span class='Delimiter'>; 
</span><a name="LN411"></a><span class='Keyword'>static bool </span><span class='Declare_Var'>MyXactDidWrite</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* local functions */ 
</span> 
<a name="LN415"></a><span class='Keyword'>static </span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>CreatePredXact</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN416"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>ReleasePredXact</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sxact</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN417"></a><span class='Keyword'>static </span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>FirstPredXact</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN418"></a><span class='Keyword'>static </span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>NextPredXact</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sxact</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<a name="LN420"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>RWConflictExists</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>reader</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>writer</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN421"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>SetRWConflict</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>reader</span><span class='Delimiter'>, </span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>writer</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN422"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>SetPossibleUnsafeConflict</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>roXact</span><span class='Delimiter'>, </span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>activeXact</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN423"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>ReleaseRWConflict</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a> <span class='Declare_Parameter'>conflict</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN424"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>FlagSxactUnsafe</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sxact</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<a name="LN426"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>OldSerXidPagePrecedesLogically</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>p</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>q</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN427"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>OldSerXidInit</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN428"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>OldSerXidAdd</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xid</span><span class='Delimiter'>, </span><a href="../../../include/storage/predicate_internals.h.html#LN21"><span class='Ref_to_Typedef'>SerCommitSeqNo</span></a> <span class='Declare_Parameter'>minConflictCommitSeqNo</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN429"></a><span class='Keyword'>static </span><a href="../../../include/storage/predicate_internals.h.html#LN21"><span class='Ref_to_Typedef'>SerCommitSeqNo</span></a> <span class='Declare_Prototype'>OldSerXidGetMinConflictCommitSeqNo</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xid</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN430"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>OldSerXidSetActiveSerXmin</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xid</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<a name="LN432"></a><span class='Keyword'>static </span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Prototype'>predicatelock_hash</span><span class='Parentheses'>(</span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>key</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a> <span class='Declare_Parameter'>keysize</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN433"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>SummarizeOldestCommittedSxact</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN434"></a><span class='Keyword'>static </span><a href="../../../include/utils/snapshot.h.html#LN22"><span class='Ref_to_Typedef'>Snapshot</span></a> <span class='Declare_Prototype'>GetSafeSnapshot</span><span class='Parentheses'>(</span><a href="../../../include/utils/snapshot.h.html#LN22"><span class='Ref_to_Typedef'>Snapshot</span></a> <span class='Declare_Parameter'>snapshot</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN435"></a><span class='Keyword'>static </span><a href="../../../include/utils/snapshot.h.html#LN22"><span class='Ref_to_Typedef'>Snapshot</span></a> <span class='Declare_Prototype'>GetSerializableTransactionSnapshotInt</span><span class='Parentheses'>(</span><a href="../../../include/utils/snapshot.h.html#LN22"><span class='Ref_to_Typedef'>Snapshot</span></a> <span class='Declare_Parameter'>snapshot</span><span class='Delimiter'>, 
</span><a name="LN436"></a>                                      <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>sourcexid</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN437"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>PredicateLockExists</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>targettag</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN438"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>GetParentPredicateLockTag</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tag</span><span class='Delimiter'>, 
</span><a name="LN439"></a>                          <a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>parent</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN440"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>CoarserLockCovers</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>newtargettag</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN441"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>RemoveScratchTarget</span><span class='Parentheses'>(</span><span class='Keyword'>bool </span><span class='Declare_Parameter'>lockheld</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN442"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>RestoreScratchTarget</span><span class='Parentheses'>(</span><span class='Keyword'>bool </span><span class='Declare_Parameter'>lockheld</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN443"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>RemoveTargetIfNoLongerUsed</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN285"><span class='Ref_to_Struct'>PREDICATELOCKTARGET</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>target</span><span class='Delimiter'>, 
</span><a name="LN444"></a>                           <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Parameter'>targettaghash</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN445"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>DeleteChildTargetLocks</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>newtargettag</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN446"></a><span class='Keyword'>static int</span>  <span class='Declare_Prototype'>MaxPredicateChildLocks</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tag</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN447"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>CheckAndPromotePredicateLockRequest</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>reqtag</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN448"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>DecrementParentLocks</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>targettag</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN449"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>CreatePredicateLock</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>targettag</span><span class='Delimiter'>, 
</span><a name="LN450"></a>                    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Parameter'>targettaghash</span><span class='Delimiter'>, 
</span><a name="LN451"></a>                    <a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sxact</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN452"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>DeleteLockTarget</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN285"><span class='Ref_to_Struct'>PREDICATELOCKTARGET</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>target</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Parameter'>targettaghash</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN453"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>TransferPredicateLocksToNewTarget</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Declare_Parameter'>oldtargettag</span><span class='Delimiter'>, 
</span><a name="LN454"></a>                                  <a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Declare_Parameter'>newtargettag</span><span class='Delimiter'>, 
</span><a name="LN455"></a>                                  <span class='Keyword'>bool </span><span class='Declare_Parameter'>removeOld</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN456"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>PredicateLockAcquire</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>targettag</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN457"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>DropAllPredicateLocksFromTable</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>relation</span><span class='Delimiter'>, 
</span><a name="LN458"></a>                               <span class='Keyword'>bool </span><span class='Declare_Parameter'>transfer</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN459"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>SetNewSxactGlobalXmin</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN460"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>ClearOldPredicateLocks</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN461"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>ReleaseOneSerializableXact</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sxact</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>partial</span><span class='Delimiter'>, 
</span><a name="LN462"></a>                           <span class='Keyword'>bool </span><span class='Declare_Parameter'>summarize</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN463"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>XidIsConcurrent</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xid</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN464"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>CheckTargetForConflictsIn</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>targettag</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN465"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>FlagRWConflict</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>reader</span><span class='Delimiter'>, </span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>writer</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN466"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>OnConflict_CheckForSerializationFailure</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>reader</span><span class='Delimiter'>, 
</span><a name="LN467"></a>                                        <a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>writer</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------*/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Does this relation participate in predicate locking? Temporary and system 
 * relations are exempt, as are materialized views. 
 */ 
</span><span class='Keyword'>static inline bool 
</span><a name="LN477"></a><span class='Declare_Function'>PredicateLockingNeededForRelation</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>relation</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <span class='Operator'>!</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN477"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN115"><span class='Ref_to_Member'>rd_id</span></a> <span class='Operator'>&LT; </span><a href="../../../include/access/transam.h.html#LN92"><span class='Ref_to_Const'>FirstBootstrapObjectId</span></a> <span class='Operator'>|| 
</span>             <a href="../../../include/utils/rel.h.html#LN512"><span class='Ref_to_Macro'>RelationUsesLocalBuffers</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN477"><span class='Ref_to_Parameter'>relation</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>             <a href="predicate.c.html#LN477"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relkind <span class='Operator'>== </span><a href="../../../include/catalog/pg_class.h.html#LN164"><span class='Ref_to_Const'>RELKIND_MATVIEW</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * When a public interface method is called for a read, this is the test to 
 * see if we should do a quick return. 
 * 
 * Note: this function has side-effects! If this transaction has been flagged 
 * as RO-safe since the last call, we release all predicate locks and reset 
 * MySerializableXact. That makes subsequent calls to return quickly. 
 * 
 * This is marked as 'inline' to make to eliminate the function call overhead 
 * in the common case that serialization is not needed. 
 */ 
</span><span class='Keyword'>static inline bool 
</span><a name="LN496"></a><span class='Declare_Function'>SerializationNeededForRead</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>relation</span><span class='Delimiter'>, </span><a href="../../../include/utils/snapshot.h.html#LN22"><span class='Ref_to_Typedef'>Snapshot</span></a> <span class='Declare_Parameter'>snapshot</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* Nothing to do if this is not a serializable transaction */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a> <span class='Operator'>== </span><a href="../../../include/storage/predicate_internals.h.html#LN468"><span class='Ref_to_Const'>InvalidSerializableXact</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Don't acquire locks or conflict when scanning with a special snapshot. 
     * This excludes things like CLUSTER and REINDEX. They use the wholesale 
     * functions TransferPredicateLocksToHeapRelation() and 
     * CheckTableForSerializableConflictIn() to participate in serialization, 
     * but the scans involved don't need serialization. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/utils/tqual.h.html#LN30"><span class='Ref_to_Macro'>IsMVCCSnapshot</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN496"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Check if we have just become "RO-safe". If we have, immediately release 
     * all locks as they're not needed anymore. This also resets 
     * MySerializableXact, so that subsequent calls to this function can exit 
     * quickly. 
     * 
     * A transaction is flagged as RO_SAFE if all concurrent R/W transactions 
     * commit without having conflicts out to an earlier snapshot, thus 
     * ensuring that no conflicts are possible for this transaction. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN277"><span class='Ref_to_Macro'>SxactIsROSafe</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/storage/predicate.h.html#LN56"><span class='Ref_to_Proto'>ReleasePredicateLocks</span></a><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Check if the relation doesn't participate in predicate locking */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN476"><span class='Ref_to_Func'>PredicateLockingNeededForRelation</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN496"><span class='Ref_to_Parameter'>relation</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>;</span>                <span class='Comment_Single_Line'>/* no excuse to skip predicate locking */ 
</span><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end SerializationNeededForRead &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Like SerializationNeededForRead(), but called on writes. 
 * The logic is the same, but there is no snapshot and we can't be RO-safe. 
 */ 
</span><span class='Keyword'>static inline bool 
</span><a name="LN540"></a><span class='Declare_Function'>SerializationNeededForWrite</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>relation</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* Nothing to do if this is not a serializable transaction */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a> <span class='Operator'>== </span><a href="../../../include/storage/predicate_internals.h.html#LN468"><span class='Ref_to_Const'>InvalidSerializableXact</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Check if the relation doesn't participate in predicate locking */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN476"><span class='Ref_to_Func'>PredicateLockingNeededForRelation</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN540"><span class='Ref_to_Parameter'>relation</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>;</span>                <span class='Comment_Single_Line'>/* no excuse to skip predicate locking */ 
</span><span class='Delimiter'>} 
</span> 
 
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------*/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * These functions are a simple implementation of a list for this specific 
 * type of struct.  If there is ever a generalized shared memory list, we 
 * should probably switch to that. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>* 
</span><a name="LN562"></a><span class='Declare_Function'>CreatePredXact</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN564"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN139"><span class='Ref_to_Typedef'>PredXactListElement</span></a> <span class='Declare_Local'>ptle</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN564"><span class='Ref_To_Local'>ptle</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN139"><span class='Ref_to_Typedef'>PredXactListElement</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN146"><span class='Ref_to_Member'>availableList</span></a><span class='Delimiter'>, 
</span>                     <span class='Operator'>&</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN146"><span class='Ref_to_Member'>availableList</span></a><span class='Delimiter'>, 
</span>                     <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN133"><span class='Ref_to_Struct'>PredXactListElementData</span></a><span class='Delimiter'>, </span><a href="../../../timezone/zic.c.html#LN109"><span class='Ref_to_Proto'>link</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN564"><span class='Ref_To_Local'>ptle</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <a href="../ipc/shmqueue.c.html#LN66"><span class='Ref_to_Func'>SHMQueueDelete</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN564"><span class='Ref_To_Local'>ptle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN135"><span class='Ref_to_Member'>link</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/shmem.h.html#LN70"><span class='Ref_to_Proto'>SHMQueueInsertBefore</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN147"><span class='Ref_to_Member'>activeList</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predicate.c.html#LN564"><span class='Ref_To_Local'>ptle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN135"><span class='Ref_to_Member'>link</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Operator'>&</span><a href="predicate.c.html#LN564"><span class='Ref_To_Local'>ptle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN136"><span class='Ref_to_Member'>sxact</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static void 
</span><a name="LN579"></a><span class='Declare_Function'>ReleasePredXact</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sxact</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN581"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN139"><span class='Ref_to_Typedef'>PredXactListElement</span></a> <span class='Declare_Local'>ptle</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/shmem.h.html#LN39"><span class='Ref_to_Proto'>ShmemAddrIsValid</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN579"><span class='Ref_to_Parameter'>sxact</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN581"><span class='Ref_To_Local'>ptle</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN139"><span class='Ref_to_Typedef'>PredXactListElement</span></a><span class='Parentheses'>) 
</span>        <span class='Parentheses'>(((</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predicate.c.html#LN579"><span class='Ref_to_Parameter'>sxact</span></a><span class='Parentheses'>)</span> 
         <span class='Operator'>- </span><a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN133"><span class='Ref_to_Struct'>PredXactListElementData</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN579"><span class='Ref_to_Parameter'>sxact</span></a><span class='Parentheses'>)</span> 
         <span class='Operator'>+ </span><a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN133"><span class='Ref_to_Struct'>PredXactListElementData</span></a><span class='Delimiter'>, </span><a href="../../../timezone/zic.c.html#LN109"><span class='Ref_to_Proto'>link</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../ipc/shmqueue.c.html#LN66"><span class='Ref_to_Func'>SHMQueueDelete</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN581"><span class='Ref_To_Local'>ptle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN135"><span class='Ref_to_Member'>link</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/shmem.h.html#LN70"><span class='Ref_to_Proto'>SHMQueueInsertBefore</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN146"><span class='Ref_to_Member'>availableList</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predicate.c.html#LN581"><span class='Ref_To_Local'>ptle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN135"><span class='Ref_to_Member'>link</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static </span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>* 
</span><a name="LN594"></a><span class='Declare_Function'>FirstPredXact</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN596"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN139"><span class='Ref_to_Typedef'>PredXactListElement</span></a> <span class='Declare_Local'>ptle</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN596"><span class='Ref_To_Local'>ptle</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN139"><span class='Ref_to_Typedef'>PredXactListElement</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN147"><span class='Ref_to_Member'>activeList</span></a><span class='Delimiter'>, 
</span>                     <span class='Operator'>&</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN147"><span class='Ref_to_Member'>activeList</span></a><span class='Delimiter'>, 
</span>                     <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN133"><span class='Ref_to_Struct'>PredXactListElementData</span></a><span class='Delimiter'>, </span><a href="../../../timezone/zic.c.html#LN109"><span class='Ref_to_Proto'>link</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN596"><span class='Ref_To_Local'>ptle</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Operator'>&</span><a href="predicate.c.html#LN596"><span class='Ref_To_Local'>ptle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN136"><span class='Ref_to_Member'>sxact</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static </span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>* 
</span><a name="LN609"></a><span class='Declare_Function'>NextPredXact</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sxact</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN611"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN139"><span class='Ref_to_Typedef'>PredXactListElement</span></a> <span class='Declare_Local'>ptle</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/shmem.h.html#LN39"><span class='Ref_to_Proto'>ShmemAddrIsValid</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN609"><span class='Ref_to_Parameter'>sxact</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN611"><span class='Ref_To_Local'>ptle</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN139"><span class='Ref_to_Typedef'>PredXactListElement</span></a><span class='Parentheses'>) 
</span>        <span class='Parentheses'>(((</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predicate.c.html#LN609"><span class='Ref_to_Parameter'>sxact</span></a><span class='Parentheses'>)</span> 
         <span class='Operator'>- </span><a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN133"><span class='Ref_to_Struct'>PredXactListElementData</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN609"><span class='Ref_to_Parameter'>sxact</span></a><span class='Parentheses'>)</span> 
         <span class='Operator'>+ </span><a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN133"><span class='Ref_to_Struct'>PredXactListElementData</span></a><span class='Delimiter'>, </span><a href="../../../timezone/zic.c.html#LN109"><span class='Ref_to_Proto'>link</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN611"><span class='Ref_To_Local'>ptle</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN139"><span class='Ref_to_Typedef'>PredXactListElement</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN147"><span class='Ref_to_Member'>activeList</span></a><span class='Delimiter'>, 
</span>                     <span class='Operator'>&</span><a href="predicate.c.html#LN611"><span class='Ref_To_Local'>ptle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN135"><span class='Ref_to_Member'>link</span></a><span class='Delimiter'>, 
</span>                     <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN133"><span class='Ref_to_Struct'>PredXactListElementData</span></a><span class='Delimiter'>, </span><a href="../../../timezone/zic.c.html#LN109"><span class='Ref_to_Proto'>link</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN611"><span class='Ref_To_Local'>ptle</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Operator'>&</span><a href="predicate.c.html#LN611"><span class='Ref_To_Local'>ptle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN136"><span class='Ref_to_Member'>sxact</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end NextPredXact &raquo; </span> 
 
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------*/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * These functions manage primitive access to the RWConflict pool and lists. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN635"></a><span class='Declare_Function'>RWConflictExists</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>reader</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>writer</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN637"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a>  <span class='Declare_Local'>conflict</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN635"><span class='Ref_to_Parameter'>reader</span></a> <span class='Operator'>!= </span><a href="predicate.c.html#LN635"><span class='Ref_to_Parameter'>writer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Check the ends of the purported conflict first. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN266"><span class='Ref_to_Macro'>SxactIsDoomed</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN635"><span class='Ref_to_Parameter'>reader</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>|| </span><a href="predicate.c.html#LN266"><span class='Ref_to_Macro'>SxactIsDoomed</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN635"><span class='Ref_to_Parameter'>writer</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>|| </span><a href="../../../include/storage/shmem.h.html#LN76"><span class='Ref_to_Proto'>SHMQueueEmpty</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN635"><span class='Ref_to_Parameter'>reader</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN85"><span class='Ref_to_Member'>outConflicts</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>|| </span><a href="../../../include/storage/shmem.h.html#LN76"><span class='Ref_to_Proto'>SHMQueueEmpty</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN635"><span class='Ref_to_Parameter'>writer</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN87"><span class='Ref_to_Member'>inConflicts</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* A conflict is possible; walk the list to find out. */ 
</span>    <a href="predicate.c.html#LN637"><span class='Ref_To_Local'>conflict</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN635"><span class='Ref_to_Parameter'>reader</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN85"><span class='Ref_to_Member'>outConflicts</span></a><span class='Delimiter'>, 
</span>                     <span class='Operator'>&</span><a href="predicate.c.html#LN635"><span class='Ref_to_Parameter'>reader</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN85"><span class='Ref_to_Member'>outConflicts</span></a><span class='Delimiter'>, 
</span>                     <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN194"><span class='Ref_to_Struct'>RWConflictData</span></a><span class='Delimiter'>, </span>outLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN637"><span class='Ref_To_Local'>conflict</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN637"><span class='Ref_To_Local'>conflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN199"><span class='Ref_to_Member'>sxactIn</span></a> <span class='Operator'>== </span><a href="predicate.c.html#LN635"><span class='Ref_to_Parameter'>writer</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN637"><span class='Ref_To_Local'>conflict</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN635"><span class='Ref_to_Parameter'>reader</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN85"><span class='Ref_to_Member'>outConflicts</span></a><span class='Delimiter'>, 
</span>                         <span class='Operator'>&</span><a href="predicate.c.html#LN637"><span class='Ref_To_Local'>conflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN196"><span class='Ref_to_Member'>outLink</span></a><span class='Delimiter'>, 
</span>                         <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN194"><span class='Ref_to_Struct'>RWConflictData</span></a><span class='Delimiter'>, </span>outLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* No conflict found. */ 
</span>    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end RWConflictExists &raquo; </span> 
 
<span class='Keyword'>static void 
</span><a name="LN668"></a><span class='Declare_Function'>SetRWConflict</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>reader</span><span class='Delimiter'>, </span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>writer</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN670"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a>  <span class='Declare_Local'>conflict</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN668"><span class='Ref_to_Parameter'>reader</span></a> <span class='Operator'>!= </span><a href="predicate.c.html#LN668"><span class='Ref_to_Parameter'>writer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN420"><span class='Ref_to_Proto'>RWConflictExists</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN668"><span class='Ref_to_Parameter'>reader</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN668"><span class='Ref_to_Parameter'>writer</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN670"><span class='Ref_To_Local'>conflict</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN379"><span class='Ref_to_Global_Var'>RWConflictPool</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN209"><span class='Ref_to_Member'>availableList</span></a><span class='Delimiter'>, 
</span>                     <span class='Operator'>&</span><a href="predicate.c.html#LN379"><span class='Ref_to_Global_Var'>RWConflictPool</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN209"><span class='Ref_to_Member'>availableList</span></a><span class='Delimiter'>, 
</span>                     <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN194"><span class='Ref_to_Struct'>RWConflictData</span></a><span class='Delimiter'>, </span>outLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN670"><span class='Ref_To_Local'>conflict</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OUT_OF_MEMORY<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"not enough elements in RWConflictPool to record a read/write conflict"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"You might need to run fewer transactions at a time or increase max_connections."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <a href="../ipc/shmqueue.c.html#LN66"><span class='Ref_to_Func'>SHMQueueDelete</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN670"><span class='Ref_To_Local'>conflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN196"><span class='Ref_to_Member'>outLink</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN670"><span class='Ref_To_Local'>conflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN198"><span class='Ref_to_Member'>sxactOut</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN668"><span class='Ref_to_Parameter'>reader</span></a><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN670"><span class='Ref_To_Local'>conflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN199"><span class='Ref_to_Member'>sxactIn</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN668"><span class='Ref_to_Parameter'>writer</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/shmem.h.html#LN70"><span class='Ref_to_Proto'>SHMQueueInsertBefore</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN668"><span class='Ref_to_Parameter'>reader</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN85"><span class='Ref_to_Member'>outConflicts</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predicate.c.html#LN670"><span class='Ref_To_Local'>conflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN196"><span class='Ref_to_Member'>outLink</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/shmem.h.html#LN70"><span class='Ref_to_Proto'>SHMQueueInsertBefore</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN668"><span class='Ref_to_Parameter'>writer</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN87"><span class='Ref_to_Member'>inConflicts</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predicate.c.html#LN670"><span class='Ref_To_Local'>conflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN197"><span class='Ref_to_Member'>inLink</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end SetRWConflict &raquo; </span> 
 
<span class='Keyword'>static void 
</span><a name="LN694"></a><span class='Declare_Function'>SetPossibleUnsafeConflict</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>roXact</span><span class='Delimiter'>, 
</span><a name="LN695"></a>                          <a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>activeXact</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN697"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a>  <span class='Declare_Local'>conflict</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN694"><span class='Ref_to_Parameter'>roXact</span></a> <span class='Operator'>!= </span><a href="predicate.c.html#LN695"><span class='Ref_to_Parameter'>activeXact</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN267"><span class='Ref_to_Macro'>SxactIsReadOnly</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN694"><span class='Ref_to_Parameter'>roXact</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN267"><span class='Ref_to_Macro'>SxactIsReadOnly</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN695"><span class='Ref_to_Parameter'>activeXact</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN697"><span class='Ref_To_Local'>conflict</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN379"><span class='Ref_to_Global_Var'>RWConflictPool</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN209"><span class='Ref_to_Member'>availableList</span></a><span class='Delimiter'>, 
</span>                     <span class='Operator'>&</span><a href="predicate.c.html#LN379"><span class='Ref_to_Global_Var'>RWConflictPool</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN209"><span class='Ref_to_Member'>availableList</span></a><span class='Delimiter'>, 
</span>                     <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN194"><span class='Ref_to_Struct'>RWConflictData</span></a><span class='Delimiter'>, </span>outLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN697"><span class='Ref_To_Local'>conflict</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OUT_OF_MEMORY<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"not enough elements in RWConflictPool to record a potential read/write conflict"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"You might need to run fewer transactions at a time or increase max_connections."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <a href="../ipc/shmqueue.c.html#LN66"><span class='Ref_to_Func'>SHMQueueDelete</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN697"><span class='Ref_To_Local'>conflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN196"><span class='Ref_to_Member'>outLink</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN697"><span class='Ref_To_Local'>conflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN198"><span class='Ref_to_Member'>sxactOut</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN695"><span class='Ref_to_Parameter'>activeXact</span></a><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN697"><span class='Ref_To_Local'>conflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN199"><span class='Ref_to_Member'>sxactIn</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN694"><span class='Ref_to_Parameter'>roXact</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/shmem.h.html#LN70"><span class='Ref_to_Proto'>SHMQueueInsertBefore</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN695"><span class='Ref_to_Parameter'>activeXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN97"><span class='Ref_to_Member'>possibleUnsafeConflicts</span></a><span class='Delimiter'>, 
</span>                         <span class='Operator'>&</span><a href="predicate.c.html#LN697"><span class='Ref_To_Local'>conflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN196"><span class='Ref_to_Member'>outLink</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/shmem.h.html#LN70"><span class='Ref_to_Proto'>SHMQueueInsertBefore</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN694"><span class='Ref_to_Parameter'>roXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN97"><span class='Ref_to_Member'>possibleUnsafeConflicts</span></a><span class='Delimiter'>, 
</span>                         <span class='Operator'>&</span><a href="predicate.c.html#LN697"><span class='Ref_To_Local'>conflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN197"><span class='Ref_to_Member'>inLink</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end SetPossibleUnsafeConflict &raquo; </span> 
 
<span class='Keyword'>static void 
</span><a name="LN724"></a><span class='Declare_Function'>ReleaseRWConflict</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a> <span class='Declare_Parameter'>conflict</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../ipc/shmqueue.c.html#LN66"><span class='Ref_to_Func'>SHMQueueDelete</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN724"><span class='Ref_to_Parameter'>conflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN197"><span class='Ref_to_Member'>inLink</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../ipc/shmqueue.c.html#LN66"><span class='Ref_to_Func'>SHMQueueDelete</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN724"><span class='Ref_to_Parameter'>conflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN196"><span class='Ref_to_Member'>outLink</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/shmem.h.html#LN70"><span class='Ref_to_Proto'>SHMQueueInsertBefore</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN379"><span class='Ref_to_Global_Var'>RWConflictPool</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN209"><span class='Ref_to_Member'>availableList</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predicate.c.html#LN724"><span class='Ref_to_Parameter'>conflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN196"><span class='Ref_to_Member'>outLink</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static void 
</span><a name="LN732"></a><span class='Declare_Function'>FlagSxactUnsafe</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sxact</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN734"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a>  <span class='Declare_Local'>conflict</span><span class='Delimiter'>, 
</span><a name="LN735"></a>                <span class='Declare_Local'>nextConflict</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN267"><span class='Ref_to_Macro'>SxactIsReadOnly</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN732"><span class='Ref_to_Parameter'>sxact</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN277"><span class='Ref_to_Macro'>SxactIsROSafe</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN732"><span class='Ref_to_Parameter'>sxact</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN732"><span class='Ref_to_Parameter'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN105"><span class='Ref_to_Member'>flags</span></a> <span class='Operator'>|= </span><a href="../../../include/storage/predicate_internals.h.html#LN122"><span class='Ref_to_Const'>SXACT_FLAG_RO_UNSAFE</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We know this isn't a safe snapshot, so we can stop looking for other 
     * potential conflicts. 
     */ 
</span>    <a href="predicate.c.html#LN734"><span class='Ref_To_Local'>conflict</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN732"><span class='Ref_to_Parameter'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN97"><span class='Ref_to_Member'>possibleUnsafeConflicts</span></a><span class='Delimiter'>, 
</span>                     <span class='Operator'>&</span><a href="predicate.c.html#LN732"><span class='Ref_to_Parameter'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN97"><span class='Ref_to_Member'>possibleUnsafeConflicts</span></a><span class='Delimiter'>, 
</span>                     <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN194"><span class='Ref_to_Struct'>RWConflictData</span></a><span class='Delimiter'>, </span>inLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN734"><span class='Ref_To_Local'>conflict</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="predicate.c.html#LN735"><span class='Ref_To_Local'>nextConflict</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN732"><span class='Ref_to_Parameter'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN97"><span class='Ref_to_Member'>possibleUnsafeConflicts</span></a><span class='Delimiter'>, 
</span>                         <span class='Operator'>&</span><a href="predicate.c.html#LN734"><span class='Ref_To_Local'>conflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN197"><span class='Ref_to_Member'>inLink</span></a><span class='Delimiter'>, 
</span>                         <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN194"><span class='Ref_to_Struct'>RWConflictData</span></a><span class='Delimiter'>, </span>inLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN267"><span class='Ref_to_Macro'>SxactIsReadOnly</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN734"><span class='Ref_To_Local'>conflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN198"><span class='Ref_to_Member'>sxactOut</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN732"><span class='Ref_to_Parameter'>sxact</span></a> <span class='Operator'>== </span><a href="predicate.c.html#LN734"><span class='Ref_To_Local'>conflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN199"><span class='Ref_to_Member'>sxactIn</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="predicate.c.html#LN423"><span class='Ref_to_Proto'>ReleaseRWConflict</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN734"><span class='Ref_To_Local'>conflict</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="predicate.c.html#LN734"><span class='Ref_To_Local'>conflict</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN735"><span class='Ref_To_Local'>nextConflict</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end FlagSxactUnsafe &raquo; </span> 
 
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------*/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * We will work on the page range of 0..OLDSERXID_MAX_PAGE. 
 * Compares using wraparound logic, as is required by slru.c. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN773"></a><span class='Declare_Function'>OldSerXidPagePrecedesLogically</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>p</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>q</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN775"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>diff</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We have to compare modulo (OLDSERXID_MAX_PAGE+1)/2.  Both inputs should 
     * be in the range 0..OLDSERXID_MAX_PAGE. 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN773"><span class='Ref_to_Parameter'>p</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="predicate.c.html#LN773"><span class='Ref_to_Parameter'>p</span></a> <span class='Operator'>&LT;= </span><a href="predicate.c.html#LN321"><span class='Ref_to_Const'>OLDSERXID_MAX_PAGE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN773"><span class='Ref_to_Parameter'>q</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="predicate.c.html#LN773"><span class='Ref_to_Parameter'>q</span></a> <span class='Operator'>&LT;= </span><a href="predicate.c.html#LN321"><span class='Ref_to_Const'>OLDSERXID_MAX_PAGE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN775"><span class='Ref_To_Local'>diff</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN773"><span class='Ref_to_Parameter'>p</span></a> <span class='Operator'>- </span><a href="predicate.c.html#LN773"><span class='Ref_to_Parameter'>q</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN775"><span class='Ref_To_Local'>diff</span></a> <span class='Operator'>&GT;= </span><span class='Parentheses'>((</span><a href="predicate.c.html#LN321"><span class='Ref_to_Const'>OLDSERXID_MAX_PAGE</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>/ </span><span class='Number'>2</span><span class='Parentheses'>))</span> 
        <a href="predicate.c.html#LN775"><span class='Ref_To_Local'>diff</span></a> <span class='Operator'>-= </span><a href="predicate.c.html#LN321"><span class='Ref_to_Const'>OLDSERXID_MAX_PAGE</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN775"><span class='Ref_To_Local'>diff</span></a> <span class='Operator'>&LT; -</span><span class='Parentheses'>((</span><span class='Keyword'>int</span><span class='Parentheses'>) (</span><a href="predicate.c.html#LN321"><span class='Ref_to_Const'>OLDSERXID_MAX_PAGE</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>/ </span><span class='Number'>2</span><span class='Parentheses'>))</span> 
        <a href="predicate.c.html#LN775"><span class='Ref_To_Local'>diff</span></a> <span class='Operator'>+= </span><a href="predicate.c.html#LN321"><span class='Ref_to_Const'>OLDSERXID_MAX_PAGE</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="predicate.c.html#LN775"><span class='Ref_To_Local'>diff</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Initialize for the tracking of old serializable committed xids. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN796"></a><span class='Declare_Function'>OldSerXidInit</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN798"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Set up SLRU management of the pg_serial data. 
     */ 
</span>    <a href="predicate.c.html#LN311"><span class='Ref_to_Const'>OldSerXidSlruCtl</span></a><span class='Operator'>-&GT;</span>PagePrecedes <span class='Operator'>= </span><a href="predicate.c.html#LN426"><span class='Ref_to_Proto'>OldSerXidPagePrecedesLogically</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/access/slru.h.html#LN144"><span class='Ref_to_Proto'>SimpleLruInit</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN311"><span class='Ref_to_Const'>OldSerXidSlruCtl</span></a><span class='Delimiter'>, </span><span class='String'>"oldserxid"</span><span class='Delimiter'>, 
</span>                  <a href="../../../include/storage/predicate.h.html#LN29"><span class='Ref_to_Const'>NUM_OLDSERXID_BUFFERS</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span>OldSerXidLock<span class='Delimiter'>, </span><span class='String'>"pg_serial"</span><span class='Delimiter'>, 
</span>                  <a href="../../../include/storage/lwlock.h.html#LN203"><span class='Ref_to_EnumConst'>LWTRANCHE_OLDSERXID_BUFFERS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* Override default assumption that writes should be fsync'd */ 
</span>    <a href="predicate.c.html#LN311"><span class='Ref_to_Const'>OldSerXidSlruCtl</span></a><span class='Operator'>-&GT;</span>do_fsync <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Create or attach to the OldSerXidControl structure. 
     */ 
</span>    <a href="predicate.c.html#LN343"><span class='Ref_to_Global_Var'>oldSerXidControl</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="predicate.c.html#LN341"><span class='Ref_to_Typedef'>OldSerXidControl</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/shmem.h.html#LN43"><span class='Ref_to_Proto'>ShmemInitStruct</span></a><span class='Parentheses'>(</span><span class='String'>"OldSerXidControlData"</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN333"><span class='Ref_to_Struct'>OldSerXidControlData</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predicate.c.html#LN798"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN798"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Set control information to reflect empty SLRU. 
         */ 
</span>        <a href="predicate.c.html#LN343"><span class='Ref_to_Global_Var'>oldSerXidControl</span></a><span class='Operator'>-&GT;</span><a href="predicate.c.html#LN335"><span class='Ref_to_Member'>headPage</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN343"><span class='Ref_to_Global_Var'>oldSerXidControl</span></a><span class='Operator'>-&GT;</span><a href="predicate.c.html#LN336"><span class='Ref_to_Member'>headXid</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN343"><span class='Ref_to_Global_Var'>oldSerXidControl</span></a><span class='Operator'>-&GT;</span><a href="predicate.c.html#LN337"><span class='Ref_to_Member'>tailXid</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN343"><span class='Ref_to_Global_Var'>oldSerXidControl</span></a><span class='Operator'>-&GT;</span><a href="predicate.c.html#LN338"><span class='Ref_to_Member'>warningIssued</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end OldSerXidInit &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Record a committed read write serializable xid and the minimum 
 * commitSeqNo of any transactions to which this xid had a rw-conflict out. 
 * An invalid seqNo means that there were no conflicts out from xid. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN834"></a><span class='Declare_Function'>OldSerXidAdd</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xid</span><span class='Delimiter'>, </span><a href="../../../include/storage/predicate_internals.h.html#LN21"><span class='Ref_to_Typedef'>SerCommitSeqNo</span></a> <span class='Declare_Parameter'>minConflictCommitSeqNo</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN836"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>tailXid</span><span class='Delimiter'>; 
</span><a name="LN837"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>targetPage</span><span class='Delimiter'>; 
</span><a name="LN838"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>slotno</span><span class='Delimiter'>; 
</span><a name="LN839"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>firstZeroPage</span><span class='Delimiter'>; 
</span><a name="LN840"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isNewPage</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN834"><span class='Ref_to_Parameter'>xid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN837"><span class='Ref_To_Local'>targetPage</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN330"><span class='Ref_to_Macro'>OldSerXidPage</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN834"><span class='Ref_to_Parameter'>xid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>OldSerXidLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If no serializable transactions are active, there shouldn't be anything 
     * to push out to the SLRU.  Hitting this assert would mean there's 
     * something wrong with the earlier cleanup logic. 
     */ 
</span>    <a href="predicate.c.html#LN836"><span class='Ref_To_Local'>tailXid</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN343"><span class='Ref_to_Global_Var'>oldSerXidControl</span></a><span class='Operator'>-&GT;</span><a href="predicate.c.html#LN337"><span class='Ref_to_Member'>tailXid</span></a><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN836"><span class='Ref_To_Local'>tailXid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the SLRU is currently unused, zero out the whole active region from 
     * tailXid to headXid before taking it into use. Otherwise zero out only 
     * any new pages that enter the tailXid-headXid range as we advance 
     * headXid. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN343"><span class='Ref_to_Global_Var'>oldSerXidControl</span></a><span class='Operator'>-&GT;</span><a href="predicate.c.html#LN335"><span class='Ref_to_Member'>headPage</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="predicate.c.html#LN839"><span class='Ref_To_Local'>firstZeroPage</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN330"><span class='Ref_to_Macro'>OldSerXidPage</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN836"><span class='Ref_To_Local'>tailXid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN840"><span class='Ref_To_Local'>isNewPage</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="predicate.c.html#LN839"><span class='Ref_To_Local'>firstZeroPage</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN324"><span class='Ref_to_Macro'>OldSerXidNextPage</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN343"><span class='Ref_to_Global_Var'>oldSerXidControl</span></a><span class='Operator'>-&GT;</span><a href="predicate.c.html#LN335"><span class='Ref_to_Member'>headPage</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN840"><span class='Ref_To_Local'>isNewPage</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN426"><span class='Ref_to_Proto'>OldSerXidPagePrecedesLogically</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN343"><span class='Ref_to_Global_Var'>oldSerXidControl</span></a><span class='Operator'>-&GT;</span><a href="predicate.c.html#LN335"><span class='Ref_to_Member'>headPage</span></a><span class='Delimiter'>, 
</span>                                                   <a href="predicate.c.html#LN837"><span class='Ref_To_Local'>targetPage</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN343"><span class='Ref_to_Global_Var'>oldSerXidControl</span></a><span class='Operator'>-&GT;</span><a href="predicate.c.html#LN336"><span class='Ref_to_Member'>headXid</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>|| </span><a href="../../../include/access/transam.h.html#LN170"><span class='Ref_to_Proto'>TransactionIdFollows</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN834"><span class='Ref_to_Parameter'>xid</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN343"><span class='Ref_to_Global_Var'>oldSerXidControl</span></a><span class='Operator'>-&GT;</span><a href="predicate.c.html#LN336"><span class='Ref_to_Member'>headXid</span></a><span class='Parentheses'>))</span> 
        <a href="predicate.c.html#LN343"><span class='Ref_to_Global_Var'>oldSerXidControl</span></a><span class='Operator'>-&GT;</span><a href="predicate.c.html#LN336"><span class='Ref_to_Member'>headXid</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN834"><span class='Ref_to_Parameter'>xid</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN840"><span class='Ref_To_Local'>isNewPage</span></a><span class='Parentheses'>) 
</span>        <a href="predicate.c.html#LN343"><span class='Ref_to_Global_Var'>oldSerXidControl</span></a><span class='Operator'>-&GT;</span><a href="predicate.c.html#LN335"><span class='Ref_to_Member'>headPage</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN837"><span class='Ref_To_Local'>targetPage</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Give a warning if we're about to run out of SLRU pages. 
     * 
     * slru.c has a maximum of 64k segments, with 32 (SLRU_PAGES_PER_SEGMENT) 
     * pages each. We need to store a 64-bit integer for each Xid, and with 
     * default 8k block size, 65536*32 pages is only enough to cover 2^30 
     * XIDs. If we're about to hit that limit and wrap around, warn the user. 
     * 
     * To avoid spamming the user, we only give one warning when we've used 1 
     * billion XIDs, and stay silent until the situation is fixed and the 
     * number of XIDs used falls below 800 million again. 
     * 
     * XXX: We have no safeguard to actually *prevent* the wrap-around, 
     * though. All you get is a warning. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN343"><span class='Ref_to_Global_Var'>oldSerXidControl</span></a><span class='Operator'>-&GT;</span><a href="predicate.c.html#LN338"><span class='Ref_to_Member'>warningIssued</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN897"></a>        <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>lowWatermark</span><span class='Delimiter'>; 
</span> 
        <a href="predicate.c.html#LN897"><span class='Ref_To_Local'>lowWatermark</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN836"><span class='Ref_To_Local'>tailXid</span></a> <span class='Operator'>+ </span><span class='Number'>800000000</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN897"><span class='Ref_To_Local'>lowWatermark</span></a> <span class='Operator'>&LT; </span><a href="../../../include/access/transam.h.html#LN33"><span class='Ref_to_Const'>FirstNormalTransactionId</span></a><span class='Parentheses'>) 
</span>            <a href="predicate.c.html#LN897"><span class='Ref_To_Local'>lowWatermark</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN33"><span class='Ref_to_Const'>FirstNormalTransactionId</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN834"><span class='Ref_to_Parameter'>xid</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN897"><span class='Ref_To_Local'>lowWatermark</span></a><span class='Parentheses'>))</span> 
            <a href="predicate.c.html#LN343"><span class='Ref_to_Global_Var'>oldSerXidControl</span></a><span class='Operator'>-&GT;</span><a href="predicate.c.html#LN338"><span class='Ref_to_Member'>warningIssued</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span><a name="LN907"></a>        <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>highWatermark</span><span class='Delimiter'>; 
</span> 
        <a href="predicate.c.html#LN907"><span class='Ref_To_Local'>highWatermark</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN836"><span class='Ref_To_Local'>tailXid</span></a> <span class='Operator'>+ </span><span class='Number'>1000000000</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN907"><span class='Ref_To_Local'>highWatermark</span></a> <span class='Operator'>&LT; </span><a href="../../../include/access/transam.h.html#LN33"><span class='Ref_to_Const'>FirstNormalTransactionId</span></a><span class='Parentheses'>) 
</span>            <a href="predicate.c.html#LN907"><span class='Ref_To_Local'>highWatermark</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN33"><span class='Ref_to_Const'>FirstNormalTransactionId</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN170"><span class='Ref_to_Proto'>TransactionIdFollows</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN834"><span class='Ref_to_Parameter'>xid</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN907"><span class='Ref_To_Local'>highWatermark</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="predicate.c.html#LN343"><span class='Ref_to_Global_Var'>oldSerXidControl</span></a><span class='Operator'>-&GT;</span><a href="predicate.c.html#LN338"><span class='Ref_to_Member'>warningIssued</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN39"><span class='Ref_to_Const'>WARNING</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"memory for serializable conflict tracking is nearly exhausted"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"There might be an idle transaction or a forgotten prepared transaction causing this."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN840"><span class='Ref_To_Local'>isNewPage</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Initialize intervening pages. */ 
</span>        <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN839"><span class='Ref_To_Local'>firstZeroPage</span></a> <span class='Operator'>!= </span><a href="predicate.c.html#LN837"><span class='Ref_To_Local'>targetPage</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="../../../include/access/slru.h.html#LN146"><span class='Ref_to_Proto'>SimpleLruZeroPage</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN311"><span class='Ref_to_Const'>OldSerXidSlruCtl</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN839"><span class='Ref_To_Local'>firstZeroPage</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="predicate.c.html#LN839"><span class='Ref_To_Local'>firstZeroPage</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN324"><span class='Ref_to_Macro'>OldSerXidNextPage</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN839"><span class='Ref_To_Local'>firstZeroPage</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="predicate.c.html#LN838"><span class='Ref_To_Local'>slotno</span></a> <span class='Operator'>= </span><a href="../../../include/access/slru.h.html#LN146"><span class='Ref_to_Proto'>SimpleLruZeroPage</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN311"><span class='Ref_to_Const'>OldSerXidSlruCtl</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN837"><span class='Ref_To_Local'>targetPage</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
        <a href="predicate.c.html#LN838"><span class='Ref_To_Local'>slotno</span></a> <span class='Operator'>= </span><a href="../../../include/access/slru.h.html#LN147"><span class='Ref_to_Proto'>SimpleLruReadPage</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN311"><span class='Ref_to_Const'>OldSerXidSlruCtl</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN837"><span class='Ref_To_Local'>targetPage</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><a href="predicate.c.html#LN834"><span class='Ref_to_Parameter'>xid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN326"><span class='Ref_to_Macro'>OldSerXidValue</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN838"><span class='Ref_To_Local'>slotno</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN834"><span class='Ref_to_Parameter'>xid</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="predicate.c.html#LN834"><span class='Ref_to_Parameter'>minConflictCommitSeqNo</span></a><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN311"><span class='Ref_to_Const'>OldSerXidSlruCtl</span></a><span class='Operator'>-&GT;</span>shared<span class='Operator'>-&GT;</span>page_dirty<span class='Delimiter'>[</span><a href="predicate.c.html#LN838"><span class='Ref_To_Local'>slotno</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>OldSerXidLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end OldSerXidAdd &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Get the minimum commitSeqNo for any conflict out for the given xid.  For 
 * a transaction which exists but has no conflict out, InvalidSerCommitSeqNo 
 * will be returned. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/storage/predicate_internals.h.html#LN21"><span class='Ref_to_Typedef'>SerCommitSeqNo</span></a> 
<a name="LN946"></a><span class='Declare_Function'>OldSerXidGetMinConflictCommitSeqNo</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN948"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>headXid</span><span class='Delimiter'>; 
</span><a name="LN949"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>tailXid</span><span class='Delimiter'>; 
</span><a name="LN950"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN21"><span class='Ref_to_Typedef'>SerCommitSeqNo</span></a> <span class='Declare_Local'>val</span><span class='Delimiter'>; 
</span><a name="LN951"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>slotno</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN946"><span class='Ref_to_Parameter'>xid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>OldSerXidLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN948"><span class='Ref_To_Local'>headXid</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN343"><span class='Ref_to_Global_Var'>oldSerXidControl</span></a><span class='Operator'>-&GT;</span><a href="predicate.c.html#LN336"><span class='Ref_to_Member'>headXid</span></a><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN949"><span class='Ref_To_Local'>tailXid</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN343"><span class='Ref_to_Global_Var'>oldSerXidControl</span></a><span class='Operator'>-&GT;</span><a href="predicate.c.html#LN337"><span class='Ref_to_Member'>tailXid</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>OldSerXidLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN948"><span class='Ref_To_Local'>headXid</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN949"><span class='Ref_To_Local'>tailXid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN946"><span class='Ref_to_Parameter'>xid</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN949"><span class='Ref_To_Local'>tailXid</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>|| </span><a href="../../../include/access/transam.h.html#LN170"><span class='Ref_to_Proto'>TransactionIdFollows</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN946"><span class='Ref_to_Parameter'>xid</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN948"><span class='Ref_To_Local'>headXid</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The following function must be called without holding OldSerXidLock, 
     * but will return with that lock held, which must then be released. 
     */ 
</span>    <a href="predicate.c.html#LN951"><span class='Ref_To_Local'>slotno</span></a> <span class='Operator'>= </span><a href="../../../include/access/slru.h.html#LN149"><span class='Ref_to_Proto'>SimpleLruReadPage_ReadOnly</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN311"><span class='Ref_to_Const'>OldSerXidSlruCtl</span></a><span class='Delimiter'>, 
</span>                                        <a href="predicate.c.html#LN330"><span class='Ref_to_Macro'>OldSerXidPage</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN946"><span class='Ref_to_Parameter'>xid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="predicate.c.html#LN946"><span class='Ref_to_Parameter'>xid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN950"><span class='Ref_To_Local'>val</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN326"><span class='Ref_to_Macro'>OldSerXidValue</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN951"><span class='Ref_To_Local'>slotno</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN946"><span class='Ref_to_Parameter'>xid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>OldSerXidLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="predicate.c.html#LN950"><span class='Ref_To_Local'>val</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end OldSerXidGetMinConflictCommitSeqNo &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Call this whenever there is a new xmin for active serializable 
 * transactions.  We don't need to keep information on transactions which 
 * precede that.  InvalidTransactionId means none active, so everything in 
 * the SLRU can be discarded. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN987"></a><span class='Declare_Function'>OldSerXidSetActiveSerXmin</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>OldSerXidLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * When no sxacts are active, nothing overlaps, set the xid values to 
     * invalid to show that there are no valid entries.  Don't clear headPage, 
     * though.  A new xmin might still land on that page, and we don't want to 
     * repeatedly zero out the same page. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN987"><span class='Ref_to_Parameter'>xid</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="predicate.c.html#LN343"><span class='Ref_to_Global_Var'>oldSerXidControl</span></a><span class='Operator'>-&GT;</span><a href="predicate.c.html#LN337"><span class='Ref_to_Member'>tailXid</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN343"><span class='Ref_to_Global_Var'>oldSerXidControl</span></a><span class='Operator'>-&GT;</span><a href="predicate.c.html#LN336"><span class='Ref_to_Member'>headXid</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>OldSerXidLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * When we're recovering prepared transactions, the global xmin might move 
     * backwards depending on the order they're recovered. Normally that's not 
     * OK, but during recovery no serializable transactions will commit, so 
     * the SLRU is empty and we can get away with it. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN242"><span class='Ref_to_Proto'>RecoveryInProgress</span></a><span class='Parentheses'>())</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN343"><span class='Ref_to_Global_Var'>oldSerXidControl</span></a><span class='Operator'>-&GT;</span><a href="predicate.c.html#LN335"><span class='Ref_to_Member'>headPage</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN343"><span class='Ref_to_Global_Var'>oldSerXidControl</span></a><span class='Operator'>-&GT;</span><a href="predicate.c.html#LN337"><span class='Ref_to_Member'>tailXid</span></a><span class='Parentheses'>) 
</span>            <span class='Operator'>|| </span><a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN987"><span class='Ref_to_Parameter'>xid</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN343"><span class='Ref_to_Global_Var'>oldSerXidControl</span></a><span class='Operator'>-&GT;</span><a href="predicate.c.html#LN337"><span class='Ref_to_Member'>tailXid</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="predicate.c.html#LN343"><span class='Ref_to_Global_Var'>oldSerXidControl</span></a><span class='Operator'>-&GT;</span><a href="predicate.c.html#LN337"><span class='Ref_to_Member'>tailXid</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN987"><span class='Ref_to_Parameter'>xid</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>OldSerXidLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN343"><span class='Ref_to_Global_Var'>oldSerXidControl</span></a><span class='Operator'>-&GT;</span><a href="predicate.c.html#LN337"><span class='Ref_to_Member'>tailXid</span></a><span class='Parentheses'>) 
</span>           <span class='Operator'>|| </span><a href="../../../include/access/transam.h.html#LN170"><span class='Ref_to_Proto'>TransactionIdFollows</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN987"><span class='Ref_to_Parameter'>xid</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN343"><span class='Ref_to_Global_Var'>oldSerXidControl</span></a><span class='Operator'>-&GT;</span><a href="predicate.c.html#LN337"><span class='Ref_to_Member'>tailXid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN343"><span class='Ref_to_Global_Var'>oldSerXidControl</span></a><span class='Operator'>-&GT;</span><a href="predicate.c.html#LN337"><span class='Ref_to_Member'>tailXid</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN987"><span class='Ref_to_Parameter'>xid</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>OldSerXidLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end OldSerXidSetActiveSerXmin &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Perform a checkpoint --- either during shutdown, or on-the-fly 
 * 
 * We don't have any data that needs to survive a restart, but this is a 
 * convenient place to truncate the SLRU. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1038"></a><span class='Declare_Function'>CheckPointPredicate</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1040"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>tailPage</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>OldSerXidLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Exit quickly if the SLRU is currently not in use. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN343"><span class='Ref_to_Global_Var'>oldSerXidControl</span></a><span class='Operator'>-&GT;</span><a href="predicate.c.html#LN335"><span class='Ref_to_Member'>headPage</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>OldSerXidLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN343"><span class='Ref_to_Global_Var'>oldSerXidControl</span></a><span class='Operator'>-&GT;</span><a href="predicate.c.html#LN337"><span class='Ref_to_Member'>tailXid</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* We can truncate the SLRU up to the page containing tailXid */ 
</span>        <a href="predicate.c.html#LN1040"><span class='Ref_To_Local'>tailPage</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN330"><span class='Ref_to_Macro'>OldSerXidPage</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN343"><span class='Ref_to_Global_Var'>oldSerXidControl</span></a><span class='Operator'>-&GT;</span><a href="predicate.c.html#LN337"><span class='Ref_to_Member'>tailXid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * The SLRU is no longer needed. Truncate to head before we set head 
         * invalid. 
         * 
         * XXX: It's possible that the SLRU is not needed again until XID 
         * wrap-around has happened, so that the segment containing headPage 
         * that we leave behind will appear to be new again. In that case it 
         * won't be removed until XID horizon advances enough to make it 
         * current again. 
         */ 
</span>        <a href="predicate.c.html#LN1040"><span class='Ref_To_Local'>tailPage</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN343"><span class='Ref_to_Global_Var'>oldSerXidControl</span></a><span class='Operator'>-&GT;</span><a href="predicate.c.html#LN335"><span class='Ref_to_Member'>headPage</span></a><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN343"><span class='Ref_to_Global_Var'>oldSerXidControl</span></a><span class='Operator'>-&GT;</span><a href="predicate.c.html#LN335"><span class='Ref_to_Member'>headPage</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>OldSerXidLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Truncate away pages that are no longer required */ 
</span>    <a href="../../../include/access/slru.h.html#LN153"><span class='Ref_to_Proto'>SimpleLruTruncate</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN311"><span class='Ref_to_Const'>OldSerXidSlruCtl</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN1040"><span class='Ref_To_Local'>tailPage</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Flush dirty SLRU pages to disk 
     * 
     * This is not actually necessary from a correctness point of view. We do 
     * it merely as a debugging aid. 
     * 
     * We're doing this after the truncation to avoid writing pages right 
     * before deleting the file in which they sit, which would be completely 
     * pointless. 
     */ 
</span>    <a href="../../../include/access/slru.h.html#LN152"><span class='Ref_to_Proto'>SimpleLruFlush</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN311"><span class='Ref_to_Const'>OldSerXidSlruCtl</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end CheckPointPredicate &raquo; </span> 
 
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------*/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * InitPredicateLocks -- Initialize the predicate locking data structures. 
 * 
 * This is called from CreateSharedMemoryAndSemaphores(), which see for 
 * more comments.  In the normal postmaster case, the shared hash tables 
 * are created here.  Backends inherit the pointers 
 * to the shared tables via fork().  In the EXEC_BACKEND case, each 
 * backend re-executes this code to obtain pointers to the already existing 
 * shared hash tables. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1103"></a><span class='Declare_Function'>InitPredicateLocks</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1105"></a>    <a href="../../../include/utils/hsearch.h.html#LN64"><span class='Ref_to_Struct'>HASHCTL</span></a>     <span class='Declare_Local'>info</span><span class='Delimiter'>; 
</span><a name="LN1106"></a>    <span class='Keyword'>long</span>        <span class='Declare_Local'>max_table_size</span><span class='Delimiter'>; 
</span><a name="LN1107"></a>    <a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Local'>requestSize</span><span class='Delimiter'>; 
</span><a name="LN1108"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Compute size of predicate lock target hashtable. Note these 
     * calculations must agree with PredicateLockShmemSize! 
     */ 
</span>    <a href="predicate.c.html#LN1106"><span class='Ref_To_Local'>max_table_size</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN250"><span class='Ref_to_Macro'>NPREDICATELOCKTARGETENTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Allocate hash table for PREDICATELOCKTARGET structs.  This stores 
     * per-predicate-lock-target information. 
     */ 
</span>    <a href="../../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN1105"><span class='Ref_To_Local'>info</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN1105"><span class='Ref_To_Local'>info</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN1105"><span class='Ref_To_Local'>info</span></a><span class='Operator'>.</span><a href="../../../include/utils/hsearch.h.html#LN71"><span class='Ref_to_Member'>keysize</span></a> <span class='Operator'>= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN1105"><span class='Ref_To_Local'>info</span></a><span class='Operator'>.</span><a href="../../../include/utils/hsearch.h.html#LN72"><span class='Ref_to_Member'>entrysize</span></a> <span class='Operator'>= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN285"><span class='Ref_to_Struct'>PREDICATELOCKTARGET</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN1105"><span class='Ref_To_Local'>info</span></a><span class='Operator'>.</span><a href="../../../include/utils/hsearch.h.html#LN66"><span class='Ref_to_Member'>num_partitions</span></a> <span class='Operator'>= </span><a href="../../../include/storage/lwlock.h.html#LN120"><span class='Ref_to_Const'>NUM_PREDICATELOCK_PARTITIONS</span></a><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN386"><span class='Ref_to_Global_Var'>PredicateLockTargetHash</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN41"><span class='Ref_to_Proto'>ShmemInitHash</span></a><span class='Parentheses'>(</span><span class='String'>"PREDICATELOCKTARGET hash"</span><span class='Delimiter'>, 
</span>                                            <a href="predicate.c.html#LN1106"><span class='Ref_To_Local'>max_table_size</span></a><span class='Delimiter'>, 
</span>                                            <a href="predicate.c.html#LN1106"><span class='Ref_To_Local'>max_table_size</span></a><span class='Delimiter'>, 
</span>                                            <span class='Operator'>&</span><a href="predicate.c.html#LN1105"><span class='Ref_To_Local'>info</span></a><span class='Delimiter'>, 
</span>                                            <a href="../../../include/utils/hsearch.h.html#LN86"><span class='Ref_to_Const'>HASH_ELEM</span></a> <span class='Operator'>| </span><a href="../../../include/utils/hsearch.h.html#LN87"><span class='Ref_to_Const'>HASH_BLOBS</span></a> <span class='Operator'>| 
</span>                                            <a href="../../../include/utils/hsearch.h.html#LN82"><span class='Ref_to_Const'>HASH_PARTITION</span></a> <span class='Operator'>| </span><a href="../../../include/utils/hsearch.h.html#LN95"><span class='Ref_to_Const'>HASH_FIXED_SIZE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Assume an average of 2 xacts per target */ 
</span>    <a href="predicate.c.html#LN1106"><span class='Ref_To_Local'>max_table_size</span></a> <span class='Operator'>*= </span><span class='Number'>2</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Reserve a dummy entry in the hash table; we use it to make sure there's 
     * always one entry available when we need to split or combine a page, 
     * because running out of space there could mean aborting a 
     * non-serializable transaction. 
     */ 
</span>    <a href="../../../include/utils/hsearch.h.html#LN125"><span class='Ref_to_Proto'>hash_search</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN386"><span class='Ref_to_Global_Var'>PredicateLockTargetHash</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predicate.c.html#LN395"><span class='Ref_to_Global_Var'>ScratchTargetTag</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/hsearch.h.html#LN105"><span class='Ref_to_EnumConst'>HASH_ENTER</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Allocate hash table for PREDICATELOCK structs.  This stores per 
     * xact-lock-of-a-target information. 
     */ 
</span>    <a href="../../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN1105"><span class='Ref_To_Local'>info</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN1105"><span class='Ref_To_Local'>info</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN1105"><span class='Ref_To_Local'>info</span></a><span class='Operator'>.</span><a href="../../../include/utils/hsearch.h.html#LN71"><span class='Ref_to_Member'>keysize</span></a> <span class='Operator'>= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN303"><span class='Ref_to_Struct'>PREDICATELOCKTAG</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN1105"><span class='Ref_To_Local'>info</span></a><span class='Operator'>.</span><a href="../../../include/utils/hsearch.h.html#LN72"><span class='Ref_to_Member'>entrysize</span></a> <span class='Operator'>= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN1105"><span class='Ref_To_Local'>info</span></a><span class='Operator'>.</span><a href="../../../include/utils/hsearch.h.html#LN73"><span class='Ref_to_Member'>hash</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN432"><span class='Ref_to_Proto'>predicatelock_hash</span></a><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN1105"><span class='Ref_To_Local'>info</span></a><span class='Operator'>.</span><a href="../../../include/utils/hsearch.h.html#LN66"><span class='Ref_to_Member'>num_partitions</span></a> <span class='Operator'>= </span><a href="../../../include/storage/lwlock.h.html#LN120"><span class='Ref_to_Const'>NUM_PREDICATELOCK_PARTITIONS</span></a><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN387"><span class='Ref_to_Global_Var'>PredicateLockHash</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN41"><span class='Ref_to_Proto'>ShmemInitHash</span></a><span class='Parentheses'>(</span><span class='String'>"PREDICATELOCK hash"</span><span class='Delimiter'>, 
</span>                                      <a href="predicate.c.html#LN1106"><span class='Ref_To_Local'>max_table_size</span></a><span class='Delimiter'>, 
</span>                                      <a href="predicate.c.html#LN1106"><span class='Ref_To_Local'>max_table_size</span></a><span class='Delimiter'>, 
</span>                                      <span class='Operator'>&</span><a href="predicate.c.html#LN1105"><span class='Ref_To_Local'>info</span></a><span class='Delimiter'>, 
</span>                                      <a href="../../../include/utils/hsearch.h.html#LN86"><span class='Ref_to_Const'>HASH_ELEM</span></a> <span class='Operator'>| </span><a href="../../../include/utils/hsearch.h.html#LN88"><span class='Ref_to_Const'>HASH_FUNCTION</span></a> <span class='Operator'>| 
</span>                                      <a href="../../../include/utils/hsearch.h.html#LN82"><span class='Ref_to_Const'>HASH_PARTITION</span></a> <span class='Operator'>| </span><a href="../../../include/utils/hsearch.h.html#LN95"><span class='Ref_to_Const'>HASH_FIXED_SIZE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Compute size for serializable transaction hashtable. Note these 
     * calculations must agree with PredicateLockShmemSize! 
     */ 
</span>    <a href="predicate.c.html#LN1106"><span class='Ref_To_Local'>max_table_size</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../utils/init/globals.c.html#LN126"><span class='Ref_to_Global_Var'>MaxBackends</span></a> <span class='Operator'>+ </span><a href="../../access/transam/twophase.c.html#LN116"><span class='Ref_to_Global_Var'>max_prepared_xacts</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Allocate a list to hold information on transactions participating in 
     * predicate locking. 
     * 
     * Assume an average of 10 predicate locking transactions per backend. 
     * This allows aggressive cleanup while detail is present before data must 
     * be summarized for storage in SLRU and the "dummy" transaction. 
     */ 
</span>    <a href="predicate.c.html#LN1106"><span class='Ref_To_Local'>max_table_size</span></a> <span class='Operator'>*= </span><span class='Number'>10</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN43"><span class='Ref_to_Proto'>ShmemInitStruct</span></a><span class='Parentheses'>(</span><span class='String'>"PredXactList"</span><span class='Delimiter'>, 
</span>                               <a href="../../../include/storage/predicate_internals.h.html#LN180"><span class='Ref_to_Const'>PredXactListDataSize</span></a><span class='Delimiter'>, 
</span>                               <span class='Operator'>&</span><a href="predicate.c.html#LN1108"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN1108"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1181"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
        <a href="../ipc/shmqueue.c.html#LN34"><span class='Ref_to_Func'>SHMQueueInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN146"><span class='Ref_to_Member'>availableList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../ipc/shmqueue.c.html#LN34"><span class='Ref_to_Func'>SHMQueueInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN147"><span class='Ref_to_Member'>activeList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN155"><span class='Ref_to_Member'>SxactGlobalXmin</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN157"><span class='Ref_to_Member'>SxactGlobalXminCount</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN159"><span class='Ref_to_Member'>WritableSxactCount</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN161"><span class='Ref_to_Member'>LastSxactCommitSeqNo</span></a> <span class='Operator'>= </span><a href="../../../include/storage/predicate_internals.h.html#LN37"><span class='Ref_to_Const'>FirstNormalSerCommitSeqNo</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN166"><span class='Ref_to_Member'>CanPartialClearThrough</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN171"><span class='Ref_to_Member'>HavePartialClearedThrough</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN1107"><span class='Ref_To_Local'>requestSize</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN45"><span class='Ref_to_Proto'>mul_size</span></a><span class='Parentheses'>((</span><a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a><span class='Parentheses'>) </span><a href="predicate.c.html#LN1106"><span class='Ref_To_Local'>max_table_size</span></a><span class='Delimiter'>, 
</span>                               <a href="../../../include/storage/predicate_internals.h.html#LN141"><span class='Ref_to_Const'>PredXactListElementDataSize</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN175"><span class='Ref_to_Member'>element</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN36"><span class='Ref_to_Proto'>ShmemAlloc</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1107"><span class='Ref_To_Local'>requestSize</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Add all elements to available list, clean. */ 
</span>        memset<span class='Parentheses'>(</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN175"><span class='Ref_to_Member'>element</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><a href="predicate.c.html#LN1107"><span class='Ref_To_Local'>requestSize</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN1181"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="predicate.c.html#LN1181"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="predicate.c.html#LN1106"><span class='Ref_To_Local'>max_table_size</span></a><span class='Delimiter'>; </span><a href="predicate.c.html#LN1181"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../../include/storage/shmem.h.html#LN70"><span class='Ref_to_Proto'>SHMQueueInsertBefore</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN146"><span class='Ref_to_Member'>availableList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                 <span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN175"><span class='Ref_to_Member'>element</span></a><span class='Delimiter'>[</span><a href="predicate.c.html#LN1181"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/storage/predicate_internals.h.html#LN135"><span class='Ref_to_Member'>link</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN173"><span class='Ref_to_Member'>OldCommittedSxact</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN415"><span class='Ref_to_Proto'>CreatePredXact</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lock.h.html#LN77"><span class='Ref_to_Macro'>SetInvalidVirtualTransactionId</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN173"><span class='Ref_to_Member'>OldCommittedSxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN57"><span class='Ref_to_Member'>vxid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN173"><span class='Ref_to_Member'>OldCommittedSxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN74"><span class='Ref_to_Member'>prepareSeqNo</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN173"><span class='Ref_to_Member'>OldCommittedSxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN75"><span class='Ref_to_Member'>commitSeqNo</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN173"><span class='Ref_to_Member'>OldCommittedSxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN84"><span class='Ref_to_Member'>SeqNo</span></a><span class='Operator'>.</span>lastCommitBeforeSnapshot <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="../ipc/shmqueue.c.html#LN34"><span class='Ref_to_Func'>SHMQueueInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN173"><span class='Ref_to_Member'>OldCommittedSxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN85"><span class='Ref_to_Member'>outConflicts</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../ipc/shmqueue.c.html#LN34"><span class='Ref_to_Func'>SHMQueueInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN173"><span class='Ref_to_Member'>OldCommittedSxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN87"><span class='Ref_to_Member'>inConflicts</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../ipc/shmqueue.c.html#LN34"><span class='Ref_to_Func'>SHMQueueInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN173"><span class='Ref_to_Member'>OldCommittedSxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN89"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../ipc/shmqueue.c.html#LN34"><span class='Ref_to_Func'>SHMQueueInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN173"><span class='Ref_to_Member'>OldCommittedSxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN90"><span class='Ref_to_Member'>finishedLink</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../ipc/shmqueue.c.html#LN34"><span class='Ref_to_Func'>SHMQueueInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN173"><span class='Ref_to_Member'>OldCommittedSxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN97"><span class='Ref_to_Member'>possibleUnsafeConflicts</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN173"><span class='Ref_to_Member'>OldCommittedSxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN99"><span class='Ref_to_Member'>topXid</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN173"><span class='Ref_to_Member'>OldCommittedSxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN101"><span class='Ref_to_Member'>finishedBefore</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN173"><span class='Ref_to_Member'>OldCommittedSxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN104"><span class='Ref_to_Member'>xmin</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN173"><span class='Ref_to_Member'>OldCommittedSxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN105"><span class='Ref_to_Member'>flags</span></a> <span class='Operator'>= </span><a href="../../../include/storage/predicate_internals.h.html#LN109"><span class='Ref_to_Const'>SXACT_FLAG_COMMITTED</span></a><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN173"><span class='Ref_to_Member'>OldCommittedSxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN106"><span class='Ref_to_Member'>pid</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !found &raquo; </span> 
    <span class='Comment_Multi_Line'>/* This never changes, so let's keep a local copy. */ 
</span>    <a href="predicate.c.html#LN351"><span class='Ref_to_Global_Var'>OldCommittedSxact</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN173"><span class='Ref_to_Member'>OldCommittedSxact</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Allocate hash table for SERIALIZABLEXID structs.  This stores per-xid 
     * information for serializable transactions which have accessed data. 
     */ 
</span>    <a href="../../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN1105"><span class='Ref_To_Local'>info</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN1105"><span class='Ref_To_Local'>info</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN1105"><span class='Ref_To_Local'>info</span></a><span class='Operator'>.</span><a href="../../../include/utils/hsearch.h.html#LN71"><span class='Ref_to_Member'>keysize</span></a> <span class='Operator'>= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN223"><span class='Ref_to_Struct'>SERIALIZABLEXIDTAG</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN1105"><span class='Ref_To_Local'>info</span></a><span class='Operator'>.</span><a href="../../../include/utils/hsearch.h.html#LN72"><span class='Ref_to_Member'>entrysize</span></a> <span class='Operator'>= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN241"><span class='Ref_to_Struct'>SERIALIZABLEXID</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN385"><span class='Ref_to_Global_Var'>SerializableXidHash</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN41"><span class='Ref_to_Proto'>ShmemInitHash</span></a><span class='Parentheses'>(</span><span class='String'>"SERIALIZABLEXID hash"</span><span class='Delimiter'>, 
</span>                                        <a href="predicate.c.html#LN1106"><span class='Ref_To_Local'>max_table_size</span></a><span class='Delimiter'>, 
</span>                                        <a href="predicate.c.html#LN1106"><span class='Ref_To_Local'>max_table_size</span></a><span class='Delimiter'>, 
</span>                                        <span class='Operator'>&</span><a href="predicate.c.html#LN1105"><span class='Ref_To_Local'>info</span></a><span class='Delimiter'>, 
</span>                                        <a href="../../../include/utils/hsearch.h.html#LN86"><span class='Ref_to_Const'>HASH_ELEM</span></a> <span class='Operator'>| </span><a href="../../../include/utils/hsearch.h.html#LN87"><span class='Ref_to_Const'>HASH_BLOBS</span></a> <span class='Operator'>| 
</span>                                        <a href="../../../include/utils/hsearch.h.html#LN95"><span class='Ref_to_Const'>HASH_FIXED_SIZE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Allocate space for tracking rw-conflicts in lists attached to the 
     * transactions. 
     * 
     * Assume an average of 5 conflicts per transaction.  Calculations suggest 
     * that this will prevent resource exhaustion in even the most pessimal 
     * loads up to max_connections = 200 with all 200 connections pounding the 
     * database with serializable transactions.  Beyond that, there may be 
     * occasional transactions canceled when trying to flag conflicts. That's 
     * probably OK. 
     */ 
</span>    <a href="predicate.c.html#LN1106"><span class='Ref_To_Local'>max_table_size</span></a> <span class='Operator'>*= </span><span class='Number'>5</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN379"><span class='Ref_to_Global_Var'>RWConflictPool</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN43"><span class='Ref_to_Proto'>ShmemInitStruct</span></a><span class='Parentheses'>(</span><span class='String'>"RWConflictPool"</span><span class='Delimiter'>, 
</span>                                     <a href="../../../include/storage/predicate_internals.h.html#LN215"><span class='Ref_to_Const'>RWConflictPoolHeaderDataSize</span></a><span class='Delimiter'>, 
</span>                                     <span class='Operator'>&</span><a href="predicate.c.html#LN1108"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN1108"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1253"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
        <a href="../ipc/shmqueue.c.html#LN34"><span class='Ref_to_Func'>SHMQueueInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN379"><span class='Ref_to_Global_Var'>RWConflictPool</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN209"><span class='Ref_to_Member'>availableList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN1107"><span class='Ref_To_Local'>requestSize</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN45"><span class='Ref_to_Proto'>mul_size</span></a><span class='Parentheses'>((</span><a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a><span class='Parentheses'>) </span><a href="predicate.c.html#LN1106"><span class='Ref_To_Local'>max_table_size</span></a><span class='Delimiter'>, 
</span>                               <a href="../../../include/storage/predicate_internals.h.html#LN204"><span class='Ref_to_Const'>RWConflictDataSize</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN379"><span class='Ref_to_Global_Var'>RWConflictPool</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN210"><span class='Ref_to_Member'>element</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN36"><span class='Ref_to_Proto'>ShmemAlloc</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1107"><span class='Ref_To_Local'>requestSize</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Add all elements to available list, clean. */ 
</span>        memset<span class='Parentheses'>(</span><a href="predicate.c.html#LN379"><span class='Ref_to_Global_Var'>RWConflictPool</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN210"><span class='Ref_to_Member'>element</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><a href="predicate.c.html#LN1107"><span class='Ref_To_Local'>requestSize</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN1253"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="predicate.c.html#LN1253"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="predicate.c.html#LN1106"><span class='Ref_To_Local'>max_table_size</span></a><span class='Delimiter'>; </span><a href="predicate.c.html#LN1253"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../../include/storage/shmem.h.html#LN70"><span class='Ref_to_Proto'>SHMQueueInsertBefore</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN379"><span class='Ref_to_Global_Var'>RWConflictPool</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN209"><span class='Ref_to_Member'>availableList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                 <span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN379"><span class='Ref_to_Global_Var'>RWConflictPool</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN210"><span class='Ref_to_Member'>element</span></a><span class='Delimiter'>[</span><a href="predicate.c.html#LN1253"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span>outLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Create or attach to the header for the list of finished serializable 
     * transactions. 
     */ 
</span>    <a href="predicate.c.html#LN388"><span class='Ref_to_Global_Var'>FinishedSerializableTransactions</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/shmem.h.html#LN27"><span class='Ref_to_Struct'>SHM_QUEUE</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/shmem.h.html#LN43"><span class='Ref_to_Proto'>ShmemInitStruct</span></a><span class='Parentheses'>(</span><span class='String'>"FinishedSerializableTransactions"</span><span class='Delimiter'>, 
</span>                        <span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/shmem.h.html#LN27"><span class='Ref_to_Struct'>SHM_QUEUE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                        <span class='Operator'>&</span><a href="predicate.c.html#LN1108"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN1108"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>        <a href="../ipc/shmqueue.c.html#LN34"><span class='Ref_to_Func'>SHMQueueInit</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN388"><span class='Ref_to_Global_Var'>FinishedSerializableTransactions</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Initialize the SLRU storage for old committed serializable 
     * transactions. 
     */ 
</span>    <a href="predicate.c.html#LN427"><span class='Ref_to_Proto'>OldSerXidInit</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Pre-calculate the hash and partition lock of the scratch entry */ 
</span>    <a href="predicate.c.html#LN396"><span class='Ref_to_Global_Var'>ScratchTargetTagHash</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN288"><span class='Ref_to_Macro'>PredicateLockTargetTagHashCode</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN395"><span class='Ref_to_Global_Var'>ScratchTargetTag</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN397"><span class='Ref_to_Global_Var'>ScratchPartitionLock</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN244"><span class='Ref_to_Macro'>PredicateLockHashPartitionLock</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN396"><span class='Ref_to_Global_Var'>ScratchTargetTagHash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end InitPredicateLocks &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Estimate shared-memory space used for predicate lock table 
 */ 
</span><a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a> 
<a name="LN1294"></a><span class='Declare_Function'>PredicateLockShmemSize</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1296"></a>    <a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Local'>size</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1297"></a>    <span class='Keyword'>long</span>        <span class='Declare_Local'>max_table_size</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* predicate lock target hash table */ 
</span>    <a href="predicate.c.html#LN1297"><span class='Ref_To_Local'>max_table_size</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN250"><span class='Ref_to_Macro'>NPREDICATELOCKTARGETENTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN1296"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1296"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/hsearch.h.html#LN138"><span class='Ref_to_Proto'>hash_estimate_size</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1297"><span class='Ref_To_Local'>max_table_size</span></a><span class='Delimiter'>, 
</span>                                             <span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN285"><span class='Ref_to_Struct'>PREDICATELOCKTARGET</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* predicate lock hash table */ 
</span>    <a href="predicate.c.html#LN1297"><span class='Ref_To_Local'>max_table_size</span></a> <span class='Operator'>*= </span><span class='Number'>2</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN1296"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1296"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/hsearch.h.html#LN138"><span class='Ref_to_Proto'>hash_estimate_size</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1297"><span class='Ref_To_Local'>max_table_size</span></a><span class='Delimiter'>, 
</span>                                             <span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Since NPREDICATELOCKTARGETENTS is only an estimate, add 10% safety 
     * margin. 
     */ 
</span>    <a href="predicate.c.html#LN1296"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1296"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN1296"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>/ </span><span class='Number'>10</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* transaction list */ 
</span>    <a href="predicate.c.html#LN1297"><span class='Ref_To_Local'>max_table_size</span></a> <span class='Operator'>= </span><a href="../../utils/init/globals.c.html#LN126"><span class='Ref_to_Global_Var'>MaxBackends</span></a> <span class='Operator'>+ </span><a href="../../access/transam/twophase.c.html#LN116"><span class='Ref_to_Global_Var'>max_prepared_xacts</span></a><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN1297"><span class='Ref_To_Local'>max_table_size</span></a> <span class='Operator'>*= </span><span class='Number'>10</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN1296"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1296"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/predicate_internals.h.html#LN180"><span class='Ref_to_Const'>PredXactListDataSize</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN1296"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1296"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/shmem.h.html#LN45"><span class='Ref_to_Proto'>mul_size</span></a><span class='Parentheses'>((</span><a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a><span class='Parentheses'>) </span><a href="predicate.c.html#LN1297"><span class='Ref_To_Local'>max_table_size</span></a><span class='Delimiter'>, 
</span>                                   <a href="../../../include/storage/predicate_internals.h.html#LN141"><span class='Ref_to_Const'>PredXactListElementDataSize</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* transaction xid table */ 
</span>    <a href="predicate.c.html#LN1296"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1296"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/hsearch.h.html#LN138"><span class='Ref_to_Proto'>hash_estimate_size</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1297"><span class='Ref_To_Local'>max_table_size</span></a><span class='Delimiter'>, 
</span>                                             <span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN241"><span class='Ref_to_Struct'>SERIALIZABLEXID</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* rw-conflict pool */ 
</span>    <a href="predicate.c.html#LN1297"><span class='Ref_To_Local'>max_table_size</span></a> <span class='Operator'>*= </span><span class='Number'>5</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN1296"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1296"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/predicate_internals.h.html#LN215"><span class='Ref_to_Const'>RWConflictPoolHeaderDataSize</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN1296"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1296"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/shmem.h.html#LN45"><span class='Ref_to_Proto'>mul_size</span></a><span class='Parentheses'>((</span><a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a><span class='Parentheses'>) </span><a href="predicate.c.html#LN1297"><span class='Ref_To_Local'>max_table_size</span></a><span class='Delimiter'>, 
</span>                                   <a href="../../../include/storage/predicate_internals.h.html#LN204"><span class='Ref_to_Const'>RWConflictDataSize</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Head for list of finished serializable transactions. */ 
</span>    <a href="predicate.c.html#LN1296"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1296"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/shmem.h.html#LN27"><span class='Ref_to_Struct'>SHM_QUEUE</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Shared memory structures for SLRU tracking of old committed xids. */ 
</span>    <a href="predicate.c.html#LN1296"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1296"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN333"><span class='Ref_to_Struct'>OldSerXidControlData</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN1296"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1296"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, </span><a href="../../access/transam/slru.c.html#LN143"><span class='Ref_to_Func'>SimpleLruShmemSize</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate.h.html#LN29"><span class='Ref_to_Const'>NUM_OLDSERXID_BUFFERS</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="predicate.c.html#LN1296"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end PredicateLockShmemSize &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Compute the hash code associated with a PREDICATELOCKTAG. 
 * 
 * Because we want to use just one set of partition locks for both the 
 * PREDICATELOCKTARGET and PREDICATELOCK hash tables, we have to make sure 
 * that PREDICATELOCKs fall into the same partition number as their 
 * associated PREDICATELOCKTARGETs.  dynahash.c expects the partition number 
 * to be the low-order bits of the hash code, and therefore a 
 * PREDICATELOCKTAG's hash code must have the same low-order bits as the 
 * associated PREDICATELOCKTARGETTAG's hash code.  We achieve this with this 
 * specialized hash function. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> 
<a name="LN1356"></a><span class='Declare_Function'>predicatelock_hash</span><span class='Parentheses'>(</span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>key</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a> <span class='Declare_Parameter'>keysize</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1358"></a>    <span class='Keyword'>const </span><a href="../../../include/storage/predicate_internals.h.html#LN303"><span class='Ref_to_Struct'>PREDICATELOCKTAG</span></a> <span class='Operator'>*</span><span class='Declare_Local'>predicatelocktag</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../../include/storage/predicate_internals.h.html#LN303"><span class='Ref_to_Struct'>PREDICATELOCKTAG</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predicate.c.html#LN1356"><span class='Ref_to_Parameter'>key</span></a><span class='Delimiter'>; 
</span><a name="LN1359"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>targethash</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN1356"><span class='Ref_to_Parameter'>keysize</span></a> <span class='Operator'>== </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN303"><span class='Ref_to_Struct'>PREDICATELOCKTAG</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Look into the associated target object, and compute its hash code */ 
</span>    <a href="predicate.c.html#LN1359"><span class='Ref_To_Local'>targethash</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN288"><span class='Ref_to_Macro'>PredicateLockTargetTagHashCode</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN1358"><span class='Ref_To_Local'>predicatelocktag</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN305"><span class='Ref_to_Member'>myTarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN288"><span class='Ref_to_Member'>tag</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="predicate.c.html#LN301"><span class='Ref_to_Macro'>PredicateLockHashCodeFromTargetHashCode</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1358"><span class='Ref_To_Local'>predicatelocktag</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN1359"><span class='Ref_To_Local'>targethash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * GetPredicateLockStatusData 
 *      Return a table containing the internal state of the predicate 
 *      lock manager for use in pg_lock_status. 
 * 
 * Like GetLockStatusData, this function tries to hold the partition LWLocks 
 * for as short a time as possible by returning two arrays that simply 
 * contain the PREDICATELOCKTARGETTAG and SERIALIZABLEXACT for each lock 
 * table entry. Multiple copies of the same PREDICATELOCKTARGETTAG and 
 * SERIALIZABLEXACT will likely appear. 
 */ 
</span><a href="../../../include/storage/predicate_internals.h.html#LN376"><span class='Ref_to_Struct'>PredicateLockData</span></a> <span class='Operator'>* 
</span><a name="LN1382"></a><span class='Declare_Function'>GetPredicateLockStatusData</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1384"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN376"><span class='Ref_to_Struct'>PredicateLockData</span></a> <span class='Operator'>*</span><span class='Declare_Local'>data</span><span class='Delimiter'>; 
</span><a name="LN1385"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN1386"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>els</span><span class='Delimiter'>, 
</span><a name="LN1387"></a>                <span class='Declare_Local'>el</span><span class='Delimiter'>; 
</span><a name="LN1388"></a>    <a href="../../../include/utils/hsearch.h.html#LN111"><span class='Ref_to_Typedef'>HASH_SEQ_STATUS</span></a> <span class='Declare_Local'>seqstat</span><span class='Delimiter'>; 
</span><a name="LN1389"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Declare_Local'>predlock</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN1384"><span class='Ref_To_Local'>data</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN376"><span class='Ref_to_Struct'>PredicateLockData</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN376"><span class='Ref_to_Struct'>PredicateLockData</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * To ensure consistency, take simultaneous locks on all partition locks 
     * in ascending order, then SerializableXactHashLock. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN1385"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="predicate.c.html#LN1385"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="../../../include/storage/lwlock.h.html#LN120"><span class='Ref_to_Const'>NUM_PREDICATELOCK_PARTITIONS</span></a><span class='Delimiter'>; </span><a href="predicate.c.html#LN1385"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN247"><span class='Ref_to_Macro'>PredicateLockHashPartitionLockByIndex</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1385"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Get number of locks and allocate appropriately-sized arrays. */ 
</span>    <a href="predicate.c.html#LN1386"><span class='Ref_To_Local'>els</span></a> <span class='Operator'>= </span><a href="../../../include/utils/hsearch.h.html#LN133"><span class='Ref_to_Proto'>hash_get_num_entries</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN387"><span class='Ref_to_Global_Var'>PredicateLockHash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN1384"><span class='Ref_To_Local'>data</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN378"><span class='Ref_to_Member'>nelements</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN1386"><span class='Ref_To_Local'>els</span></a><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN1384"><span class='Ref_To_Local'>data</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN379"><span class='Ref_to_Member'>locktags</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>        <a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="predicate.c.html#LN1386"><span class='Ref_To_Local'>els</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN1384"><span class='Ref_To_Local'>data</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN380"><span class='Ref_to_Member'>xacts</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>        <a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="predicate.c.html#LN1386"><span class='Ref_To_Local'>els</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
    <span class='Comment_Multi_Line'>/* Scan through PredicateLockHash and copy contents */ 
</span>    <a href="../../../include/utils/hsearch.h.html#LN134"><span class='Ref_to_Proto'>hash_seq_init</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN1388"><span class='Ref_To_Local'>seqstat</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN387"><span class='Ref_to_Global_Var'>PredicateLockHash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN1387"><span class='Ref_To_Local'>el</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>while</span> <span class='Parentheses'>((</span><a href="predicate.c.html#LN1389"><span class='Ref_To_Local'>predlock</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/utils/hsearch.h.html#LN135"><span class='Ref_to_Proto'>hash_seq_search</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN1388"><span class='Ref_To_Local'>seqstat</span></a><span class='Parentheses'>)))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="predicate.c.html#LN1384"><span class='Ref_To_Local'>data</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN379"><span class='Ref_to_Member'>locktags</span></a><span class='Delimiter'>[</span><a href="predicate.c.html#LN1387"><span class='Ref_To_Local'>el</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="predicate.c.html#LN1389"><span class='Ref_To_Local'>predlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN321"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/predicate_internals.h.html#LN305"><span class='Ref_to_Member'>myTarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN288"><span class='Ref_to_Member'>tag</span></a><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN1384"><span class='Ref_To_Local'>data</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN380"><span class='Ref_to_Member'>xacts</span></a><span class='Delimiter'>[</span><a href="predicate.c.html#LN1387"><span class='Ref_To_Local'>el</span></a><span class='Delimiter'>] </span><span class='Operator'>= *</span><a href="predicate.c.html#LN1389"><span class='Ref_To_Local'>predlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN321"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/predicate_internals.h.html#LN306"><span class='Ref_to_Member'>myXact</span></a><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN1387"><span class='Ref_To_Local'>el</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN1387"><span class='Ref_To_Local'>el</span></a> <span class='Operator'>== </span><a href="predicate.c.html#LN1386"><span class='Ref_To_Local'>els</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Release locks in reverse order */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN1385"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><a href="../../../include/storage/lwlock.h.html#LN120"><span class='Ref_to_Const'>NUM_PREDICATELOCK_PARTITIONS</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="predicate.c.html#LN1385"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="predicate.c.html#LN1385"><span class='Ref_To_Local'>i</span></a><span class='Operator'>--</span><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN247"><span class='Ref_to_Macro'>PredicateLockHashPartitionLockByIndex</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1385"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="predicate.c.html#LN1384"><span class='Ref_To_Local'>data</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end GetPredicateLockStatusData &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Free up shared memory structures by pushing the oldest sxact (the one at 
 * the front of the SummarizeOldestCommittedSxact queue) into summary form. 
 * Each call will free exactly one SERIALIZABLEXACT structure and may also 
 * free one or more of these structures: SERIALIZABLEXID, PREDICATELOCK, 
 * PREDICATELOCKTARGET, RWConflictData. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1440"></a><span class='Declare_Function'>SummarizeOldestCommittedSxact</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1442"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sxact</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SerializableFinishedListLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * This function is only called if there are no sxact slots available. 
     * Some of them must belong to old, already-finished transactions, so 
     * there should be something in FinishedSerializableTransactions list that 
     * we can summarize. However, there's a race condition: while we were not 
     * holding any locks, a transaction might have ended and cleaned up all 
     * the finished sxact entries already, freeing up their sxact slots. In 
     * that case, we have nothing to do here. The caller will find one of the 
     * slots released by the other backend when it retries. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/shmem.h.html#LN76"><span class='Ref_to_Proto'>SHMQueueEmpty</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN388"><span class='Ref_to_Global_Var'>FinishedSerializableTransactions</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableFinishedListLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Grab the first sxact off the finished list -- this will be the earliest 
     * commit.  Remove it from the list. 
     */ 
</span>    <a href="predicate.c.html#LN1442"><span class='Ref_To_Local'>sxact</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN388"><span class='Ref_to_Global_Var'>FinishedSerializableTransactions</span></a><span class='Delimiter'>, 
</span>                     <a href="predicate.c.html#LN388"><span class='Ref_to_Global_Var'>FinishedSerializableTransactions</span></a><span class='Delimiter'>, 
</span>                     <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a><span class='Delimiter'>, </span>finishedLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../ipc/shmqueue.c.html#LN66"><span class='Ref_to_Func'>SHMQueueDelete</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN1442"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN90"><span class='Ref_to_Member'>finishedLink</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Add to SLRU summary information. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1442"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN99"><span class='Ref_to_Member'>topXid</span></a><span class='Parentheses'>) </span><span class='Operator'>&& !</span><a href="predicate.c.html#LN267"><span class='Ref_to_Macro'>SxactIsReadOnly</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1442"><span class='Ref_To_Local'>sxact</span></a><span class='Parentheses'>))</span> 
        <a href="predicate.c.html#LN428"><span class='Ref_to_Proto'>OldSerXidAdd</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1442"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN99"><span class='Ref_to_Member'>topXid</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN275"><span class='Ref_to_Macro'>SxactHasConflictOut</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1442"><span class='Ref_To_Local'>sxact</span></a><span class='Parentheses'>) 
</span>           <span class='Operator'>? </span><a href="predicate.c.html#LN1442"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN84"><span class='Ref_to_Member'>SeqNo</span></a><span class='Operator'>.</span>earliestOutConflictCommit <span class='Operator'>: </span><a href="../../../include/storage/predicate_internals.h.html#LN35"><span class='Ref_to_Const'>InvalidSerCommitSeqNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Summarize and release the detail. */ 
</span>    <a href="predicate.c.html#LN461"><span class='Ref_to_Proto'>ReleaseOneSerializableXact</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1442"><span class='Ref_To_Local'>sxact</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableFinishedListLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end SummarizeOldestCommittedSxact &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * GetSafeSnapshot 
 *      Obtain and register a snapshot for a READ ONLY DEFERRABLE 
 *      transaction. Ensures that the snapshot is "safe", i.e. a 
 *      read-only transaction running on it can execute serializably 
 *      without further checks. This requires waiting for concurrent 
 *      transactions to complete, and retrying with a new snapshot if 
 *      one of them could possibly create a conflict. 
 * 
 *      As with GetSerializableTransactionSnapshot (which this is a subroutine 
 *      for), the passed-in Snapshot pointer should reference a static data 
 *      area that can safely be passed to GetSnapshotData. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/utils/snapshot.h.html#LN22"><span class='Ref_to_Typedef'>Snapshot</span></a> 
<a name="LN1497"></a><span class='Declare_Function'>GetSafeSnapshot</span><span class='Parentheses'>(</span><a href="../../../include/utils/snapshot.h.html#LN22"><span class='Ref_to_Typedef'>Snapshot</span></a> <span class='Declare_Parameter'>origSnapshot</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1499"></a>    <a href="../../../include/utils/snapshot.h.html#LN22"><span class='Ref_to_Typedef'>Snapshot</span></a>    <span class='Declare_Local'>snapshot</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../access/transam/xact.c.html#LN76"><span class='Ref_to_Global_Var'>XactReadOnly</span></a> <span class='Operator'>&& </span><a href="../../access/transam/xact.c.html#LN79"><span class='Ref_to_Global_Var'>XactDeferrable</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>while</span> <span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * GetSerializableTransactionSnapshotInt is going to call 
         * GetSnapshotData, so we need to provide it the static snapshot area 
         * our caller passed to us.  The pointer returned is actually the same 
         * one passed to it, but we avoid assuming that here. 
         */ 
</span>        <a href="predicate.c.html#LN1499"><span class='Ref_To_Local'>snapshot</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN435"><span class='Ref_to_Proto'>GetSerializableTransactionSnapshotInt</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1497"><span class='Ref_to_Parameter'>origSnapshot</span></a><span class='Delimiter'>, 
</span>                                                       <a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a> <span class='Operator'>== </span><a href="../../../include/storage/predicate_internals.h.html#LN468"><span class='Ref_to_Const'>InvalidSerializableXact</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <a href="predicate.c.html#LN1499"><span class='Ref_To_Local'>snapshot</span></a><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* no concurrent r/w xacts; it's safe */ 
</span> 
        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Wait for concurrent transactions to finish. Stop early if one of 
         * them marked us as conflicted. 
         */ 
</span>        <a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN105"><span class='Ref_to_Member'>flags</span></a> <span class='Operator'>|= </span><a href="../../../include/storage/predicate_internals.h.html#LN120"><span class='Ref_to_Const'>SXACT_FLAG_DEFERRABLE_WAITING</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>while</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="../../../include/storage/shmem.h.html#LN76"><span class='Ref_to_Proto'>SHMQueueEmpty</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN97"><span class='Ref_to_Member'>possibleUnsafeConflicts</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>                 <a href="predicate.c.html#LN278"><span class='Ref_to_Macro'>SxactIsROUnsafe</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Parentheses'>)))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/storage/proc.h.html#LN307"><span class='Ref_to_Proto'>ProcWaitForSignal</span></a><span class='Parentheses'>(</span><a href="../../../include/pgstat.h.html#LN811"><span class='Ref_to_EnumConst'>WAIT_EVENT_SAFE_SNAPSHOT</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN105"><span class='Ref_to_Member'>flags</span></a> <span class='Operator'>&= ~</span><a href="../../../include/storage/predicate_internals.h.html#LN120"><span class='Ref_to_Const'>SXACT_FLAG_DEFERRABLE_WAITING</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN278"><span class='Ref_to_Macro'>SxactIsROUnsafe</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>;</span>              <span class='Comment_Single_Line'>/* success */ 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* else, need to retry... */ 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_T_R_SERIALIZATION_FAILURE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"deferrable snapshot was unsafe; trying a new one"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/predicate.h.html#LN56"><span class='Ref_to_Proto'>ReleasePredicateLocks</span></a><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while true &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Now we have a safe snapshot, so we don't need to do any further checks. 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN277"><span class='Ref_to_Macro'>SxactIsROSafe</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/predicate.h.html#LN56"><span class='Ref_to_Proto'>ReleasePredicateLocks</span></a><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="predicate.c.html#LN1499"><span class='Ref_To_Local'>snapshot</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end GetSafeSnapshot &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * GetSafeSnapshotBlockingPids 
 *      If the specified process is currently blocked in GetSafeSnapshot, 
 *      write the process IDs of all processes that it is blocked by 
 *      into the caller-supplied buffer output[].  The list is truncated at 
 *      output_size, and the number of PIDs written into the buffer is 
 *      returned.  Returns zero if the given PID is not currently blocked 
 *      in GetSafeSnapshot. 
 */ 
</span><span class='Keyword'>int 
</span><a name="LN1567"></a><span class='Declare_Function'>GetSafeSnapshotBlockingPids</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>blocked_pid</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Operator'>*</span><span class='Declare_Parameter'>output</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>output_size</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1569"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>num_written</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1570"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sxact</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Find blocked_pid's SERIALIZABLEXACT by linear search. */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN1570"><span class='Ref_To_Local'>sxact</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN417"><span class='Ref_to_Proto'>FirstPredXact</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; </span><a href="predicate.c.html#LN1570"><span class='Ref_To_Local'>sxact</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; </span><a href="predicate.c.html#LN1570"><span class='Ref_To_Local'>sxact</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN418"><span class='Ref_to_Proto'>NextPredXact</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1570"><span class='Ref_To_Local'>sxact</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN1570"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN106"><span class='Ref_to_Member'>pid</span></a> <span class='Operator'>== </span><a href="predicate.c.html#LN1567"><span class='Ref_to_Parameter'>blocked_pid</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Did we find it, and is it currently waiting in GetSafeSnapshot? */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN1570"><span class='Ref_To_Local'>sxact</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL </span><span class='Operator'>&& </span><a href="predicate.c.html#LN276"><span class='Ref_to_Macro'>SxactIsDeferrableWaiting</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1570"><span class='Ref_To_Local'>sxact</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1584"></a>        <a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a>  <span class='Declare_Local'>possibleUnsafeConflict</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Traverse the list of possible unsafe conflicts collecting PIDs. */ 
</span>        <a href="predicate.c.html#LN1584"><span class='Ref_To_Local'>possibleUnsafeConflict</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN1570"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN97"><span class='Ref_to_Member'>possibleUnsafeConflicts</span></a><span class='Delimiter'>, 
</span>                         <span class='Operator'>&</span><a href="predicate.c.html#LN1570"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN97"><span class='Ref_to_Member'>possibleUnsafeConflicts</span></a><span class='Delimiter'>, 
</span>                         <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN194"><span class='Ref_to_Struct'>RWConflictData</span></a><span class='Delimiter'>, </span>inLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN1584"><span class='Ref_To_Local'>possibleUnsafeConflict</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL </span><span class='Operator'>&& </span><a href="predicate.c.html#LN1569"><span class='Ref_To_Local'>num_written</span></a> <span class='Operator'>&LT; </span><a href="predicate.c.html#LN1567"><span class='Ref_to_Parameter'>output_size</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="predicate.c.html#LN1567"><span class='Ref_to_Parameter'>output</span></a><span class='Delimiter'>[</span><a href="predicate.c.html#LN1569"><span class='Ref_To_Local'>num_written</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="predicate.c.html#LN1584"><span class='Ref_To_Local'>possibleUnsafeConflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN198"><span class='Ref_to_Member'>sxactOut</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN106"><span class='Ref_to_Member'>pid</span></a><span class='Delimiter'>; 
</span>            <a href="predicate.c.html#LN1584"><span class='Ref_To_Local'>possibleUnsafeConflict</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a><span class='Parentheses'>) 
</span>                <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN1570"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN97"><span class='Ref_to_Member'>possibleUnsafeConflicts</span></a><span class='Delimiter'>, 
</span>                             <span class='Operator'>&</span><a href="predicate.c.html#LN1584"><span class='Ref_To_Local'>possibleUnsafeConflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN197"><span class='Ref_to_Member'>inLink</span></a><span class='Delimiter'>, 
</span>                             <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN194"><span class='Ref_to_Struct'>RWConflictData</span></a><span class='Delimiter'>, </span>inLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="predicate.c.html#LN1569"><span class='Ref_To_Local'>num_written</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end GetSafeSnapshotBlockingPids &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Acquire a snapshot that can be used for the current transaction. 
 * 
 * Make sure we have a SERIALIZABLEXACT reference in MySerializableXact. 
 * It should be current for this process and be contained in PredXact. 
 * 
 * The passed-in Snapshot pointer should reference a static data area that 
 * can safely be passed to GetSnapshotData.  The return value is actually 
 * always this same pointer; no new snapshot data structure is allocated 
 * within this function. 
 */ 
</span><a href="../../../include/utils/snapshot.h.html#LN22"><span class='Ref_to_Typedef'>Snapshot</span></a> 
<a name="LN1619"></a><span class='Declare_Function'>GetSerializableTransactionSnapshot</span><span class='Parentheses'>(</span><a href="../../../include/utils/snapshot.h.html#LN22"><span class='Ref_to_Typedef'>Snapshot</span></a> <span class='Declare_Parameter'>snapshot</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/xact.h.html#LN43"><span class='Ref_to_Macro'>IsolationIsSerializable</span></a><span class='Parentheses'>())</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Can't use serializable mode while recovery is still active, as it is, 
     * for example, on a hot standby.  We could get here despite the check in 
     * check_XactIsoLevel() if default_transaction_isolation is set to 
     * serializable, so phrase the hint accordingly. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN242"><span class='Ref_to_Proto'>RecoveryInProgress</span></a><span class='Parentheses'>())</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"cannot use serializable mode in a hot standby"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"\"default_transaction_isolation\" is set to \"serializable\"."</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"You can use \"SET default_transaction_isolation = 'repeatable read'\" to change the default."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * A special optimization is available for SERIALIZABLE READ ONLY 
     * DEFERRABLE transactions -- we can wait for a suitable snapshot and 
     * thereby avoid all SSI overhead once it's running. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../access/transam/xact.c.html#LN76"><span class='Ref_to_Global_Var'>XactReadOnly</span></a> <span class='Operator'>&& </span><a href="../../access/transam/xact.c.html#LN79"><span class='Ref_to_Global_Var'>XactDeferrable</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="predicate.c.html#LN434"><span class='Ref_to_Proto'>GetSafeSnapshot</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1619"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="predicate.c.html#LN435"><span class='Ref_to_Proto'>GetSerializableTransactionSnapshotInt</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1619"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Delimiter'>, 
</span>                                                 <a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end GetSerializableTransactionSnapshot &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Import a snapshot to be used for the current transaction. 
 * 
 * This is nearly the same as GetSerializableTransactionSnapshot, except that 
 * we don't take a new snapshot, but rather use the data we're handed. 
 * 
 * The caller must have verified that the snapshot came from a serializable 
 * transaction; and if we're read-write, the source transaction must not be 
 * read-only. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1659"></a><span class='Declare_Function'>SetSerializableTransactionSnapshot</span><span class='Parentheses'>(</span><a href="../../../include/utils/snapshot.h.html#LN22"><span class='Ref_to_Typedef'>Snapshot</span></a> <span class='Declare_Parameter'>snapshot</span><span class='Delimiter'>, 
</span><a name="LN1660"></a>                                   <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>sourcexid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/xact.h.html#LN43"><span class='Ref_to_Macro'>IsolationIsSerializable</span></a><span class='Parentheses'>())</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We do not allow SERIALIZABLE READ ONLY DEFERRABLE transactions to 
     * import snapshots, since there's no way to wait for a safe snapshot when 
     * we're using the snap we're told to.  (XXX instead of throwing an error, 
     * we could just ignore the XactDeferrable flag?) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../access/transam/xact.c.html#LN76"><span class='Ref_to_Global_Var'>XactReadOnly</span></a> <span class='Operator'>&& </span><a href="../../access/transam/xact.c.html#LN79"><span class='Ref_to_Global_Var'>XactDeferrable</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"a snapshot-importing transaction must not be READ ONLY DEFERRABLE"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="predicate.c.html#LN435"><span class='Ref_to_Proto'>GetSerializableTransactionSnapshotInt</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1659"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN1660"><span class='Ref_to_Parameter'>sourcexid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Guts of GetSerializableTransactionSnapshot 
 * 
 * If sourcexid is valid, this is actually an import operation and we should 
 * skip calling GetSnapshotData, because the snapshot contents are already 
 * loaded up.  HOWEVER: to avoid race conditions, we must check that the 
 * source xact is still running after we acquire SerializableXactHashLock. 
 * We do that by calling ProcArrayInstallImportedXmin. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/utils/snapshot.h.html#LN22"><span class='Ref_to_Typedef'>Snapshot</span></a> 
<a name="LN1688"></a><span class='Declare_Function'>GetSerializableTransactionSnapshotInt</span><span class='Parentheses'>(</span><a href="../../../include/utils/snapshot.h.html#LN22"><span class='Ref_to_Typedef'>Snapshot</span></a> <span class='Declare_Parameter'>snapshot</span><span class='Delimiter'>, 
</span><a name="LN1689"></a>                                      <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>sourcexid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1691"></a>    <a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>proc</span><span class='Delimiter'>; 
</span><a name="LN1692"></a>    <a href="../../../include/storage/lock.h.html#LN62"><span class='Ref_to_Typedef'>VirtualTransactionId</span></a> <span class='Declare_Local'>vxid</span><span class='Delimiter'>; 
</span><a name="LN1693"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sxact</span><span class='Delimiter'>, 
</span><a name="LN1694"></a>               <span class='Operator'>*</span><span class='Declare_Local'>othersxact</span><span class='Delimiter'>; 
</span><a name="LN1695"></a>    <a href="../../../include/utils/hsearch.h.html#LN64"><span class='Ref_to_Struct'>HASHCTL</span></a>     <span class='Declare_Local'>hash_ctl</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* We only do this for serializable transactions.  Once. */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a> <span class='Operator'>== </span><a href="../../../include/storage/predicate_internals.h.html#LN468"><span class='Ref_to_Const'>InvalidSerializableXact</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/xlog.h.html#LN242"><span class='Ref_to_Proto'>RecoveryInProgress</span></a><span class='Parentheses'>())</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Since all parts of a serializable transaction must use the same 
     * snapshot, it is too late to establish one after a parallel operation 
     * has begun. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xact.h.html#LN405"><span class='Ref_to_Proto'>IsInParallelMode</span></a><span class='Parentheses'>())</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cannot establish serializable snapshot during a parallel operation"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN1691"><span class='Ref_To_Local'>proc</span></a> <span class='Operator'>= </span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN1691"><span class='Ref_To_Local'>proc</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lock.h.html#LN80"><span class='Ref_to_Macro'>GET_VXID_FROM_PGPROC</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1692"><span class='Ref_To_Local'>vxid</span></a><span class='Delimiter'>, </span><span class='Operator'>*</span><a href="predicate.c.html#LN1691"><span class='Ref_To_Local'>proc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * First we get the sxact structure, which may involve looping and access 
     * to the "finished" list to free a structure for use. 
     * 
     * We must hold SerializableXactHashLock when taking/checking the snapshot 
     * to avoid race conditions, for much the same reasons that 
     * GetSnapshotData takes the ProcArrayLock.  Since we might have to 
     * release SerializableXactHashLock to call SummarizeOldestCommittedSxact, 
     * this means we have to create the sxact first, which is a bit annoying 
     * (in particular, an elog(ERROR) in procarray.c would cause us to leak 
     * the sxact).  Consider refactoring to avoid this. 
     */ 
</span><span class='Directive'>#ifdef</span> TEST_OLDSERXID 
    <a href="predicate.c.html#LN433"><span class='Ref_to_Proto'>SummarizeOldestCommittedSxact</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>do</span> 
    <span class='Delimiter'>{ 
</span>        <a href="predicate.c.html#LN1693"><span class='Ref_To_Local'>sxact</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN415"><span class='Ref_to_Proto'>CreatePredXact</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* If null, push out committed sxact to SLRU summary & retry. */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN1693"><span class='Ref_To_Local'>sxact</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="predicate.c.html#LN433"><span class='Ref_to_Proto'>SummarizeOldestCommittedSxact</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} </span><span class='Control'>while</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN1693"><span class='Ref_To_Local'>sxact</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Get the snapshot, or check that it's safe to use */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1689"><span class='Ref_to_Parameter'>sourcexid</span></a><span class='Parentheses'>))</span> 
        <a href="predicate.c.html#LN1688"><span class='Ref_to_Parameter'>snapshot</span></a> <span class='Operator'>= </span><a href="../../../include/storage/procarray.h.html#LN81"><span class='Ref_to_Proto'>GetSnapshotData</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1688"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/storage/procarray.h.html#LN83"><span class='Ref_to_Proto'>ProcArrayInstallImportedXmin</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1688"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/snapshot.h.html#LN65"><span class='Ref_to_Member'>xmin</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN1689"><span class='Ref_to_Parameter'>sourcexid</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="predicate.c.html#LN416"><span class='Ref_to_Proto'>ReleasePredXact</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1693"><span class='Ref_To_Local'>sxact</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not import the requested snapshot"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>               <a href="../../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"The source transaction %u is not running anymore."</span><span class='Delimiter'>, 
</span>                         <a href="predicate.c.html#LN1689"><span class='Ref_to_Parameter'>sourcexid</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If there are no serializable transactions which are not read-only, we 
     * can "opt out" of predicate locking and conflict checking for a 
     * read-only transaction. 
     * 
     * The reason this is safe is that a read-only transaction can only become 
     * part of a dangerous structure if it overlaps a writable transaction 
     * which in turn overlaps a writable transaction which committed before 
     * the read-only transaction started.  A new writable transaction can 
     * overlap this one, but it can't meet the other condition of overlapping 
     * a transaction which committed before this one started. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../access/transam/xact.c.html#LN76"><span class='Ref_to_Global_Var'>XactReadOnly</span></a> <span class='Operator'>&& </span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN159"><span class='Ref_to_Member'>WritableSxactCount</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="predicate.c.html#LN416"><span class='Ref_to_Proto'>ReleasePredXact</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1693"><span class='Ref_To_Local'>sxact</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <a href="predicate.c.html#LN1688"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Maintain serializable global xmin info. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN155"><span class='Ref_to_Member'>SxactGlobalXmin</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN157"><span class='Ref_to_Member'>SxactGlobalXminCount</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN155"><span class='Ref_to_Member'>SxactGlobalXmin</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN1688"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/snapshot.h.html#LN65"><span class='Ref_to_Member'>xmin</span></a><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN157"><span class='Ref_to_Member'>SxactGlobalXminCount</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN430"><span class='Ref_to_Proto'>OldSerXidSetActiveSerXmin</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1688"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/snapshot.h.html#LN65"><span class='Ref_to_Member'>xmin</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN42"><span class='Ref_to_Macro'>TransactionIdEquals</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1688"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/snapshot.h.html#LN65"><span class='Ref_to_Member'>xmin</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN155"><span class='Ref_to_Member'>SxactGlobalXmin</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN157"><span class='Ref_to_Member'>SxactGlobalXminCount</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN157"><span class='Ref_to_Member'>SxactGlobalXminCount</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN170"><span class='Ref_to_Proto'>TransactionIdFollows</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1688"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/snapshot.h.html#LN65"><span class='Ref_to_Member'>xmin</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN155"><span class='Ref_to_Member'>SxactGlobalXmin</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Initialize the structure. */ 
</span>    <a href="predicate.c.html#LN1693"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN57"><span class='Ref_to_Member'>vxid</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN1692"><span class='Ref_To_Local'>vxid</span></a><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN1693"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN84"><span class='Ref_to_Member'>SeqNo</span></a><span class='Operator'>.</span>lastCommitBeforeSnapshot <span class='Operator'>= </span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN161"><span class='Ref_to_Member'>LastSxactCommitSeqNo</span></a><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN1693"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN74"><span class='Ref_to_Member'>prepareSeqNo</span></a> <span class='Operator'>= </span><a href="../../../include/storage/predicate_internals.h.html#LN35"><span class='Ref_to_Const'>InvalidSerCommitSeqNo</span></a><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN1693"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN75"><span class='Ref_to_Member'>commitSeqNo</span></a> <span class='Operator'>= </span><a href="../../../include/storage/predicate_internals.h.html#LN35"><span class='Ref_to_Const'>InvalidSerCommitSeqNo</span></a><span class='Delimiter'>; 
</span>    <a href="../ipc/shmqueue.c.html#LN34"><span class='Ref_to_Func'>SHMQueueInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN1693"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN85"><span class='Ref_to_Member'>outConflicts</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../ipc/shmqueue.c.html#LN34"><span class='Ref_to_Func'>SHMQueueInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN1693"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN87"><span class='Ref_to_Member'>inConflicts</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../ipc/shmqueue.c.html#LN34"><span class='Ref_to_Func'>SHMQueueInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN1693"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN97"><span class='Ref_to_Member'>possibleUnsafeConflicts</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN1693"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN99"><span class='Ref_to_Member'>topXid</span></a> <span class='Operator'>= </span><a href="../../../include/access/xact.h.html#LN332"><span class='Ref_to_Proto'>GetTopTransactionIdIfAny</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN1693"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN101"><span class='Ref_to_Member'>finishedBefore</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN1693"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN104"><span class='Ref_to_Member'>xmin</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN1688"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/snapshot.h.html#LN65"><span class='Ref_to_Member'>xmin</span></a><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN1693"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN106"><span class='Ref_to_Member'>pid</span></a> <span class='Operator'>= </span><a href="../../utils/init/globals.c.html#LN38"><span class='Ref_to_Global_Var'>MyProcPid</span></a><span class='Delimiter'>; 
</span>    <a href="../ipc/shmqueue.c.html#LN34"><span class='Ref_to_Func'>SHMQueueInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN1693"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN89"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../ipc/shmqueue.c.html#LN55"><span class='Ref_to_Func'>SHMQueueElemInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN1693"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN90"><span class='Ref_to_Member'>finishedLink</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN1693"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN105"><span class='Ref_to_Member'>flags</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../access/transam/xact.c.html#LN76"><span class='Ref_to_Global_Var'>XactReadOnly</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="predicate.c.html#LN1693"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN105"><span class='Ref_to_Member'>flags</span></a> <span class='Operator'>|= </span><a href="../../../include/storage/predicate_internals.h.html#LN119"><span class='Ref_to_Const'>SXACT_FLAG_READ_ONLY</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Register all concurrent r/w transactions as possible conflicts; if 
         * all of them commit without any outgoing conflicts to earlier 
         * transactions then this snapshot can be deemed safe (and we can run 
         * without tracking predicate locks). 
         */ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN1694"><span class='Ref_To_Local'>othersxact</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN417"><span class='Ref_to_Proto'>FirstPredXact</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>             <a href="predicate.c.html#LN1694"><span class='Ref_To_Local'>othersxact</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>             <a href="predicate.c.html#LN1694"><span class='Ref_To_Local'>othersxact</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN418"><span class='Ref_to_Proto'>NextPredXact</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1694"><span class='Ref_To_Local'>othersxact</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN263"><span class='Ref_to_Macro'>SxactIsCommitted</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1694"><span class='Ref_To_Local'>othersxact</span></a><span class='Parentheses'>) 
</span>                <span class='Operator'>&& !</span><a href="predicate.c.html#LN266"><span class='Ref_to_Macro'>SxactIsDoomed</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1694"><span class='Ref_To_Local'>othersxact</span></a><span class='Parentheses'>) 
</span>                <span class='Operator'>&& !</span><a href="predicate.c.html#LN267"><span class='Ref_to_Macro'>SxactIsReadOnly</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1694"><span class='Ref_To_Local'>othersxact</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="predicate.c.html#LN422"><span class='Ref_to_Proto'>SetPossibleUnsafeConflict</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1693"><span class='Ref_To_Local'>sxact</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN1694"><span class='Ref_To_Local'>othersxact</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if XactReadOnly &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Operator'>++</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN159"><span class='Ref_to_Member'>WritableSxactCount</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN159"><span class='Ref_to_Member'>WritableSxactCount</span></a> <span class='Operator'>&LT;= 
</span>               <span class='Parentheses'>(</span><a href="../../utils/init/globals.c.html#LN126"><span class='Ref_to_Global_Var'>MaxBackends</span></a> <span class='Operator'>+ </span><a href="../../access/transam/twophase.c.html#LN116"><span class='Ref_to_Global_Var'>max_prepared_xacts</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN1693"><span class='Ref_To_Local'>sxact</span></a><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN411"><span class='Ref_to_Global_Var'>MyXactDidWrite</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* haven't written anything yet */ 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Initialize the backend-local hash table of parent locks */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN403"><span class='Ref_to_Global_Var'>LocalPredicateLockHash</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN1695"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN1695"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN1695"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Operator'>.</span><a href="../../../include/utils/hsearch.h.html#LN71"><span class='Ref_to_Member'>keysize</span></a> <span class='Operator'>= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN1695"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Operator'>.</span><a href="../../../include/utils/hsearch.h.html#LN72"><span class='Ref_to_Member'>entrysize</span></a> <span class='Operator'>= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN348"><span class='Ref_to_Struct'>LOCALPREDICATELOCK</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN403"><span class='Ref_to_Global_Var'>LocalPredicateLockHash</span></a> <span class='Operator'>= </span><a href="../../../include/utils/hsearch.h.html#LN121"><span class='Ref_to_Proto'>hash_create</span></a><span class='Parentheses'>(</span><span class='String'>"Local predicate lock"</span><span class='Delimiter'>, 
</span>                                         <a href="predicate.c.html#LN360"><span class='Ref_to_Global_Var'>max_predicate_locks_per_xact</span></a><span class='Delimiter'>, 
</span>                                         <span class='Operator'>&</span><a href="predicate.c.html#LN1695"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Delimiter'>, 
</span>                                         <a href="../../../include/utils/hsearch.h.html#LN86"><span class='Ref_to_Const'>HASH_ELEM</span></a> <span class='Operator'>| </span><a href="../../../include/utils/hsearch.h.html#LN87"><span class='Ref_to_Const'>HASH_BLOBS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="predicate.c.html#LN1688"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end GetSerializableTransactionSnapshotInt &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Register the top level XID in SerializableXidHash. 
 * Also store it for easy reference in MySerializableXact. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1860"></a><span class='Declare_Function'>RegisterPredicateLockingXid</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1862"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN223"><span class='Ref_to_Struct'>SERIALIZABLEXIDTAG</span></a> <span class='Declare_Local'>sxidtag</span><span class='Delimiter'>; 
</span><a name="LN1863"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN241"><span class='Ref_to_Struct'>SERIALIZABLEXID</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sxid</span><span class='Delimiter'>; 
</span><a name="LN1864"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we're not tracking predicate lock data for this transaction, we 
     * should ignore the request and return quickly. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a> <span class='Operator'>== </span><a href="../../../include/storage/predicate_internals.h.html#LN468"><span class='Ref_to_Const'>InvalidSerializableXact</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* We should have a valid XID and be at the top level. */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1860"><span class='Ref_to_Parameter'>xid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* This should only be done once per transaction. */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN99"><span class='Ref_to_Member'>topXid</span></a> <span class='Operator'>== </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN99"><span class='Ref_to_Member'>topXid</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN1860"><span class='Ref_to_Parameter'>xid</span></a><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN1862"><span class='Ref_To_Local'>sxidtag</span></a><span class='Operator'>.</span><a href="../../../include/storage/predicate_internals.h.html#LN225"><span class='Ref_to_Member'>xid</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN1860"><span class='Ref_to_Parameter'>xid</span></a><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN1863"><span class='Ref_To_Local'>sxid</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN241"><span class='Ref_to_Struct'>SERIALIZABLEXID</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/utils/hsearch.h.html#LN125"><span class='Ref_to_Proto'>hash_search</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN385"><span class='Ref_to_Global_Var'>SerializableXidHash</span></a><span class='Delimiter'>, 
</span>                                           <span class='Operator'>&</span><a href="predicate.c.html#LN1862"><span class='Ref_To_Local'>sxidtag</span></a><span class='Delimiter'>, 
</span>                                           <a href="../../../include/utils/hsearch.h.html#LN105"><span class='Ref_to_EnumConst'>HASH_ENTER</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predicate.c.html#LN1864"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN1864"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Initialize the structure. */ 
</span>    <a href="predicate.c.html#LN1863"><span class='Ref_To_Local'>sxid</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN247"><span class='Ref_to_Member'>myXact</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end RegisterPredicateLockingXid &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Check whether there are any predicate locks held by any transaction 
 * for the page at the given block number. 
 * 
 * Note that the transaction may be completed but not yet subject to 
 * cleanup due to overlapping serializable transactions.  This must 
 * return valid information regardless of transaction isolation level. 
 * 
 * Also note that this doesn't check for a conflicting relation lock, 
 * just a lock specifically on the given page. 
 * 
 * One use is to support proper behavior during GiST index vacuum. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN1909"></a><span class='Declare_Function'>PageIsPredicateLocked</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>relation</span><span class='Delimiter'>, </span><a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Parameter'>blkno</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1911"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Declare_Local'>targettag</span><span class='Delimiter'>; 
</span><a name="LN1912"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>targettaghash</span><span class='Delimiter'>; 
</span><a name="LN1913"></a>    <a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>partitionLock</span><span class='Delimiter'>; 
</span><a name="LN1914"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN285"><span class='Ref_to_Struct'>PREDICATELOCKTARGET</span></a> <span class='Operator'>*</span><span class='Declare_Local'>target</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/predicate_internals.h.html#LN395"><span class='Ref_to_Macro'>SET_PREDICATELOCKTARGETTAG_PAGE</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1911"><span class='Ref_To_Local'>targettag</span></a><span class='Delimiter'>, 
</span>                                    <a href="predicate.c.html#LN1909"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN84"><span class='Ref_to_Member'>rd_node</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN59"><span class='Ref_to_Member'>dbNode</span></a><span class='Delimiter'>, 
</span>                                    <a href="predicate.c.html#LN1909"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN115"><span class='Ref_to_Member'>rd_id</span></a><span class='Delimiter'>, 
</span>                                    <a href="predicate.c.html#LN1909"><span class='Ref_to_Parameter'>blkno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN1912"><span class='Ref_To_Local'>targettaghash</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN288"><span class='Ref_to_Macro'>PredicateLockTargetTagHashCode</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN1911"><span class='Ref_To_Local'>targettag</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN1913"><span class='Ref_To_Local'>partitionLock</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN244"><span class='Ref_to_Macro'>PredicateLockHashPartitionLock</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1912"><span class='Ref_To_Local'>targettaghash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1913"><span class='Ref_To_Local'>partitionLock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN1914"><span class='Ref_To_Local'>target</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN285"><span class='Ref_to_Struct'>PREDICATELOCKTARGET</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/hsearch.h.html#LN128"><span class='Ref_to_Proto'>hash_search_with_hash_value</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN386"><span class='Ref_to_Global_Var'>PredicateLockTargetHash</span></a><span class='Delimiter'>, 
</span>                                    <span class='Operator'>&</span><a href="predicate.c.html#LN1911"><span class='Ref_To_Local'>targettag</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN1912"><span class='Ref_To_Local'>targettaghash</span></a><span class='Delimiter'>, 
</span>                                    <a href="../../../include/utils/hsearch.h.html#LN104"><span class='Ref_to_EnumConst'>HASH_FIND</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN1913"><span class='Ref_To_Local'>partitionLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN1914"><span class='Ref_To_Local'>target</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end PageIsPredicateLocked &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Check whether a particular lock is held by this transaction. 
 * 
 * Important note: this function may return false even if the lock is 
 * being held, because it uses the local lock table which is not 
 * updated if another transaction modifies our lock list (e.g. to 
 * split an index page). It can also return true when a coarser 
 * granularity lock that covers this target is being held. Be careful 
 * to only use this function in circumstances where such errors are 
 * acceptable! 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN1946"></a><span class='Declare_Function'>PredicateLockExists</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>targettag</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1948"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN348"><span class='Ref_to_Struct'>LOCALPREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Declare_Local'>lock</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* check local hash table */ 
</span>    <a href="predicate.c.html#LN1948"><span class='Ref_To_Local'>lock</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN348"><span class='Ref_to_Struct'>LOCALPREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/utils/hsearch.h.html#LN125"><span class='Ref_to_Proto'>hash_search</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN403"><span class='Ref_to_Global_Var'>LocalPredicateLockHash</span></a><span class='Delimiter'>, 
</span>                                              <a href="predicate.c.html#LN1946"><span class='Ref_to_Parameter'>targettag</span></a><span class='Delimiter'>, 
</span>                                              <a href="../../../include/utils/hsearch.h.html#LN104"><span class='Ref_to_EnumConst'>HASH_FIND</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN1948"><span class='Ref_To_Local'>lock</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Found entry in the table, but still need to check whether it's actually 
     * held -- it could just be a parent of some held lock. 
     */ 
</span>    <span class='Control'>return</span> <a href="predicate.c.html#LN1948"><span class='Ref_To_Local'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN354"><span class='Ref_to_Member'>held</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Return the parent lock tag in the lock hierarchy: the next coarser 
 * lock that covers the provided tag. 
 * 
 * Returns true and sets *parent to the parent tag if one exists, 
 * returns false if none exists. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN1973"></a><span class='Declare_Function'>GetParentPredicateLockTag</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tag</span><span class='Delimiter'>, 
</span><a name="LN1974"></a>                          <a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>parent</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN415"><span class='Ref_to_Macro'>GET_PREDICATELOCKTARGETTAG_TYPE</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="predicate.c.html#LN1973"><span class='Ref_to_Parameter'>tag</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../../include/storage/predicate_internals.h.html#LN364"><span class='Ref_to_EnumConst'>PREDLOCKTAG_RELATION</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* relation locks have no parent lock */ 
</span>            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="../../../include/storage/predicate_internals.h.html#LN365"><span class='Ref_to_EnumConst'>PREDLOCKTAG_PAGE</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* parent lock is relation lock */ 
</span>            <a href="../../../include/storage/predicate_internals.h.html#LN389"><span class='Ref_to_Macro'>SET_PREDICATELOCKTARGETTAG_RELATION</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="predicate.c.html#LN1974"><span class='Ref_to_Parameter'>parent</span></a><span class='Delimiter'>, 
</span>                                         <a href="../../../include/storage/predicate_internals.h.html#LN407"><span class='Ref_to_Macro'>GET_PREDICATELOCKTARGETTAG_DB</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="predicate.c.html#LN1973"><span class='Ref_to_Parameter'>tag</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                  <a href="../../../include/storage/predicate_internals.h.html#LN409"><span class='Ref_to_Macro'>GET_PREDICATELOCKTARGETTAG_RELATION</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="predicate.c.html#LN1973"><span class='Ref_to_Parameter'>tag</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="../../../include/storage/predicate_internals.h.html#LN366"><span class='Ref_to_EnumConst'>PREDLOCKTAG_TUPLE</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* parent lock is page lock */ 
</span>            <a href="../../../include/storage/predicate_internals.h.html#LN395"><span class='Ref_to_Macro'>SET_PREDICATELOCKTARGETTAG_PAGE</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="predicate.c.html#LN1974"><span class='Ref_to_Parameter'>parent</span></a><span class='Delimiter'>, 
</span>                                         <a href="../../../include/storage/predicate_internals.h.html#LN407"><span class='Ref_to_Macro'>GET_PREDICATELOCKTARGETTAG_DB</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="predicate.c.html#LN1973"><span class='Ref_to_Parameter'>tag</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                   <a href="../../../include/storage/predicate_internals.h.html#LN409"><span class='Ref_to_Macro'>GET_PREDICATELOCKTARGETTAG_RELATION</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="predicate.c.html#LN1973"><span class='Ref_to_Parameter'>tag</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                      <a href="../../../include/storage/predicate_internals.h.html#LN411"><span class='Ref_to_Macro'>GET_PREDICATELOCKTARGETTAG_PAGE</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="predicate.c.html#LN1973"><span class='Ref_to_Parameter'>tag</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch GET_PREDICATELOCKTARG... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* not reachable */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end GetParentPredicateLockTag &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Check whether the lock we are considering is already covered by a 
 * coarser lock for our transaction. 
 * 
 * Like PredicateLockExists, this function might return a false 
 * negative, but it will never return a false positive. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN2012"></a><span class='Declare_Function'>CoarserLockCovers</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>newtargettag</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2014"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Declare_Local'>targettag</span><span class='Delimiter'>, 
</span><a name="LN2015"></a>                <span class='Declare_Local'>parenttag</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN2014"><span class='Ref_To_Local'>targettag</span></a> <span class='Operator'>= *</span><a href="predicate.c.html#LN2012"><span class='Ref_to_Parameter'>newtargettag</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* check parents iteratively until no more */ 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN438"><span class='Ref_to_Proto'>GetParentPredicateLockTag</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN2014"><span class='Ref_To_Local'>targettag</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predicate.c.html#LN2015"><span class='Ref_To_Local'>parenttag</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="predicate.c.html#LN2014"><span class='Ref_To_Local'>targettag</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN2015"><span class='Ref_To_Local'>parenttag</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN437"><span class='Ref_to_Proto'>PredicateLockExists</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN2014"><span class='Ref_To_Local'>targettag</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* no more parents to check; lock is not covered */ 
</span>    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Remove the dummy entry from the predicate lock target hash, to free up some 
 * scratch space. The caller must be holding SerializablePredicateLockListLock, 
 * and must restore the entry with RestoreScratchTarget() before releasing the 
 * lock. 
 * 
 * If lockheld is true, the caller is already holding the partition lock 
 * of the partition containing the scratch entry. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2041"></a><span class='Declare_Function'>RemoveScratchTarget</span><span class='Parentheses'>(</span><span class='Keyword'>bool </span><span class='Declare_Parameter'>lockheld</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2043"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN151"><span class='Ref_to_Proto'>LWLockHeldByMe</span></a><span class='Parentheses'>(</span>SerializablePredicateLockListLock<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN2041"><span class='Ref_to_Parameter'>lockheld</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN397"><span class='Ref_to_Global_Var'>ScratchPartitionLock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/utils/hsearch.h.html#LN128"><span class='Ref_to_Proto'>hash_search_with_hash_value</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN386"><span class='Ref_to_Global_Var'>PredicateLockTargetHash</span></a><span class='Delimiter'>, 
</span>                                <span class='Operator'>&</span><a href="predicate.c.html#LN395"><span class='Ref_to_Global_Var'>ScratchTargetTag</span></a><span class='Delimiter'>, 
</span>                                <a href="predicate.c.html#LN396"><span class='Ref_to_Global_Var'>ScratchTargetTagHash</span></a><span class='Delimiter'>, 
</span>                                <a href="../../../include/utils/hsearch.h.html#LN106"><span class='Ref_to_EnumConst'>HASH_REMOVE</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predicate.c.html#LN2043"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2043"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN2041"><span class='Ref_to_Parameter'>lockheld</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN397"><span class='Ref_to_Global_Var'>ScratchPartitionLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Re-insert the dummy entry in predicate lock target hash. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2062"></a><span class='Declare_Function'>RestoreScratchTarget</span><span class='Parentheses'>(</span><span class='Keyword'>bool </span><span class='Declare_Parameter'>lockheld</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2064"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN151"><span class='Ref_to_Proto'>LWLockHeldByMe</span></a><span class='Parentheses'>(</span>SerializablePredicateLockListLock<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN2062"><span class='Ref_to_Parameter'>lockheld</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN397"><span class='Ref_to_Global_Var'>ScratchPartitionLock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/utils/hsearch.h.html#LN128"><span class='Ref_to_Proto'>hash_search_with_hash_value</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN386"><span class='Ref_to_Global_Var'>PredicateLockTargetHash</span></a><span class='Delimiter'>, 
</span>                                <span class='Operator'>&</span><a href="predicate.c.html#LN395"><span class='Ref_to_Global_Var'>ScratchTargetTag</span></a><span class='Delimiter'>, 
</span>                                <a href="predicate.c.html#LN396"><span class='Ref_to_Global_Var'>ScratchTargetTagHash</span></a><span class='Delimiter'>, 
</span>                                <a href="../../../include/utils/hsearch.h.html#LN105"><span class='Ref_to_EnumConst'>HASH_ENTER</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predicate.c.html#LN2064"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN2064"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN2062"><span class='Ref_to_Parameter'>lockheld</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN397"><span class='Ref_to_Global_Var'>ScratchPartitionLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Check whether the list of related predicate locks is empty for a 
 * predicate lock target, and remove the target if it is. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2084"></a><span class='Declare_Function'>RemoveTargetIfNoLongerUsed</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN285"><span class='Ref_to_Struct'>PREDICATELOCKTARGET</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>target</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Parameter'>targettaghash</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2086"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN285"><span class='Ref_to_Struct'>PREDICATELOCKTARGET</span></a> <span class='Operator'>*</span>rmtarget <span class='Declare_Local'>PG_USED_FOR_ASSERTS_ONLY</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN151"><span class='Ref_to_Proto'>LWLockHeldByMe</span></a><span class='Parentheses'>(</span>SerializablePredicateLockListLock<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Can't remove it until no locks at this target. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/storage/shmem.h.html#LN76"><span class='Ref_to_Proto'>SHMQueueEmpty</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN2084"><span class='Ref_to_Parameter'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN291"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Actually remove the target. */ 
</span>    rmtarget <span class='Operator'>= </span><a href="../../../include/utils/hsearch.h.html#LN128"><span class='Ref_to_Proto'>hash_search_with_hash_value</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN386"><span class='Ref_to_Global_Var'>PredicateLockTargetHash</span></a><span class='Delimiter'>, 
</span>                                           <span class='Operator'>&</span><a href="predicate.c.html#LN2084"><span class='Ref_to_Parameter'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN288"><span class='Ref_to_Member'>tag</span></a><span class='Delimiter'>, 
</span>                                           <a href="predicate.c.html#LN2084"><span class='Ref_to_Parameter'>targettaghash</span></a><span class='Delimiter'>, 
</span>                                           <a href="../../../include/utils/hsearch.h.html#LN106"><span class='Ref_to_EnumConst'>HASH_REMOVE</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span>rmtarget <span class='Operator'>== </span><a href="predicate.c.html#LN2084"><span class='Ref_to_Parameter'>target</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Delete child target locks owned by this process. 
 * This implementation is assuming that the usage of each target tag field 
 * is uniform.  No need to make this hard if we don't have to. 
 * 
 * We aren't acquiring lightweight locks for the predicate lock or lock 
 * target structures associated with this transaction unless we're going 
 * to modify them, because no other process is permitted to modify our 
 * locks. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2113"></a><span class='Declare_Function'>DeleteChildTargetLocks</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>newtargettag</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2115"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sxact</span><span class='Delimiter'>; 
</span><a name="LN2116"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Declare_Local'>predlock</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SerializablePredicateLockListLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN2115"><span class='Ref_To_Local'>sxact</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN2116"><span class='Ref_To_Local'>predlock</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2115"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN89"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2115"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN89"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a><span class='Delimiter'>, </span>xactLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN2116"><span class='Ref_To_Local'>predlock</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2126"></a>        <a href="../../../include/storage/shmem.h.html#LN27"><span class='Ref_to_Struct'>SHM_QUEUE</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>predlocksxactlink</span><span class='Delimiter'>; 
</span><a name="LN2127"></a>        <a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Declare_Local'>nextpredlock</span><span class='Delimiter'>; 
</span><a name="LN2128"></a>        <a href="../../../include/storage/predicate_internals.h.html#LN303"><span class='Ref_to_Struct'>PREDICATELOCKTAG</span></a> <span class='Declare_Local'>oldlocktag</span><span class='Delimiter'>; 
</span><a name="LN2129"></a>        <a href="../../../include/storage/predicate_internals.h.html#LN285"><span class='Ref_to_Struct'>PREDICATELOCKTARGET</span></a> <span class='Operator'>*</span><span class='Declare_Local'>oldtarget</span><span class='Delimiter'>; 
</span><a name="LN2130"></a>        <a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Declare_Local'>oldtargettag</span><span class='Delimiter'>; 
</span> 
        <a href="predicate.c.html#LN2126"><span class='Ref_To_Local'>predlocksxactlink</span></a> <span class='Operator'>= &</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2116"><span class='Ref_To_Local'>predlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN326"><span class='Ref_to_Member'>xactLink</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN2127"><span class='Ref_To_Local'>nextpredlock</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2115"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN89"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="predicate.c.html#LN2126"><span class='Ref_To_Local'>predlocksxactlink</span></a><span class='Delimiter'>, 
</span>                         <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a><span class='Delimiter'>, </span>xactLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <a href="predicate.c.html#LN2128"><span class='Ref_To_Local'>oldlocktag</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN2116"><span class='Ref_To_Local'>predlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN321"><span class='Ref_to_Member'>tag</span></a><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2128"><span class='Ref_To_Local'>oldlocktag</span></a><span class='Operator'>.</span><a href="../../../include/storage/predicate_internals.h.html#LN306"><span class='Ref_to_Member'>myXact</span></a> <span class='Operator'>== </span><a href="predicate.c.html#LN2115"><span class='Ref_To_Local'>sxact</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN2129"><span class='Ref_To_Local'>oldtarget</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN2128"><span class='Ref_To_Local'>oldlocktag</span></a><span class='Operator'>.</span><a href="../../../include/storage/predicate_internals.h.html#LN305"><span class='Ref_to_Member'>myTarget</span></a><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN2130"><span class='Ref_To_Local'>oldtargettag</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN2129"><span class='Ref_To_Local'>oldtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN288"><span class='Ref_to_Member'>tag</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN219"><span class='Ref_to_Macro'>TargetTagIsCoveredBy</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2130"><span class='Ref_To_Local'>oldtargettag</span></a><span class='Delimiter'>, </span><span class='Operator'>*</span><a href="predicate.c.html#LN2113"><span class='Ref_to_Parameter'>newtargettag</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN2145"></a>            <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>oldtargettaghash</span><span class='Delimiter'>; 
</span><a name="LN2146"></a>            <a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>partitionLock</span><span class='Delimiter'>; 
</span><a name="LN2147"></a>            <a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span>rmpredlock <span class='Declare_Local'>PG_USED_FOR_ASSERTS_ONLY</span><span class='Delimiter'>; 
</span> 
            <a href="predicate.c.html#LN2145"><span class='Ref_To_Local'>oldtargettaghash</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN288"><span class='Ref_to_Macro'>PredicateLockTargetTagHashCode</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN2130"><span class='Ref_To_Local'>oldtargettag</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="predicate.c.html#LN2146"><span class='Ref_To_Local'>partitionLock</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN244"><span class='Ref_to_Macro'>PredicateLockHashPartitionLock</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2145"><span class='Ref_To_Local'>oldtargettaghash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2146"><span class='Ref_To_Local'>partitionLock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../ipc/shmqueue.c.html#LN66"><span class='Ref_to_Func'>SHMQueueDelete</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2126"><span class='Ref_To_Local'>predlocksxactlink</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../ipc/shmqueue.c.html#LN66"><span class='Ref_to_Func'>SHMQueueDelete</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2116"><span class='Ref_To_Local'>predlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN324"><span class='Ref_to_Member'>targetLink</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            rmpredlock <span class='Operator'>= </span><a href="../../../include/utils/hsearch.h.html#LN128"><span class='Ref_to_Proto'>hash_search_with_hash_value</span></a> 
                <span class='Parentheses'>(</span><a href="predicate.c.html#LN387"><span class='Ref_to_Global_Var'>PredicateLockHash</span></a><span class='Delimiter'>, 
</span>                 <span class='Operator'>&</span><a href="predicate.c.html#LN2128"><span class='Ref_To_Local'>oldlocktag</span></a><span class='Delimiter'>, 
</span>                 <a href="predicate.c.html#LN301"><span class='Ref_to_Macro'>PredicateLockHashCodeFromTargetHashCode</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN2128"><span class='Ref_To_Local'>oldlocktag</span></a><span class='Delimiter'>, 
</span>                                                         <a href="predicate.c.html#LN2145"><span class='Ref_To_Local'>oldtargettaghash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../../include/utils/hsearch.h.html#LN106"><span class='Ref_to_EnumConst'>HASH_REMOVE</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span>rmpredlock <span class='Operator'>== </span><a href="predicate.c.html#LN2116"><span class='Ref_To_Local'>predlock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="predicate.c.html#LN443"><span class='Ref_to_Proto'>RemoveTargetIfNoLongerUsed</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2129"><span class='Ref_To_Local'>oldtarget</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN2145"><span class='Ref_To_Local'>oldtargettaghash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2146"><span class='Ref_To_Local'>partitionLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="predicate.c.html#LN448"><span class='Ref_to_Proto'>DecrementParentLocks</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN2130"><span class='Ref_To_Local'>oldtargettag</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if TargetTagIsCoveredBy(... &raquo; </span> 
 
        <a href="predicate.c.html#LN2116"><span class='Ref_To_Local'>predlock</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN2127"><span class='Ref_To_Local'>nextpredlock</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while predlock &raquo; </span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializablePredicateLockListLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end DeleteChildTargetLocks &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Returns the promotion limit for a given predicate lock target.  This is the 
 * max number of descendant locks allowed before promoting to the specified 
 * tag. Note that the limit includes non-direct descendants (e.g., both tuples 
 * and pages for a relation lock). 
 * 
 * Currently the default limit is 2 for a page lock, and half of the value of 
 * max_pred_locks_per_transaction - 1 for a relation lock, to match behavior 
 * of earlier releases when upgrading. 
 * 
 * TODO SSI: We should probably add additional GUCs to allow a maximum ratio 
 * of page and tuple locks based on the pages in a relation, and the maximum 
 * ratio of tuple locks to tuples in a page.  This would provide more 
 * generally "balanced" allocation of locks to where they are most useful, 
 * while still allowing the absolute numbers to prevent one relation from 
 * tying up all predicate lock resources. 
 */ 
</span><span class='Keyword'>static int 
</span><a name="LN2194"></a><span class='Declare_Function'>MaxPredicateChildLocks</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tag</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN415"><span class='Ref_to_Macro'>GET_PREDICATELOCKTARGETTAG_TYPE</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="predicate.c.html#LN2194"><span class='Ref_to_Parameter'>tag</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../../include/storage/predicate_internals.h.html#LN364"><span class='Ref_to_EnumConst'>PREDLOCKTAG_RELATION</span></a><span class='Operator'>: 
</span>            <span class='Control'>return</span> <a href="predicate.c.html#LN361"><span class='Ref_to_Global_Var'>max_predicate_locks_per_relation</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span> 
                <span class='Operator'>? </span><span class='Parentheses'>(</span><a href="predicate.c.html#LN360"><span class='Ref_to_Global_Var'>max_predicate_locks_per_xact</span></a> 
                   <span class='Operator'>/ </span><span class='Parentheses'>(</span><span class='Operator'>-</span><a href="predicate.c.html#LN361"><span class='Ref_to_Global_Var'>max_predicate_locks_per_relation</span></a><span class='Parentheses'>))</span> <span class='Operator'>- </span><span class='Number'>1</span> 
                <span class='Operator'>: </span><a href="predicate.c.html#LN361"><span class='Ref_to_Global_Var'>max_predicate_locks_per_relation</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="../../../include/storage/predicate_internals.h.html#LN365"><span class='Ref_to_EnumConst'>PREDLOCKTAG_PAGE</span></a><span class='Operator'>: 
</span>            <span class='Control'>return</span> <a href="predicate.c.html#LN362"><span class='Ref_to_Global_Var'>max_predicate_locks_per_page</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="../../../include/storage/predicate_internals.h.html#LN366"><span class='Ref_to_EnumConst'>PREDLOCKTAG_TUPLE</span></a><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * not reachable: nothing is finer-granularity than a tuple, so we 
             * should never try to promote to it. 
             */ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch GET_PREDICATELOCKTARG... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* not reachable */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Number'>0</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end MaxPredicateChildLocks &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * For all ancestors of a newly-acquired predicate lock, increment 
 * their child count in the parent hash table. If any of them have 
 * more descendants than their promotion threshold, acquire the 
 * coarsest such lock. 
 * 
 * Returns true if a parent lock was acquired and false otherwise. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN2231"></a><span class='Declare_Function'>CheckAndPromotePredicateLockRequest</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>reqtag</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2233"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Declare_Local'>targettag</span><span class='Delimiter'>, 
</span><a name="LN2234"></a>                <span class='Declare_Local'>nexttag</span><span class='Delimiter'>, 
</span><a name="LN2235"></a>                <span class='Declare_Local'>promotiontag</span><span class='Delimiter'>; 
</span><a name="LN2236"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN348"><span class='Ref_to_Struct'>LOCALPREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Declare_Local'>parentlock</span><span class='Delimiter'>; 
</span><a name="LN2237"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span><span class='Delimiter'>, 
</span><a name="LN2238"></a>                <span class='Declare_Local'>promote</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN2238"><span class='Ref_To_Local'>promote</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN2233"><span class='Ref_To_Local'>targettag</span></a> <span class='Operator'>= *</span><a href="predicate.c.html#LN2231"><span class='Ref_to_Parameter'>reqtag</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* check parents iteratively */ 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN438"><span class='Ref_to_Proto'>GetParentPredicateLockTag</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN2233"><span class='Ref_To_Local'>targettag</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predicate.c.html#LN2234"><span class='Ref_To_Local'>nexttag</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="predicate.c.html#LN2233"><span class='Ref_To_Local'>targettag</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN2234"><span class='Ref_To_Local'>nexttag</span></a><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN2236"><span class='Ref_To_Local'>parentlock</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN348"><span class='Ref_to_Struct'>LOCALPREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/utils/hsearch.h.html#LN125"><span class='Ref_to_Proto'>hash_search</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN403"><span class='Ref_to_Global_Var'>LocalPredicateLockHash</span></a><span class='Delimiter'>, 
</span>                                                        <span class='Operator'>&</span><a href="predicate.c.html#LN2233"><span class='Ref_To_Local'>targettag</span></a><span class='Delimiter'>, 
</span>                                                        <a href="../../../include/utils/hsearch.h.html#LN105"><span class='Ref_to_EnumConst'>HASH_ENTER</span></a><span class='Delimiter'>, 
</span>                                                        <span class='Operator'>&</span><a href="predicate.c.html#LN2237"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN2237"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="predicate.c.html#LN2236"><span class='Ref_To_Local'>parentlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN354"><span class='Ref_to_Member'>held</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="predicate.c.html#LN2236"><span class='Ref_To_Local'>parentlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN355"><span class='Ref_to_Member'>childLocks</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <a href="predicate.c.html#LN2236"><span class='Ref_To_Local'>parentlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN355"><span class='Ref_to_Member'>childLocks</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN2236"><span class='Ref_To_Local'>parentlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN355"><span class='Ref_to_Member'>childLocks</span></a> <span class='Operator'>&GT; 
</span>            <a href="predicate.c.html#LN446"><span class='Ref_to_Proto'>MaxPredicateChildLocks</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN2233"><span class='Ref_To_Local'>targettag</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * We should promote to this parent lock. Continue to check its 
             * ancestors, however, both to get their child counts right and to 
             * check whether we should just go ahead and promote to one of 
             * them. 
             */ 
</span>            <a href="predicate.c.html#LN2235"><span class='Ref_To_Local'>promotiontag</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN2233"><span class='Ref_To_Local'>targettag</span></a><span class='Delimiter'>; 
</span>            <a href="predicate.c.html#LN2238"><span class='Ref_To_Local'>promote</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while GetParentPredicateLoc... &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN2238"><span class='Ref_To_Local'>promote</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* acquire coarsest ancestor eligible for promotion */ 
</span>        <a href="predicate.c.html#LN456"><span class='Ref_to_Proto'>PredicateLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN2235"><span class='Ref_To_Local'>promotiontag</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end CheckAndPromotePredicateLockRequest &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * When releasing a lock, decrement the child count on all ancestor 
 * locks. 
 * 
 * This is called only when releasing a lock via 
 * DeleteChildTargetLocks (i.e. when a lock becomes redundant because 
 * we've acquired its parent, possibly due to promotion) or when a new 
 * MVCC write lock makes the predicate lock unnecessary. There's no 
 * point in calling it when locks are released at transaction end, as 
 * this information is no longer needed. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2296"></a><span class='Declare_Function'>DecrementParentLocks</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>targettag</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2298"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Declare_Local'>parenttag</span><span class='Delimiter'>, 
</span><a name="LN2299"></a>                <span class='Declare_Local'>nexttag</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN2298"><span class='Ref_To_Local'>parenttag</span></a> <span class='Operator'>= *</span><a href="predicate.c.html#LN2296"><span class='Ref_to_Parameter'>targettag</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN438"><span class='Ref_to_Proto'>GetParentPredicateLockTag</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN2298"><span class='Ref_To_Local'>parenttag</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predicate.c.html#LN2299"><span class='Ref_To_Local'>nexttag</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN2305"></a>        <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>targettaghash</span><span class='Delimiter'>; 
</span><a name="LN2306"></a>        <a href="../../../include/storage/predicate_internals.h.html#LN348"><span class='Ref_to_Struct'>LOCALPREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Declare_Local'>parentlock</span><span class='Delimiter'>, 
</span><a name="LN2307"></a>                   <span class='Operator'>*</span>rmlock <span class='Declare_Local'>PG_USED_FOR_ASSERTS_ONLY</span><span class='Delimiter'>; 
</span> 
        <a href="predicate.c.html#LN2298"><span class='Ref_To_Local'>parenttag</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN2299"><span class='Ref_To_Local'>nexttag</span></a><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN2305"><span class='Ref_To_Local'>targettaghash</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN288"><span class='Ref_to_Macro'>PredicateLockTargetTagHashCode</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN2298"><span class='Ref_To_Local'>parenttag</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN2306"><span class='Ref_To_Local'>parentlock</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN348"><span class='Ref_to_Struct'>LOCALPREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../../include/utils/hsearch.h.html#LN128"><span class='Ref_to_Proto'>hash_search_with_hash_value</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN403"><span class='Ref_to_Global_Var'>LocalPredicateLockHash</span></a><span class='Delimiter'>, 
</span>                                        <span class='Operator'>&</span><a href="predicate.c.html#LN2298"><span class='Ref_To_Local'>parenttag</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN2305"><span class='Ref_To_Local'>targettaghash</span></a><span class='Delimiter'>, 
</span>                                        <a href="../../../include/utils/hsearch.h.html#LN104"><span class='Ref_to_EnumConst'>HASH_FIND</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * There's a small chance the parent lock doesn't exist in the lock 
         * table. This can happen if we prematurely removed it because an 
         * index split caused the child refcount to be off. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN2306"><span class='Ref_To_Local'>parentlock</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <a href="predicate.c.html#LN2306"><span class='Ref_To_Local'>parentlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN355"><span class='Ref_to_Member'>childLocks</span></a><span class='Operator'>--</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Under similar circumstances the parent lock's refcount might be 
         * zero. This only happens if we're holding that lock (otherwise we 
         * would have removed the entry). 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN2306"><span class='Ref_To_Local'>parentlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN355"><span class='Ref_to_Member'>childLocks</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2306"><span class='Ref_To_Local'>parentlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN354"><span class='Ref_to_Member'>held</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="predicate.c.html#LN2306"><span class='Ref_To_Local'>parentlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN355"><span class='Ref_to_Member'>childLocks</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="predicate.c.html#LN2306"><span class='Ref_To_Local'>parentlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN355"><span class='Ref_to_Member'>childLocks</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) </span><span class='Operator'>&& </span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN2306"><span class='Ref_To_Local'>parentlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN354"><span class='Ref_to_Member'>held</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            rmlock <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN348"><span class='Ref_to_Struct'>LOCALPREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                <a href="../../../include/utils/hsearch.h.html#LN128"><span class='Ref_to_Proto'>hash_search_with_hash_value</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN403"><span class='Ref_to_Global_Var'>LocalPredicateLockHash</span></a><span class='Delimiter'>, 
</span>                                            <span class='Operator'>&</span><a href="predicate.c.html#LN2298"><span class='Ref_To_Local'>parenttag</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN2305"><span class='Ref_To_Local'>targettaghash</span></a><span class='Delimiter'>, 
</span>                                            <a href="../../../include/utils/hsearch.h.html#LN106"><span class='Ref_to_EnumConst'>HASH_REMOVE</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span>rmlock <span class='Operator'>== </span><a href="predicate.c.html#LN2306"><span class='Ref_To_Local'>parentlock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while GetParentPredicateLoc... &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end DecrementParentLocks &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Indicate that a predicate lock on the given target is held by the 
 * specified transaction. Has no effect if the lock is already held. 
 * 
 * This updates the lock table and the sxact's lock list, and creates 
 * the lock target if necessary, but does *not* do anything related to 
 * granularity promotion or the local lock table. See 
 * PredicateLockAcquire for that. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2358"></a><span class='Declare_Function'>CreatePredicateLock</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>targettag</span><span class='Delimiter'>, 
</span><a name="LN2359"></a>                    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Parameter'>targettaghash</span><span class='Delimiter'>, 
</span><a name="LN2360"></a>                    <a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sxact</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2362"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN285"><span class='Ref_to_Struct'>PREDICATELOCKTARGET</span></a> <span class='Operator'>*</span><span class='Declare_Local'>target</span><span class='Delimiter'>; 
</span><a name="LN2363"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN303"><span class='Ref_to_Struct'>PREDICATELOCKTAG</span></a> <span class='Declare_Local'>locktag</span><span class='Delimiter'>; 
</span><a name="LN2364"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Declare_Local'>lock</span><span class='Delimiter'>; 
</span><a name="LN2365"></a>    <a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>partitionLock</span><span class='Delimiter'>; 
</span><a name="LN2366"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN2365"><span class='Ref_To_Local'>partitionLock</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN244"><span class='Ref_to_Macro'>PredicateLockHashPartitionLock</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2359"><span class='Ref_to_Parameter'>targettaghash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SerializablePredicateLockListLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2365"><span class='Ref_To_Local'>partitionLock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Make sure that the target is represented. */ 
</span>    <a href="predicate.c.html#LN2362"><span class='Ref_To_Local'>target</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN285"><span class='Ref_to_Struct'>PREDICATELOCKTARGET</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/hsearch.h.html#LN128"><span class='Ref_to_Proto'>hash_search_with_hash_value</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN386"><span class='Ref_to_Global_Var'>PredicateLockTargetHash</span></a><span class='Delimiter'>, 
</span>                                    <a href="predicate.c.html#LN2358"><span class='Ref_to_Parameter'>targettag</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN2359"><span class='Ref_to_Parameter'>targettaghash</span></a><span class='Delimiter'>, 
</span>                                    <a href="../../../include/utils/hsearch.h.html#LN107"><span class='Ref_to_EnumConst'>HASH_ENTER_NULL</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predicate.c.html#LN2366"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN2362"><span class='Ref_To_Local'>target</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OUT_OF_MEMORY<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"out of shared memory"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"You might need to increase max_pred_locks_per_transaction."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN2366"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>        <a href="../ipc/shmqueue.c.html#LN34"><span class='Ref_to_Func'>SHMQueueInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2362"><span class='Ref_To_Local'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN291"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* We've got the sxact and target, make sure they're joined. */ 
</span>    <a href="predicate.c.html#LN2363"><span class='Ref_To_Local'>locktag</span></a><span class='Operator'>.</span><a href="../../../include/storage/predicate_internals.h.html#LN305"><span class='Ref_to_Member'>myTarget</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN2362"><span class='Ref_To_Local'>target</span></a><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN2363"><span class='Ref_To_Local'>locktag</span></a><span class='Operator'>.</span><a href="../../../include/storage/predicate_internals.h.html#LN306"><span class='Ref_to_Member'>myXact</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN2360"><span class='Ref_to_Parameter'>sxact</span></a><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN2364"><span class='Ref_To_Local'>lock</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/hsearch.h.html#LN128"><span class='Ref_to_Proto'>hash_search_with_hash_value</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN387"><span class='Ref_to_Global_Var'>PredicateLockHash</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predicate.c.html#LN2363"><span class='Ref_To_Local'>locktag</span></a><span class='Delimiter'>, 
</span>            <a href="predicate.c.html#LN301"><span class='Ref_to_Macro'>PredicateLockHashCodeFromTargetHashCode</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN2363"><span class='Ref_To_Local'>locktag</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN2359"><span class='Ref_to_Parameter'>targettaghash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                    <a href="../../../include/utils/hsearch.h.html#LN107"><span class='Ref_to_EnumConst'>HASH_ENTER_NULL</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predicate.c.html#LN2366"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN2364"><span class='Ref_To_Local'>lock</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OUT_OF_MEMORY<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"out of shared memory"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"You might need to increase max_pred_locks_per_transaction."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN2366"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/storage/shmem.h.html#LN70"><span class='Ref_to_Proto'>SHMQueueInsertBefore</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2362"><span class='Ref_To_Local'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN291"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2364"><span class='Ref_To_Local'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN324"><span class='Ref_to_Member'>targetLink</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/shmem.h.html#LN70"><span class='Ref_to_Proto'>SHMQueueInsertBefore</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2360"><span class='Ref_to_Parameter'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN89"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2364"><span class='Ref_To_Local'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN326"><span class='Ref_to_Member'>xactLink</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN2364"><span class='Ref_To_Local'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN328"><span class='Ref_to_Member'>commitSeqNo</span></a> <span class='Operator'>= </span><a href="../../../include/storage/predicate_internals.h.html#LN35"><span class='Ref_to_Const'>InvalidSerCommitSeqNo</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2365"><span class='Ref_To_Local'>partitionLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializablePredicateLockListLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end CreatePredicateLock &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Acquire a predicate lock on the specified target for the current 
 * connection if not already held. This updates the local lock table 
 * and uses it to implement granularity promotion. It will consolidate 
 * multiple locks into a coarser lock if warranted, and will release 
 * any finer-grained locks covered by the new one. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2419"></a><span class='Declare_Function'>PredicateLockAcquire</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>targettag</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2421"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>targettaghash</span><span class='Delimiter'>; 
</span><a name="LN2422"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span><span class='Delimiter'>; 
</span><a name="LN2423"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN348"><span class='Ref_to_Struct'>LOCALPREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Declare_Local'>locallock</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Do we have the lock already, or a covering lock? */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN437"><span class='Ref_to_Proto'>PredicateLockExists</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2419"><span class='Ref_to_Parameter'>targettag</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN440"><span class='Ref_to_Proto'>CoarserLockCovers</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2419"><span class='Ref_to_Parameter'>targettag</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* the same hash and LW lock apply to the lock target and the local lock. */ 
</span>    <a href="predicate.c.html#LN2421"><span class='Ref_To_Local'>targettaghash</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN288"><span class='Ref_to_Macro'>PredicateLockTargetTagHashCode</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2419"><span class='Ref_to_Parameter'>targettag</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Acquire lock in local table */ 
</span>    <a href="predicate.c.html#LN2423"><span class='Ref_To_Local'>locallock</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN348"><span class='Ref_to_Struct'>LOCALPREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/hsearch.h.html#LN128"><span class='Ref_to_Proto'>hash_search_with_hash_value</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN403"><span class='Ref_to_Global_Var'>LocalPredicateLockHash</span></a><span class='Delimiter'>, 
</span>                                    <a href="predicate.c.html#LN2419"><span class='Ref_to_Parameter'>targettag</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN2421"><span class='Ref_To_Local'>targettaghash</span></a><span class='Delimiter'>, 
</span>                                    <a href="../../../include/utils/hsearch.h.html#LN105"><span class='Ref_to_EnumConst'>HASH_ENTER</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predicate.c.html#LN2422"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN2423"><span class='Ref_To_Local'>locallock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN354"><span class='Ref_to_Member'>held</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN2422"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>        <a href="predicate.c.html#LN2423"><span class='Ref_To_Local'>locallock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN355"><span class='Ref_to_Member'>childLocks</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Actually create the lock */ 
</span>    <a href="predicate.c.html#LN449"><span class='Ref_to_Proto'>CreatePredicateLock</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2419"><span class='Ref_to_Parameter'>targettag</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN2421"><span class='Ref_To_Local'>targettaghash</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Lock has been acquired. Check whether it should be promoted to a 
     * coarser granularity, or whether there are finer-granularity locks to 
     * clean up. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN447"><span class='Ref_to_Proto'>CheckAndPromotePredicateLockRequest</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2419"><span class='Ref_to_Parameter'>targettag</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Lock request was promoted to a coarser-granularity lock, and that 
         * lock was acquired. It will delete this lock and any of its 
         * children, so we're done. 
         */ 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Clean up any finer-granularity locks */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN415"><span class='Ref_to_Macro'>GET_PREDICATELOCKTARGETTAG_TYPE</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="predicate.c.html#LN2419"><span class='Ref_to_Parameter'>targettag</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="../../../include/storage/predicate_internals.h.html#LN366"><span class='Ref_to_EnumConst'>PREDLOCKTAG_TUPLE</span></a><span class='Parentheses'>)</span> 
            <a href="predicate.c.html#LN445"><span class='Ref_to_Proto'>DeleteChildTargetLocks</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2419"><span class='Ref_to_Parameter'>targettag</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end PredicateLockAcquire &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 *      PredicateLockRelation 
 * 
 * Gets a predicate lock at the relation level. 
 * Skip if not in full serializable transaction isolation level. 
 * Skip if this is a temporary table. 
 * Clear any finer-grained predicate locks this session has on the relation. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2478"></a><span class='Declare_Function'>PredicateLockRelation</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>relation</span><span class='Delimiter'>, </span><a href="../../../include/utils/snapshot.h.html#LN22"><span class='Ref_to_Typedef'>Snapshot</span></a> <span class='Declare_Parameter'>snapshot</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2480"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Declare_Local'>tag</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN495"><span class='Ref_to_Func'>SerializationNeededForRead</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2478"><span class='Ref_to_Parameter'>relation</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN2478"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/predicate_internals.h.html#LN389"><span class='Ref_to_Macro'>SET_PREDICATELOCKTARGETTAG_RELATION</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2480"><span class='Ref_To_Local'>tag</span></a><span class='Delimiter'>, 
</span>                                        <a href="predicate.c.html#LN2478"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN84"><span class='Ref_to_Member'>rd_node</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN59"><span class='Ref_to_Member'>dbNode</span></a><span class='Delimiter'>, 
</span>                                        <a href="predicate.c.html#LN2478"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN115"><span class='Ref_to_Member'>rd_id</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN456"><span class='Ref_to_Proto'>PredicateLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN2480"><span class='Ref_To_Local'>tag</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *      PredicateLockPage 
 * 
 * Gets a predicate lock at the page level. 
 * Skip if not in full serializable transaction isolation level. 
 * Skip if this is a temporary table. 
 * Skip if a coarser predicate lock already covers this page. 
 * Clear any finer-grained predicate locks this session has on the relation. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2501"></a><span class='Declare_Function'>PredicateLockPage</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>relation</span><span class='Delimiter'>, </span><a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Parameter'>blkno</span><span class='Delimiter'>, </span><a href="../../../include/utils/snapshot.h.html#LN22"><span class='Ref_to_Typedef'>Snapshot</span></a> <span class='Declare_Parameter'>snapshot</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2503"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Declare_Local'>tag</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN495"><span class='Ref_to_Func'>SerializationNeededForRead</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2501"><span class='Ref_to_Parameter'>relation</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN2501"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/predicate_internals.h.html#LN395"><span class='Ref_to_Macro'>SET_PREDICATELOCKTARGETTAG_PAGE</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2503"><span class='Ref_To_Local'>tag</span></a><span class='Delimiter'>, 
</span>                                    <a href="predicate.c.html#LN2501"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN84"><span class='Ref_to_Member'>rd_node</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN59"><span class='Ref_to_Member'>dbNode</span></a><span class='Delimiter'>, 
</span>                                    <a href="predicate.c.html#LN2501"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN115"><span class='Ref_to_Member'>rd_id</span></a><span class='Delimiter'>, 
</span>                                    <a href="predicate.c.html#LN2501"><span class='Ref_to_Parameter'>blkno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN456"><span class='Ref_to_Proto'>PredicateLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN2503"><span class='Ref_To_Local'>tag</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *      PredicateLockTuple 
 * 
 * Gets a predicate lock at the tuple level. 
 * Skip if not in full serializable transaction isolation level. 
 * Skip if this is a temporary table. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2523"></a><span class='Declare_Function'>PredicateLockTuple</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>relation</span><span class='Delimiter'>, </span><a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> <span class='Declare_Parameter'>tuple</span><span class='Delimiter'>, </span><a href="../../../include/utils/snapshot.h.html#LN22"><span class='Ref_to_Typedef'>Snapshot</span></a> <span class='Declare_Parameter'>snapshot</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2525"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Declare_Local'>tag</span><span class='Delimiter'>; 
</span><a name="LN2526"></a>    <a href="../../../include/storage/itemptr.h.html#LN47"><span class='Ref_to_Typedef'>ItemPointer</span></a> <span class='Declare_Local'>tid</span><span class='Delimiter'>; 
</span><a name="LN2527"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>targetxmin</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN495"><span class='Ref_to_Func'>SerializationNeededForRead</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2523"><span class='Ref_to_Parameter'>relation</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN2523"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If it's a heap tuple, return if this xact wrote it. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN2523"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN158"><span class='Ref_to_Member'>rd_index</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2537"></a>        <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>myxid</span><span class='Delimiter'>; 
</span> 
        <a href="predicate.c.html#LN2527"><span class='Ref_To_Local'>targetxmin</span></a> <span class='Operator'>= </span><a href="../../../include/access/htup_details.h.html#LN306"><span class='Ref_to_Macro'>HeapTupleHeaderGetXmin</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2523"><span class='Ref_to_Parameter'>tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="predicate.c.html#LN2537"><span class='Ref_To_Local'>myxid</span></a> <span class='Operator'>= </span><a href="../../../include/access/xact.h.html#LN332"><span class='Ref_to_Proto'>GetTopTransactionIdIfAny</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2537"><span class='Ref_To_Local'>myxid</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN171"><span class='Ref_to_Proto'>TransactionIdFollowsOrEquals</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2527"><span class='Ref_To_Local'>targetxmin</span></a><span class='Delimiter'>, </span><a href="../../utils/time/snapmgr.c.html#LN163"><span class='Ref_to_Global_Var'>TransactionXmin</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span><a name="LN2546"></a>                <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>xid</span> <span class='Operator'>= </span><a href="../../../include/access/subtrans.h.html#LN18"><span class='Ref_to_Proto'>SubTransGetTopmostTransaction</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2527"><span class='Ref_To_Local'>targetxmin</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN42"><span class='Ref_to_Macro'>TransactionIdEquals</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2546"><span class='Ref_To_Local'>xid</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN2537"><span class='Ref_To_Local'>myxid</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* We wrote it; we already have a write lock. */ 
</span>                    <span class='Control'>return</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if relation-&GT;rd_index==N... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Do quick-but-not-definitive test for a relation lock first.  This will 
     * never cause a return when the relation is *not* locked, but will 
     * occasionally let the check continue when there really *is* a relation 
     * level lock. 
     */ 
</span>    <a href="../../../include/storage/predicate_internals.h.html#LN389"><span class='Ref_to_Macro'>SET_PREDICATELOCKTARGETTAG_RELATION</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2525"><span class='Ref_To_Local'>tag</span></a><span class='Delimiter'>, 
</span>                                        <a href="predicate.c.html#LN2523"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN84"><span class='Ref_to_Member'>rd_node</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN59"><span class='Ref_to_Member'>dbNode</span></a><span class='Delimiter'>, 
</span>                                        <a href="predicate.c.html#LN2523"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN115"><span class='Ref_to_Member'>rd_id</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN437"><span class='Ref_to_Proto'>PredicateLockExists</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN2525"><span class='Ref_To_Local'>tag</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN2526"><span class='Ref_To_Local'>tid</span></a> <span class='Operator'>= &</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2523"><span class='Ref_to_Parameter'>tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN64"><span class='Ref_to_Member'>t_self</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/predicate_internals.h.html#LN401"><span class='Ref_to_Macro'>SET_PREDICATELOCKTARGETTAG_TUPLE</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2525"><span class='Ref_To_Local'>tag</span></a><span class='Delimiter'>, 
</span>                                     <a href="predicate.c.html#LN2523"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN84"><span class='Ref_to_Member'>rd_node</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN59"><span class='Ref_to_Member'>dbNode</span></a><span class='Delimiter'>, 
</span>                                     <a href="predicate.c.html#LN2523"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN115"><span class='Ref_to_Member'>rd_id</span></a><span class='Delimiter'>, 
</span>                                     <a href="../../../include/storage/itemptr.h.html#LN74"><span class='Ref_to_Macro'>ItemPointerGetBlockNumber</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2526"><span class='Ref_To_Local'>tid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                     <a href="../../../include/storage/itemptr.h.html#LN93"><span class='Ref_to_Macro'>ItemPointerGetOffsetNumber</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2526"><span class='Ref_To_Local'>tid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN456"><span class='Ref_to_Proto'>PredicateLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN2525"><span class='Ref_To_Local'>tag</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end PredicateLockTuple &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 *      DeleteLockTarget 
 * 
 * Remove a predicate lock target along with any locks held for it. 
 * 
 * Caller must hold SerializablePredicateLockListLock and the 
 * appropriate hash partition lock for the target. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2588"></a><span class='Declare_Function'>DeleteLockTarget</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN285"><span class='Ref_to_Struct'>PREDICATELOCKTARGET</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>target</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Parameter'>targettaghash</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2590"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Declare_Local'>predlock</span><span class='Delimiter'>; 
</span><a name="LN2591"></a>    <a href="../../../include/storage/shmem.h.html#LN27"><span class='Ref_to_Struct'>SHM_QUEUE</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>predlocktargetlink</span><span class='Delimiter'>; 
</span><a name="LN2592"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Declare_Local'>nextpredlock</span><span class='Delimiter'>; 
</span><a name="LN2593"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN151"><span class='Ref_to_Proto'>LWLockHeldByMe</span></a><span class='Parentheses'>(</span>SerializablePredicateLockListLock<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN151"><span class='Ref_to_Proto'>LWLockHeldByMe</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN244"><span class='Ref_to_Macro'>PredicateLockHashPartitionLock</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2588"><span class='Ref_to_Parameter'>targettaghash</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN2590"><span class='Ref_To_Local'>predlock</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2588"><span class='Ref_to_Parameter'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN291"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2588"><span class='Ref_to_Parameter'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN291"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a><span class='Delimiter'>, </span>targetLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN2590"><span class='Ref_To_Local'>predlock</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="predicate.c.html#LN2591"><span class='Ref_To_Local'>predlocktargetlink</span></a> <span class='Operator'>= &</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2590"><span class='Ref_To_Local'>predlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN324"><span class='Ref_to_Member'>targetLink</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN2592"><span class='Ref_To_Local'>nextpredlock</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2588"><span class='Ref_to_Parameter'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN291"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="predicate.c.html#LN2591"><span class='Ref_To_Local'>predlocktargetlink</span></a><span class='Delimiter'>, 
</span>                         <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a><span class='Delimiter'>, </span>targetLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <a href="../ipc/shmqueue.c.html#LN66"><span class='Ref_to_Func'>SHMQueueDelete</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2590"><span class='Ref_To_Local'>predlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN326"><span class='Ref_to_Member'>xactLink</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="../ipc/shmqueue.c.html#LN66"><span class='Ref_to_Func'>SHMQueueDelete</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2590"><span class='Ref_To_Local'>predlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN324"><span class='Ref_to_Member'>targetLink</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/utils/hsearch.h.html#LN128"><span class='Ref_to_Proto'>hash_search_with_hash_value</span></a> 
            <span class='Parentheses'>(</span><a href="predicate.c.html#LN387"><span class='Ref_to_Global_Var'>PredicateLockHash</span></a><span class='Delimiter'>, 
</span>             <span class='Operator'>&</span><a href="predicate.c.html#LN2590"><span class='Ref_To_Local'>predlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN321"><span class='Ref_to_Member'>tag</span></a><span class='Delimiter'>, 
</span>             <a href="predicate.c.html#LN301"><span class='Ref_to_Macro'>PredicateLockHashCodeFromTargetHashCode</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN2590"><span class='Ref_To_Local'>predlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN321"><span class='Ref_to_Member'>tag</span></a><span class='Delimiter'>, 
</span>                                                     <a href="predicate.c.html#LN2588"><span class='Ref_to_Parameter'>targettaghash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>             <a href="../../../include/utils/hsearch.h.html#LN106"><span class='Ref_to_EnumConst'>HASH_REMOVE</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predicate.c.html#LN2593"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2593"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="predicate.c.html#LN2590"><span class='Ref_To_Local'>predlock</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN2592"><span class='Ref_To_Local'>nextpredlock</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while predlock &raquo; </span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Remove the target itself, if possible. */ 
</span>    <a href="predicate.c.html#LN443"><span class='Ref_to_Proto'>RemoveTargetIfNoLongerUsed</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2588"><span class='Ref_to_Parameter'>target</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN2588"><span class='Ref_to_Parameter'>targettaghash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end DeleteLockTarget &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 *      TransferPredicateLocksToNewTarget 
 * 
 * Move or copy all the predicate locks for a lock target, for use by 
 * index page splits/combines and other things that create or replace 
 * lock targets. If 'removeOld' is true, the old locks and the target 
 * will be removed. 
 * 
 * Returns true on success, or false if we ran out of shared memory to 
 * allocate the new target or locks. Guaranteed to always succeed if 
 * removeOld is set (by using the scratch entry in PredicateLockTargetHash 
 * for scratch space). 
 * 
 * Warning: the "removeOld" option should be used only with care, 
 * because this function does not (indeed, can not) update other 
 * backends' LocalPredicateLockHash. If we are only adding new 
 * entries, this is not a problem: the local lock table is used only 
 * as a hint, so missing entries for locks that are held are 
 * OK. Having entries for locks that are no longer held, as can happen 
 * when using "removeOld", is not in general OK. We can only use it 
 * safely when replacing a lock with a coarser-granularity lock that 
 * covers it, or if we are absolutely certain that no one will need to 
 * refer to that lock in the future. 
 * 
 * Caller must hold SerializablePredicateLockListLock. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN2658"></a><span class='Declare_Function'>TransferPredicateLocksToNewTarget</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Declare_Parameter'>oldtargettag</span><span class='Delimiter'>, 
</span><a name="LN2659"></a>                                  <a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Declare_Parameter'>newtargettag</span><span class='Delimiter'>, 
</span><a name="LN2660"></a>                                  <span class='Keyword'>bool </span><span class='Declare_Parameter'>removeOld</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2662"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>oldtargettaghash</span><span class='Delimiter'>; 
</span><a name="LN2663"></a>    <a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>oldpartitionLock</span><span class='Delimiter'>; 
</span><a name="LN2664"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN285"><span class='Ref_to_Struct'>PREDICATELOCKTARGET</span></a> <span class='Operator'>*</span><span class='Declare_Local'>oldtarget</span><span class='Delimiter'>; 
</span><a name="LN2665"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>newtargettaghash</span><span class='Delimiter'>; 
</span><a name="LN2666"></a>    <a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>newpartitionLock</span><span class='Delimiter'>; 
</span><a name="LN2667"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span><span class='Delimiter'>; 
</span><a name="LN2668"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>outOfShmem</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN151"><span class='Ref_to_Proto'>LWLockHeldByMe</span></a><span class='Parentheses'>(</span>SerializablePredicateLockListLock<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN2662"><span class='Ref_To_Local'>oldtargettaghash</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN288"><span class='Ref_to_Macro'>PredicateLockTargetTagHashCode</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN2658"><span class='Ref_to_Parameter'>oldtargettag</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN2665"><span class='Ref_To_Local'>newtargettaghash</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN288"><span class='Ref_to_Macro'>PredicateLockTargetTagHashCode</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN2659"><span class='Ref_to_Parameter'>newtargettag</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN2663"><span class='Ref_To_Local'>oldpartitionLock</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN244"><span class='Ref_to_Macro'>PredicateLockHashPartitionLock</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2662"><span class='Ref_To_Local'>oldtargettaghash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN2666"><span class='Ref_To_Local'>newpartitionLock</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN244"><span class='Ref_to_Macro'>PredicateLockHashPartitionLock</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2665"><span class='Ref_To_Local'>newtargettaghash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN2660"><span class='Ref_to_Parameter'>removeOld</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Remove the dummy entry to give us scratch space, so we know we'll 
         * be able to create the new lock target. 
         */ 
</span>        <a href="predicate.c.html#LN441"><span class='Ref_to_Proto'>RemoveScratchTarget</span></a><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We must get the partition locks in ascending sequence to avoid 
     * deadlocks. If old and new partitions are the same, we must request the 
     * lock only once. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN2663"><span class='Ref_To_Local'>oldpartitionLock</span></a> <span class='Operator'>&LT; </span><a href="predicate.c.html#LN2666"><span class='Ref_To_Local'>newpartitionLock</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2663"><span class='Ref_To_Local'>oldpartitionLock</span></a><span class='Delimiter'>, 
</span>                      <span class='Parentheses'>(</span><a href="predicate.c.html#LN2660"><span class='Ref_to_Parameter'>removeOld</span></a> <span class='Operator'>? </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a> <span class='Operator'>: </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2666"><span class='Ref_To_Local'>newpartitionLock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN2663"><span class='Ref_To_Local'>oldpartitionLock</span></a> <span class='Operator'>&GT; </span><a href="predicate.c.html#LN2666"><span class='Ref_To_Local'>newpartitionLock</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2666"><span class='Ref_To_Local'>newpartitionLock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2663"><span class='Ref_To_Local'>oldpartitionLock</span></a><span class='Delimiter'>, 
</span>                      <span class='Parentheses'>(</span><a href="predicate.c.html#LN2660"><span class='Ref_to_Parameter'>removeOld</span></a> <span class='Operator'>? </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a> <span class='Operator'>: </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2666"><span class='Ref_To_Local'>newpartitionLock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Look for the old target.  If not found, that's OK; no predicate locks 
     * are affected, so we can just clean up and return. If it does exist, 
     * walk its list of predicate locks and move or copy them to the new 
     * target. 
     */ 
</span>    <a href="predicate.c.html#LN2664"><span class='Ref_To_Local'>oldtarget</span></a> <span class='Operator'>= </span><a href="../../../include/utils/hsearch.h.html#LN128"><span class='Ref_to_Proto'>hash_search_with_hash_value</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN386"><span class='Ref_to_Global_Var'>PredicateLockTargetHash</span></a><span class='Delimiter'>, 
</span>                                            <span class='Operator'>&</span><a href="predicate.c.html#LN2658"><span class='Ref_to_Parameter'>oldtargettag</span></a><span class='Delimiter'>, 
</span>                                            <a href="predicate.c.html#LN2662"><span class='Ref_To_Local'>oldtargettaghash</span></a><span class='Delimiter'>, 
</span>                                            <a href="../../../include/utils/hsearch.h.html#LN104"><span class='Ref_to_EnumConst'>HASH_FIND</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN2664"><span class='Ref_To_Local'>oldtarget</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2719"></a>        <a href="../../../include/storage/predicate_internals.h.html#LN285"><span class='Ref_to_Struct'>PREDICATELOCKTARGET</span></a> <span class='Operator'>*</span><span class='Declare_Local'>newtarget</span><span class='Delimiter'>; 
</span><a name="LN2720"></a>        <a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Declare_Local'>oldpredlock</span><span class='Delimiter'>; 
</span><a name="LN2721"></a>        <a href="../../../include/storage/predicate_internals.h.html#LN303"><span class='Ref_to_Struct'>PREDICATELOCKTAG</span></a> <span class='Declare_Local'>newpredlocktag</span><span class='Delimiter'>; 
</span> 
        <a href="predicate.c.html#LN2719"><span class='Ref_To_Local'>newtarget</span></a> <span class='Operator'>= </span><a href="../../../include/utils/hsearch.h.html#LN128"><span class='Ref_to_Proto'>hash_search_with_hash_value</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN386"><span class='Ref_to_Global_Var'>PredicateLockTargetHash</span></a><span class='Delimiter'>, 
</span>                                                <span class='Operator'>&</span><a href="predicate.c.html#LN2659"><span class='Ref_to_Parameter'>newtargettag</span></a><span class='Delimiter'>, 
</span>                                                <a href="predicate.c.html#LN2665"><span class='Ref_To_Local'>newtargettaghash</span></a><span class='Delimiter'>, 
</span>                                                <a href="../../../include/utils/hsearch.h.html#LN107"><span class='Ref_to_EnumConst'>HASH_ENTER_NULL</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predicate.c.html#LN2667"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN2719"><span class='Ref_To_Local'>newtarget</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Failed to allocate due to insufficient shmem */ 
</span>            <a href="predicate.c.html#LN2668"><span class='Ref_To_Local'>outOfShmem</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="predicate.c.html#LN2823"><span class='Ref_to_Label'>exit</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* If we created a new entry, initialize it */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN2667"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>            <a href="../ipc/shmqueue.c.html#LN34"><span class='Ref_to_Func'>SHMQueueInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2719"><span class='Ref_To_Local'>newtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN291"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <a href="predicate.c.html#LN2721"><span class='Ref_To_Local'>newpredlocktag</span></a><span class='Operator'>.</span><a href="../../../include/storage/predicate_internals.h.html#LN305"><span class='Ref_to_Member'>myTarget</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN2719"><span class='Ref_To_Local'>newtarget</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Loop through all the locks on the old target, replacing them with 
         * locks on the new target. 
         */ 
</span>        <a href="predicate.c.html#LN2720"><span class='Ref_To_Local'>oldpredlock</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2664"><span class='Ref_To_Local'>oldtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN291"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2664"><span class='Ref_To_Local'>oldtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN291"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a><span class='Delimiter'>, </span>targetLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN2720"><span class='Ref_To_Local'>oldpredlock</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN2752"></a>            <a href="../../../include/storage/shmem.h.html#LN27"><span class='Ref_to_Struct'>SHM_QUEUE</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>predlocktargetlink</span><span class='Delimiter'>; 
</span><a name="LN2753"></a>            <a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Declare_Local'>nextpredlock</span><span class='Delimiter'>; 
</span><a name="LN2754"></a>            <a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Declare_Local'>newpredlock</span><span class='Delimiter'>; 
</span><a name="LN2755"></a>            <a href="../../../include/storage/predicate_internals.h.html#LN21"><span class='Ref_to_Typedef'>SerCommitSeqNo</span></a> <span class='Declare_Local'>oldCommitSeqNo</span> <span class='Operator'>= </span><a href="predicate.c.html#LN2720"><span class='Ref_To_Local'>oldpredlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN328"><span class='Ref_to_Member'>commitSeqNo</span></a><span class='Delimiter'>; 
</span> 
            <a href="predicate.c.html#LN2752"><span class='Ref_To_Local'>predlocktargetlink</span></a> <span class='Operator'>= &</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2720"><span class='Ref_To_Local'>oldpredlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN324"><span class='Ref_to_Member'>targetLink</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="predicate.c.html#LN2753"><span class='Ref_To_Local'>nextpredlock</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2664"><span class='Ref_To_Local'>oldtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN291"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <a href="predicate.c.html#LN2752"><span class='Ref_To_Local'>predlocktargetlink</span></a><span class='Delimiter'>, 
</span>                             <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a><span class='Delimiter'>, </span>targetLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="predicate.c.html#LN2721"><span class='Ref_To_Local'>newpredlocktag</span></a><span class='Operator'>.</span><a href="../../../include/storage/predicate_internals.h.html#LN306"><span class='Ref_to_Member'>myXact</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN2720"><span class='Ref_To_Local'>oldpredlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN321"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/predicate_internals.h.html#LN306"><span class='Ref_to_Member'>myXact</span></a><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN2660"><span class='Ref_to_Parameter'>removeOld</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="../ipc/shmqueue.c.html#LN66"><span class='Ref_to_Func'>SHMQueueDelete</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2720"><span class='Ref_To_Local'>oldpredlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN326"><span class='Ref_to_Member'>xactLink</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <a href="../ipc/shmqueue.c.html#LN66"><span class='Ref_to_Func'>SHMQueueDelete</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2720"><span class='Ref_To_Local'>oldpredlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN324"><span class='Ref_to_Member'>targetLink</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
                <a href="../../../include/utils/hsearch.h.html#LN128"><span class='Ref_to_Proto'>hash_search_with_hash_value</span></a> 
                    <span class='Parentheses'>(</span><a href="predicate.c.html#LN387"><span class='Ref_to_Global_Var'>PredicateLockHash</span></a><span class='Delimiter'>, 
</span>                     <span class='Operator'>&</span><a href="predicate.c.html#LN2720"><span class='Ref_To_Local'>oldpredlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN321"><span class='Ref_to_Member'>tag</span></a><span class='Delimiter'>, 
</span>                   <a href="predicate.c.html#LN301"><span class='Ref_to_Macro'>PredicateLockHashCodeFromTargetHashCode</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN2720"><span class='Ref_To_Local'>oldpredlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN321"><span class='Ref_to_Member'>tag</span></a><span class='Delimiter'>, 
</span>                                                           <a href="predicate.c.html#LN2662"><span class='Ref_To_Local'>oldtargettaghash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../../include/utils/hsearch.h.html#LN106"><span class='Ref_to_EnumConst'>HASH_REMOVE</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predicate.c.html#LN2667"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2667"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <a href="predicate.c.html#LN2754"><span class='Ref_To_Local'>newpredlock</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                <a href="../../../include/utils/hsearch.h.html#LN128"><span class='Ref_to_Proto'>hash_search_with_hash_value</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN387"><span class='Ref_to_Global_Var'>PredicateLockHash</span></a><span class='Delimiter'>, 
</span>                                            <span class='Operator'>&</span><a href="predicate.c.html#LN2721"><span class='Ref_To_Local'>newpredlocktag</span></a><span class='Delimiter'>, 
</span>                     <a href="predicate.c.html#LN301"><span class='Ref_to_Macro'>PredicateLockHashCodeFromTargetHashCode</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN2721"><span class='Ref_To_Local'>newpredlocktag</span></a><span class='Delimiter'>, 
</span>                                                           <a href="predicate.c.html#LN2665"><span class='Ref_To_Local'>newtargettaghash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                            <a href="../../../include/utils/hsearch.h.html#LN107"><span class='Ref_to_EnumConst'>HASH_ENTER_NULL</span></a><span class='Delimiter'>, 
</span>                                            <span class='Operator'>&</span><a href="predicate.c.html#LN2667"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN2754"><span class='Ref_To_Local'>newpredlock</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Out of shared memory. Undo what we've done so far. */ 
</span>                <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="predicate.c.html#LN452"><span class='Ref_to_Proto'>DeleteLockTarget</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2719"><span class='Ref_To_Local'>newtarget</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN2665"><span class='Ref_To_Local'>newtargettaghash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="predicate.c.html#LN2668"><span class='Ref_To_Local'>outOfShmem</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="predicate.c.html#LN2823"><span class='Ref_to_Label'>exit</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN2667"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="../../../include/storage/shmem.h.html#LN70"><span class='Ref_to_Proto'>SHMQueueInsertBefore</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2719"><span class='Ref_To_Local'>newtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN291"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                     <span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2754"><span class='Ref_To_Local'>newpredlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN324"><span class='Ref_to_Member'>targetLink</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <a href="../../../include/storage/shmem.h.html#LN70"><span class='Ref_to_Proto'>SHMQueueInsertBefore</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2721"><span class='Ref_To_Local'>newpredlocktag</span></a><span class='Operator'>.</span><a href="../../../include/storage/predicate_internals.h.html#LN306"><span class='Ref_to_Member'>myXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN89"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                     <span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2754"><span class='Ref_To_Local'>newpredlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN326"><span class='Ref_to_Member'>xactLink</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <a href="predicate.c.html#LN2754"><span class='Ref_To_Local'>newpredlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN328"><span class='Ref_to_Member'>commitSeqNo</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN2755"><span class='Ref_To_Local'>oldCommitSeqNo</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN2754"><span class='Ref_To_Local'>newpredlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN328"><span class='Ref_to_Member'>commitSeqNo</span></a> <span class='Operator'>&LT; </span><a href="predicate.c.html#LN2755"><span class='Ref_To_Local'>oldCommitSeqNo</span></a><span class='Parentheses'>) 
</span>                    <a href="predicate.c.html#LN2754"><span class='Ref_To_Local'>newpredlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN328"><span class='Ref_to_Member'>commitSeqNo</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN2755"><span class='Ref_To_Local'>oldCommitSeqNo</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2754"><span class='Ref_To_Local'>newpredlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN328"><span class='Ref_to_Member'>commitSeqNo</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>((</span><a href="predicate.c.html#LN2754"><span class='Ref_To_Local'>newpredlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN328"><span class='Ref_to_Member'>commitSeqNo</span></a> <span class='Operator'>== </span><a href="../../../include/storage/predicate_internals.h.html#LN35"><span class='Ref_to_Const'>InvalidSerCommitSeqNo</span></a><span class='Parentheses'>) 
</span>                   <span class='Operator'>|| </span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2754"><span class='Ref_To_Local'>newpredlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN321"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/predicate_internals.h.html#LN306"><span class='Ref_to_Member'>myXact</span></a> <span class='Operator'>== </span><a href="predicate.c.html#LN351"><span class='Ref_to_Global_Var'>OldCommittedSxact</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <a href="predicate.c.html#LN2720"><span class='Ref_To_Local'>oldpredlock</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN2753"><span class='Ref_To_Local'>nextpredlock</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while oldpredlock &raquo; </span> 
        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN2660"><span class='Ref_to_Parameter'>removeOld</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/shmem.h.html#LN76"><span class='Ref_to_Proto'>SHMQueueEmpty</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN2664"><span class='Ref_To_Local'>oldtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN291"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="predicate.c.html#LN443"><span class='Ref_to_Proto'>RemoveTargetIfNoLongerUsed</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2664"><span class='Ref_To_Local'>oldtarget</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN2662"><span class='Ref_To_Local'>oldtargettaghash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if oldtarget &raquo; </span> 
 
 
<a name="LN2823"></a><span class='Label'>exit</span><span class='Operator'>: 
</span>    <span class='Comment_Multi_Line'>/* Release partition locks in reverse order of acquisition. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN2663"><span class='Ref_To_Local'>oldpartitionLock</span></a> <span class='Operator'>&LT; </span><a href="predicate.c.html#LN2666"><span class='Ref_To_Local'>newpartitionLock</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2666"><span class='Ref_To_Local'>newpartitionLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2663"><span class='Ref_To_Local'>oldpartitionLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN2663"><span class='Ref_To_Local'>oldpartitionLock</span></a> <span class='Operator'>&GT; </span><a href="predicate.c.html#LN2666"><span class='Ref_To_Local'>newpartitionLock</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2663"><span class='Ref_To_Local'>oldpartitionLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2666"><span class='Ref_To_Local'>newpartitionLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2666"><span class='Ref_To_Local'>newpartitionLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN2660"><span class='Ref_to_Parameter'>removeOld</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* We shouldn't run out of memory if we're moving locks */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN2668"><span class='Ref_To_Local'>outOfShmem</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Put the scratch entry back */ 
</span>        <a href="predicate.c.html#LN442"><span class='Ref_to_Proto'>RestoreScratchTarget</span></a><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <span class='Operator'>!</span><a href="predicate.c.html#LN2668"><span class='Ref_To_Local'>outOfShmem</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end TransferPredicateLocksToNewTarget &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Drop all predicate locks of any granularity from the specified relation, 
 * which can be a heap relation or an index relation.  If 'transfer' is true, 
 * acquire a relation lock on the heap for any transactions with any lock(s) 
 * on the specified relation. 
 * 
 * This requires grabbing a lot of LW locks and scanning the entire lock 
 * target table for matches.  That makes this more expensive than most 
 * predicate lock management functions, but it will only be called for DDL 
 * type commands that are expensive anyway, and there are fast returns when 
 * no serializable transactions are active or the relation is temporary. 
 * 
 * We don't use the TransferPredicateLocksToNewTarget function because it 
 * acquires its own locks on the partitions of the two targets involved, 
 * and we'll already be holding all partition locks. 
 * 
 * We can't throw an error from here, because the call could be from a 
 * transaction which is not serializable. 
 * 
 * NOTE: This is currently only called with transfer set to true, but that may 
 * change.  If we decide to clean up the locks from a table on commit of a 
 * transaction which executed DROP TABLE, the false condition will be useful. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2874"></a><span class='Declare_Function'>DropAllPredicateLocksFromTable</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>relation</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>transfer</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2876"></a>    <a href="../../../include/utils/hsearch.h.html#LN111"><span class='Ref_to_Typedef'>HASH_SEQ_STATUS</span></a> <span class='Declare_Local'>seqstat</span><span class='Delimiter'>; 
</span><a name="LN2877"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN285"><span class='Ref_to_Struct'>PREDICATELOCKTARGET</span></a> <span class='Operator'>*</span><span class='Declare_Local'>oldtarget</span><span class='Delimiter'>; 
</span><a name="LN2878"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN285"><span class='Ref_to_Struct'>PREDICATELOCKTARGET</span></a> <span class='Operator'>*</span><span class='Declare_Local'>heaptarget</span><span class='Delimiter'>; 
</span><a name="LN2879"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>dbId</span><span class='Delimiter'>; 
</span><a name="LN2880"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>relId</span><span class='Delimiter'>; 
</span><a name="LN2881"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>heapId</span><span class='Delimiter'>; 
</span><a name="LN2882"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN2883"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isIndex</span><span class='Delimiter'>; 
</span><a name="LN2884"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span><span class='Delimiter'>; 
</span><a name="LN2885"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>heaptargettaghash</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Bail out quickly if there are no serializable transactions running. 
     * It's safe to check this without taking locks because the caller is 
     * holding an ACCESS EXCLUSIVE lock on the relation.  No new locks which 
     * would matter here can be acquired while that is held. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN155"><span class='Ref_to_Member'>SxactGlobalXmin</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN476"><span class='Ref_to_Func'>PredicateLockingNeededForRelation</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2874"><span class='Ref_to_Parameter'>relation</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN2879"><span class='Ref_To_Local'>dbId</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN2874"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN84"><span class='Ref_to_Member'>rd_node</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN59"><span class='Ref_to_Member'>dbNode</span></a><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN2880"><span class='Ref_To_Local'>relId</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN2874"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN115"><span class='Ref_to_Member'>rd_id</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN2874"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN158"><span class='Ref_to_Member'>rd_index</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="predicate.c.html#LN2883"><span class='Ref_To_Local'>isIndex</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN2881"><span class='Ref_To_Local'>heapId</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN2880"><span class='Ref_To_Local'>relId</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="predicate.c.html#LN2883"><span class='Ref_To_Local'>isIndex</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN2881"><span class='Ref_To_Local'>heapId</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN2874"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN158"><span class='Ref_to_Member'>rd_index</span></a><span class='Operator'>-&GT;</span>indrelid<span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2881"><span class='Ref_To_Local'>heapId</span></a> <span class='Operator'>!= </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2874"><span class='Ref_to_Parameter'>transfer</span></a> <span class='Operator'>|| !</span><a href="predicate.c.html#LN2883"><span class='Ref_To_Local'>isIndex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>       <span class='Comment_Multi_Line'>/* index OID only makes sense with 
                                         * transfer */ 
</span> 
    <span class='Comment_Multi_Line'>/* Retrieve first time needed, then keep. */ 
</span>    <a href="predicate.c.html#LN2885"><span class='Ref_To_Local'>heaptargettaghash</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN2878"><span class='Ref_To_Local'>heaptarget</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Acquire locks on all lock partitions */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SerializablePredicateLockListLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN2882"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="predicate.c.html#LN2882"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="../../../include/storage/lwlock.h.html#LN120"><span class='Ref_to_Const'>NUM_PREDICATELOCK_PARTITIONS</span></a><span class='Delimiter'>; </span><a href="predicate.c.html#LN2882"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN247"><span class='Ref_to_Macro'>PredicateLockHashPartitionLockByIndex</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2882"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Remove the dummy entry to give us scratch space, so we know we'll be 
     * able to create the new lock target. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN2874"><span class='Ref_to_Parameter'>transfer</span></a><span class='Parentheses'>) 
</span>        <a href="predicate.c.html#LN441"><span class='Ref_to_Proto'>RemoveScratchTarget</span></a><span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Scan through target map */ 
</span>    <a href="../../../include/utils/hsearch.h.html#LN134"><span class='Ref_to_Proto'>hash_seq_init</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN2876"><span class='Ref_To_Local'>seqstat</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN386"><span class='Ref_to_Global_Var'>PredicateLockTargetHash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>while</span> <span class='Parentheses'>((</span><a href="predicate.c.html#LN2877"><span class='Ref_To_Local'>oldtarget</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN285"><span class='Ref_to_Struct'>PREDICATELOCKTARGET</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/utils/hsearch.h.html#LN135"><span class='Ref_to_Proto'>hash_seq_search</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN2876"><span class='Ref_To_Local'>seqstat</span></a><span class='Parentheses'>)))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN2937"></a>        <a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Declare_Local'>oldpredlock</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Check whether this is a target which needs attention. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN409"><span class='Ref_to_Macro'>GET_PREDICATELOCKTARGETTAG_RELATION</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2877"><span class='Ref_To_Local'>oldtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN288"><span class='Ref_to_Member'>tag</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="predicate.c.html#LN2880"><span class='Ref_To_Local'>relId</span></a><span class='Parentheses'>)</span> 
            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* wrong relation id */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN407"><span class='Ref_to_Macro'>GET_PREDICATELOCKTARGETTAG_DB</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2877"><span class='Ref_To_Local'>oldtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN288"><span class='Ref_to_Member'>tag</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="predicate.c.html#LN2879"><span class='Ref_To_Local'>dbId</span></a><span class='Parentheses'>)</span> 
            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* wrong database id */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN2874"><span class='Ref_to_Parameter'>transfer</span></a> <span class='Operator'>&& !</span><a href="predicate.c.html#LN2883"><span class='Ref_To_Local'>isIndex</span></a> 
            <span class='Operator'>&& </span><a href="../../../include/storage/predicate_internals.h.html#LN415"><span class='Ref_to_Macro'>GET_PREDICATELOCKTARGETTAG_TYPE</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2877"><span class='Ref_To_Local'>oldtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN288"><span class='Ref_to_Member'>tag</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="../../../include/storage/predicate_internals.h.html#LN364"><span class='Ref_to_EnumConst'>PREDLOCKTAG_RELATION</span></a><span class='Parentheses'>)</span> 
            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* already the right lock */ 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If we made it here, we have work to do.  We make sure the heap 
         * relation lock exists, then we walk the list of predicate locks for 
         * the old target we found, moving all locks to the heap relation lock 
         * -- unless they already hold that. 
         */ 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * First make sure we have the heap relation target.  We only need to 
         * do this once. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN2874"><span class='Ref_to_Parameter'>transfer</span></a> <span class='Operator'>&& </span><a href="predicate.c.html#LN2878"><span class='Ref_To_Local'>heaptarget</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN2963"></a>            <a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Declare_Local'>heaptargettag</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/storage/predicate_internals.h.html#LN389"><span class='Ref_to_Macro'>SET_PREDICATELOCKTARGETTAG_RELATION</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2963"><span class='Ref_To_Local'>heaptargettag</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN2879"><span class='Ref_To_Local'>dbId</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN2881"><span class='Ref_To_Local'>heapId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="predicate.c.html#LN2885"><span class='Ref_To_Local'>heaptargettaghash</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN288"><span class='Ref_to_Macro'>PredicateLockTargetTagHashCode</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN2963"><span class='Ref_To_Local'>heaptargettag</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="predicate.c.html#LN2878"><span class='Ref_To_Local'>heaptarget</span></a> <span class='Operator'>= </span><a href="../../../include/utils/hsearch.h.html#LN128"><span class='Ref_to_Proto'>hash_search_with_hash_value</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN386"><span class='Ref_to_Global_Var'>PredicateLockTargetHash</span></a><span class='Delimiter'>, 
</span>                                                     <span class='Operator'>&</span><a href="predicate.c.html#LN2963"><span class='Ref_To_Local'>heaptargettag</span></a><span class='Delimiter'>, 
</span>                                                     <a href="predicate.c.html#LN2885"><span class='Ref_To_Local'>heaptargettaghash</span></a><span class='Delimiter'>, 
</span>                                                     <a href="../../../include/utils/hsearch.h.html#LN105"><span class='Ref_to_EnumConst'>HASH_ENTER</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predicate.c.html#LN2884"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN2884"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>                <a href="../ipc/shmqueue.c.html#LN34"><span class='Ref_to_Func'>SHMQueueInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN2878"><span class='Ref_To_Local'>heaptarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN291"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Loop through all the locks on the old target, replacing them with 
         * locks on the new target. 
         */ 
</span>        <a href="predicate.c.html#LN2937"><span class='Ref_To_Local'>oldpredlock</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2877"><span class='Ref_To_Local'>oldtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN291"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2877"><span class='Ref_To_Local'>oldtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN291"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a><span class='Delimiter'>, </span>targetLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN2937"><span class='Ref_To_Local'>oldpredlock</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN2985"></a>            <a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Declare_Local'>nextpredlock</span><span class='Delimiter'>; 
</span><a name="LN2986"></a>            <a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Declare_Local'>newpredlock</span><span class='Delimiter'>; 
</span><a name="LN2987"></a>            <a href="../../../include/storage/predicate_internals.h.html#LN21"><span class='Ref_to_Typedef'>SerCommitSeqNo</span></a> <span class='Declare_Local'>oldCommitSeqNo</span><span class='Delimiter'>; 
</span><a name="LN2988"></a>            <a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Local'>oldXact</span><span class='Delimiter'>; 
</span> 
            <a href="predicate.c.html#LN2985"><span class='Ref_To_Local'>nextpredlock</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2877"><span class='Ref_To_Local'>oldtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN291"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2937"><span class='Ref_To_Local'>oldpredlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN324"><span class='Ref_to_Member'>targetLink</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a><span class='Delimiter'>, </span>targetLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Remove the old lock first. This avoids the chance of running 
             * out of lock structure entries for the hash table. 
             */ 
</span>            <a href="predicate.c.html#LN2987"><span class='Ref_To_Local'>oldCommitSeqNo</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN2937"><span class='Ref_To_Local'>oldpredlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN328"><span class='Ref_to_Member'>commitSeqNo</span></a><span class='Delimiter'>; 
</span>            <a href="predicate.c.html#LN2988"><span class='Ref_To_Local'>oldXact</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN2937"><span class='Ref_To_Local'>oldpredlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN321"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/predicate_internals.h.html#LN306"><span class='Ref_to_Member'>myXact</span></a><span class='Delimiter'>; 
</span> 
            <a href="../ipc/shmqueue.c.html#LN66"><span class='Ref_to_Func'>SHMQueueDelete</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2937"><span class='Ref_To_Local'>oldpredlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN326"><span class='Ref_to_Member'>xactLink</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * No need for retail delete from oldtarget list, we're removing 
             * the whole target anyway. 
             */ 
</span>            <a href="../../../include/utils/hsearch.h.html#LN125"><span class='Ref_to_Proto'>hash_search</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN387"><span class='Ref_to_Global_Var'>PredicateLockHash</span></a><span class='Delimiter'>, 
</span>                        <span class='Operator'>&</span><a href="predicate.c.html#LN2937"><span class='Ref_To_Local'>oldpredlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN321"><span class='Ref_to_Member'>tag</span></a><span class='Delimiter'>, 
</span>                        <a href="../../../include/utils/hsearch.h.html#LN106"><span class='Ref_to_EnumConst'>HASH_REMOVE</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predicate.c.html#LN2884"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2884"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN2874"><span class='Ref_to_Parameter'>transfer</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN3015"></a>                <a href="../../../include/storage/predicate_internals.h.html#LN303"><span class='Ref_to_Struct'>PREDICATELOCKTAG</span></a> <span class='Declare_Local'>newpredlocktag</span><span class='Delimiter'>; 
</span> 
                <a href="predicate.c.html#LN3015"><span class='Ref_To_Local'>newpredlocktag</span></a><span class='Operator'>.</span><a href="../../../include/storage/predicate_internals.h.html#LN305"><span class='Ref_to_Member'>myTarget</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN2878"><span class='Ref_To_Local'>heaptarget</span></a><span class='Delimiter'>; 
</span>                <a href="predicate.c.html#LN3015"><span class='Ref_To_Local'>newpredlocktag</span></a><span class='Operator'>.</span><a href="../../../include/storage/predicate_internals.h.html#LN306"><span class='Ref_to_Member'>myXact</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN2988"><span class='Ref_To_Local'>oldXact</span></a><span class='Delimiter'>; 
</span>                <a href="predicate.c.html#LN2986"><span class='Ref_To_Local'>newpredlock</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                    <a href="../../../include/utils/hsearch.h.html#LN128"><span class='Ref_to_Proto'>hash_search_with_hash_value</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN387"><span class='Ref_to_Global_Var'>PredicateLockHash</span></a><span class='Delimiter'>, 
</span>                                                <span class='Operator'>&</span><a href="predicate.c.html#LN3015"><span class='Ref_To_Local'>newpredlocktag</span></a><span class='Delimiter'>, 
</span>                     <a href="predicate.c.html#LN301"><span class='Ref_to_Macro'>PredicateLockHashCodeFromTargetHashCode</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN3015"><span class='Ref_To_Local'>newpredlocktag</span></a><span class='Delimiter'>, 
</span>                                                          <a href="predicate.c.html#LN2885"><span class='Ref_To_Local'>heaptargettaghash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                <a href="../../../include/utils/hsearch.h.html#LN105"><span class='Ref_to_EnumConst'>HASH_ENTER</span></a><span class='Delimiter'>, 
</span>                                                <span class='Operator'>&</span><a href="predicate.c.html#LN2884"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN2884"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <a href="../../../include/storage/shmem.h.html#LN70"><span class='Ref_to_Proto'>SHMQueueInsertBefore</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2878"><span class='Ref_To_Local'>heaptarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN291"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                         <span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2986"><span class='Ref_To_Local'>newpredlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN324"><span class='Ref_to_Member'>targetLink</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                    <a href="../../../include/storage/shmem.h.html#LN70"><span class='Ref_to_Proto'>SHMQueueInsertBefore</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN3015"><span class='Ref_To_Local'>newpredlocktag</span></a><span class='Operator'>.</span><a href="../../../include/storage/predicate_internals.h.html#LN306"><span class='Ref_to_Member'>myXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN89"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                         <span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2986"><span class='Ref_To_Local'>newpredlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN326"><span class='Ref_to_Member'>xactLink</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                    <a href="predicate.c.html#LN2986"><span class='Ref_To_Local'>newpredlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN328"><span class='Ref_to_Member'>commitSeqNo</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN2987"><span class='Ref_To_Local'>oldCommitSeqNo</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>else</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN2986"><span class='Ref_To_Local'>newpredlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN328"><span class='Ref_to_Member'>commitSeqNo</span></a> <span class='Operator'>&LT; </span><a href="predicate.c.html#LN2987"><span class='Ref_To_Local'>oldCommitSeqNo</span></a><span class='Parentheses'>) 
</span>                        <a href="predicate.c.html#LN2986"><span class='Ref_To_Local'>newpredlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN328"><span class='Ref_to_Member'>commitSeqNo</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN2987"><span class='Ref_To_Local'>oldCommitSeqNo</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2986"><span class='Ref_To_Local'>newpredlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN328"><span class='Ref_to_Member'>commitSeqNo</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Debug'>Assert</span><span class='Parentheses'>((</span><a href="predicate.c.html#LN2986"><span class='Ref_To_Local'>newpredlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN328"><span class='Ref_to_Member'>commitSeqNo</span></a> <span class='Operator'>== </span><a href="../../../include/storage/predicate_internals.h.html#LN35"><span class='Ref_to_Const'>InvalidSerCommitSeqNo</span></a><span class='Parentheses'>) 
</span>                       <span class='Operator'>|| </span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2986"><span class='Ref_To_Local'>newpredlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN321"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/predicate_internals.h.html#LN306"><span class='Ref_to_Member'>myXact</span></a> <span class='Operator'>== </span><a href="predicate.c.html#LN351"><span class='Ref_to_Global_Var'>OldCommittedSxact</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if transfer &raquo; </span> 
 
            <a href="predicate.c.html#LN2937"><span class='Ref_To_Local'>oldpredlock</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN2985"><span class='Ref_To_Local'>nextpredlock</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while oldpredlock &raquo; </span> 
 
        <a href="../../../include/utils/hsearch.h.html#LN125"><span class='Ref_to_Proto'>hash_search</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN386"><span class='Ref_to_Global_Var'>PredicateLockTargetHash</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predicate.c.html#LN2877"><span class='Ref_To_Local'>oldtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN288"><span class='Ref_to_Member'>tag</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/hsearch.h.html#LN106"><span class='Ref_to_EnumConst'>HASH_REMOVE</span></a><span class='Delimiter'>, 
</span>                    <span class='Operator'>&</span><a href="predicate.c.html#LN2884"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN2884"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while (oldtarget=(PREDICATE... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Put the scratch entry back */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN2874"><span class='Ref_to_Parameter'>transfer</span></a><span class='Parentheses'>) 
</span>        <a href="predicate.c.html#LN442"><span class='Ref_to_Proto'>RestoreScratchTarget</span></a><span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Release locks in reverse order */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN2882"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><a href="../../../include/storage/lwlock.h.html#LN120"><span class='Ref_to_Const'>NUM_PREDICATELOCK_PARTITIONS</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="predicate.c.html#LN2882"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="predicate.c.html#LN2882"><span class='Ref_To_Local'>i</span></a><span class='Operator'>--</span><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN247"><span class='Ref_to_Macro'>PredicateLockHashPartitionLockByIndex</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN2882"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializablePredicateLockListLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end DropAllPredicateLocksFromTable &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * TransferPredicateLocksToHeapRelation 
 *      For all transactions, transfer all predicate locks for the given 
 *      relation to a single relation lock on the heap. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN3070"></a><span class='Declare_Function'>TransferPredicateLocksToHeapRelation</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>relation</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="predicate.c.html#LN457"><span class='Ref_to_Proto'>DropAllPredicateLocksFromTable</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3070"><span class='Ref_to_Parameter'>relation</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 *      PredicateLockPageSplit 
 * 
 * Copies any predicate locks for the old page to the new page. 
 * Skip if this is a temporary table or toast table. 
 * 
 * NOTE: A page split (or overflow) affects all serializable transactions, 
 * even if it occurs in the context of another transaction isolation level. 
 * 
 * NOTE: This currently leaves the local copy of the locks without 
 * information on the new lock which is in shared memory.  This could cause 
 * problems if enough page splits occur on locked pages without the processes 
 * which hold the locks getting in and noticing. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN3091"></a><span class='Declare_Function'>PredicateLockPageSplit</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>relation</span><span class='Delimiter'>, </span><a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Parameter'>oldblkno</span><span class='Delimiter'>, 
</span><a name="LN3092"></a>                       <a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Parameter'>newblkno</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3094"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Declare_Local'>oldtargettag</span><span class='Delimiter'>; 
</span><a name="LN3095"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Declare_Local'>newtargettag</span><span class='Delimiter'>; 
</span><a name="LN3096"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>success</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Bail out quickly if there are no serializable transactions running. 
     * 
     * It's safe to do this check without taking any additional locks. Even if 
     * a serializable transaction starts concurrently, we know it can't take 
     * any SIREAD locks on the page being split because the caller is holding 
     * the associated buffer page lock. Memory reordering isn't an issue; the 
     * memory barrier in the LWLock acquisition guarantees that this read 
     * occurs while the buffer page lock is held. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN155"><span class='Ref_to_Member'>SxactGlobalXmin</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN476"><span class='Ref_to_Func'>PredicateLockingNeededForRelation</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3091"><span class='Ref_to_Parameter'>relation</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN3091"><span class='Ref_to_Parameter'>oldblkno</span></a> <span class='Operator'>!= </span><a href="predicate.c.html#LN3092"><span class='Ref_to_Parameter'>newblkno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/block.h.html#LN69"><span class='Ref_to_Macro'>BlockNumberIsValid</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3091"><span class='Ref_to_Parameter'>oldblkno</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/block.h.html#LN69"><span class='Ref_to_Macro'>BlockNumberIsValid</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3092"><span class='Ref_to_Parameter'>newblkno</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/predicate_internals.h.html#LN395"><span class='Ref_to_Macro'>SET_PREDICATELOCKTARGETTAG_PAGE</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3094"><span class='Ref_To_Local'>oldtargettag</span></a><span class='Delimiter'>, 
</span>                                    <a href="predicate.c.html#LN3091"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN84"><span class='Ref_to_Member'>rd_node</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN59"><span class='Ref_to_Member'>dbNode</span></a><span class='Delimiter'>, 
</span>                                    <a href="predicate.c.html#LN3091"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN115"><span class='Ref_to_Member'>rd_id</span></a><span class='Delimiter'>, 
</span>                                    <a href="predicate.c.html#LN3091"><span class='Ref_to_Parameter'>oldblkno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/predicate_internals.h.html#LN395"><span class='Ref_to_Macro'>SET_PREDICATELOCKTARGETTAG_PAGE</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3095"><span class='Ref_To_Local'>newtargettag</span></a><span class='Delimiter'>, 
</span>                                    <a href="predicate.c.html#LN3091"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN84"><span class='Ref_to_Member'>rd_node</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN59"><span class='Ref_to_Member'>dbNode</span></a><span class='Delimiter'>, 
</span>                                    <a href="predicate.c.html#LN3091"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN115"><span class='Ref_to_Member'>rd_id</span></a><span class='Delimiter'>, 
</span>                                    <a href="predicate.c.html#LN3092"><span class='Ref_to_Parameter'>newblkno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SerializablePredicateLockListLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Try copying the locks over to the new page's tag, creating it if 
     * necessary. 
     */ 
</span>    <a href="predicate.c.html#LN3096"><span class='Ref_To_Local'>success</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN453"><span class='Ref_to_Proto'>TransferPredicateLocksToNewTarget</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3094"><span class='Ref_To_Local'>oldtargettag</span></a><span class='Delimiter'>, 
</span>                                                <a href="predicate.c.html#LN3095"><span class='Ref_To_Local'>newtargettag</span></a><span class='Delimiter'>, 
</span>                                                <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN3096"><span class='Ref_To_Local'>success</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * No more predicate lock entries are available. Failure isn't an 
         * option here, so promote the page lock to a relation lock. 
         */ 
</span> 
        <span class='Comment_Multi_Line'>/* Get the parent relation lock's lock tag */ 
</span>        <a href="predicate.c.html#LN3096"><span class='Ref_To_Local'>success</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN438"><span class='Ref_to_Proto'>GetParentPredicateLockTag</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN3094"><span class='Ref_To_Local'>oldtargettag</span></a><span class='Delimiter'>, 
</span>                                            <span class='Operator'>&</span><a href="predicate.c.html#LN3095"><span class='Ref_To_Local'>newtargettag</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN3096"><span class='Ref_To_Local'>success</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Move the locks to the parent. This shouldn't fail. 
         * 
         * Note that here we are removing locks held by other backends, 
         * leading to a possible inconsistency in their local lock hash table. 
         * This is OK because we're replacing it with a lock that covers the 
         * old one. 
         */ 
</span>        <a href="predicate.c.html#LN3096"><span class='Ref_To_Local'>success</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN453"><span class='Ref_to_Proto'>TransferPredicateLocksToNewTarget</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3094"><span class='Ref_To_Local'>oldtargettag</span></a><span class='Delimiter'>, 
</span>                                                    <a href="predicate.c.html#LN3095"><span class='Ref_To_Local'>newtargettag</span></a><span class='Delimiter'>, 
</span>                                                    <span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN3096"><span class='Ref_To_Local'>success</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !success &raquo; </span> 
 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializablePredicateLockListLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end PredicateLockPageSplit &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *      PredicateLockPageCombine 
 * 
 * Combines predicate locks for two existing pages. 
 * Skip if this is a temporary table or toast table. 
 * 
 * NOTE: A page combine affects all serializable transactions, even if it 
 * occurs in the context of another transaction isolation level. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN3176"></a><span class='Declare_Function'>PredicateLockPageCombine</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>relation</span><span class='Delimiter'>, </span><a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Parameter'>oldblkno</span><span class='Delimiter'>, 
</span><a name="LN3177"></a>                         <a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Parameter'>newblkno</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * Page combines differ from page splits in that we ought to be able to 
     * remove the locks on the old page after transferring them to the new 
     * page, instead of duplicating them. However, because we can't edit other 
     * backends' local lock tables, removing the old lock would leave them 
     * with an entry in their LocalPredicateLockHash for a lock they're not 
     * holding, which isn't acceptable. So we wind up having to do the same 
     * work as a page split, acquiring a lock on the new page and keeping the 
     * old page locked too. That can lead to some false positives, but should 
     * be rare in practice. 
     */ 
</span>    <a href="../../../include/storage/predicate.h.html#LN53"><span class='Ref_to_Proto'>PredicateLockPageSplit</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3176"><span class='Ref_to_Parameter'>relation</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN3176"><span class='Ref_to_Parameter'>oldblkno</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN3177"><span class='Ref_to_Parameter'>newblkno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Walk the list of in-progress serializable transactions and find the new 
 * xmin. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3198"></a><span class='Declare_Function'>SetNewSxactGlobalXmin</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3200"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sxact</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN151"><span class='Ref_to_Proto'>LWLockHeldByMe</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN155"><span class='Ref_to_Member'>SxactGlobalXmin</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN157"><span class='Ref_to_Member'>SxactGlobalXminCount</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN3200"><span class='Ref_To_Local'>sxact</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN417"><span class='Ref_to_Proto'>FirstPredXact</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; </span><a href="predicate.c.html#LN3200"><span class='Ref_To_Local'>sxact</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; </span><a href="predicate.c.html#LN3200"><span class='Ref_To_Local'>sxact</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN418"><span class='Ref_to_Proto'>NextPredXact</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3200"><span class='Ref_To_Local'>sxact</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN265"><span class='Ref_to_Macro'>SxactIsRolledBack</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3200"><span class='Ref_To_Local'>sxact</span></a><span class='Parentheses'>) 
</span>            <span class='Operator'>&& !</span><a href="predicate.c.html#LN263"><span class='Ref_to_Macro'>SxactIsCommitted</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3200"><span class='Ref_To_Local'>sxact</span></a><span class='Parentheses'>) 
</span>            <span class='Operator'>&& </span><a href="predicate.c.html#LN3200"><span class='Ref_To_Local'>sxact</span></a> <span class='Operator'>!= </span><a href="predicate.c.html#LN351"><span class='Ref_to_Global_Var'>OldCommittedSxact</span></a><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN3200"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN104"><span class='Ref_to_Member'>xmin</span></a> <span class='Operator'>!= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN155"><span class='Ref_to_Member'>SxactGlobalXmin</span></a><span class='Parentheses'>) 
</span>                <span class='Operator'>|| </span><a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3200"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN104"><span class='Ref_to_Member'>xmin</span></a><span class='Delimiter'>, 
</span>                                         <a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN155"><span class='Ref_to_Member'>SxactGlobalXmin</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN155"><span class='Ref_to_Member'>SxactGlobalXmin</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN3200"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN104"><span class='Ref_to_Member'>xmin</span></a><span class='Delimiter'>; 
</span>                <a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN157"><span class='Ref_to_Member'>SxactGlobalXminCount</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN42"><span class='Ref_to_Macro'>TransactionIdEquals</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3200"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN104"><span class='Ref_to_Member'>xmin</span></a><span class='Delimiter'>, 
</span>                                         <a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN155"><span class='Ref_to_Member'>SxactGlobalXmin</span></a><span class='Parentheses'>))</span> 
                <a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN157"><span class='Ref_to_Member'>SxactGlobalXminCount</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="predicate.c.html#LN430"><span class='Ref_to_Proto'>OldSerXidSetActiveSerXmin</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN155"><span class='Ref_to_Member'>SxactGlobalXmin</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end SetNewSxactGlobalXmin &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *      ReleasePredicateLocks 
 * 
 * Releases predicate locks based on completion of the current transaction, 
 * whether committed or rolled back.  It can also be called for a read only 
 * transaction when it becomes impossible for the transaction to become 
 * part of a dangerous structure. 
 * 
 * We do nothing unless this is a serializable transaction. 
 * 
 * This method must ensure that shared memory hash tables are cleaned 
 * up in some relatively timely fashion. 
 * 
 * If this transaction is committing and is holding any predicate locks, 
 * it must be added to a list of completed serializable transactions still 
 * holding locks. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN3248"></a><span class='Declare_Function'>ReleasePredicateLocks</span><span class='Parentheses'>(</span><span class='Keyword'>bool </span><span class='Declare_Parameter'>isCommit</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3250"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>needToClear</span><span class='Delimiter'>; 
</span><a name="LN3251"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a>  <span class='Declare_Local'>conflict</span><span class='Delimiter'>, 
</span><a name="LN3252"></a>                <span class='Declare_Local'>nextConflict</span><span class='Delimiter'>, 
</span><a name="LN3253"></a>                <span class='Declare_Local'>possibleUnsafeConflict</span><span class='Delimiter'>; 
</span><a name="LN3254"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Local'>roXact</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We can't trust XactReadOnly here, because a transaction which started 
     * as READ WRITE can show as READ ONLY later, e.g., within 
     * subtransactions.  We want to flag a transaction as READ ONLY if it 
     * commits without writing so that de facto READ ONLY transactions get the 
     * benefit of some RO optimizations, so we will use this local variable to 
     * get some cleanup logic right which is based on whether the transaction 
     * was declared READ ONLY at the top level. 
     */ 
</span><a name="LN3265"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>topLevelIsDeclaredReadOnly</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a> <span class='Operator'>== </span><a href="../../../include/storage/predicate_internals.h.html#LN468"><span class='Ref_to_Const'>InvalidSerializableXact</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN403"><span class='Ref_to_Global_Var'>LocalPredicateLockHash</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN3248"><span class='Ref_to_Parameter'>isCommit</span></a> <span class='Operator'>|| </span><a href="predicate.c.html#LN264"><span class='Ref_to_Macro'>SxactIsPrepared</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN3248"><span class='Ref_to_Parameter'>isCommit</span></a> <span class='Operator'>|| !</span><a href="predicate.c.html#LN266"><span class='Ref_to_Macro'>SxactIsDoomed</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN263"><span class='Ref_to_Macro'>SxactIsCommitted</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN265"><span class='Ref_to_Macro'>SxactIsRolledBack</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* may not be serializable during COMMIT/ROLLBACK PREPARED */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN106"><span class='Ref_to_Member'>pid</span></a> <span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>|| </span><a href="../../../include/access/xact.h.html#LN43"><span class='Ref_to_Macro'>IsolationIsSerializable</span></a><span class='Parentheses'>())</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* We'd better not already be on the cleanup list. */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN253"><span class='Ref_to_Macro'>SxactIsOnFinishedList</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN3265"><span class='Ref_To_Local'>topLevelIsDeclaredReadOnly</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN267"><span class='Ref_to_Macro'>SxactIsReadOnly</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We don't hold XidGenLock lock here, assuming that TransactionId is 
     * atomic! 
     * 
     * If this value is changing, we don't care that much whether we get the 
     * old or new value -- it is just used to determine how far 
     * GlobalSerializableXmin must advance before this transaction can be 
     * fully cleaned up.  The worst that could happen is we wait for one more 
     * transaction to complete before freeing some RAM; correctness of visible 
     * behavior is not affected. 
     */ 
</span>    <a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN101"><span class='Ref_to_Member'>finishedBefore</span></a> <span class='Operator'>= </span><a href="../../access/transam/varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN116"><span class='Ref_to_Member'>nextXid</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If it's not a commit it's a rollback, and we can clear our locks 
     * immediately. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN3248"><span class='Ref_to_Parameter'>isCommit</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN105"><span class='Ref_to_Member'>flags</span></a> <span class='Operator'>|= </span><a href="../../../include/storage/predicate_internals.h.html#LN109"><span class='Ref_to_Const'>SXACT_FLAG_COMMITTED</span></a><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN75"><span class='Ref_to_Member'>commitSeqNo</span></a> <span class='Operator'>= ++</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN161"><span class='Ref_to_Member'>LastSxactCommitSeqNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Recognize implicit read-only transaction (commit without write). */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN411"><span class='Ref_to_Global_Var'>MyXactDidWrite</span></a><span class='Parentheses'>) 
</span>            <a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN105"><span class='Ref_to_Member'>flags</span></a> <span class='Operator'>|= </span><a href="../../../include/storage/predicate_internals.h.html#LN119"><span class='Ref_to_Const'>SXACT_FLAG_READ_ONLY</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * The DOOMED flag indicates that we intend to roll back this 
         * transaction and so it should not cause serialization failures for 
         * other transactions that conflict with it. Note that this flag might 
         * already be set, if another backend marked this transaction for 
         * abort. 
         * 
         * The ROLLED_BACK flag further indicates that ReleasePredicateLocks 
         * has been called, and so the SerializableXact is eligible for 
         * cleanup. This means it should not be considered when calculating 
         * SxactGlobalXmin. 
         */ 
</span>        <a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN105"><span class='Ref_to_Member'>flags</span></a> <span class='Operator'>|= </span><a href="../../../include/storage/predicate_internals.h.html#LN112"><span class='Ref_to_Const'>SXACT_FLAG_DOOMED</span></a><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN105"><span class='Ref_to_Member'>flags</span></a> <span class='Operator'>|= </span><a href="../../../include/storage/predicate_internals.h.html#LN111"><span class='Ref_to_Const'>SXACT_FLAG_ROLLED_BACK</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If the transaction was previously prepared, but is now failing due 
         * to a ROLLBACK PREPARED or (hopefully very rare) error after the 
         * prepare, clear the prepared flag.  This simplifies conflict 
         * checking. 
         */ 
</span>        <a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN105"><span class='Ref_to_Member'>flags</span></a> <span class='Operator'>&= ~</span><a href="../../../include/storage/predicate_internals.h.html#LN110"><span class='Ref_to_Const'>SXACT_FLAG_PREPARED</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN3265"><span class='Ref_To_Local'>topLevelIsDeclaredReadOnly</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN159"><span class='Ref_to_Member'>WritableSxactCount</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>--</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN159"><span class='Ref_to_Member'>WritableSxactCount</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Release predicate locks and rw-conflicts in for all committed 
             * transactions.  There are no longer any transactions which might 
             * conflict with the locks and no chance for new transactions to 
             * overlap.  Similarly, existing conflicts in can't cause pivots, 
             * and any conflicts in which could have completed a dangerous 
             * structure would already have caused a rollback, so any 
             * remaining ones must be benign. 
             */ 
</span>            <a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN166"><span class='Ref_to_Member'>CanPartialClearThrough</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN161"><span class='Ref_to_Member'>LastSxactCommitSeqNo</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Read-only transactions: clear the list of transactions that might 
         * make us unsafe. Note that we use 'inLink' for the iteration as 
         * opposed to 'outLink' for the r/w xacts. 
         */ 
</span>        <a href="predicate.c.html#LN3253"><span class='Ref_To_Local'>possibleUnsafeConflict</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN97"><span class='Ref_to_Member'>possibleUnsafeConflicts</span></a><span class='Delimiter'>, 
</span>                         <span class='Operator'>&</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN97"><span class='Ref_to_Member'>possibleUnsafeConflicts</span></a><span class='Delimiter'>, 
</span>                         <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN194"><span class='Ref_to_Struct'>RWConflictData</span></a><span class='Delimiter'>, </span>inLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN3253"><span class='Ref_To_Local'>possibleUnsafeConflict</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="predicate.c.html#LN3252"><span class='Ref_To_Local'>nextConflict</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a><span class='Parentheses'>) 
</span>                <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN97"><span class='Ref_to_Member'>possibleUnsafeConflicts</span></a><span class='Delimiter'>, 
</span>                             <span class='Operator'>&</span><a href="predicate.c.html#LN3253"><span class='Ref_To_Local'>possibleUnsafeConflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN197"><span class='Ref_to_Member'>inLink</span></a><span class='Delimiter'>, 
</span>                             <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN194"><span class='Ref_to_Struct'>RWConflictData</span></a><span class='Delimiter'>, </span>inLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN267"><span class='Ref_to_Macro'>SxactIsReadOnly</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3253"><span class='Ref_To_Local'>possibleUnsafeConflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN198"><span class='Ref_to_Member'>sxactOut</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a> <span class='Operator'>== </span><a href="predicate.c.html#LN3253"><span class='Ref_To_Local'>possibleUnsafeConflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN199"><span class='Ref_to_Member'>sxactIn</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="predicate.c.html#LN423"><span class='Ref_to_Proto'>ReleaseRWConflict</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3253"><span class='Ref_To_Local'>possibleUnsafeConflict</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="predicate.c.html#LN3253"><span class='Ref_To_Local'>possibleUnsafeConflict</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN3252"><span class='Ref_To_Local'>nextConflict</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Check for conflict out to old committed transactions. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN3248"><span class='Ref_to_Parameter'>isCommit</span></a> 
        <span class='Operator'>&& !</span><a href="predicate.c.html#LN267"><span class='Ref_to_Macro'>SxactIsReadOnly</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>&& </span><a href="predicate.c.html#LN269"><span class='Ref_to_Macro'>SxactHasSummaryConflictOut</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * we don't know which old committed transaction we conflicted with, 
         * so be conservative and use FirstNormalSerCommitSeqNo here 
         */ 
</span>        <a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN84"><span class='Ref_to_Member'>SeqNo</span></a><span class='Operator'>.</span>earliestOutConflictCommit <span class='Operator'>= 
</span>            <a href="../../../include/storage/predicate_internals.h.html#LN37"><span class='Ref_to_Const'>FirstNormalSerCommitSeqNo</span></a><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN105"><span class='Ref_to_Member'>flags</span></a> <span class='Operator'>|= </span><a href="../../../include/storage/predicate_internals.h.html#LN118"><span class='Ref_to_Const'>SXACT_FLAG_CONFLICT_OUT</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Release all outConflicts to committed transactions.  If we're rolling 
     * back clear them all.  Set SXACT_FLAG_CONFLICT_OUT if any point to 
     * previously committed transactions. 
     */ 
</span>    <a href="predicate.c.html#LN3251"><span class='Ref_To_Local'>conflict</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN85"><span class='Ref_to_Member'>outConflicts</span></a><span class='Delimiter'>, 
</span>                     <span class='Operator'>&</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN85"><span class='Ref_to_Member'>outConflicts</span></a><span class='Delimiter'>, 
</span>                     <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN194"><span class='Ref_to_Struct'>RWConflictData</span></a><span class='Delimiter'>, </span>outLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN3251"><span class='Ref_To_Local'>conflict</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="predicate.c.html#LN3252"><span class='Ref_To_Local'>nextConflict</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN85"><span class='Ref_to_Member'>outConflicts</span></a><span class='Delimiter'>, 
</span>                         <span class='Operator'>&</span><a href="predicate.c.html#LN3251"><span class='Ref_To_Local'>conflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN196"><span class='Ref_to_Member'>outLink</span></a><span class='Delimiter'>, 
</span>                         <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN194"><span class='Ref_to_Struct'>RWConflictData</span></a><span class='Delimiter'>, </span>outLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN3248"><span class='Ref_to_Parameter'>isCommit</span></a> 
            <span class='Operator'>&& !</span><a href="predicate.c.html#LN267"><span class='Ref_to_Macro'>SxactIsReadOnly</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Parentheses'>) 
</span>            <span class='Operator'>&& </span><a href="predicate.c.html#LN263"><span class='Ref_to_Macro'>SxactIsCommitted</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3251"><span class='Ref_To_Local'>conflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN199"><span class='Ref_to_Member'>sxactIn</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN105"><span class='Ref_to_Member'>flags</span></a> <span class='Operator'>& </span><a href="../../../include/storage/predicate_internals.h.html#LN118"><span class='Ref_to_Const'>SXACT_FLAG_CONFLICT_OUT</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span> 
                <span class='Operator'>|| </span><a href="predicate.c.html#LN3251"><span class='Ref_To_Local'>conflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN199"><span class='Ref_to_Member'>sxactIn</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN74"><span class='Ref_to_Member'>prepareSeqNo</span></a> <span class='Operator'>&LT; </span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN84"><span class='Ref_to_Member'>SeqNo</span></a><span class='Operator'>.</span>earliestOutConflictCommit<span class='Parentheses'>)</span> 
                <a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN84"><span class='Ref_to_Member'>SeqNo</span></a><span class='Operator'>.</span>earliestOutConflictCommit <span class='Operator'>= </span><a href="predicate.c.html#LN3251"><span class='Ref_To_Local'>conflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN199"><span class='Ref_to_Member'>sxactIn</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN74"><span class='Ref_to_Member'>prepareSeqNo</span></a><span class='Delimiter'>; 
</span>            <a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN105"><span class='Ref_to_Member'>flags</span></a> <span class='Operator'>|= </span><a href="../../../include/storage/predicate_internals.h.html#LN118"><span class='Ref_to_Const'>SXACT_FLAG_CONFLICT_OUT</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN3248"><span class='Ref_to_Parameter'>isCommit</span></a> 
            <span class='Operator'>|| </span><a href="predicate.c.html#LN263"><span class='Ref_to_Macro'>SxactIsCommitted</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3251"><span class='Ref_To_Local'>conflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN199"><span class='Ref_to_Member'>sxactIn</span></a><span class='Parentheses'>) 
</span>            <span class='Operator'>|| </span><span class='Parentheses'>(</span><a href="predicate.c.html#LN3251"><span class='Ref_To_Local'>conflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN199"><span class='Ref_to_Member'>sxactIn</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN84"><span class='Ref_to_Member'>SeqNo</span></a><span class='Operator'>.</span>lastCommitBeforeSnapshot <span class='Operator'>&GT;= </span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN161"><span class='Ref_to_Member'>LastSxactCommitSeqNo</span></a><span class='Parentheses'>))</span> 
            <a href="predicate.c.html#LN423"><span class='Ref_to_Proto'>ReleaseRWConflict</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3251"><span class='Ref_To_Local'>conflict</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="predicate.c.html#LN3251"><span class='Ref_To_Local'>conflict</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN3252"><span class='Ref_To_Local'>nextConflict</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while conflict &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Release all inConflicts from committed and read-only transactions. If 
     * we're rolling back, clear them all. 
     */ 
</span>    <a href="predicate.c.html#LN3251"><span class='Ref_To_Local'>conflict</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN87"><span class='Ref_to_Member'>inConflicts</span></a><span class='Delimiter'>, 
</span>                     <span class='Operator'>&</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN87"><span class='Ref_to_Member'>inConflicts</span></a><span class='Delimiter'>, 
</span>                     <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN194"><span class='Ref_to_Struct'>RWConflictData</span></a><span class='Delimiter'>, </span>inLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN3251"><span class='Ref_To_Local'>conflict</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="predicate.c.html#LN3252"><span class='Ref_To_Local'>nextConflict</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN87"><span class='Ref_to_Member'>inConflicts</span></a><span class='Delimiter'>, 
</span>                         <span class='Operator'>&</span><a href="predicate.c.html#LN3251"><span class='Ref_To_Local'>conflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN197"><span class='Ref_to_Member'>inLink</span></a><span class='Delimiter'>, 
</span>                         <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN194"><span class='Ref_to_Struct'>RWConflictData</span></a><span class='Delimiter'>, </span>inLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN3248"><span class='Ref_to_Parameter'>isCommit</span></a> 
            <span class='Operator'>|| </span><a href="predicate.c.html#LN263"><span class='Ref_to_Macro'>SxactIsCommitted</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3251"><span class='Ref_To_Local'>conflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN198"><span class='Ref_to_Member'>sxactOut</span></a><span class='Parentheses'>) 
</span>            <span class='Operator'>|| </span><a href="predicate.c.html#LN267"><span class='Ref_to_Macro'>SxactIsReadOnly</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3251"><span class='Ref_To_Local'>conflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN198"><span class='Ref_to_Member'>sxactOut</span></a><span class='Parentheses'>))</span> 
            <a href="predicate.c.html#LN423"><span class='Ref_to_Proto'>ReleaseRWConflict</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3251"><span class='Ref_To_Local'>conflict</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="predicate.c.html#LN3251"><span class='Ref_To_Local'>conflict</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN3252"><span class='Ref_To_Local'>nextConflict</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN3265"><span class='Ref_To_Local'>topLevelIsDeclaredReadOnly</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Remove ourselves from the list of possible conflicts for concurrent 
         * READ ONLY transactions, flagging them as unsafe if we have a 
         * conflict out. If any are waiting DEFERRABLE transactions, wake them 
         * up if they are known safe or known unsafe. 
         */ 
</span>        <a href="predicate.c.html#LN3253"><span class='Ref_To_Local'>possibleUnsafeConflict</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN97"><span class='Ref_to_Member'>possibleUnsafeConflicts</span></a><span class='Delimiter'>, 
</span>                         <span class='Operator'>&</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN97"><span class='Ref_to_Member'>possibleUnsafeConflicts</span></a><span class='Delimiter'>, 
</span>                         <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN194"><span class='Ref_to_Struct'>RWConflictData</span></a><span class='Delimiter'>, </span>outLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN3253"><span class='Ref_To_Local'>possibleUnsafeConflict</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="predicate.c.html#LN3252"><span class='Ref_To_Local'>nextConflict</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a><span class='Parentheses'>) 
</span>                <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN97"><span class='Ref_to_Member'>possibleUnsafeConflicts</span></a><span class='Delimiter'>, 
</span>                             <span class='Operator'>&</span><a href="predicate.c.html#LN3253"><span class='Ref_To_Local'>possibleUnsafeConflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN196"><span class='Ref_to_Member'>outLink</span></a><span class='Delimiter'>, 
</span>                             <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN194"><span class='Ref_to_Struct'>RWConflictData</span></a><span class='Delimiter'>, </span>outLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <a href="predicate.c.html#LN3254"><span class='Ref_To_Local'>roXact</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN3253"><span class='Ref_To_Local'>possibleUnsafeConflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN199"><span class='Ref_to_Member'>sxactIn</span></a><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a> <span class='Operator'>== </span><a href="predicate.c.html#LN3253"><span class='Ref_To_Local'>possibleUnsafeConflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN198"><span class='Ref_to_Member'>sxactOut</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN267"><span class='Ref_to_Macro'>SxactIsReadOnly</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3254"><span class='Ref_To_Local'>roXact</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Mark conflicted if necessary. */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN3248"><span class='Ref_to_Parameter'>isCommit</span></a> 
                <span class='Operator'>&& </span><a href="predicate.c.html#LN411"><span class='Ref_to_Global_Var'>MyXactDidWrite</span></a> 
                <span class='Operator'>&& </span><a href="predicate.c.html#LN275"><span class='Ref_to_Macro'>SxactHasConflictOut</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Parentheses'>) 
</span>                <span class='Operator'>&& </span><span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN84"><span class='Ref_to_Member'>SeqNo</span></a><span class='Operator'>.</span>earliestOutConflictCommit 
                    <span class='Operator'>&LT;= </span><a href="predicate.c.html#LN3254"><span class='Ref_To_Local'>roXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN84"><span class='Ref_to_Member'>SeqNo</span></a><span class='Operator'>.</span>lastCommitBeforeSnapshot<span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * This releases possibleUnsafeConflict (as well as all other 
                 * possible conflicts for roXact) 
                 */ 
</span>                <a href="predicate.c.html#LN424"><span class='Ref_to_Proto'>FlagSxactUnsafe</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3254"><span class='Ref_To_Local'>roXact</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <a href="predicate.c.html#LN423"><span class='Ref_to_Proto'>ReleaseRWConflict</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3253"><span class='Ref_To_Local'>possibleUnsafeConflict</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * If we were the last possible conflict, flag it safe. The 
                 * transaction can now safely release its predicate locks (but 
                 * that transaction's backend has to do that itself). 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/shmem.h.html#LN76"><span class='Ref_to_Proto'>SHMQueueEmpty</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN3254"><span class='Ref_To_Local'>roXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN97"><span class='Ref_to_Member'>possibleUnsafeConflicts</span></a><span class='Parentheses'>))</span> 
                    <a href="predicate.c.html#LN3254"><span class='Ref_To_Local'>roXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN105"><span class='Ref_to_Member'>flags</span></a> <span class='Operator'>|= </span><a href="../../../include/storage/predicate_internals.h.html#LN121"><span class='Ref_to_Const'>SXACT_FLAG_RO_SAFE</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Wake up the process for a waiting DEFERRABLE transaction if we 
             * now know it's either safe or conflicted. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN276"><span class='Ref_to_Macro'>SxactIsDeferrableWaiting</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3254"><span class='Ref_To_Local'>roXact</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>                <span class='Parentheses'>(</span><a href="predicate.c.html#LN278"><span class='Ref_to_Macro'>SxactIsROUnsafe</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3254"><span class='Ref_To_Local'>roXact</span></a><span class='Parentheses'>) </span><span class='Operator'>|| </span><a href="predicate.c.html#LN277"><span class='Ref_to_Macro'>SxactIsROSafe</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3254"><span class='Ref_To_Local'>roXact</span></a><span class='Parentheses'>)))</span> 
                <a href="../../../include/storage/proc.h.html#LN308"><span class='Ref_to_Proto'>ProcSendSignal</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3254"><span class='Ref_To_Local'>roXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN106"><span class='Ref_to_Member'>pid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="predicate.c.html#LN3253"><span class='Ref_To_Local'>possibleUnsafeConflict</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN3252"><span class='Ref_To_Local'>nextConflict</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while possibleUnsafeConflic... &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !topLevelIsDeclaredRe... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Check whether it's time to clean up old transactions. This can only be 
     * done when the last serializable transaction with the oldest xmin among 
     * serializable transactions completes.  We then find the "new oldest" 
     * xmin and purge any transactions which finished before this transaction 
     * was launched. 
     */ 
</span>    <a href="predicate.c.html#LN3250"><span class='Ref_To_Local'>needToClear</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN42"><span class='Ref_to_Macro'>TransactionIdEquals</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN104"><span class='Ref_to_Member'>xmin</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN155"><span class='Ref_to_Member'>SxactGlobalXmin</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN157"><span class='Ref_to_Member'>SxactGlobalXminCount</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>--</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN157"><span class='Ref_to_Member'>SxactGlobalXminCount</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <a href="predicate.c.html#LN459"><span class='Ref_to_Proto'>SetNewSxactGlobalXmin</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <a href="predicate.c.html#LN3250"><span class='Ref_To_Local'>needToClear</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SerializableFinishedListLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Add this to the list of transactions to check for later cleanup. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN3248"><span class='Ref_to_Parameter'>isCommit</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/shmem.h.html#LN70"><span class='Ref_to_Proto'>SHMQueueInsertBefore</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN388"><span class='Ref_to_Global_Var'>FinishedSerializableTransactions</span></a><span class='Delimiter'>, 
</span>                             <span class='Operator'>&</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN90"><span class='Ref_to_Member'>finishedLink</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN3248"><span class='Ref_to_Parameter'>isCommit</span></a><span class='Parentheses'>) 
</span>        <a href="predicate.c.html#LN461"><span class='Ref_to_Proto'>ReleaseOneSerializableXact</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableFinishedListLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN3250"><span class='Ref_To_Local'>needToClear</span></a><span class='Parentheses'>) 
</span>        <a href="predicate.c.html#LN460"><span class='Ref_to_Proto'>ClearOldPredicateLocks</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a> <span class='Operator'>= </span><a href="../../../include/storage/predicate_internals.h.html#LN468"><span class='Ref_to_Const'>InvalidSerializableXact</span></a><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN411"><span class='Ref_to_Global_Var'>MyXactDidWrite</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Delete per-transaction lock table */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN403"><span class='Ref_to_Global_Var'>LocalPredicateLockHash</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/utils/hsearch.h.html#LN123"><span class='Ref_to_Proto'>hash_destroy</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN403"><span class='Ref_to_Global_Var'>LocalPredicateLockHash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN403"><span class='Ref_to_Global_Var'>LocalPredicateLockHash</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end ReleasePredicateLocks &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Clear old predicate locks, belonging to committed transactions that are no 
 * longer interesting to any in-progress transaction. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3566"></a><span class='Declare_Function'>ClearOldPredicateLocks</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3568"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Local'>finishedSxact</span><span class='Delimiter'>; 
</span><a name="LN3569"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Declare_Local'>predlock</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Loop through finished transactions. They are in commit order, so we can 
     * stop as soon as we find one that's still interesting. 
     */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SerializableFinishedListLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN3568"><span class='Ref_To_Local'>finishedSxact</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN388"><span class='Ref_to_Global_Var'>FinishedSerializableTransactions</span></a><span class='Delimiter'>, 
</span>                     <a href="predicate.c.html#LN388"><span class='Ref_to_Global_Var'>FinishedSerializableTransactions</span></a><span class='Delimiter'>, 
</span>                     <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a><span class='Delimiter'>, </span>finishedLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN3568"><span class='Ref_To_Local'>finishedSxact</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3583"></a>        <a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Local'>nextSxact</span><span class='Delimiter'>; 
</span> 
        <a href="predicate.c.html#LN3583"><span class='Ref_To_Local'>nextSxact</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN388"><span class='Ref_to_Global_Var'>FinishedSerializableTransactions</span></a><span class='Delimiter'>, 
</span>                         <span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN3568"><span class='Ref_To_Local'>finishedSxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN90"><span class='Ref_to_Member'>finishedLink</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a><span class='Delimiter'>, </span>finishedLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN155"><span class='Ref_to_Member'>SxactGlobalXmin</span></a><span class='Parentheses'>) 
</span>            <span class='Operator'>|| </span><a href="../../../include/access/transam.h.html#LN169"><span class='Ref_to_Proto'>TransactionIdPrecedesOrEquals</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3568"><span class='Ref_To_Local'>finishedSxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN101"><span class='Ref_to_Member'>finishedBefore</span></a><span class='Delimiter'>, 
</span>                                             <a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN155"><span class='Ref_to_Member'>SxactGlobalXmin</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * This transaction committed before any in-progress transaction 
             * took its snapshot. It's no longer interesting. 
             */ 
</span>            <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../ipc/shmqueue.c.html#LN66"><span class='Ref_to_Func'>SHMQueueDelete</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN3568"><span class='Ref_To_Local'>finishedSxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN90"><span class='Ref_to_Member'>finishedLink</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="predicate.c.html#LN461"><span class='Ref_to_Proto'>ReleaseOneSerializableXact</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3568"><span class='Ref_To_Local'>finishedSxact</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN3568"><span class='Ref_To_Local'>finishedSxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN75"><span class='Ref_to_Member'>commitSeqNo</span></a> <span class='Operator'>&GT; </span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN171"><span class='Ref_to_Member'>HavePartialClearedThrough</span></a> 
           <span class='Operator'>&& </span><a href="predicate.c.html#LN3568"><span class='Ref_To_Local'>finishedSxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN75"><span class='Ref_to_Member'>commitSeqNo</span></a> <span class='Operator'>&LT;= </span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN166"><span class='Ref_to_Member'>CanPartialClearThrough</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Any active transactions that took their snapshot before this 
             * transaction committed are read-only, so we can clear part of 
             * its state. 
             */ 
</span>            <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN267"><span class='Ref_to_Macro'>SxactIsReadOnly</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3568"><span class='Ref_To_Local'>finishedSxact</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* A read-only transaction can be removed entirely */ 
</span>                <a href="../ipc/shmqueue.c.html#LN66"><span class='Ref_to_Func'>SHMQueueDelete</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN3568"><span class='Ref_To_Local'>finishedSxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN90"><span class='Ref_to_Member'>finishedLink</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <a href="predicate.c.html#LN461"><span class='Ref_to_Proto'>ReleaseOneSerializableXact</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3568"><span class='Ref_To_Local'>finishedSxact</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * A read-write transaction can only be partially cleared. We 
                 * need to keep the SERIALIZABLEXACT but can release the 
                 * SIREAD locks and conflicts in. 
                 */ 
</span>                <a href="predicate.c.html#LN461"><span class='Ref_to_Proto'>ReleaseOneSerializableXact</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3568"><span class='Ref_To_Local'>finishedSxact</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN171"><span class='Ref_to_Member'>HavePartialClearedThrough</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN3568"><span class='Ref_To_Local'>finishedSxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN75"><span class='Ref_to_Member'>commitSeqNo</span></a><span class='Delimiter'>; 
</span>            <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if finishedSxact-&GT;commit... &raquo; </span> 
        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Still interesting. */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="predicate.c.html#LN3568"><span class='Ref_To_Local'>finishedSxact</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN3583"><span class='Ref_To_Local'>nextSxact</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while finishedSxact &raquo; </span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Loop through predicate locks on dummy transaction for summarized data. 
     */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SerializablePredicateLockListLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN3569"><span class='Ref_To_Local'>predlock</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN351"><span class='Ref_to_Global_Var'>OldCommittedSxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN89"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Delimiter'>, 
</span>                     <span class='Operator'>&</span><a href="predicate.c.html#LN351"><span class='Ref_to_Global_Var'>OldCommittedSxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN89"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Delimiter'>, 
</span>                     <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a><span class='Delimiter'>, </span>xactLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN3569"><span class='Ref_To_Local'>predlock</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3650"></a>        <a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Declare_Local'>nextpredlock</span><span class='Delimiter'>; 
</span><a name="LN3651"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>canDoPartialCleanup</span><span class='Delimiter'>; 
</span> 
        <a href="predicate.c.html#LN3650"><span class='Ref_To_Local'>nextpredlock</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN351"><span class='Ref_to_Global_Var'>OldCommittedSxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN89"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Delimiter'>, 
</span>                         <span class='Operator'>&</span><a href="predicate.c.html#LN3569"><span class='Ref_To_Local'>predlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN326"><span class='Ref_to_Member'>xactLink</span></a><span class='Delimiter'>, 
</span>                         <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a><span class='Delimiter'>, </span>xactLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN3569"><span class='Ref_To_Local'>predlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN328"><span class='Ref_to_Member'>commitSeqNo</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN3569"><span class='Ref_To_Local'>predlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN328"><span class='Ref_to_Member'>commitSeqNo</span></a> <span class='Operator'>!= </span><a href="../../../include/storage/predicate_internals.h.html#LN35"><span class='Ref_to_Const'>InvalidSerCommitSeqNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN3651"><span class='Ref_To_Local'>canDoPartialCleanup</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="predicate.c.html#LN3569"><span class='Ref_To_Local'>predlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN328"><span class='Ref_to_Member'>commitSeqNo</span></a> <span class='Operator'>&LT;= </span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN166"><span class='Ref_to_Member'>CanPartialClearThrough</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If this lock originally belonged to an old enough transaction, we 
         * can release it. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN3651"><span class='Ref_To_Local'>canDoPartialCleanup</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN3670"></a>            <a href="../../../include/storage/predicate_internals.h.html#LN303"><span class='Ref_to_Struct'>PREDICATELOCKTAG</span></a> <span class='Declare_Local'>tag</span><span class='Delimiter'>; 
</span><a name="LN3671"></a>            <a href="../../../include/storage/predicate_internals.h.html#LN285"><span class='Ref_to_Struct'>PREDICATELOCKTARGET</span></a> <span class='Operator'>*</span><span class='Declare_Local'>target</span><span class='Delimiter'>; 
</span><a name="LN3672"></a>            <a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Declare_Local'>targettag</span><span class='Delimiter'>; 
</span><a name="LN3673"></a>            <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>targettaghash</span><span class='Delimiter'>; 
</span><a name="LN3674"></a>            <a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>partitionLock</span><span class='Delimiter'>; 
</span> 
            <a href="predicate.c.html#LN3670"><span class='Ref_To_Local'>tag</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN3569"><span class='Ref_To_Local'>predlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN321"><span class='Ref_to_Member'>tag</span></a><span class='Delimiter'>; 
</span>            <a href="predicate.c.html#LN3671"><span class='Ref_To_Local'>target</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN3670"><span class='Ref_To_Local'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/predicate_internals.h.html#LN305"><span class='Ref_to_Member'>myTarget</span></a><span class='Delimiter'>; 
</span>            <a href="predicate.c.html#LN3672"><span class='Ref_To_Local'>targettag</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN3671"><span class='Ref_To_Local'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN288"><span class='Ref_to_Member'>tag</span></a><span class='Delimiter'>; 
</span>            <a href="predicate.c.html#LN3673"><span class='Ref_To_Local'>targettaghash</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN288"><span class='Ref_to_Macro'>PredicateLockTargetTagHashCode</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN3672"><span class='Ref_To_Local'>targettag</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="predicate.c.html#LN3674"><span class='Ref_To_Local'>partitionLock</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN244"><span class='Ref_to_Macro'>PredicateLockHashPartitionLock</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3673"><span class='Ref_To_Local'>targettaghash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3674"><span class='Ref_To_Local'>partitionLock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../ipc/shmqueue.c.html#LN66"><span class='Ref_to_Func'>SHMQueueDelete</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN3569"><span class='Ref_To_Local'>predlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN324"><span class='Ref_to_Member'>targetLink</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="../ipc/shmqueue.c.html#LN66"><span class='Ref_to_Func'>SHMQueueDelete</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN3569"><span class='Ref_To_Local'>predlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN326"><span class='Ref_to_Member'>xactLink</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/utils/hsearch.h.html#LN128"><span class='Ref_to_Proto'>hash_search_with_hash_value</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN387"><span class='Ref_to_Global_Var'>PredicateLockHash</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predicate.c.html#LN3670"><span class='Ref_To_Local'>tag</span></a><span class='Delimiter'>, 
</span>                                <a href="predicate.c.html#LN301"><span class='Ref_to_Macro'>PredicateLockHashCodeFromTargetHashCode</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN3670"><span class='Ref_To_Local'>tag</span></a><span class='Delimiter'>, 
</span>                                                              <a href="predicate.c.html#LN3673"><span class='Ref_To_Local'>targettaghash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                        <a href="../../../include/utils/hsearch.h.html#LN106"><span class='Ref_to_EnumConst'>HASH_REMOVE</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="predicate.c.html#LN443"><span class='Ref_to_Proto'>RemoveTargetIfNoLongerUsed</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3671"><span class='Ref_To_Local'>target</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN3673"><span class='Ref_To_Local'>targettaghash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3674"><span class='Ref_To_Local'>partitionLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if canDoPartialCleanup &raquo; </span> 
 
        <a href="predicate.c.html#LN3569"><span class='Ref_To_Local'>predlock</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN3650"><span class='Ref_To_Local'>nextpredlock</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while predlock &raquo; </span> 
 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializablePredicateLockListLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableFinishedListLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ClearOldPredicateLocks &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * This is the normal way to delete anything from any of the predicate 
 * locking hash tables.  Given a transaction which we know can be deleted: 
 * delete all predicate locks held by that transaction and any predicate 
 * lock targets which are now unreferenced by a lock; delete all conflicts 
 * for the transaction; delete all xid values for the transaction; then 
 * delete the transaction. 
 * 
 * When the partial flag is set, we can release all predicate locks and 
 * in-conflict information -- we've established that there are no longer 
 * any overlapping read write transactions for which this transaction could 
 * matter -- but keep the transaction entry itself and any outConflicts. 
 * 
 * When the summarize flag is set, we've run short of room for sxact data 
 * and must summarize to the SLRU.  Predicate locks are transferred to a 
 * dummy "old" transaction, with duplicate locks on a single target 
 * collapsing to a single lock with the "latest" commitSeqNo from among 
 * the conflicting locks.. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3723"></a><span class='Declare_Function'>ReleaseOneSerializableXact</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sxact</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>partial</span><span class='Delimiter'>, 
</span><a name="LN3724"></a>                           <span class='Keyword'>bool </span><span class='Declare_Parameter'>summarize</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3726"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Declare_Local'>predlock</span><span class='Delimiter'>; 
</span><a name="LN3727"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN223"><span class='Ref_to_Struct'>SERIALIZABLEXIDTAG</span></a> <span class='Declare_Local'>sxidtag</span><span class='Delimiter'>; 
</span><a name="LN3728"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a>  <span class='Declare_Local'>conflict</span><span class='Delimiter'>, 
</span><a name="LN3729"></a>                <span class='Declare_Local'>nextConflict</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN3723"><span class='Ref_to_Parameter'>sxact</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN265"><span class='Ref_to_Macro'>SxactIsRolledBack</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3723"><span class='Ref_to_Parameter'>sxact</span></a><span class='Parentheses'>) </span><span class='Operator'>|| </span><a href="predicate.c.html#LN263"><span class='Ref_to_Macro'>SxactIsCommitted</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3723"><span class='Ref_to_Parameter'>sxact</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN3723"><span class='Ref_to_Parameter'>partial</span></a> <span class='Operator'>|| !</span><a href="predicate.c.html#LN253"><span class='Ref_to_Macro'>SxactIsOnFinishedList</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3723"><span class='Ref_to_Parameter'>sxact</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN151"><span class='Ref_to_Proto'>LWLockHeldByMe</span></a><span class='Parentheses'>(</span>SerializableFinishedListLock<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * First release all the predicate locks held by this xact (or transfer 
     * them to OldCommittedSxact if summarize is true) 
     */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SerializablePredicateLockListLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN3726"><span class='Ref_To_Local'>predlock</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN3723"><span class='Ref_to_Parameter'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN89"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN3723"><span class='Ref_to_Parameter'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN89"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a><span class='Delimiter'>, </span>xactLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN3726"><span class='Ref_To_Local'>predlock</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3747"></a>        <a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Declare_Local'>nextpredlock</span><span class='Delimiter'>; 
</span><a name="LN3748"></a>        <a href="../../../include/storage/predicate_internals.h.html#LN303"><span class='Ref_to_Struct'>PREDICATELOCKTAG</span></a> <span class='Declare_Local'>tag</span><span class='Delimiter'>; 
</span><a name="LN3749"></a>        <a href="../../../include/storage/shmem.h.html#LN27"><span class='Ref_to_Struct'>SHM_QUEUE</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>targetLink</span><span class='Delimiter'>; 
</span><a name="LN3750"></a>        <a href="../../../include/storage/predicate_internals.h.html#LN285"><span class='Ref_to_Struct'>PREDICATELOCKTARGET</span></a> <span class='Operator'>*</span><span class='Declare_Local'>target</span><span class='Delimiter'>; 
</span><a name="LN3751"></a>        <a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Declare_Local'>targettag</span><span class='Delimiter'>; 
</span><a name="LN3752"></a>        <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>targettaghash</span><span class='Delimiter'>; 
</span><a name="LN3753"></a>        <a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>partitionLock</span><span class='Delimiter'>; 
</span> 
        <a href="predicate.c.html#LN3747"><span class='Ref_To_Local'>nextpredlock</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN3723"><span class='Ref_to_Parameter'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN89"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN3726"><span class='Ref_To_Local'>predlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN326"><span class='Ref_to_Member'>xactLink</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a><span class='Delimiter'>, </span>xactLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <a href="predicate.c.html#LN3748"><span class='Ref_To_Local'>tag</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN3726"><span class='Ref_To_Local'>predlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN321"><span class='Ref_to_Member'>tag</span></a><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN3749"><span class='Ref_To_Local'>targetLink</span></a> <span class='Operator'>= &</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN3726"><span class='Ref_To_Local'>predlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN324"><span class='Ref_to_Member'>targetLink</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN3750"><span class='Ref_To_Local'>target</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN3748"><span class='Ref_To_Local'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/predicate_internals.h.html#LN305"><span class='Ref_to_Member'>myTarget</span></a><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN3751"><span class='Ref_To_Local'>targettag</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN3750"><span class='Ref_To_Local'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN288"><span class='Ref_to_Member'>tag</span></a><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN3752"><span class='Ref_To_Local'>targettaghash</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN288"><span class='Ref_to_Macro'>PredicateLockTargetTagHashCode</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN3751"><span class='Ref_To_Local'>targettag</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN3753"><span class='Ref_To_Local'>partitionLock</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN244"><span class='Ref_to_Macro'>PredicateLockHashPartitionLock</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3752"><span class='Ref_To_Local'>targettaghash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3753"><span class='Ref_To_Local'>partitionLock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../ipc/shmqueue.c.html#LN66"><span class='Ref_to_Func'>SHMQueueDelete</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3749"><span class='Ref_To_Local'>targetLink</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/utils/hsearch.h.html#LN128"><span class='Ref_to_Proto'>hash_search_with_hash_value</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN387"><span class='Ref_to_Global_Var'>PredicateLockHash</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predicate.c.html#LN3748"><span class='Ref_To_Local'>tag</span></a><span class='Delimiter'>, 
</span>                                <a href="predicate.c.html#LN301"><span class='Ref_to_Macro'>PredicateLockHashCodeFromTargetHashCode</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN3748"><span class='Ref_To_Local'>tag</span></a><span class='Delimiter'>, 
</span>                                                              <a href="predicate.c.html#LN3752"><span class='Ref_To_Local'>targettaghash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                    <a href="../../../include/utils/hsearch.h.html#LN106"><span class='Ref_to_EnumConst'>HASH_REMOVE</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN3724"><span class='Ref_to_Parameter'>summarize</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN3777"></a>            <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Fold into dummy transaction list. */ 
</span>            <a href="predicate.c.html#LN3748"><span class='Ref_To_Local'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/predicate_internals.h.html#LN306"><span class='Ref_to_Member'>myXact</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN351"><span class='Ref_to_Global_Var'>OldCommittedSxact</span></a><span class='Delimiter'>; 
</span>            <a href="predicate.c.html#LN3726"><span class='Ref_To_Local'>predlock</span></a> <span class='Operator'>= </span><a href="../../../include/utils/hsearch.h.html#LN128"><span class='Ref_to_Proto'>hash_search_with_hash_value</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN387"><span class='Ref_to_Global_Var'>PredicateLockHash</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predicate.c.html#LN3748"><span class='Ref_To_Local'>tag</span></a><span class='Delimiter'>, 
</span>                                <a href="predicate.c.html#LN301"><span class='Ref_to_Macro'>PredicateLockHashCodeFromTargetHashCode</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN3748"><span class='Ref_To_Local'>tag</span></a><span class='Delimiter'>, 
</span>                                                              <a href="predicate.c.html#LN3752"><span class='Ref_To_Local'>targettaghash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                   <a href="../../../include/utils/hsearch.h.html#LN107"><span class='Ref_to_EnumConst'>HASH_ENTER_NULL</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predicate.c.html#LN3777"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN3726"><span class='Ref_To_Local'>predlock</span></a><span class='Parentheses'>) 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OUT_OF_MEMORY<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"out of shared memory"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"You might need to increase max_pred_locks_per_transaction."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN3777"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN3726"><span class='Ref_To_Local'>predlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN328"><span class='Ref_to_Member'>commitSeqNo</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN3726"><span class='Ref_To_Local'>predlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN328"><span class='Ref_to_Member'>commitSeqNo</span></a> <span class='Operator'>!= </span><a href="../../../include/storage/predicate_internals.h.html#LN35"><span class='Ref_to_Const'>InvalidSerCommitSeqNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN3726"><span class='Ref_To_Local'>predlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN328"><span class='Ref_to_Member'>commitSeqNo</span></a> <span class='Operator'>&LT; </span><a href="predicate.c.html#LN3723"><span class='Ref_to_Parameter'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN75"><span class='Ref_to_Member'>commitSeqNo</span></a><span class='Parentheses'>) 
</span>                    <a href="predicate.c.html#LN3726"><span class='Ref_To_Local'>predlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN328"><span class='Ref_to_Member'>commitSeqNo</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN3723"><span class='Ref_to_Parameter'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN75"><span class='Ref_to_Member'>commitSeqNo</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <a href="../../../include/storage/shmem.h.html#LN70"><span class='Ref_to_Proto'>SHMQueueInsertBefore</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN3750"><span class='Ref_To_Local'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN291"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                     <span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN3726"><span class='Ref_To_Local'>predlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN324"><span class='Ref_to_Member'>targetLink</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <a href="../../../include/storage/shmem.h.html#LN70"><span class='Ref_to_Proto'>SHMQueueInsertBefore</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN351"><span class='Ref_to_Global_Var'>OldCommittedSxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN89"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                     <span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN3726"><span class='Ref_To_Local'>predlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN326"><span class='Ref_to_Member'>xactLink</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <a href="predicate.c.html#LN3726"><span class='Ref_To_Local'>predlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN328"><span class='Ref_to_Member'>commitSeqNo</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN3723"><span class='Ref_to_Parameter'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN75"><span class='Ref_to_Member'>commitSeqNo</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if summarize &raquo; </span> 
        <span class='Control'>else</span> 
            <a href="predicate.c.html#LN443"><span class='Ref_to_Proto'>RemoveTargetIfNoLongerUsed</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3750"><span class='Ref_To_Local'>target</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN3752"><span class='Ref_To_Local'>targettaghash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3753"><span class='Ref_To_Local'>partitionLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="predicate.c.html#LN3726"><span class='Ref_To_Local'>predlock</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN3747"><span class='Ref_To_Local'>nextpredlock</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while predlock &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Rather than retail removal, just re-init the head after we've run 
     * through the list. 
     */ 
</span>    <a href="../ipc/shmqueue.c.html#LN34"><span class='Ref_to_Func'>SHMQueueInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN3723"><span class='Ref_to_Parameter'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN89"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializablePredicateLockListLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN3727"><span class='Ref_To_Local'>sxidtag</span></a><span class='Operator'>.</span><a href="../../../include/storage/predicate_internals.h.html#LN225"><span class='Ref_to_Member'>xid</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN3723"><span class='Ref_to_Parameter'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN99"><span class='Ref_to_Member'>topXid</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Release all outConflicts (unless 'partial' is true) */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN3723"><span class='Ref_to_Parameter'>partial</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="predicate.c.html#LN3728"><span class='Ref_To_Local'>conflict</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN3723"><span class='Ref_to_Parameter'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN85"><span class='Ref_to_Member'>outConflicts</span></a><span class='Delimiter'>, 
</span>                         <span class='Operator'>&</span><a href="predicate.c.html#LN3723"><span class='Ref_to_Parameter'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN85"><span class='Ref_to_Member'>outConflicts</span></a><span class='Delimiter'>, 
</span>                         <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN194"><span class='Ref_to_Struct'>RWConflictData</span></a><span class='Delimiter'>, </span>outLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN3728"><span class='Ref_To_Local'>conflict</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="predicate.c.html#LN3729"><span class='Ref_To_Local'>nextConflict</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a><span class='Parentheses'>) 
</span>                <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN3723"><span class='Ref_to_Parameter'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN85"><span class='Ref_to_Member'>outConflicts</span></a><span class='Delimiter'>, 
</span>                             <span class='Operator'>&</span><a href="predicate.c.html#LN3728"><span class='Ref_To_Local'>conflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN196"><span class='Ref_to_Member'>outLink</span></a><span class='Delimiter'>, 
</span>                             <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN194"><span class='Ref_to_Struct'>RWConflictData</span></a><span class='Delimiter'>, </span>outLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN3724"><span class='Ref_to_Parameter'>summarize</span></a><span class='Parentheses'>) 
</span>                <a href="predicate.c.html#LN3728"><span class='Ref_To_Local'>conflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN199"><span class='Ref_to_Member'>sxactIn</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN105"><span class='Ref_to_Member'>flags</span></a> <span class='Operator'>|= </span><a href="../../../include/storage/predicate_internals.h.html#LN123"><span class='Ref_to_Const'>SXACT_FLAG_SUMMARY_CONFLICT_IN</span></a><span class='Delimiter'>; 
</span>            <a href="predicate.c.html#LN423"><span class='Ref_to_Proto'>ReleaseRWConflict</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3728"><span class='Ref_To_Local'>conflict</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="predicate.c.html#LN3728"><span class='Ref_To_Local'>conflict</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN3729"><span class='Ref_To_Local'>nextConflict</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Release all inConflicts. */ 
</span>    <a href="predicate.c.html#LN3728"><span class='Ref_To_Local'>conflict</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN3723"><span class='Ref_to_Parameter'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN87"><span class='Ref_to_Member'>inConflicts</span></a><span class='Delimiter'>, 
</span>                     <span class='Operator'>&</span><a href="predicate.c.html#LN3723"><span class='Ref_to_Parameter'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN87"><span class='Ref_to_Member'>inConflicts</span></a><span class='Delimiter'>, 
</span>                     <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN194"><span class='Ref_to_Struct'>RWConflictData</span></a><span class='Delimiter'>, </span>inLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN3728"><span class='Ref_To_Local'>conflict</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="predicate.c.html#LN3729"><span class='Ref_To_Local'>nextConflict</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN3723"><span class='Ref_to_Parameter'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN87"><span class='Ref_to_Member'>inConflicts</span></a><span class='Delimiter'>, 
</span>                         <span class='Operator'>&</span><a href="predicate.c.html#LN3728"><span class='Ref_To_Local'>conflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN197"><span class='Ref_to_Member'>inLink</span></a><span class='Delimiter'>, 
</span>                         <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN194"><span class='Ref_to_Struct'>RWConflictData</span></a><span class='Delimiter'>, </span>inLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN3724"><span class='Ref_to_Parameter'>summarize</span></a><span class='Parentheses'>) 
</span>            <a href="predicate.c.html#LN3728"><span class='Ref_To_Local'>conflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN198"><span class='Ref_to_Member'>sxactOut</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN105"><span class='Ref_to_Member'>flags</span></a> <span class='Operator'>|= </span><a href="../../../include/storage/predicate_internals.h.html#LN124"><span class='Ref_to_Const'>SXACT_FLAG_SUMMARY_CONFLICT_OUT</span></a><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN423"><span class='Ref_to_Proto'>ReleaseRWConflict</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3728"><span class='Ref_To_Local'>conflict</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN3728"><span class='Ref_To_Local'>conflict</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN3729"><span class='Ref_To_Local'>nextConflict</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Finally, get rid of the xid and the record of the transaction itself. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN3723"><span class='Ref_to_Parameter'>partial</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN3727"><span class='Ref_To_Local'>sxidtag</span></a><span class='Operator'>.</span><a href="../../../include/storage/predicate_internals.h.html#LN225"><span class='Ref_to_Member'>xid</span></a> <span class='Operator'>!= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/utils/hsearch.h.html#LN125"><span class='Ref_to_Proto'>hash_search</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN385"><span class='Ref_to_Global_Var'>SerializableXidHash</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predicate.c.html#LN3727"><span class='Ref_To_Local'>sxidtag</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/hsearch.h.html#LN106"><span class='Ref_to_EnumConst'>HASH_REMOVE</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN416"><span class='Ref_to_Proto'>ReleasePredXact</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3723"><span class='Ref_to_Parameter'>sxact</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ReleaseOneSerializableXact &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Tests whether the given top level transaction is concurrent with 
 * (overlaps) our current transaction. 
 * 
 * We need to identify the top level transaction for SSI, anyway, so pass 
 * that to this function to save the overhead of checking the snapshot's 
 * subxip array. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN3882"></a><span class='Declare_Function'>XidIsConcurrent</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3884"></a>    <a href="../../../include/utils/snapshot.h.html#LN22"><span class='Ref_to_Typedef'>Snapshot</span></a>    <span class='Declare_Local'>snap</span><span class='Delimiter'>; 
</span><a name="LN3885"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3882"><span class='Ref_to_Parameter'>xid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN42"><span class='Ref_to_Macro'>TransactionIdEquals</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3882"><span class='Ref_to_Parameter'>xid</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xact.h.html#LN332"><span class='Ref_to_Proto'>GetTopTransactionIdIfAny</span></a><span class='Parentheses'>()))</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN3884"><span class='Ref_To_Local'>snap</span></a> <span class='Operator'>= </span><a href="../../../include/utils/snapmgr.h.html#LN63"><span class='Ref_to_Proto'>GetTransactionSnapshot</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3882"><span class='Ref_to_Parameter'>xid</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN3884"><span class='Ref_To_Local'>snap</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/snapshot.h.html#LN65"><span class='Ref_to_Member'>xmin</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN171"><span class='Ref_to_Proto'>TransactionIdFollowsOrEquals</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3882"><span class='Ref_to_Parameter'>xid</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN3884"><span class='Ref_To_Local'>snap</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/snapshot.h.html#LN66"><span class='Ref_to_Member'>xmax</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN3885"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="predicate.c.html#LN3885"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="predicate.c.html#LN3884"><span class='Ref_To_Local'>snap</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/snapshot.h.html#LN77"><span class='Ref_to_Member'>xcnt</span></a><span class='Delimiter'>; </span><a href="predicate.c.html#LN3885"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN3882"><span class='Ref_to_Parameter'>xid</span></a> <span class='Operator'>== </span><a href="predicate.c.html#LN3884"><span class='Ref_To_Local'>snap</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/snapshot.h.html#LN76"><span class='Ref_to_Member'>xip</span></a><span class='Delimiter'>[</span><a href="predicate.c.html#LN3885"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end XidIsConcurrent &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * CheckForSerializableConflictOut 
 *      We are reading a tuple which has been modified.  If it is visible to 
 *      us but has been deleted, that indicates a rw-conflict out.  If it's 
 *      not visible and was created by a concurrent (overlapping) 
 *      serializable transaction, that is also a rw-conflict out, 
 * 
 * We will determine the top level xid of the writing transaction with which 
 * we may be in conflict, and check for overlap with our own transaction. 
 * If the transactions overlap (i.e., they cannot see each other's writes), 
 * then we have a conflict out. 
 * 
 * This function should be called just about anywhere in heapam.c where a 
 * tuple has been read. The caller must hold at least a shared lock on the 
 * buffer, because this function might set hint bits on the tuple. There is 
 * currently no known reason to call this function from an index AM. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN3925"></a><span class='Declare_Function'>CheckForSerializableConflictOut</span><span class='Parentheses'>(</span><span class='Keyword'>bool </span><span class='Declare_Parameter'>visible</span><span class='Delimiter'>, </span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>relation</span><span class='Delimiter'>, 
</span><a name="LN3926"></a>                                <a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> <span class='Declare_Parameter'>tuple</span><span class='Delimiter'>, </span><a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> <span class='Declare_Parameter'>buffer</span><span class='Delimiter'>, 
</span><a name="LN3927"></a>                                <a href="../../../include/utils/snapshot.h.html#LN22"><span class='Ref_to_Typedef'>Snapshot</span></a> <span class='Declare_Parameter'>snapshot</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3929"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>xid</span><span class='Delimiter'>; 
</span><a name="LN3930"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN223"><span class='Ref_to_Struct'>SERIALIZABLEXIDTAG</span></a> <span class='Declare_Local'>sxidtag</span><span class='Delimiter'>; 
</span><a name="LN3931"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN241"><span class='Ref_to_Struct'>SERIALIZABLEXID</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sxid</span><span class='Delimiter'>; 
</span><a name="LN3932"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sxact</span><span class='Delimiter'>; 
</span><a name="LN3933"></a>    <a href="../../../include/utils/tqual.h.html#LN48"><span class='Ref_to_Typedef'>HTSV_Result</span></a> <span class='Declare_Local'>htsvResult</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN495"><span class='Ref_to_Func'>SerializationNeededForRead</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3925"><span class='Ref_to_Parameter'>relation</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN3927"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Check if someone else has already decided that we need to die */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN266"><span class='Ref_to_Macro'>SxactIsDoomed</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_T_R_SERIALIZATION_FAILURE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not serialize access due to read/write dependencies among transactions"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN898"><span class='Ref_to_Func'>errdetail_internal</span></a><span class='Parentheses'>(</span><span class='String'>"Reason code: Canceled on identification as a pivot, during conflict out checking."</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"The transaction might succeed if retried."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Check to see whether the tuple has been written to by a concurrent 
     * transaction, either to create it not visible to us, or to delete it 
     * while it is visible to us.  The "visible" bool indicates whether the 
     * tuple is visible to us, while HeapTupleSatisfiesVacuum checks what else 
     * is going on with it. 
     */ 
</span>    <a href="predicate.c.html#LN3933"><span class='Ref_To_Local'>htsvResult</span></a> <span class='Operator'>= </span><a href="../../../include/utils/tqual.h.html#LN74"><span class='Ref_to_Proto'>HeapTupleSatisfiesVacuum</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3926"><span class='Ref_to_Parameter'>tuple</span></a><span class='Delimiter'>, </span><a href="../../utils/time/snapmgr.c.html#LN163"><span class='Ref_to_Global_Var'>TransactionXmin</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN3926"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN3933"><span class='Ref_To_Local'>htsvResult</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../../include/utils/tqual.h.html#LN51"><span class='Ref_to_EnumConst'>HEAPTUPLE_LIVE</span></a><span class='Operator'>: 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN3925"><span class='Ref_to_Parameter'>visible</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>return</span><span class='Delimiter'>; 
</span>            <a href="predicate.c.html#LN3929"><span class='Ref_To_Local'>xid</span></a> <span class='Operator'>= </span><a href="../../../include/access/htup_details.h.html#LN306"><span class='Ref_to_Macro'>HeapTupleHeaderGetXmin</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3926"><span class='Ref_to_Parameter'>tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/utils/tqual.h.html#LN52"><span class='Ref_to_EnumConst'>HEAPTUPLE_RECENTLY_DEAD</span></a><span class='Operator'>: 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN3925"><span class='Ref_to_Parameter'>visible</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>return</span><span class='Delimiter'>; 
</span>            <a href="predicate.c.html#LN3929"><span class='Ref_To_Local'>xid</span></a> <span class='Operator'>= </span><a href="../../../include/access/htup_details.h.html#LN358"><span class='Ref_to_Macro'>HeapTupleHeaderGetUpdateXid</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3926"><span class='Ref_to_Parameter'>tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/utils/tqual.h.html#LN54"><span class='Ref_to_EnumConst'>HEAPTUPLE_DELETE_IN_PROGRESS</span></a><span class='Operator'>: 
</span>            <a href="predicate.c.html#LN3929"><span class='Ref_To_Local'>xid</span></a> <span class='Operator'>= </span><a href="../../../include/access/htup_details.h.html#LN358"><span class='Ref_to_Macro'>HeapTupleHeaderGetUpdateXid</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3926"><span class='Ref_to_Parameter'>tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/utils/tqual.h.html#LN53"><span class='Ref_to_EnumConst'>HEAPTUPLE_INSERT_IN_PROGRESS</span></a><span class='Operator'>: 
</span>            <a href="predicate.c.html#LN3929"><span class='Ref_To_Local'>xid</span></a> <span class='Operator'>= </span><a href="../../../include/access/htup_details.h.html#LN306"><span class='Ref_to_Macro'>HeapTupleHeaderGetXmin</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3926"><span class='Ref_to_Parameter'>tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/utils/tqual.h.html#LN50"><span class='Ref_to_EnumConst'>HEAPTUPLE_DEAD</span></a><span class='Operator'>: 
</span>            <span class='Control'>return</span><span class='Delimiter'>; 
</span>        <span class='Control'>default</span><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * The only way to get to this default clause is if a new value is 
             * added to the enum type without adding it to this switch 
             * statement.  That's a bug, so elog. 
             */ 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized return value from HeapTupleSatisfiesVacuum: %u"</span><span class='Delimiter'>, </span><a href="predicate.c.html#LN3933"><span class='Ref_To_Local'>htsvResult</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * In spite of having all enum values covered and calling elog on 
             * this default, some compilers think this is a code path which 
             * allows xid to be used below without initialization. Silence 
             * that warning. 
             */ 
</span>            <a href="predicate.c.html#LN3929"><span class='Ref_To_Local'>xid</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch htsvResult &raquo; </span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3929"><span class='Ref_To_Local'>xid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN171"><span class='Ref_to_Proto'>TransactionIdFollowsOrEquals</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3929"><span class='Ref_To_Local'>xid</span></a><span class='Delimiter'>, </span><a href="../../utils/time/snapmgr.c.html#LN163"><span class='Ref_to_Global_Var'>TransactionXmin</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Find top level xid.  Bail out if xid is too early to be a conflict, or 
     * if it's our own xid. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN42"><span class='Ref_to_Macro'>TransactionIdEquals</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3929"><span class='Ref_To_Local'>xid</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xact.h.html#LN332"><span class='Ref_to_Proto'>GetTopTransactionIdIfAny</span></a><span class='Parentheses'>()))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN3929"><span class='Ref_To_Local'>xid</span></a> <span class='Operator'>= </span><a href="../../../include/access/subtrans.h.html#LN18"><span class='Ref_to_Proto'>SubTransGetTopmostTransaction</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3929"><span class='Ref_To_Local'>xid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3929"><span class='Ref_To_Local'>xid</span></a><span class='Delimiter'>, </span><a href="../../utils/time/snapmgr.c.html#LN163"><span class='Ref_to_Global_Var'>TransactionXmin</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN42"><span class='Ref_to_Macro'>TransactionIdEquals</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3929"><span class='Ref_To_Local'>xid</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xact.h.html#LN332"><span class='Ref_to_Proto'>GetTopTransactionIdIfAny</span></a><span class='Parentheses'>()))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Find sxact or summarized info for the top level xid. 
     */ 
</span>    <a href="predicate.c.html#LN3930"><span class='Ref_To_Local'>sxidtag</span></a><span class='Operator'>.</span><a href="../../../include/storage/predicate_internals.h.html#LN225"><span class='Ref_to_Member'>xid</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN3929"><span class='Ref_To_Local'>xid</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN3931"><span class='Ref_To_Local'>sxid</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN241"><span class='Ref_to_Struct'>SERIALIZABLEXID</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/hsearch.h.html#LN125"><span class='Ref_to_Proto'>hash_search</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN385"><span class='Ref_to_Global_Var'>SerializableXidHash</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predicate.c.html#LN3930"><span class='Ref_To_Local'>sxidtag</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/hsearch.h.html#LN104"><span class='Ref_to_EnumConst'>HASH_FIND</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN3931"><span class='Ref_To_Local'>sxid</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Transaction not found in "normal" SSI structures.  Check whether it 
         * got pushed out to SLRU storage for "old committed" transactions. 
         */ 
</span><a name="LN4021"></a>        <a href="../../../include/storage/predicate_internals.h.html#LN21"><span class='Ref_to_Typedef'>SerCommitSeqNo</span></a> <span class='Declare_Local'>conflictCommitSeqNo</span><span class='Delimiter'>; 
</span> 
        <a href="predicate.c.html#LN4021"><span class='Ref_To_Local'>conflictCommitSeqNo</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN429"><span class='Ref_to_Proto'>OldSerXidGetMinConflictCommitSeqNo</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3929"><span class='Ref_To_Local'>xid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN4021"><span class='Ref_To_Local'>conflictCommitSeqNo</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN4021"><span class='Ref_To_Local'>conflictCommitSeqNo</span></a> <span class='Operator'>!= </span><a href="../../../include/storage/predicate_internals.h.html#LN35"><span class='Ref_to_Const'>InvalidSerCommitSeqNo</span></a> 
                <span class='Operator'>&& </span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN267"><span class='Ref_to_Macro'>SxactIsReadOnly</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Parentheses'>) 
</span>                    <span class='Operator'>|| </span><a href="predicate.c.html#LN4021"><span class='Ref_To_Local'>conflictCommitSeqNo</span></a> 
                    <span class='Operator'>&LT;= </span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN84"><span class='Ref_to_Member'>SeqNo</span></a><span class='Operator'>.</span>lastCommitBeforeSnapshot<span class='Parentheses'>))</span> 
                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_T_R_SERIALIZATION_FAILURE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not serialize access due to read/write dependencies among transactions"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN898"><span class='Ref_to_Func'>errdetail_internal</span></a><span class='Parentheses'>(</span><span class='String'>"Reason code: Canceled on conflict out to old pivot %u."</span><span class='Delimiter'>, </span><a href="predicate.c.html#LN3929"><span class='Ref_To_Local'>xid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                      <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"The transaction might succeed if retried."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN268"><span class='Ref_to_Macro'>SxactHasSummaryConflictIn</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Parentheses'>) 
</span>                <span class='Operator'>|| !</span><a href="../../../include/storage/shmem.h.html#LN76"><span class='Ref_to_Proto'>SHMQueueEmpty</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN87"><span class='Ref_to_Member'>inConflicts</span></a><span class='Parentheses'>))</span> 
                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_T_R_SERIALIZATION_FAILURE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not serialize access due to read/write dependencies among transactions"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN898"><span class='Ref_to_Func'>errdetail_internal</span></a><span class='Parentheses'>(</span><span class='String'>"Reason code: Canceled on identification as a pivot, with conflict out to old committed transaction %u."</span><span class='Delimiter'>, </span><a href="predicate.c.html#LN3929"><span class='Ref_To_Local'>xid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                      <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"The transaction might succeed if retried."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
            <a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN105"><span class='Ref_to_Member'>flags</span></a> <span class='Operator'>|= </span><a href="../../../include/storage/predicate_internals.h.html#LN124"><span class='Ref_to_Const'>SXACT_FLAG_SUMMARY_CONFLICT_OUT</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if conflictCommitSeqNo!=... &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* It's not serializable or otherwise not important. */ 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !sxid &raquo; </span> 
    <a href="predicate.c.html#LN3932"><span class='Ref_To_Local'>sxact</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN3931"><span class='Ref_To_Local'>sxid</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN247"><span class='Ref_to_Member'>myXact</span></a><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN42"><span class='Ref_to_Macro'>TransactionIdEquals</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3932"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN99"><span class='Ref_to_Member'>topXid</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN3929"><span class='Ref_To_Local'>xid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN3932"><span class='Ref_To_Local'>sxact</span></a> <span class='Operator'>== </span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a> <span class='Operator'>|| </span><a href="predicate.c.html#LN266"><span class='Ref_to_Macro'>SxactIsDoomed</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3932"><span class='Ref_To_Local'>sxact</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Can't conflict with ourself or a transaction that will roll back. */ 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We have a conflict out to a transaction which has a conflict out to a 
     * summarized transaction.  That summarized transaction must have 
     * committed first, and we can't tell when it committed in relation to our 
     * snapshot acquisition, so something needs to be canceled. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN269"><span class='Ref_to_Macro'>SxactHasSummaryConflictOut</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3932"><span class='Ref_To_Local'>sxact</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN264"><span class='Ref_to_Macro'>SxactIsPrepared</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3932"><span class='Ref_To_Local'>sxact</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="predicate.c.html#LN3932"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN105"><span class='Ref_to_Member'>flags</span></a> <span class='Operator'>|= </span><a href="../../../include/storage/predicate_internals.h.html#LN112"><span class='Ref_to_Const'>SXACT_FLAG_DOOMED</span></a><span class='Delimiter'>; 
</span>            <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_T_R_SERIALIZATION_FAILURE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not serialize access due to read/write dependencies among transactions"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN898"><span class='Ref_to_Func'>errdetail_internal</span></a><span class='Parentheses'>(</span><span class='String'>"Reason code: Canceled on conflict out to old pivot."</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"The transaction might succeed if retried."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If this is a read-only transaction and the writing transaction has 
     * committed, and it doesn't have a rw-conflict to a transaction which 
     * committed before it, no conflict. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN267"><span class='Ref_to_Macro'>SxactIsReadOnly</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Parentheses'>)</span> 
        <span class='Operator'>&& </span><a href="predicate.c.html#LN263"><span class='Ref_to_Macro'>SxactIsCommitted</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3932"><span class='Ref_To_Local'>sxact</span></a><span class='Parentheses'>)</span> 
        <span class='Operator'>&& !</span><a href="predicate.c.html#LN269"><span class='Ref_to_Macro'>SxactHasSummaryConflictOut</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3932"><span class='Ref_To_Local'>sxact</span></a><span class='Parentheses'>)</span> 
        <span class='Operator'>&& </span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN275"><span class='Ref_to_Macro'>SxactHasConflictOut</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3932"><span class='Ref_To_Local'>sxact</span></a><span class='Parentheses'>) 
</span>            <span class='Operator'>|| </span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN84"><span class='Ref_to_Member'>SeqNo</span></a><span class='Operator'>.</span>lastCommitBeforeSnapshot <span class='Operator'>&LT; </span><a href="predicate.c.html#LN3932"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN84"><span class='Ref_to_Member'>SeqNo</span></a><span class='Operator'>.</span>earliestOutConflictCommit<span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Read-only transaction will appear to run first.  No conflict. */ 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN463"><span class='Ref_to_Proto'>XidIsConcurrent</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN3929"><span class='Ref_To_Local'>xid</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* This write was already in our snapshot; no conflict. */ 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN420"><span class='Ref_to_Proto'>RWConflictExists</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN3932"><span class='Ref_To_Local'>sxact</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* We don't want duplicate conflict records in the list. */ 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Flag the conflict.  But first, if this conflict creates a dangerous 
     * structure, ereport an error. 
     */ 
</span>    <a href="predicate.c.html#LN465"><span class='Ref_to_Proto'>FlagRWConflict</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN3932"><span class='Ref_To_Local'>sxact</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end CheckForSerializableConflictOut &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Check a particular target for rw-dependency conflict in. A subroutine of 
 * CheckForSerializableConflictIn(). 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN4128"></a><span class='Declare_Function'>CheckTargetForConflictsIn</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>targettag</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4130"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>targettaghash</span><span class='Delimiter'>; 
</span><a name="LN4131"></a>    <a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>partitionLock</span><span class='Delimiter'>; 
</span><a name="LN4132"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN285"><span class='Ref_to_Struct'>PREDICATELOCKTARGET</span></a> <span class='Operator'>*</span><span class='Declare_Local'>target</span><span class='Delimiter'>; 
</span><a name="LN4133"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Declare_Local'>predlock</span><span class='Delimiter'>; 
</span><a name="LN4134"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Declare_Local'>mypredlock</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN4135"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN303"><span class='Ref_to_Struct'>PREDICATELOCKTAG</span></a> <span class='Declare_Local'>mypredlocktag</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a> <span class='Operator'>!= </span><a href="../../../include/storage/predicate_internals.h.html#LN468"><span class='Ref_to_Const'>InvalidSerializableXact</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The same hash and LW lock apply to the lock target and the lock itself. 
     */ 
</span>    <a href="predicate.c.html#LN4130"><span class='Ref_To_Local'>targettaghash</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN288"><span class='Ref_to_Macro'>PredicateLockTargetTagHashCode</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4128"><span class='Ref_to_Parameter'>targettag</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN4131"><span class='Ref_To_Local'>partitionLock</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN244"><span class='Ref_to_Macro'>PredicateLockHashPartitionLock</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4130"><span class='Ref_To_Local'>targettaghash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4131"><span class='Ref_To_Local'>partitionLock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN4132"><span class='Ref_To_Local'>target</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN285"><span class='Ref_to_Struct'>PREDICATELOCKTARGET</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/hsearch.h.html#LN128"><span class='Ref_to_Proto'>hash_search_with_hash_value</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN386"><span class='Ref_to_Global_Var'>PredicateLockTargetHash</span></a><span class='Delimiter'>, 
</span>                                    <a href="predicate.c.html#LN4128"><span class='Ref_to_Parameter'>targettag</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN4130"><span class='Ref_To_Local'>targettaghash</span></a><span class='Delimiter'>, 
</span>                                    <a href="../../../include/utils/hsearch.h.html#LN104"><span class='Ref_to_EnumConst'>HASH_FIND</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN4132"><span class='Ref_To_Local'>target</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Nothing has this target locked; we're done here. */ 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4131"><span class='Ref_To_Local'>partitionLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Each lock for an overlapping transaction represents a conflict: a 
     * rw-dependency in to this transaction. 
     */ 
</span>    <a href="predicate.c.html#LN4133"><span class='Ref_To_Local'>predlock</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN4132"><span class='Ref_To_Local'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN291"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN4132"><span class='Ref_To_Local'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN291"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a><span class='Delimiter'>, </span>targetLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN4133"><span class='Ref_To_Local'>predlock</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN4167"></a>        <a href="../../../include/storage/shmem.h.html#LN27"><span class='Ref_to_Struct'>SHM_QUEUE</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>predlocktargetlink</span><span class='Delimiter'>; 
</span><a name="LN4168"></a>        <a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Declare_Local'>nextpredlock</span><span class='Delimiter'>; 
</span><a name="LN4169"></a>        <a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sxact</span><span class='Delimiter'>; 
</span> 
        <a href="predicate.c.html#LN4167"><span class='Ref_To_Local'>predlocktargetlink</span></a> <span class='Operator'>= &</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN4133"><span class='Ref_To_Local'>predlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN324"><span class='Ref_to_Member'>targetLink</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN4168"><span class='Ref_To_Local'>nextpredlock</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN4132"><span class='Ref_To_Local'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN291"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="predicate.c.html#LN4167"><span class='Ref_To_Local'>predlocktargetlink</span></a><span class='Delimiter'>, 
</span>                         <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a><span class='Delimiter'>, </span>targetLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <a href="predicate.c.html#LN4169"><span class='Ref_To_Local'>sxact</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN4133"><span class='Ref_To_Local'>predlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN321"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/predicate_internals.h.html#LN306"><span class='Ref_to_Member'>myXact</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN4169"><span class='Ref_To_Local'>sxact</span></a> <span class='Operator'>== </span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * If we're getting a write lock on a tuple, we don't need a 
             * predicate (SIREAD) lock on the same tuple. We can safely remove 
             * our SIREAD lock, but we'll defer doing so until after the loop 
             * because that requires upgrading to an exclusive partition lock. 
             * 
             * We can't use this optimization within a subtransaction because 
             * the subtransaction could roll back, and we would be left 
             * without any lock at the top level. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/xact.h.html#LN361"><span class='Ref_to_Proto'>IsSubTransaction</span></a><span class='Parentheses'>() 
</span>                <span class='Operator'>&& </span><a href="../../../include/storage/predicate_internals.h.html#LN413"><span class='Ref_to_Macro'>GET_PREDICATELOCKTARGETTAG_OFFSET</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="predicate.c.html#LN4128"><span class='Ref_to_Parameter'>targettag</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="predicate.c.html#LN4134"><span class='Ref_To_Local'>mypredlock</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN4133"><span class='Ref_To_Local'>predlock</span></a><span class='Delimiter'>; 
</span>                <a href="predicate.c.html#LN4135"><span class='Ref_To_Local'>mypredlocktag</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN4133"><span class='Ref_To_Local'>predlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN321"><span class='Ref_to_Member'>tag</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN266"><span class='Ref_to_Macro'>SxactIsDoomed</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4169"><span class='Ref_To_Local'>sxact</span></a><span class='Parentheses'>)</span> 
                 <span class='Operator'>&& </span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN263"><span class='Ref_to_Macro'>SxactIsCommitted</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4169"><span class='Ref_To_Local'>sxact</span></a><span class='Parentheses'>)</span> 
                     <span class='Operator'>|| </span><a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/snapmgr.h.html#LN63"><span class='Ref_to_Proto'>GetTransactionSnapshot</span></a><span class='Parentheses'>()</span><span class='Operator'>-&GT;</span><a href="../../../include/utils/snapshot.h.html#LN65"><span class='Ref_to_Member'>xmin</span></a><span class='Delimiter'>, 
</span>                                              <a href="predicate.c.html#LN4169"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN101"><span class='Ref_to_Member'>finishedBefore</span></a><span class='Parentheses'>))</span> 
                 <span class='Operator'>&& !</span><a href="predicate.c.html#LN420"><span class='Ref_to_Proto'>RWConflictExists</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4169"><span class='Ref_To_Local'>sxact</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Re-check after getting exclusive lock because the other 
             * transaction may have flagged a conflict. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN266"><span class='Ref_to_Macro'>SxactIsDoomed</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4169"><span class='Ref_To_Local'>sxact</span></a><span class='Parentheses'>)</span> 
                <span class='Operator'>&& </span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN263"><span class='Ref_to_Macro'>SxactIsCommitted</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4169"><span class='Ref_To_Local'>sxact</span></a><span class='Parentheses'>)</span> 
                    <span class='Operator'>|| </span><a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/snapmgr.h.html#LN63"><span class='Ref_to_Proto'>GetTransactionSnapshot</span></a><span class='Parentheses'>()</span><span class='Operator'>-&GT;</span><a href="../../../include/utils/snapshot.h.html#LN65"><span class='Ref_to_Member'>xmin</span></a><span class='Delimiter'>, 
</span>                                             <a href="predicate.c.html#LN4169"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN101"><span class='Ref_to_Member'>finishedBefore</span></a><span class='Parentheses'>))</span> 
                <span class='Operator'>&& !</span><a href="predicate.c.html#LN420"><span class='Ref_to_Proto'>RWConflictExists</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4169"><span class='Ref_To_Local'>sxact</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="predicate.c.html#LN465"><span class='Ref_to_Proto'>FlagRWConflict</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4169"><span class='Ref_To_Local'>sxact</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !SxactIsDoomed(sxact)... &raquo; </span> 
 
        <a href="predicate.c.html#LN4133"><span class='Ref_To_Local'>predlock</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN4168"><span class='Ref_To_Local'>nextpredlock</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while predlock &raquo; </span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4131"><span class='Ref_To_Local'>partitionLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we found one of our own SIREAD locks to remove, remove it now. 
     * 
     * At this point our transaction already has an ExclusiveRowLock on the 
     * relation, so we are OK to drop the predicate lock on the tuple, if 
     * found, without fearing that another write against the tuple will occur 
     * before the MVCC information makes it to the buffer. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN4134"><span class='Ref_To_Local'>mypredlock</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN4238"></a>        <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>predlockhashcode</span><span class='Delimiter'>; 
</span><a name="LN4239"></a>        <a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rmpredlock</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SerializablePredicateLockListLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4131"><span class='Ref_To_Local'>partitionLock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Remove the predicate lock from shared memory, if it wasn't removed 
         * while the locks were released.  One way that could happen is from 
         * autovacuum cleaning up an index. 
         */ 
</span>        <a href="predicate.c.html#LN4238"><span class='Ref_To_Local'>predlockhashcode</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN301"><span class='Ref_to_Macro'>PredicateLockHashCodeFromTargetHashCode</span></a> 
            <span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN4135"><span class='Ref_To_Local'>mypredlocktag</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN4130"><span class='Ref_To_Local'>targettaghash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN4239"><span class='Ref_To_Local'>rmpredlock</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../../include/utils/hsearch.h.html#LN128"><span class='Ref_to_Proto'>hash_search_with_hash_value</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN387"><span class='Ref_to_Global_Var'>PredicateLockHash</span></a><span class='Delimiter'>, 
</span>                                        <span class='Operator'>&</span><a href="predicate.c.html#LN4135"><span class='Ref_To_Local'>mypredlocktag</span></a><span class='Delimiter'>, 
</span>                                        <a href="predicate.c.html#LN4238"><span class='Ref_To_Local'>predlockhashcode</span></a><span class='Delimiter'>, 
</span>                                        <a href="../../../include/utils/hsearch.h.html#LN104"><span class='Ref_to_EnumConst'>HASH_FIND</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN4239"><span class='Ref_To_Local'>rmpredlock</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN4239"><span class='Ref_To_Local'>rmpredlock</span></a> <span class='Operator'>== </span><a href="predicate.c.html#LN4134"><span class='Ref_To_Local'>mypredlock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../ipc/shmqueue.c.html#LN66"><span class='Ref_to_Func'>SHMQueueDelete</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN4134"><span class='Ref_To_Local'>mypredlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN324"><span class='Ref_to_Member'>targetLink</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="../ipc/shmqueue.c.html#LN66"><span class='Ref_to_Func'>SHMQueueDelete</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN4134"><span class='Ref_To_Local'>mypredlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN326"><span class='Ref_to_Member'>xactLink</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <a href="predicate.c.html#LN4239"><span class='Ref_To_Local'>rmpredlock</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                <a href="../../../include/utils/hsearch.h.html#LN128"><span class='Ref_to_Proto'>hash_search_with_hash_value</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN387"><span class='Ref_to_Global_Var'>PredicateLockHash</span></a><span class='Delimiter'>, 
</span>                                            <span class='Operator'>&</span><a href="predicate.c.html#LN4135"><span class='Ref_To_Local'>mypredlocktag</span></a><span class='Delimiter'>, 
</span>                                            <a href="predicate.c.html#LN4238"><span class='Ref_To_Local'>predlockhashcode</span></a><span class='Delimiter'>, 
</span>                                            <a href="../../../include/utils/hsearch.h.html#LN106"><span class='Ref_to_EnumConst'>HASH_REMOVE</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN4239"><span class='Ref_To_Local'>rmpredlock</span></a> <span class='Operator'>== </span><a href="predicate.c.html#LN4134"><span class='Ref_To_Local'>mypredlock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="predicate.c.html#LN443"><span class='Ref_to_Proto'>RemoveTargetIfNoLongerUsed</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4132"><span class='Ref_To_Local'>target</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN4130"><span class='Ref_To_Local'>targettaghash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4131"><span class='Ref_To_Local'>partitionLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializablePredicateLockListLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN4239"><span class='Ref_To_Local'>rmpredlock</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Remove entry in local lock table if it exists. It's OK if it 
             * doesn't exist; that means the lock was transferred to a new 
             * target by a different backend. 
             */ 
</span>            <a href="../../../include/utils/hsearch.h.html#LN128"><span class='Ref_to_Proto'>hash_search_with_hash_value</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN403"><span class='Ref_to_Global_Var'>LocalPredicateLockHash</span></a><span class='Delimiter'>, 
</span>                                        <a href="predicate.c.html#LN4128"><span class='Ref_to_Parameter'>targettag</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN4130"><span class='Ref_To_Local'>targettaghash</span></a><span class='Delimiter'>, 
</span>                                        <a href="../../../include/utils/hsearch.h.html#LN106"><span class='Ref_to_EnumConst'>HASH_REMOVE</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="predicate.c.html#LN448"><span class='Ref_to_Proto'>DecrementParentLocks</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4128"><span class='Ref_to_Parameter'>targettag</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if mypredlock!=NULL &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end CheckTargetForConflictsIn &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * CheckForSerializableConflictIn 
 *      We are writing the given tuple.  If that indicates a rw-conflict 
 *      in from another serializable transaction, take appropriate action. 
 * 
 * Skip checking for any granularity for which a parameter is missing. 
 * 
 * A tuple update or delete is in conflict if we have a predicate lock 
 * against the relation or page in which the tuple exists, or against the 
 * tuple itself. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN4306"></a><span class='Declare_Function'>CheckForSerializableConflictIn</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>relation</span><span class='Delimiter'>, </span><a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> <span class='Declare_Parameter'>tuple</span><span class='Delimiter'>, 
</span><a name="LN4307"></a>                               <a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> <span class='Declare_Parameter'>buffer</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4309"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Declare_Local'>targettag</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN539"><span class='Ref_to_Func'>SerializationNeededForWrite</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4306"><span class='Ref_to_Parameter'>relation</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Check if someone else has already decided that we need to die */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN266"><span class='Ref_to_Macro'>SxactIsDoomed</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Parentheses'>))</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_T_R_SERIALIZATION_FAILURE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not serialize access due to read/write dependencies among transactions"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN898"><span class='Ref_to_Func'>errdetail_internal</span></a><span class='Parentheses'>(</span><span class='String'>"Reason code: Canceled on identification as a pivot, during conflict in checking."</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"The transaction might succeed if retried."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We're doing a write which might cause rw-conflicts now or later. 
     * Memorize that fact. 
     */ 
</span>    <a href="predicate.c.html#LN411"><span class='Ref_to_Global_Var'>MyXactDidWrite</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * It is important that we check for locks from the finest granularity to 
     * the coarsest granularity, so that granularity promotion doesn't cause 
     * us to miss a lock.  The new (coarser) lock will be acquired before the 
     * old (finer) locks are released. 
     * 
     * It is not possible to take and hold a lock across the checks for all 
     * granularities because each target could be in a separate partition. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN4306"><span class='Ref_to_Parameter'>tuple</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/storage/predicate_internals.h.html#LN401"><span class='Ref_to_Macro'>SET_PREDICATELOCKTARGETTAG_TUPLE</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4309"><span class='Ref_To_Local'>targettag</span></a><span class='Delimiter'>, 
</span>                                         <a href="predicate.c.html#LN4306"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN84"><span class='Ref_to_Member'>rd_node</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN59"><span class='Ref_to_Member'>dbNode</span></a><span class='Delimiter'>, 
</span>                                         <a href="predicate.c.html#LN4306"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN115"><span class='Ref_to_Member'>rd_id</span></a><span class='Delimiter'>, 
</span>                                 <a href="../../../include/storage/itemptr.h.html#LN74"><span class='Ref_to_Macro'>ItemPointerGetBlockNumber</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN4306"><span class='Ref_to_Parameter'>tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN64"><span class='Ref_to_Member'>t_self</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                               <a href="../../../include/storage/itemptr.h.html#LN93"><span class='Ref_to_Macro'>ItemPointerGetOffsetNumber</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN4306"><span class='Ref_to_Parameter'>tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN64"><span class='Ref_to_Member'>t_self</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN464"><span class='Ref_to_Proto'>CheckTargetForConflictsIn</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN4309"><span class='Ref_To_Local'>targettag</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/bufmgr.h.html#LN113"><span class='Ref_to_Macro'>BufferIsValid</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4307"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/storage/predicate_internals.h.html#LN395"><span class='Ref_to_Macro'>SET_PREDICATELOCKTARGETTAG_PAGE</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4309"><span class='Ref_To_Local'>targettag</span></a><span class='Delimiter'>, 
</span>                                        <a href="predicate.c.html#LN4306"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN84"><span class='Ref_to_Member'>rd_node</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN59"><span class='Ref_to_Member'>dbNode</span></a><span class='Delimiter'>, 
</span>                                        <a href="predicate.c.html#LN4306"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN115"><span class='Ref_to_Member'>rd_id</span></a><span class='Delimiter'>, 
</span>                                        <a href="../../../include/storage/bufmgr.h.html#LN187"><span class='Ref_to_Proto'>BufferGetBlockNumber</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4307"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN464"><span class='Ref_to_Proto'>CheckTargetForConflictsIn</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN4309"><span class='Ref_To_Local'>targettag</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/storage/predicate_internals.h.html#LN389"><span class='Ref_to_Macro'>SET_PREDICATELOCKTARGETTAG_RELATION</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4309"><span class='Ref_To_Local'>targettag</span></a><span class='Delimiter'>, 
</span>                                        <a href="predicate.c.html#LN4306"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN84"><span class='Ref_to_Member'>rd_node</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN59"><span class='Ref_to_Member'>dbNode</span></a><span class='Delimiter'>, 
</span>                                        <a href="predicate.c.html#LN4306"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN115"><span class='Ref_to_Member'>rd_id</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN464"><span class='Ref_to_Proto'>CheckTargetForConflictsIn</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN4309"><span class='Ref_To_Local'>targettag</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end CheckForSerializableConflictIn &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * CheckTableForSerializableConflictIn 
 *      The entire table is going through a DDL-style logical mass delete 
 *      like TRUNCATE or DROP TABLE.  If that causes a rw-conflict in from 
 *      another serializable transaction, take appropriate action. 
 * 
 * While these operations do not operate entirely within the bounds of 
 * snapshot isolation, they can occur inside a serializable transaction, and 
 * will logically occur after any reads which saw rows which were destroyed 
 * by these operations, so we do what we can to serialize properly under 
 * SSI. 
 * 
 * The relation passed in must be a heap relation. Any predicate lock of any 
 * granularity on the heap will cause a rw-conflict in to this transaction. 
 * Predicate locks on indexes do not matter because they only exist to guard 
 * against conflicting inserts into the index, and this is a mass *delete*. 
 * When a table is truncated or dropped, the index will also be truncated 
 * or dropped, and we'll deal with locks on the index when that happens. 
 * 
 * Dropping or truncating a table also needs to drop any existing predicate 
 * locks on heap tuples or pages, because they're about to go away. This 
 * should be done before altering the predicate locks because the transaction 
 * could be rolled back because of a conflict, in which case the lock changes 
 * are not needed. (At the moment, we don't actually bother to drop the 
 * existing locks on a dropped or truncated table at the moment. That might 
 * lead to some false positives, but it doesn't seem worth the trouble.) 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN4390"></a><span class='Declare_Function'>CheckTableForSerializableConflictIn</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>relation</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4392"></a>    <a href="../../../include/utils/hsearch.h.html#LN111"><span class='Ref_to_Typedef'>HASH_SEQ_STATUS</span></a> <span class='Declare_Local'>seqstat</span><span class='Delimiter'>; 
</span><a name="LN4393"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN285"><span class='Ref_to_Struct'>PREDICATELOCKTARGET</span></a> <span class='Operator'>*</span><span class='Declare_Local'>target</span><span class='Delimiter'>; 
</span><a name="LN4394"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>dbId</span><span class='Delimiter'>; 
</span><a name="LN4395"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>heapId</span><span class='Delimiter'>; 
</span><a name="LN4396"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Bail out quickly if there are no serializable transactions running. 
     * It's safe to check this without taking locks because the caller is 
     * holding an ACCESS EXCLUSIVE lock on the relation.  No new locks which 
     * would matter here can be acquired while that is held. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN155"><span class='Ref_to_Member'>SxactGlobalXmin</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN539"><span class='Ref_to_Func'>SerializationNeededForWrite</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4390"><span class='Ref_to_Parameter'>relation</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We're doing a write which might cause rw-conflicts now or later. 
     * Memorize that fact. 
     */ 
</span>    <a href="predicate.c.html#LN411"><span class='Ref_to_Global_Var'>MyXactDidWrite</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN4390"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN158"><span class='Ref_to_Member'>rd_index</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* not an index relation */ 
</span> 
    <a href="predicate.c.html#LN4394"><span class='Ref_To_Local'>dbId</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN4390"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN84"><span class='Ref_to_Member'>rd_node</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN59"><span class='Ref_to_Member'>dbNode</span></a><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN4395"><span class='Ref_To_Local'>heapId</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN4390"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN115"><span class='Ref_to_Member'>rd_id</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SerializablePredicateLockListLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN4396"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="predicate.c.html#LN4396"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="../../../include/storage/lwlock.h.html#LN120"><span class='Ref_to_Const'>NUM_PREDICATELOCK_PARTITIONS</span></a><span class='Delimiter'>; </span><a href="predicate.c.html#LN4396"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN247"><span class='Ref_to_Macro'>PredicateLockHashPartitionLockByIndex</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4396"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Scan through target list */ 
</span>    <a href="../../../include/utils/hsearch.h.html#LN134"><span class='Ref_to_Proto'>hash_seq_init</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN4392"><span class='Ref_To_Local'>seqstat</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN386"><span class='Ref_to_Global_Var'>PredicateLockTargetHash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>while</span> <span class='Parentheses'>((</span><a href="predicate.c.html#LN4393"><span class='Ref_To_Local'>target</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN285"><span class='Ref_to_Struct'>PREDICATELOCKTARGET</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/utils/hsearch.h.html#LN135"><span class='Ref_to_Proto'>hash_seq_search</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN4392"><span class='Ref_To_Local'>seqstat</span></a><span class='Parentheses'>)))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN4431"></a>        <a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Declare_Local'>predlock</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Check whether this is a target which needs attention. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN409"><span class='Ref_to_Macro'>GET_PREDICATELOCKTARGETTAG_RELATION</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4393"><span class='Ref_To_Local'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN288"><span class='Ref_to_Member'>tag</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="predicate.c.html#LN4395"><span class='Ref_To_Local'>heapId</span></a><span class='Parentheses'>)</span> 
            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* wrong relation id */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN407"><span class='Ref_to_Macro'>GET_PREDICATELOCKTARGETTAG_DB</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4393"><span class='Ref_To_Local'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN288"><span class='Ref_to_Member'>tag</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="predicate.c.html#LN4394"><span class='Ref_To_Local'>dbId</span></a><span class='Parentheses'>)</span> 
            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* wrong database id */ 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Loop through locks for this target and flag conflicts. 
         */ 
</span>        <a href="predicate.c.html#LN4431"><span class='Ref_To_Local'>predlock</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN4393"><span class='Ref_To_Local'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN291"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN4393"><span class='Ref_To_Local'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN291"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a><span class='Delimiter'>, </span>targetLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN4431"><span class='Ref_To_Local'>predlock</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN4450"></a>            <a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Declare_Local'>nextpredlock</span><span class='Delimiter'>; 
</span> 
            <a href="predicate.c.html#LN4450"><span class='Ref_To_Local'>nextpredlock</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN4393"><span class='Ref_To_Local'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN291"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN4431"><span class='Ref_To_Local'>predlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN324"><span class='Ref_to_Member'>targetLink</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a><span class='Delimiter'>, </span>targetLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN4431"><span class='Ref_To_Local'>predlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN321"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/predicate_internals.h.html#LN306"><span class='Ref_to_Member'>myXact</span></a> <span class='Operator'>!= </span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a> 
              <span class='Operator'>&& !</span><a href="predicate.c.html#LN420"><span class='Ref_to_Proto'>RWConflictExists</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4431"><span class='Ref_To_Local'>predlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN321"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/predicate_internals.h.html#LN306"><span class='Ref_to_Member'>myXact</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="predicate.c.html#LN465"><span class='Ref_to_Proto'>FlagRWConflict</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4431"><span class='Ref_To_Local'>predlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN321"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/predicate_internals.h.html#LN306"><span class='Ref_to_Member'>myXact</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <a href="predicate.c.html#LN4431"><span class='Ref_To_Local'>predlock</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN4450"><span class='Ref_To_Local'>nextpredlock</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while (target=(PREDICATELOC... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Release locks in reverse order */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN4396"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><a href="../../../include/storage/lwlock.h.html#LN120"><span class='Ref_to_Const'>NUM_PREDICATELOCK_PARTITIONS</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="predicate.c.html#LN4396"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="predicate.c.html#LN4396"><span class='Ref_To_Local'>i</span></a><span class='Operator'>--</span><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN247"><span class='Ref_to_Macro'>PredicateLockHashPartitionLockByIndex</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4396"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializablePredicateLockListLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end CheckTableForSerializableConflictIn &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Flag a rw-dependency between two serializable transactions. 
 * 
 * The caller is responsible for ensuring that we have a LW lock on 
 * the transaction hash table. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN4482"></a><span class='Declare_Function'>FlagRWConflict</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>reader</span><span class='Delimiter'>, </span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>writer</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN4482"><span class='Ref_to_Parameter'>reader</span></a> <span class='Operator'>!= </span><a href="predicate.c.html#LN4482"><span class='Ref_to_Parameter'>writer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* First, see if this conflict causes failure. */ 
</span>    <a href="predicate.c.html#LN466"><span class='Ref_to_Proto'>OnConflict_CheckForSerializationFailure</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4482"><span class='Ref_to_Parameter'>reader</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN4482"><span class='Ref_to_Parameter'>writer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Actually do the conflict flagging. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN4482"><span class='Ref_to_Parameter'>reader</span></a> <span class='Operator'>== </span><a href="predicate.c.html#LN351"><span class='Ref_to_Global_Var'>OldCommittedSxact</span></a><span class='Parentheses'>) 
</span>        <a href="predicate.c.html#LN4482"><span class='Ref_to_Parameter'>writer</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN105"><span class='Ref_to_Member'>flags</span></a> <span class='Operator'>|= </span><a href="../../../include/storage/predicate_internals.h.html#LN123"><span class='Ref_to_Const'>SXACT_FLAG_SUMMARY_CONFLICT_IN</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN4482"><span class='Ref_to_Parameter'>writer</span></a> <span class='Operator'>== </span><a href="predicate.c.html#LN351"><span class='Ref_to_Global_Var'>OldCommittedSxact</span></a><span class='Parentheses'>) 
</span>        <a href="predicate.c.html#LN4482"><span class='Ref_to_Parameter'>reader</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN105"><span class='Ref_to_Member'>flags</span></a> <span class='Operator'>|= </span><a href="../../../include/storage/predicate_internals.h.html#LN124"><span class='Ref_to_Const'>SXACT_FLAG_SUMMARY_CONFLICT_OUT</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="predicate.c.html#LN421"><span class='Ref_to_Proto'>SetRWConflict</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4482"><span class='Ref_to_Parameter'>reader</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN4482"><span class='Ref_to_Parameter'>writer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/*---------------------------------------------------------------------------- 
 * We are about to add a RW-edge to the dependency graph - check that we don't 
 * introduce a dangerous structure by doing so, and abort one of the 
 * transactions if so. 
 * 
 * A serialization failure can only occur if there is a dangerous structure 
 * in the dependency graph: 
 * 
 *      Tin ------&GT; Tpivot ------&GT; Tout 
 *            rw             rw 
 * 
 * Furthermore, Tout must commit first. 
 * 
 * One more optimization is that if Tin is declared READ ONLY (or commits 
 * without writing), we can only have a problem if Tout committed before Tin 
 * acquired its snapshot. 
 *---------------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN4517"></a><span class='Declare_Function'>OnConflict_CheckForSerializationFailure</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>reader</span><span class='Delimiter'>, 
</span><a name="LN4518"></a>                                        <a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>writer</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4520"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>failure</span><span class='Delimiter'>; 
</span><a name="LN4521"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a>  <span class='Declare_Local'>conflict</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN151"><span class='Ref_to_Proto'>LWLockHeldByMe</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN4520"><span class='Ref_To_Local'>failure</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/*------------------------------------------------------------------------ 
     * Check for already-committed writer with rw-conflict out flagged 
     * (conflict-flag on W means that T2 committed before W): 
     * 
     *      R ------&GT; W ------&GT; T2 
     *          rw        rw 
     * 
     * That is a dangerous structure, so we must abort. (Since the writer 
     * has already committed, we must be the reader) 
     *------------------------------------------------------------------------ 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN263"><span class='Ref_to_Macro'>SxactIsCommitted</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4518"><span class='Ref_to_Parameter'>writer</span></a><span class='Parentheses'>)</span> 
      <span class='Operator'>&& </span><span class='Parentheses'>(</span><a href="predicate.c.html#LN275"><span class='Ref_to_Macro'>SxactHasConflictOut</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4518"><span class='Ref_to_Parameter'>writer</span></a><span class='Parentheses'>) </span><span class='Operator'>|| </span><a href="predicate.c.html#LN269"><span class='Ref_to_Macro'>SxactHasSummaryConflictOut</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4518"><span class='Ref_to_Parameter'>writer</span></a><span class='Parentheses'>)))</span> 
        <a href="predicate.c.html#LN4520"><span class='Ref_To_Local'>failure</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/*------------------------------------------------------------------------ 
     * Check whether the writer has become a pivot with an out-conflict 
     * committed transaction (T2), and T2 committed first: 
     * 
     *      R ------&GT; W ------&GT; T2 
     *          rw        rw 
     * 
     * Because T2 must've committed first, there is no anomaly if: 
     * - the reader committed before T2 
     * - the writer committed before T2 
     * - the reader is a READ ONLY transaction and the reader was concurrent 
     *   with T2 (= reader acquired its snapshot before T2 committed) 
     * 
     * We also handle the case that T2 is prepared but not yet committed 
     * here. In that case T2 has already checked for conflicts, so if it 
     * commits first, making the above conflict real, it's too late for it 
     * to abort. 
     *------------------------------------------------------------------------ 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN4520"><span class='Ref_To_Local'>failure</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN269"><span class='Ref_to_Macro'>SxactHasSummaryConflictOut</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4518"><span class='Ref_to_Parameter'>writer</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="predicate.c.html#LN4520"><span class='Ref_To_Local'>failure</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="predicate.c.html#LN4521"><span class='Ref_To_Local'>conflict</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <a href="predicate.c.html#LN4521"><span class='Ref_To_Local'>conflict</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a><span class='Parentheses'>) 
</span>                <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN4518"><span class='Ref_to_Parameter'>writer</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN85"><span class='Ref_to_Member'>outConflicts</span></a><span class='Delimiter'>, 
</span>                             <span class='Operator'>&</span><a href="predicate.c.html#LN4518"><span class='Ref_to_Parameter'>writer</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN85"><span class='Ref_to_Member'>outConflicts</span></a><span class='Delimiter'>, 
</span>                             <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN194"><span class='Ref_to_Struct'>RWConflictData</span></a><span class='Delimiter'>, </span>outLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN4521"><span class='Ref_To_Local'>conflict</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN4575"></a>            <a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Local'>t2</span> <span class='Operator'>= </span><a href="predicate.c.html#LN4521"><span class='Ref_To_Local'>conflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN199"><span class='Ref_to_Member'>sxactIn</span></a><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN264"><span class='Ref_to_Macro'>SxactIsPrepared</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4575"><span class='Ref_To_Local'>t2</span></a><span class='Parentheses'>)</span> 
                <span class='Operator'>&& </span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN263"><span class='Ref_to_Macro'>SxactIsCommitted</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4517"><span class='Ref_to_Parameter'>reader</span></a><span class='Parentheses'>) 
</span>                    <span class='Operator'>|| </span><a href="predicate.c.html#LN4575"><span class='Ref_To_Local'>t2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN74"><span class='Ref_to_Member'>prepareSeqNo</span></a> <span class='Operator'>&LT;= </span><a href="predicate.c.html#LN4517"><span class='Ref_to_Parameter'>reader</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN75"><span class='Ref_to_Member'>commitSeqNo</span></a><span class='Parentheses'>)</span> 
                <span class='Operator'>&& </span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN263"><span class='Ref_to_Macro'>SxactIsCommitted</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4518"><span class='Ref_to_Parameter'>writer</span></a><span class='Parentheses'>) 
</span>                    <span class='Operator'>|| </span><a href="predicate.c.html#LN4575"><span class='Ref_To_Local'>t2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN74"><span class='Ref_to_Member'>prepareSeqNo</span></a> <span class='Operator'>&LT;= </span><a href="predicate.c.html#LN4518"><span class='Ref_to_Parameter'>writer</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN75"><span class='Ref_to_Member'>commitSeqNo</span></a><span class='Parentheses'>)</span> 
                <span class='Operator'>&& </span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN267"><span class='Ref_to_Macro'>SxactIsReadOnly</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4517"><span class='Ref_to_Parameter'>reader</span></a><span class='Parentheses'>) 
</span>              <span class='Operator'>|| </span><a href="predicate.c.html#LN4575"><span class='Ref_To_Local'>t2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN74"><span class='Ref_to_Member'>prepareSeqNo</span></a> <span class='Operator'>&LT;= </span><a href="predicate.c.html#LN4517"><span class='Ref_to_Parameter'>reader</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN84"><span class='Ref_to_Member'>SeqNo</span></a><span class='Operator'>.</span>lastCommitBeforeSnapshot<span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="predicate.c.html#LN4520"><span class='Ref_To_Local'>failure</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <a href="predicate.c.html#LN4521"><span class='Ref_To_Local'>conflict</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a><span class='Parentheses'>) 
</span>                <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN4518"><span class='Ref_to_Parameter'>writer</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN85"><span class='Ref_to_Member'>outConflicts</span></a><span class='Delimiter'>, 
</span>                             <span class='Operator'>&</span><a href="predicate.c.html#LN4521"><span class='Ref_To_Local'>conflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN196"><span class='Ref_to_Member'>outLink</span></a><span class='Delimiter'>, 
</span>                             <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN194"><span class='Ref_to_Struct'>RWConflictData</span></a><span class='Delimiter'>, </span>outLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while conflict &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !failure &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/*------------------------------------------------------------------------ 
     * Check whether the reader has become a pivot with a writer 
     * that's committed (or prepared): 
     * 
     *      T0 ------&GT; R ------&GT; W 
     *           rw        rw 
     * 
     * Because W must've committed first for an anomaly to occur, there is no 
     * anomaly if: 
     * - T0 committed before the writer 
     * - T0 is READ ONLY, and overlaps the writer 
     *------------------------------------------------------------------------ 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN4520"><span class='Ref_To_Local'>failure</span></a> <span class='Operator'>&& </span><a href="predicate.c.html#LN264"><span class='Ref_to_Macro'>SxactIsPrepared</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4518"><span class='Ref_to_Parameter'>writer</span></a><span class='Parentheses'>) </span><span class='Operator'>&& !</span><a href="predicate.c.html#LN267"><span class='Ref_to_Macro'>SxactIsReadOnly</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4517"><span class='Ref_to_Parameter'>reader</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN268"><span class='Ref_to_Macro'>SxactHasSummaryConflictIn</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4517"><span class='Ref_to_Parameter'>reader</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="predicate.c.html#LN4520"><span class='Ref_To_Local'>failure</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="predicate.c.html#LN4521"><span class='Ref_To_Local'>conflict</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <a href="predicate.c.html#LN4521"><span class='Ref_To_Local'>conflict</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a><span class='Parentheses'>) 
</span>                <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN4517"><span class='Ref_to_Parameter'>reader</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN87"><span class='Ref_to_Member'>inConflicts</span></a><span class='Delimiter'>, 
</span>                             <span class='Operator'>&</span><a href="predicate.c.html#LN4517"><span class='Ref_to_Parameter'>reader</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN87"><span class='Ref_to_Member'>inConflicts</span></a><span class='Delimiter'>, 
</span>                             <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN194"><span class='Ref_to_Struct'>RWConflictData</span></a><span class='Delimiter'>, </span>inLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN4521"><span class='Ref_To_Local'>conflict</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN4622"></a>            <a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Local'>t0</span> <span class='Operator'>= </span><a href="predicate.c.html#LN4521"><span class='Ref_To_Local'>conflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN198"><span class='Ref_to_Member'>sxactOut</span></a><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN266"><span class='Ref_to_Macro'>SxactIsDoomed</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4622"><span class='Ref_To_Local'>t0</span></a><span class='Parentheses'>)</span> 
                <span class='Operator'>&& </span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN263"><span class='Ref_to_Macro'>SxactIsCommitted</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4622"><span class='Ref_To_Local'>t0</span></a><span class='Parentheses'>) 
</span>                    <span class='Operator'>|| </span><a href="predicate.c.html#LN4622"><span class='Ref_To_Local'>t0</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN75"><span class='Ref_to_Member'>commitSeqNo</span></a> <span class='Operator'>&GT;= </span><a href="predicate.c.html#LN4518"><span class='Ref_to_Parameter'>writer</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN74"><span class='Ref_to_Member'>prepareSeqNo</span></a><span class='Parentheses'>)</span> 
                <span class='Operator'>&& </span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN267"><span class='Ref_to_Macro'>SxactIsReadOnly</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4622"><span class='Ref_To_Local'>t0</span></a><span class='Parentheses'>) 
</span>              <span class='Operator'>|| </span><a href="predicate.c.html#LN4622"><span class='Ref_To_Local'>t0</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN84"><span class='Ref_to_Member'>SeqNo</span></a><span class='Operator'>.</span>lastCommitBeforeSnapshot <span class='Operator'>&GT;= </span><a href="predicate.c.html#LN4518"><span class='Ref_to_Parameter'>writer</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN74"><span class='Ref_to_Member'>prepareSeqNo</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="predicate.c.html#LN4520"><span class='Ref_To_Local'>failure</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <a href="predicate.c.html#LN4521"><span class='Ref_To_Local'>conflict</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a><span class='Parentheses'>) 
</span>                <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN4517"><span class='Ref_to_Parameter'>reader</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN87"><span class='Ref_to_Member'>inConflicts</span></a><span class='Delimiter'>, 
</span>                             <span class='Operator'>&</span><a href="predicate.c.html#LN4521"><span class='Ref_To_Local'>conflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN197"><span class='Ref_to_Member'>inLink</span></a><span class='Delimiter'>, 
</span>                             <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN194"><span class='Ref_to_Struct'>RWConflictData</span></a><span class='Delimiter'>, </span>inLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !failure&&SxactIsPrep... &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN4520"><span class='Ref_To_Local'>failure</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We have to kill a transaction to avoid a possible anomaly from 
         * occurring. If the writer is us, we can just ereport() to cause a 
         * transaction abort. Otherwise we flag the writer for termination, 
         * causing it to abort when it tries to commit. However, if the writer 
         * is a prepared transaction, already prepared, we can't abort it 
         * anymore, so we have to kill the reader instead. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a> <span class='Operator'>== </span><a href="predicate.c.html#LN4518"><span class='Ref_to_Parameter'>writer</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_T_R_SERIALIZATION_FAILURE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not serialize access due to read/write dependencies among transactions"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN898"><span class='Ref_to_Func'>errdetail_internal</span></a><span class='Parentheses'>(</span><span class='String'>"Reason code: Canceled on identification as a pivot, during write."</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"The transaction might succeed if retried."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN264"><span class='Ref_to_Macro'>SxactIsPrepared</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4518"><span class='Ref_to_Parameter'>writer</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* if we're not the writer, we have to be the reader */ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a> <span class='Operator'>== </span><a href="predicate.c.html#LN4517"><span class='Ref_to_Parameter'>reader</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_T_R_SERIALIZATION_FAILURE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not serialize access due to read/write dependencies among transactions"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN898"><span class='Ref_to_Func'>errdetail_internal</span></a><span class='Parentheses'>(</span><span class='String'>"Reason code: Canceled on conflict out to pivot %u, during read."</span><span class='Delimiter'>, </span><a href="predicate.c.html#LN4518"><span class='Ref_to_Parameter'>writer</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN99"><span class='Ref_to_Member'>topXid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"The transaction might succeed if retried."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="predicate.c.html#LN4518"><span class='Ref_to_Parameter'>writer</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN105"><span class='Ref_to_Member'>flags</span></a> <span class='Operator'>|= </span><a href="../../../include/storage/predicate_internals.h.html#LN112"><span class='Ref_to_Const'>SXACT_FLAG_DOOMED</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if failure &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end OnConflict_CheckForSerializationFailure &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * PreCommit_CheckForSerializableConflicts 
 *      Check for dangerous structures in a serializable transaction 
 *      at commit. 
 * 
 * We're checking for a dangerous structure as each conflict is recorded. 
 * The only way we could have a problem at commit is if this is the "out" 
 * side of a pivot, and neither the "in" side nor the pivot has yet 
 * committed. 
 * 
 * If a dangerous structure is found, the pivot (the near conflict) is 
 * marked for death, because rolling back another transaction might mean 
 * that we flail without ever making progress.  This transaction is 
 * committing writes, so letting it commit ensures progress.  If we 
 * canceled the far conflict, it might immediately fail again on retry. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN4692"></a><span class='Declare_Function'>PreCommit_CheckForSerializationFailure</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4694"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a>  <span class='Declare_Local'>nearConflict</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a> <span class='Operator'>== </span><a href="../../../include/storage/predicate_internals.h.html#LN468"><span class='Ref_to_Const'>InvalidSerializableXact</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/xact.h.html#LN43"><span class='Ref_to_Macro'>IsolationIsSerializable</span></a><span class='Parentheses'>())</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Check if someone else has already decided that we need to die */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN266"><span class='Ref_to_Macro'>SxactIsDoomed</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_T_R_SERIALIZATION_FAILURE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not serialize access due to read/write dependencies among transactions"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN898"><span class='Ref_to_Func'>errdetail_internal</span></a><span class='Parentheses'>(</span><span class='String'>"Reason code: Canceled on identification as a pivot, during commit attempt."</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"The transaction might succeed if retried."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="predicate.c.html#LN4694"><span class='Ref_To_Local'>nearConflict</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN87"><span class='Ref_to_Member'>inConflicts</span></a><span class='Delimiter'>, 
</span>                     <span class='Operator'>&</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN87"><span class='Ref_to_Member'>inConflicts</span></a><span class='Delimiter'>, 
</span>                     <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN194"><span class='Ref_to_Struct'>RWConflictData</span></a><span class='Delimiter'>, </span>inLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN4694"><span class='Ref_To_Local'>nearConflict</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN263"><span class='Ref_to_Macro'>SxactIsCommitted</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4694"><span class='Ref_To_Local'>nearConflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN198"><span class='Ref_to_Member'>sxactOut</span></a><span class='Parentheses'>) 
</span>            <span class='Operator'>&& !</span><a href="predicate.c.html#LN266"><span class='Ref_to_Macro'>SxactIsDoomed</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4694"><span class='Ref_To_Local'>nearConflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN198"><span class='Ref_to_Member'>sxactOut</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN4723"></a>            <a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a>  <span class='Declare_Local'>farConflict</span><span class='Delimiter'>; 
</span> 
            <a href="predicate.c.html#LN4723"><span class='Ref_To_Local'>farConflict</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a><span class='Parentheses'>) 
</span>                <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN4694"><span class='Ref_To_Local'>nearConflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN198"><span class='Ref_to_Member'>sxactOut</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN87"><span class='Ref_to_Member'>inConflicts</span></a><span class='Delimiter'>, 
</span>                             <span class='Operator'>&</span><a href="predicate.c.html#LN4694"><span class='Ref_To_Local'>nearConflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN198"><span class='Ref_to_Member'>sxactOut</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN87"><span class='Ref_to_Member'>inConflicts</span></a><span class='Delimiter'>, 
</span>                             <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN194"><span class='Ref_to_Struct'>RWConflictData</span></a><span class='Delimiter'>, </span>inLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN4723"><span class='Ref_To_Local'>farConflict</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN4723"><span class='Ref_To_Local'>farConflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN198"><span class='Ref_to_Member'>sxactOut</span></a> <span class='Operator'>== </span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a> 
                    <span class='Operator'>|| </span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN263"><span class='Ref_to_Macro'>SxactIsCommitted</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4723"><span class='Ref_To_Local'>farConflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN198"><span class='Ref_to_Member'>sxactOut</span></a><span class='Parentheses'>) 
</span>                        <span class='Operator'>&& !</span><a href="predicate.c.html#LN267"><span class='Ref_to_Macro'>SxactIsReadOnly</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4723"><span class='Ref_To_Local'>farConflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN198"><span class='Ref_to_Member'>sxactOut</span></a><span class='Parentheses'>) 
</span>                        <span class='Operator'>&& !</span><a href="predicate.c.html#LN266"><span class='Ref_to_Macro'>SxactIsDoomed</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4723"><span class='Ref_To_Local'>farConflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN198"><span class='Ref_to_Member'>sxactOut</span></a><span class='Parentheses'>)))</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* 
                     * Normally, we kill the pivot transaction to make sure we 
                     * make progress if the failing transaction is retried. 
                     * However, we can't kill it if it's already prepared, so 
                     * in that case we commit suicide instead. 
                     */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN264"><span class='Ref_to_Macro'>SxactIsPrepared</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4694"><span class='Ref_To_Local'>nearConflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN198"><span class='Ref_to_Member'>sxactOut</span></a><span class='Parentheses'>))</span> 
                    <span class='Delimiter'>{ 
</span>                        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_T_R_SERIALIZATION_FAILURE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not serialize access due to read/write dependencies among transactions"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                 <a href="../../utils/error/elog.c.html#LN898"><span class='Ref_to_Func'>errdetail_internal</span></a><span class='Parentheses'>(</span><span class='String'>"Reason code: Canceled on commit attempt with conflict in from prepared pivot."</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                 <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"The transaction might succeed if retried."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <a href="predicate.c.html#LN4694"><span class='Ref_To_Local'>nearConflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN198"><span class='Ref_to_Member'>sxactOut</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN105"><span class='Ref_to_Member'>flags</span></a> <span class='Operator'>|= </span><a href="../../../include/storage/predicate_internals.h.html#LN112"><span class='Ref_to_Const'>SXACT_FLAG_DOOMED</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if farConflict-&GT;sxactOut... &raquo; </span> 
                <a href="predicate.c.html#LN4723"><span class='Ref_To_Local'>farConflict</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a><span class='Parentheses'>) 
</span>                    <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN4694"><span class='Ref_To_Local'>nearConflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN198"><span class='Ref_to_Member'>sxactOut</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN87"><span class='Ref_to_Member'>inConflicts</span></a><span class='Delimiter'>, 
</span>                                 <span class='Operator'>&</span><a href="predicate.c.html#LN4723"><span class='Ref_To_Local'>farConflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN197"><span class='Ref_to_Member'>inLink</span></a><span class='Delimiter'>, 
</span>                                 <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN194"><span class='Ref_to_Struct'>RWConflictData</span></a><span class='Delimiter'>, </span>inLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while farConflict &raquo; </span> 
        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !SxactIsCommitted(nea... &raquo; </span> 
 
        <a href="predicate.c.html#LN4694"><span class='Ref_To_Local'>nearConflict</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN87"><span class='Ref_to_Member'>inConflicts</span></a><span class='Delimiter'>, 
</span>                         <span class='Operator'>&</span><a href="predicate.c.html#LN4694"><span class='Ref_To_Local'>nearConflict</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN197"><span class='Ref_to_Member'>inLink</span></a><span class='Delimiter'>, 
</span>                         <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN194"><span class='Ref_to_Struct'>RWConflictData</span></a><span class='Delimiter'>, </span>inLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while nearConflict &raquo; </span> 
 
    <a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN74"><span class='Ref_to_Member'>prepareSeqNo</span></a> <span class='Operator'>= ++</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN161"><span class='Ref_to_Member'>LastSxactCommitSeqNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN105"><span class='Ref_to_Member'>flags</span></a> <span class='Operator'>|= </span><a href="../../../include/storage/predicate_internals.h.html#LN110"><span class='Ref_to_Const'>SXACT_FLAG_PREPARED</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end PreCommit_CheckForSerializationFailure &raquo; </span> 
 
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------*/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Two-phase commit support 
 */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * AtPrepare_Locks 
 *      Do the preparatory work for a PREPARE: make 2PC state file 
 *      records for all predicate locks currently held. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN4785"></a><span class='Declare_Function'>AtPrepare_PredicateLocks</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4787"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Declare_Local'>predlock</span><span class='Delimiter'>; 
</span><a name="LN4788"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sxact</span><span class='Delimiter'>; 
</span><a name="LN4789"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN455"><span class='Ref_to_Struct'>TwoPhasePredicateRecord</span></a> <span class='Declare_Local'>record</span><span class='Delimiter'>; 
</span><a name="LN4790"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN442"><span class='Ref_to_Struct'>TwoPhasePredicateXactRecord</span></a> <span class='Operator'>*</span><span class='Declare_Local'>xactRecord</span><span class='Delimiter'>; 
</span><a name="LN4791"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN449"><span class='Ref_to_Struct'>TwoPhasePredicateLockRecord</span></a> <span class='Operator'>*</span><span class='Declare_Local'>lockRecord</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN4788"><span class='Ref_To_Local'>sxact</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN4790"><span class='Ref_To_Local'>xactRecord</span></a> <span class='Operator'>= &</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN4789"><span class='Ref_To_Local'>record</span></a><span class='Operator'>.</span><a href="../../../include/storage/predicate_internals.h.html#LN462"><span class='Ref_to_Member'>data</span></a><span class='Operator'>.</span>xactRecord<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN4791"><span class='Ref_To_Local'>lockRecord</span></a> <span class='Operator'>= &</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN4789"><span class='Ref_To_Local'>record</span></a><span class='Operator'>.</span><a href="../../../include/storage/predicate_internals.h.html#LN462"><span class='Ref_to_Member'>data</span></a><span class='Operator'>.</span>lockRecord<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a> <span class='Operator'>== </span><a href="../../../include/storage/predicate_internals.h.html#LN468"><span class='Ref_to_Const'>InvalidSerializableXact</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Generate an xact record for our SERIALIZABLEXACT */ 
</span>    <a href="predicate.c.html#LN4789"><span class='Ref_To_Local'>record</span></a><span class='Operator'>.</span><a href="../../../include/storage/predicate_internals.h.html#LN457"><span class='Ref_to_Member'>type</span></a> <span class='Operator'>= </span><a href="../../../include/storage/predicate_internals.h.html#LN427"><span class='Ref_to_EnumConst'>TWOPHASEPREDICATERECORD_XACT</span></a><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN4790"><span class='Ref_To_Local'>xactRecord</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN444"><span class='Ref_to_Member'>xmin</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN104"><span class='Ref_to_Member'>xmin</span></a><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN4790"><span class='Ref_To_Local'>xactRecord</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN445"><span class='Ref_to_Member'>flags</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN105"><span class='Ref_to_Member'>flags</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Note that we don't include the list of conflicts in our out in the 
     * statefile, because new conflicts can be added even after the 
     * transaction prepares. We'll just make a conservative assumption during 
     * recovery instead. 
     */ 
</span> 
    <a href="../../../include/access/twophase_rmgr.h.html#LN36"><span class='Ref_to_Proto'>RegisterTwoPhaseRecord</span></a><span class='Parentheses'>(</span><a href="../../../include/access/twophase_rmgr.h.html#LN27"><span class='Ref_to_Const'>TWOPHASE_RM_PREDICATELOCK_ID</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, 
</span>                           <span class='Operator'>&</span><a href="predicate.c.html#LN4789"><span class='Ref_To_Local'>record</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN4789"><span class='Ref_To_Local'>record</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Generate a lock record for each lock. 
     * 
     * To do this, we need to walk the predicate lock list in our sxact rather 
     * than using the local predicate lock table because the latter is not 
     * guaranteed to be accurate. 
     */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SerializablePredicateLockListLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN4787"><span class='Ref_To_Local'>predlock</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN4788"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN89"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN4788"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN89"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a><span class='Delimiter'>, </span>xactLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN4787"><span class='Ref_To_Local'>predlock</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="predicate.c.html#LN4789"><span class='Ref_To_Local'>record</span></a><span class='Operator'>.</span><a href="../../../include/storage/predicate_internals.h.html#LN457"><span class='Ref_to_Member'>type</span></a> <span class='Operator'>= </span><a href="../../../include/storage/predicate_internals.h.html#LN428"><span class='Ref_to_EnumConst'>TWOPHASEPREDICATERECORD_LOCK</span></a><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN4791"><span class='Ref_To_Local'>lockRecord</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN451"><span class='Ref_to_Member'>target</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN4787"><span class='Ref_To_Local'>predlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN321"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/predicate_internals.h.html#LN305"><span class='Ref_to_Member'>myTarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN288"><span class='Ref_to_Member'>tag</span></a><span class='Delimiter'>; 
</span> 
        <a href="../../../include/access/twophase_rmgr.h.html#LN36"><span class='Ref_to_Proto'>RegisterTwoPhaseRecord</span></a><span class='Parentheses'>(</span><a href="../../../include/access/twophase_rmgr.h.html#LN27"><span class='Ref_to_Const'>TWOPHASE_RM_PREDICATELOCK_ID</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, 
</span>                               <span class='Operator'>&</span><a href="predicate.c.html#LN4789"><span class='Ref_To_Local'>record</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN4789"><span class='Ref_To_Local'>record</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <a href="predicate.c.html#LN4787"><span class='Ref_To_Local'>predlock</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN4788"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN89"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN4787"><span class='Ref_To_Local'>predlock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN326"><span class='Ref_to_Member'>xactLink</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN318"><span class='Ref_to_Struct'>PREDICATELOCK</span></a><span class='Delimiter'>, </span>xactLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializablePredicateLockListLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end AtPrepare_PredicateLocks &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * PostPrepare_Locks 
 *      Clean up after successful PREPARE. Unlike the non-predicate 
 *      lock manager, we do not need to transfer locks to a dummy 
 *      PGPROC because our SERIALIZABLEXACT will stay around 
 *      anyway. We only need to clean up our local state. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN4854"></a><span class='Declare_Function'>PostPrepare_PredicateLocks</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a> <span class='Operator'>== </span><a href="../../../include/storage/predicate_internals.h.html#LN468"><span class='Ref_to_Const'>InvalidSerializableXact</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN264"><span class='Ref_to_Macro'>SxactIsPrepared</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN106"><span class='Ref_to_Member'>pid</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/hsearch.h.html#LN123"><span class='Ref_to_Proto'>hash_destroy</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN403"><span class='Ref_to_Global_Var'>LocalPredicateLockHash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN403"><span class='Ref_to_Global_Var'>LocalPredicateLockHash</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a> <span class='Operator'>= </span><a href="../../../include/storage/predicate_internals.h.html#LN468"><span class='Ref_to_Const'>InvalidSerializableXact</span></a><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN411"><span class='Ref_to_Global_Var'>MyXactDidWrite</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * PredicateLockTwoPhaseFinish 
 *      Release a prepared transaction's predicate locks once it 
 *      commits or aborts. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN4876"></a><span class='Declare_Function'>PredicateLockTwoPhaseFinish</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xid</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>isCommit</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4878"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN241"><span class='Ref_to_Struct'>SERIALIZABLEXID</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sxid</span><span class='Delimiter'>; 
</span><a name="LN4879"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN223"><span class='Ref_to_Struct'>SERIALIZABLEXIDTAG</span></a> <span class='Declare_Local'>sxidtag</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN4879"><span class='Ref_To_Local'>sxidtag</span></a><span class='Operator'>.</span><a href="../../../include/storage/predicate_internals.h.html#LN225"><span class='Ref_to_Member'>xid</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN4876"><span class='Ref_to_Parameter'>xid</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN4878"><span class='Ref_To_Local'>sxid</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN241"><span class='Ref_to_Struct'>SERIALIZABLEXID</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/hsearch.h.html#LN125"><span class='Ref_to_Proto'>hash_search</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN385"><span class='Ref_to_Global_Var'>SerializableXidHash</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predicate.c.html#LN4879"><span class='Ref_To_Local'>sxidtag</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/hsearch.h.html#LN104"><span class='Ref_to_EnumConst'>HASH_FIND</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* xid will not be found if it wasn't a serializable transaction */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN4878"><span class='Ref_To_Local'>sxid</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Release its locks */ 
</span>    <a href="predicate.c.html#LN410"><span class='Ref_to_Global_Var'>MySerializableXact</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN4878"><span class='Ref_To_Local'>sxid</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN247"><span class='Ref_to_Member'>myXact</span></a><span class='Delimiter'>; 
</span>    <a href="predicate.c.html#LN411"><span class='Ref_to_Global_Var'>MyXactDidWrite</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>;</span>      <span class='Comment_Multi_Line'>/* conservatively assume that we wrote 
                                 * something */ 
</span>    <a href="../../../include/storage/predicate.h.html#LN56"><span class='Ref_to_Proto'>ReleasePredicateLocks</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4876"><span class='Ref_to_Parameter'>isCommit</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end PredicateLockTwoPhaseFinish &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Re-acquire a predicate lock belonging to a transaction that was prepared. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN4903"></a><span class='Declare_Function'>predicatelock_twophase_recover</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xid</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN266"><span class='Ref_to_Typedef'>uint16</span></a> <span class='Declare_Parameter'>info</span><span class='Delimiter'>, 
</span><a name="LN4904"></a>                               <span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>recdata</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Parameter'>len</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4906"></a>    <a href="../../../include/storage/predicate_internals.h.html#LN455"><span class='Ref_to_Struct'>TwoPhasePredicateRecord</span></a> <span class='Operator'>*</span><span class='Declare_Local'>record</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN4904"><span class='Ref_to_Parameter'>len</span></a> <span class='Operator'>== </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN455"><span class='Ref_to_Struct'>TwoPhasePredicateRecord</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="predicate.c.html#LN4906"><span class='Ref_To_Local'>record</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN455"><span class='Ref_to_Struct'>TwoPhasePredicateRecord</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predicate.c.html#LN4904"><span class='Ref_to_Parameter'>recdata</span></a><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>((</span><a href="predicate.c.html#LN4906"><span class='Ref_To_Local'>record</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN457"><span class='Ref_to_Member'>type</span></a> <span class='Operator'>== </span><a href="../../../include/storage/predicate_internals.h.html#LN427"><span class='Ref_to_EnumConst'>TWOPHASEPREDICATERECORD_XACT</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>           <span class='Parentheses'>(</span><a href="predicate.c.html#LN4906"><span class='Ref_To_Local'>record</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN457"><span class='Ref_to_Member'>type</span></a> <span class='Operator'>== </span><a href="../../../include/storage/predicate_internals.h.html#LN428"><span class='Ref_to_EnumConst'>TWOPHASEPREDICATERECORD_LOCK</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN4906"><span class='Ref_To_Local'>record</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN457"><span class='Ref_to_Member'>type</span></a> <span class='Operator'>== </span><a href="../../../include/storage/predicate_internals.h.html#LN427"><span class='Ref_to_EnumConst'>TWOPHASEPREDICATERECORD_XACT</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Per-transaction record. Set up a SERIALIZABLEXACT. */ 
</span><a name="LN4918"></a>        <a href="../../../include/storage/predicate_internals.h.html#LN442"><span class='Ref_to_Struct'>TwoPhasePredicateXactRecord</span></a> <span class='Operator'>*</span><span class='Declare_Local'>xactRecord</span><span class='Delimiter'>; 
</span><a name="LN4919"></a>        <a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sxact</span><span class='Delimiter'>; 
</span><a name="LN4920"></a>        <a href="../../../include/storage/predicate_internals.h.html#LN241"><span class='Ref_to_Struct'>SERIALIZABLEXID</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sxid</span><span class='Delimiter'>; 
</span><a name="LN4921"></a>        <a href="../../../include/storage/predicate_internals.h.html#LN223"><span class='Ref_to_Struct'>SERIALIZABLEXIDTAG</span></a> <span class='Declare_Local'>sxidtag</span><span class='Delimiter'>; 
</span><a name="LN4922"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span><span class='Delimiter'>; 
</span> 
        <a href="predicate.c.html#LN4918"><span class='Ref_To_Local'>xactRecord</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN442"><span class='Ref_to_Struct'>TwoPhasePredicateXactRecord</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="predicate.c.html#LN4906"><span class='Ref_To_Local'>record</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN462"><span class='Ref_to_Member'>data</span></a><span class='Operator'>.</span>xactRecord<span class='Delimiter'>; 
</span> 
        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN4919"><span class='Ref_To_Local'>sxact</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN415"><span class='Ref_to_Proto'>CreatePredXact</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN4919"><span class='Ref_To_Local'>sxact</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OUT_OF_MEMORY<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"out of shared memory"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* vxid for a prepared xact is InvalidBackendId/xid; no pid */ 
</span>        <a href="predicate.c.html#LN4919"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN57"><span class='Ref_to_Member'>vxid</span></a><span class='Operator'>.</span><a href="../../../include/storage/lock.h.html#LN64"><span class='Ref_to_Member'>backendId</span></a> <span class='Operator'>= </span><a href="../../../include/storage/backendid.h.html#LN22"><span class='Ref_to_Const'>InvalidBackendId</span></a><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN4919"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN57"><span class='Ref_to_Member'>vxid</span></a><span class='Operator'>.</span><a href="../../../include/storage/lock.h.html#LN65"><span class='Ref_to_Member'>localTransactionId</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN398"><span class='Ref_to_Typedef'>LocalTransactionId</span></a><span class='Parentheses'>) </span><a href="predicate.c.html#LN4903"><span class='Ref_to_Parameter'>xid</span></a><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN4919"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN106"><span class='Ref_to_Member'>pid</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* a prepared xact hasn't committed yet */ 
</span>        <a href="predicate.c.html#LN4919"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN74"><span class='Ref_to_Member'>prepareSeqNo</span></a> <span class='Operator'>= </span><a href="../../../include/storage/predicate_internals.h.html#LN36"><span class='Ref_to_Const'>RecoverySerCommitSeqNo</span></a><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN4919"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN75"><span class='Ref_to_Member'>commitSeqNo</span></a> <span class='Operator'>= </span><a href="../../../include/storage/predicate_internals.h.html#LN35"><span class='Ref_to_Const'>InvalidSerCommitSeqNo</span></a><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN4919"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN101"><span class='Ref_to_Member'>finishedBefore</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span> 
        <a href="predicate.c.html#LN4919"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN84"><span class='Ref_to_Member'>SeqNo</span></a><span class='Operator'>.</span>lastCommitBeforeSnapshot <span class='Operator'>= </span><a href="../../../include/storage/predicate_internals.h.html#LN36"><span class='Ref_to_Const'>RecoverySerCommitSeqNo</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Don't need to track this; no transactions running at the time the 
         * recovered xact started are still active, except possibly other 
         * prepared xacts and we don't care whether those are RO_SAFE or not. 
         */ 
</span>        <a href="../ipc/shmqueue.c.html#LN34"><span class='Ref_to_Func'>SHMQueueInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN4919"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN97"><span class='Ref_to_Member'>possibleUnsafeConflicts</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <a href="../ipc/shmqueue.c.html#LN34"><span class='Ref_to_Func'>SHMQueueInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN4919"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN89"><span class='Ref_to_Member'>predicateLocks</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="../ipc/shmqueue.c.html#LN55"><span class='Ref_to_Func'>SHMQueueElemInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN4919"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN90"><span class='Ref_to_Member'>finishedLink</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <a href="predicate.c.html#LN4919"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN99"><span class='Ref_to_Member'>topXid</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN4903"><span class='Ref_to_Parameter'>xid</span></a><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN4919"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN104"><span class='Ref_to_Member'>xmin</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN4918"><span class='Ref_To_Local'>xactRecord</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN444"><span class='Ref_to_Member'>xmin</span></a><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN4919"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN105"><span class='Ref_to_Member'>flags</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN4918"><span class='Ref_To_Local'>xactRecord</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN445"><span class='Ref_to_Member'>flags</span></a><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN264"><span class='Ref_to_Macro'>SxactIsPrepared</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4919"><span class='Ref_To_Local'>sxact</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN267"><span class='Ref_to_Macro'>SxactIsReadOnly</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4919"><span class='Ref_To_Local'>sxact</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Operator'>++</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN159"><span class='Ref_to_Member'>WritableSxactCount</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN159"><span class='Ref_to_Member'>WritableSxactCount</span></a> <span class='Operator'>&LT;= 
</span>                   <span class='Parentheses'>(</span><a href="../../utils/init/globals.c.html#LN126"><span class='Ref_to_Global_Var'>MaxBackends</span></a> <span class='Operator'>+ </span><a href="../../access/transam/twophase.c.html#LN116"><span class='Ref_to_Global_Var'>max_prepared_xacts</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We don't know whether the transaction had any conflicts or not, so 
         * we'll conservatively assume that it had both a conflict in and a 
         * conflict out, and represent that with the summary conflict flags. 
         */ 
</span>        <a href="../ipc/shmqueue.c.html#LN34"><span class='Ref_to_Func'>SHMQueueInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN4919"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN85"><span class='Ref_to_Member'>outConflicts</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="../ipc/shmqueue.c.html#LN34"><span class='Ref_to_Func'>SHMQueueInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN4919"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN87"><span class='Ref_to_Member'>inConflicts</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN4919"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN105"><span class='Ref_to_Member'>flags</span></a> <span class='Operator'>|= </span><a href="../../../include/storage/predicate_internals.h.html#LN123"><span class='Ref_to_Const'>SXACT_FLAG_SUMMARY_CONFLICT_IN</span></a><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN4919"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN105"><span class='Ref_to_Member'>flags</span></a> <span class='Operator'>|= </span><a href="../../../include/storage/predicate_internals.h.html#LN124"><span class='Ref_to_Const'>SXACT_FLAG_SUMMARY_CONFLICT_OUT</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Register the transaction's xid */ 
</span>        <a href="predicate.c.html#LN4921"><span class='Ref_To_Local'>sxidtag</span></a><span class='Operator'>.</span><a href="../../../include/storage/predicate_internals.h.html#LN225"><span class='Ref_to_Member'>xid</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN4903"><span class='Ref_to_Parameter'>xid</span></a><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN4920"><span class='Ref_To_Local'>sxid</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN241"><span class='Ref_to_Struct'>SERIALIZABLEXID</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/utils/hsearch.h.html#LN125"><span class='Ref_to_Proto'>hash_search</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN385"><span class='Ref_to_Global_Var'>SerializableXidHash</span></a><span class='Delimiter'>, 
</span>                                               <span class='Operator'>&</span><a href="predicate.c.html#LN4921"><span class='Ref_To_Local'>sxidtag</span></a><span class='Delimiter'>, 
</span>                                               <a href="../../../include/utils/hsearch.h.html#LN105"><span class='Ref_to_EnumConst'>HASH_ENTER</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predicate.c.html#LN4922"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN4920"><span class='Ref_To_Local'>sxid</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="predicate.c.html#LN4922"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN4920"><span class='Ref_To_Local'>sxid</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN247"><span class='Ref_to_Member'>myXact</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="predicate.c.html#LN4919"><span class='Ref_To_Local'>sxact</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Update global xmin. Note that this is a special case compared to 
         * registering a normal transaction, because the global xmin might go 
         * backwards. That's OK, because until recovery is over we're not 
         * going to complete any transactions or create any non-prepared 
         * transactions, so there's no danger of throwing away. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>((</span><span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN155"><span class='Ref_to_Member'>SxactGlobalXmin</span></a><span class='Parentheses'>))</span> <span class='Operator'>|| 
</span>            <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN170"><span class='Ref_to_Proto'>TransactionIdFollows</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN155"><span class='Ref_to_Member'>SxactGlobalXmin</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN4919"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN104"><span class='Ref_to_Member'>xmin</span></a><span class='Parentheses'>)))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN155"><span class='Ref_to_Member'>SxactGlobalXmin</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN4919"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN104"><span class='Ref_to_Member'>xmin</span></a><span class='Delimiter'>; 
</span>            <a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN157"><span class='Ref_to_Member'>SxactGlobalXminCount</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>            <a href="predicate.c.html#LN430"><span class='Ref_to_Proto'>OldSerXidSetActiveSerXmin</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4919"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN104"><span class='Ref_to_Member'>xmin</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN42"><span class='Ref_to_Macro'>TransactionIdEquals</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN4919"><span class='Ref_To_Local'>sxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN104"><span class='Ref_to_Member'>xmin</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN155"><span class='Ref_to_Member'>SxactGlobalXmin</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN157"><span class='Ref_to_Member'>SxactGlobalXminCount</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="predicate.c.html#LN373"><span class='Ref_to_Global_Var'>PredXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN157"><span class='Ref_to_Member'>SxactGlobalXminCount</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if record-&GT;type==TWOPHAS... &raquo; </span> 
    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="predicate.c.html#LN4906"><span class='Ref_To_Local'>record</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN457"><span class='Ref_to_Member'>type</span></a> <span class='Operator'>== </span><a href="../../../include/storage/predicate_internals.h.html#LN428"><span class='Ref_to_EnumConst'>TWOPHASEPREDICATERECORD_LOCK</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Lock record. Recreate the PREDICATELOCK */ 
</span><a name="LN5010"></a>        <a href="../../../include/storage/predicate_internals.h.html#LN449"><span class='Ref_to_Struct'>TwoPhasePredicateLockRecord</span></a> <span class='Operator'>*</span><span class='Declare_Local'>lockRecord</span><span class='Delimiter'>; 
</span><a name="LN5011"></a>        <a href="../../../include/storage/predicate_internals.h.html#LN241"><span class='Ref_to_Struct'>SERIALIZABLEXID</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sxid</span><span class='Delimiter'>; 
</span><a name="LN5012"></a>        <a href="../../../include/storage/predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sxact</span><span class='Delimiter'>; 
</span><a name="LN5013"></a>        <a href="../../../include/storage/predicate_internals.h.html#LN223"><span class='Ref_to_Struct'>SERIALIZABLEXIDTAG</span></a> <span class='Declare_Local'>sxidtag</span><span class='Delimiter'>; 
</span><a name="LN5014"></a>        <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>targettaghash</span><span class='Delimiter'>; 
</span> 
        <a href="predicate.c.html#LN5010"><span class='Ref_To_Local'>lockRecord</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN449"><span class='Ref_to_Struct'>TwoPhasePredicateLockRecord</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="predicate.c.html#LN4906"><span class='Ref_To_Local'>record</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN462"><span class='Ref_to_Member'>data</span></a><span class='Operator'>.</span>lockRecord<span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN5014"><span class='Ref_To_Local'>targettaghash</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN288"><span class='Ref_to_Macro'>PredicateLockTargetTagHashCode</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN5010"><span class='Ref_To_Local'>lockRecord</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN451"><span class='Ref_to_Member'>target</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN5013"><span class='Ref_To_Local'>sxidtag</span></a><span class='Operator'>.</span><a href="../../../include/storage/predicate_internals.h.html#LN225"><span class='Ref_to_Member'>xid</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN4903"><span class='Ref_to_Parameter'>xid</span></a><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN5011"><span class='Ref_To_Local'>sxid</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/predicate_internals.h.html#LN241"><span class='Ref_to_Struct'>SERIALIZABLEXID</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../../include/utils/hsearch.h.html#LN125"><span class='Ref_to_Proto'>hash_search</span></a><span class='Parentheses'>(</span><a href="predicate.c.html#LN385"><span class='Ref_to_Global_Var'>SerializableXidHash</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="predicate.c.html#LN5013"><span class='Ref_To_Local'>sxidtag</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/hsearch.h.html#LN104"><span class='Ref_to_EnumConst'>HASH_FIND</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>SerializableXactHashLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN5011"><span class='Ref_To_Local'>sxid</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="predicate.c.html#LN5012"><span class='Ref_To_Local'>sxact</span></a> <span class='Operator'>= </span><a href="predicate.c.html#LN5011"><span class='Ref_To_Local'>sxid</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN247"><span class='Ref_to_Member'>myXact</span></a><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="predicate.c.html#LN5012"><span class='Ref_To_Local'>sxact</span></a> <span class='Operator'>!= </span><a href="../../../include/storage/predicate_internals.h.html#LN468"><span class='Ref_to_Const'>InvalidSerializableXact</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="predicate.c.html#LN449"><span class='Ref_to_Proto'>CreatePredicateLock</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="predicate.c.html#LN5010"><span class='Ref_To_Local'>lockRecord</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/predicate_internals.h.html#LN451"><span class='Ref_to_Member'>target</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN5014"><span class='Ref_To_Local'>targettaghash</span></a><span class='Delimiter'>, </span><a href="predicate.c.html#LN5012"><span class='Ref_To_Local'>sxact</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if record-&GT;type==TWOPHAS... &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end predicatelock_twophase_recover &raquo; </span> 
</pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>