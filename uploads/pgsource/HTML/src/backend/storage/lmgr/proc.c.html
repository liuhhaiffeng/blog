<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\storage\lmgr\proc.c</title>
<LINK REL=StyleSheet HREF="../../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\storage\lmgr\proc.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:49 2017
</td></tr>
<tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * proc.c 
 *    routines to manage per-process shared memory data structure 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * 
 * IDENTIFICATION 
 *    src/backend/storage/lmgr/proc.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
/* 
 * Interface (a): 
 *      ProcSleep(), ProcWakeup(), 
 *      ProcQueueAlloc() -- create a shm queue for sleeping processes 
 *      ProcQueueInit() -- create a queue without allocing memory 
 * 
 * Waiting for a lock causes the backend to be put to sleep.  Whoever releases 
 * the lock wakes the process up again (and gives it an error code so it knows 
 * whether it was awoken on an error condition). 
 * 
 * Interface (b): 
 * 
 * ProcReleaseLocks -- frees the locks associated with current transaction 
 * 
 * ProcKill -- destroys the shared memory state (and locks) 
 * associated with the process. 
 */ 
</span><span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>&LT;signal.h&GT;</span> 
<span class='Keyword'>#include </span><span class='String'>&LT;unistd.h&GT;</span> 
<span class='Keyword'>#include </span><span class='String'>&LT;sys/time.h&GT;</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/transam.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/twophase.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/xact.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"miscadmin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"pgstat.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"postmaster/autovacuum.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"replication/slot.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"replication/syncrep.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/condition_variable.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/standby.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/ipc.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/lmgr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/pmsignal.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/proc.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/procarray.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/procsignal.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/spin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/timeout.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/timestamp.h"</span> 
 
 
<span class='Comment_Multi_Line'>/* GUC variables */ 
</span><a name="LN59"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>DeadlockTimeout</span> <span class='Operator'>= </span><span class='Number'>1000</span><span class='Delimiter'>; 
</span><a name="LN60"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>StatementTimeout</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN61"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>LockTimeout</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN62"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>IdleInTransactionSessionTimeout</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN63"></a><span class='Keyword'>bool</span>        <span class='Declare_Var'>log_lock_waits</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Pointer to this process's PGPROC and PGXACT structs, if any */ 
</span><a name="LN66"></a><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a>     <span class='Operator'>*</span><span class='Declare_Var'>MyProc</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN67"></a><a href="../../../include/storage/proc.h.html#LN206"><span class='Ref_to_Struct'>PGXACT</span></a>     <span class='Operator'>*</span><span class='Declare_Var'>MyPgXact</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * This spinlock protects the freelist of recycled PGPROC structures. 
 * We cannot use an LWLock because the LWLock manager depends on already 
 * having a PGPROC and a wait semaphore!  But these structures are touched 
 * relatively infrequently (only at backend startup or shutdown) and not for 
 * very long, so a spinlock is okay. 
 */ 
</span><a name="LN76"></a><a href="../../../include/c.h.html#LN1118"><span class='Ref_to_Const'>NON_EXEC_STATIC</span></a> <a href="../../../include/storage/s_lock.h.html#LN137"><span class='Ref_to_Typedef'>slock_t</span></a> <span class='Operator'>*</span><span class='Declare_Var'>ProcStructLock</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Pointers to shared-memory structures */ 
</span><a name="LN79"></a><a href="../../../include/storage/proc.h.html#LN228"><span class='Ref_to_Struct'>PROC_HDR</span></a>   <span class='Operator'>*</span><span class='Declare_Var'>ProcGlobal</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN80"></a><a href="../../../include/c.h.html#LN1118"><span class='Ref_to_Const'>NON_EXEC_STATIC</span></a> <a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Declare_Var'>AuxiliaryProcs</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN81"></a><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a>     <span class='Operator'>*</span><span class='Declare_Var'>PreparedXactProcs</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* If we are waiting for a lock, this points to the associated LOCALLOCK */ 
</span><a name="LN84"></a><span class='Keyword'>static </span><a href="../../../include/storage/lock.h.html#LN401"><span class='Ref_to_Struct'>LOCALLOCK</span></a> <span class='Operator'>*</span><span class='Declare_Var'>lockAwaited</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
<a name="LN86"></a><span class='Keyword'>static </span><a href="../../../include/storage/lock.h.html#LN479"><span class='Ref_to_Typedef'>DeadLockState</span></a> <span class='Declare_Var'>deadlock_state</span> <span class='Operator'>= </span><a href="../../../include/storage/lock.h.html#LN481"><span class='Ref_to_EnumConst'>DS_NOT_YET_CHECKED</span></a><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Is a deadlock check pending? */ 
</span><a name="LN89"></a><span class='Keyword'>static volatile </span>sig_atomic_t <span class='Declare_Var'>got_deadlock_timeout</span><span class='Delimiter'>; 
</span> 
<a name="LN91"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>RemoveProcFromArray</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>code</span><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>arg</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN92"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>ProcKill</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>code</span><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>arg</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN93"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>AuxiliaryProcKill</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>code</span><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>arg</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN94"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>CheckDeadLock</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Report shared-memory space needed by InitProcGlobal. 
 */ 
</span><a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a> 
<a name="LN101"></a><span class='Declare_Function'>ProcGlobalShmemSize</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN103"></a>    <a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Local'>size</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* ProcGlobal */ 
</span>    <a href="proc.c.html#LN103"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN103"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/proc.h.html#LN228"><span class='Ref_to_Struct'>PROC_HDR</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* MyProcs, including autovacuum workers and launcher */ 
</span>    <a href="proc.c.html#LN103"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN103"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/shmem.h.html#LN45"><span class='Ref_to_Proto'>mul_size</span></a><span class='Parentheses'>(</span><a href="../../utils/init/globals.c.html#LN126"><span class='Ref_to_Global_Var'>MaxBackends</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* AuxiliaryProcs */ 
</span>    <a href="proc.c.html#LN103"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN103"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/shmem.h.html#LN45"><span class='Ref_to_Proto'>mul_size</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/proc.h.html#LN272"><span class='Ref_to_Const'>NUM_AUXILIARY_PROCS</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* Prepared xacts */ 
</span>    <a href="proc.c.html#LN103"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN103"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/shmem.h.html#LN45"><span class='Ref_to_Proto'>mul_size</span></a><span class='Parentheses'>(</span><a href="../../access/transam/twophase.c.html#LN116"><span class='Ref_to_Global_Var'>max_prepared_xacts</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* ProcStructLock */ 
</span>    <a href="proc.c.html#LN103"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN103"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/s_lock.h.html#LN137"><span class='Ref_to_Typedef'>slock_t</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="proc.c.html#LN103"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN103"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/shmem.h.html#LN45"><span class='Ref_to_Proto'>mul_size</span></a><span class='Parentheses'>(</span><a href="../../utils/init/globals.c.html#LN126"><span class='Ref_to_Global_Var'>MaxBackends</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/proc.h.html#LN206"><span class='Ref_to_Struct'>PGXACT</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN103"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN103"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/shmem.h.html#LN45"><span class='Ref_to_Proto'>mul_size</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/proc.h.html#LN272"><span class='Ref_to_Const'>NUM_AUXILIARY_PROCS</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/proc.h.html#LN206"><span class='Ref_to_Struct'>PGXACT</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN103"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN103"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/shmem.h.html#LN45"><span class='Ref_to_Proto'>mul_size</span></a><span class='Parentheses'>(</span><a href="../../access/transam/twophase.c.html#LN116"><span class='Ref_to_Global_Var'>max_prepared_xacts</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/proc.h.html#LN206"><span class='Ref_to_Struct'>PGXACT</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="proc.c.html#LN103"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ProcGlobalShmemSize &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Report number of semaphores needed by InitProcGlobal. 
 */ 
</span><span class='Keyword'>int 
</span><a name="LN127"></a><span class='Declare_Function'>ProcGlobalSemas</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * We need a sema per backend (including autovacuum), plus one for each 
     * auxiliary process. 
     */ 
</span>    <span class='Control'>return</span> <a href="../../utils/init/globals.c.html#LN126"><span class='Ref_to_Global_Var'>MaxBackends</span></a> <span class='Operator'>+ </span><a href="../../../include/storage/proc.h.html#LN272"><span class='Ref_to_Const'>NUM_AUXILIARY_PROCS</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * InitProcGlobal - 
 *    Initialize the global process table during postmaster or standalone 
 *    backend startup. 
 * 
 *    We also create all the per-process semaphores we will need to support 
 *    the requested number of backends.  We used to allocate semaphores 
 *    only when backends were actually started up, but that is bad because 
 *    it lets Postgres fail under load --- a lot of Unix systems are 
 *    (mis)configured with small limits on the number of semaphores, and 
 *    running out when trying to start another backend is a common failure. 
 *    So, now we grab enough semaphores to support the desired max number 
 *    of backends immediately at initialization --- if the sysadmin has set 
 *    MaxConnections, max_worker_processes, or autovacuum_max_workers higher 
 *    than his kernel will support, he'll find out sooner rather than later. 
 * 
 *    Another reason for creating semaphores here is that the semaphore 
 *    implementation typically requires us to create semaphores in the 
 *    postmaster, not in backends. 
 * 
 * Note: this is NOT called by individual backends under a postmaster, 
 * not even in the EXEC_BACKEND case.  The ProcGlobal and AuxiliaryProcs 
 * pointers must be propagated specially for EXEC_BACKEND operation. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN161"></a><span class='Declare_Function'>InitProcGlobal</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN163"></a>    <a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>procs</span><span class='Delimiter'>; 
</span><a name="LN164"></a>    <a href="../../../include/storage/proc.h.html#LN206"><span class='Ref_to_Struct'>PGXACT</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>pgxacts</span><span class='Delimiter'>; 
</span><a name="LN165"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>, 
</span><a name="LN166"></a>                <span class='Declare_Local'>j</span><span class='Delimiter'>; 
</span><a name="LN167"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span><span class='Delimiter'>; 
</span><a name="LN168"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>TotalProcs</span> <span class='Operator'>= </span><a href="../../utils/init/globals.c.html#LN126"><span class='Ref_to_Global_Var'>MaxBackends</span></a> <span class='Operator'>+ </span><a href="../../../include/storage/proc.h.html#LN272"><span class='Ref_to_Const'>NUM_AUXILIARY_PROCS</span></a> <span class='Operator'>+ </span><a href="../../access/transam/twophase.c.html#LN116"><span class='Ref_to_Global_Var'>max_prepared_xacts</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Create the ProcGlobal shared structure */ 
</span>    <a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/proc.h.html#LN228"><span class='Ref_to_Struct'>PROC_HDR</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/shmem.h.html#LN43"><span class='Ref_to_Proto'>ShmemInitStruct</span></a><span class='Parentheses'>(</span><span class='String'>"Proc Header"</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/proc.h.html#LN228"><span class='Ref_to_Struct'>PROC_HDR</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="proc.c.html#LN167"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="proc.c.html#LN167"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Initialize the data structures. 
     */ 
</span>    <a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN249"><span class='Ref_to_Member'>spins_per_delay</span></a> <span class='Operator'>= </span><a href="../../../include/storage/s_lock.h.html#LN965"><span class='Ref_to_Const'>DEFAULT_SPINS_PER_DELAY</span></a><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN237"><span class='Ref_to_Member'>freeProcs</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN239"><span class='Ref_to_Member'>autovacFreeProcs</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN241"><span class='Ref_to_Member'>bgworkerFreeProcs</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN251"><span class='Ref_to_Member'>startupProc</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN252"><span class='Ref_to_Member'>startupProcPid</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN254"><span class='Ref_to_Member'>startupBufferPinWaitBufId</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN245"><span class='Ref_to_Member'>walwriterLatch</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN247"><span class='Ref_to_Member'>checkpointerLatch</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="../../../include/port/atomics.h.html#LN232"><span class='Ref_to_Func'>pg_atomic_init_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN243"><span class='Ref_to_Member'>procArrayGroupFirst</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/proc.h.html#LN75"><span class='Ref_to_Const'>INVALID_PGPROCNO</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Create and initialize all the PGPROC structures we'll need.  There are 
     * five separate consumers: (1) normal backends, (2) autovacuum workers 
     * and the autovacuum launcher, (3) background workers, (4) auxiliary 
     * processes, and (5) prepared transactions.  Each PGPROC structure is 
     * dedicated to exactly one of these purposes, and they do not move 
     * between groups. 
     */ 
</span>    <a href="proc.c.html#LN163"><span class='Ref_To_Local'>procs</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/storage/shmem.h.html#LN36"><span class='Ref_to_Proto'>ShmemAlloc</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN168"><span class='Ref_To_Local'>TotalProcs</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN163"><span class='Ref_To_Local'>procs</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><a href="proc.c.html#LN168"><span class='Ref_To_Local'>TotalProcs</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN231"><span class='Ref_to_Member'>allProcs</span></a> <span class='Operator'>= </span><a href="proc.c.html#LN163"><span class='Ref_To_Local'>procs</span></a><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* XXX allProcCount isn't really all of them; it excludes prepared xacts */ 
</span>    <a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN235"><span class='Ref_to_Member'>allProcCount</span></a> <span class='Operator'>= </span><a href="../../utils/init/globals.c.html#LN126"><span class='Ref_to_Global_Var'>MaxBackends</span></a> <span class='Operator'>+ </span><a href="../../../include/storage/proc.h.html#LN272"><span class='Ref_to_Const'>NUM_AUXILIARY_PROCS</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Also allocate a separate array of PGXACT structures.  This is separate 
     * from the main PGPROC array so that the most heavily accessed data is 
     * stored contiguously in memory in as few cache lines as possible. This 
     * provides significant performance benefits, especially on a 
     * multiprocessor system.  There is one PGXACT structure for every PGPROC 
     * structure. 
     */ 
</span>    <a href="proc.c.html#LN164"><span class='Ref_To_Local'>pgxacts</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/proc.h.html#LN206"><span class='Ref_to_Struct'>PGXACT</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/storage/shmem.h.html#LN36"><span class='Ref_to_Proto'>ShmemAlloc</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN168"><span class='Ref_To_Local'>TotalProcs</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/proc.h.html#LN206"><span class='Ref_to_Struct'>PGXACT</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN164"><span class='Ref_To_Local'>pgxacts</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><a href="proc.c.html#LN168"><span class='Ref_To_Local'>TotalProcs</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/proc.h.html#LN206"><span class='Ref_to_Struct'>PGXACT</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN233"><span class='Ref_to_Member'>allPgXact</span></a> <span class='Operator'>= </span><a href="proc.c.html#LN164"><span class='Ref_To_Local'>pgxacts</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN165"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="proc.c.html#LN165"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="proc.c.html#LN168"><span class='Ref_To_Local'>TotalProcs</span></a><span class='Delimiter'>; </span><a href="proc.c.html#LN165"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Common initialization for all PGPROCs, regardless of type. */ 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Set up per-PGPROC semaphore, latch, and backendLock. Prepared xact 
         * dummy PGPROCs don't need these though - they're never associated 
         * with a real process 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN165"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="../../utils/init/globals.c.html#LN126"><span class='Ref_to_Global_Var'>MaxBackends</span></a> <span class='Operator'>+ </span><a href="../../../include/storage/proc.h.html#LN272"><span class='Ref_to_Const'>NUM_AUXILIARY_PROCS</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="proc.c.html#LN163"><span class='Ref_To_Local'>procs</span></a><span class='Delimiter'>[</span><a href="proc.c.html#LN165"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/storage/proc.h.html#LN99"><span class='Ref_to_Member'>sem</span></a> <span class='Operator'>= </span><a href="../../../include/storage/pg_sema.h.html#LN46"><span class='Ref_to_Proto'>PGSemaphoreCreate</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <a href="../../../include/storage/latch.h.html#LN148"><span class='Ref_to_Proto'>InitSharedLatch</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="proc.c.html#LN163"><span class='Ref_To_Local'>procs</span></a><span class='Delimiter'>[</span><a href="proc.c.html#LN165"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/storage/proc.h.html#LN102"><span class='Ref_to_Member'>procLatch</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="../../../include/storage/lwlock.h.html#LN187"><span class='Ref_to_Proto'>LWLockInitialize</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="proc.c.html#LN163"><span class='Ref_To_Local'>procs</span></a><span class='Delimiter'>[</span><a href="proc.c.html#LN165"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/storage/proc.h.html#LN174"><span class='Ref_to_Member'>backendLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN209"><span class='Ref_to_EnumConst'>LWTRANCHE_PROC</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="proc.c.html#LN163"><span class='Ref_To_Local'>procs</span></a><span class='Delimiter'>[</span><a href="proc.c.html#LN165"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/storage/proc.h.html#LN108"><span class='Ref_to_Member'>pgprocno</span></a> <span class='Operator'>= </span><a href="proc.c.html#LN165"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Newly created PGPROCs for normal backends, autovacuum and bgworkers 
         * must be queued up on the appropriate free list.  Because there can 
         * only ever be a small, fixed number of auxiliary processes, no free 
         * list is used in that case; InitAuxiliaryProcess() instead uses a 
         * linear search.   PGPROCs for prepared transactions are added to a 
         * free list by TwoPhaseShmemInit(). 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN165"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="../../utils/init/globals.c.html#LN123"><span class='Ref_to_Global_Var'>MaxConnections</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* PGPROC for normal backend, add to freeProcs list */ 
</span>            <a href="proc.c.html#LN163"><span class='Ref_To_Local'>procs</span></a><span class='Delimiter'>[</span><a href="proc.c.html#LN165"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/storage/proc.h.html#LN96"><span class='Ref_to_Member'>links</span></a><span class='Operator'>.</span><a href="../../../include/storage/shmem.h.html#LN30"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/shmem.h.html#LN27"><span class='Ref_to_Struct'>SHM_QUEUE</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN237"><span class='Ref_to_Member'>freeProcs</span></a><span class='Delimiter'>; 
</span>            <a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN237"><span class='Ref_to_Member'>freeProcs</span></a> <span class='Operator'>= &</span><a href="proc.c.html#LN163"><span class='Ref_To_Local'>procs</span></a><span class='Delimiter'>[</span><a href="proc.c.html#LN165"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>            <a href="proc.c.html#LN163"><span class='Ref_To_Local'>procs</span></a><span class='Delimiter'>[</span><a href="proc.c.html#LN165"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/storage/proc.h.html#LN97"><span class='Ref_to_Member'>procgloballist</span></a> <span class='Operator'>= &</span><a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN237"><span class='Ref_to_Member'>freeProcs</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN165"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="../../utils/init/globals.c.html#LN123"><span class='Ref_to_Global_Var'>MaxConnections</span></a> <span class='Operator'>+ </span><a href="../../postmaster/autovacuum.c.html#LN112"><span class='Ref_to_Global_Var'>autovacuum_max_workers</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* PGPROC for AV launcher/worker, add to autovacFreeProcs list */ 
</span>            <a href="proc.c.html#LN163"><span class='Ref_To_Local'>procs</span></a><span class='Delimiter'>[</span><a href="proc.c.html#LN165"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/storage/proc.h.html#LN96"><span class='Ref_to_Member'>links</span></a><span class='Operator'>.</span><a href="../../../include/storage/shmem.h.html#LN30"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/shmem.h.html#LN27"><span class='Ref_to_Struct'>SHM_QUEUE</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN239"><span class='Ref_to_Member'>autovacFreeProcs</span></a><span class='Delimiter'>; 
</span>            <a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN239"><span class='Ref_to_Member'>autovacFreeProcs</span></a> <span class='Operator'>= &</span><a href="proc.c.html#LN163"><span class='Ref_To_Local'>procs</span></a><span class='Delimiter'>[</span><a href="proc.c.html#LN165"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>            <a href="proc.c.html#LN163"><span class='Ref_To_Local'>procs</span></a><span class='Delimiter'>[</span><a href="proc.c.html#LN165"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/storage/proc.h.html#LN97"><span class='Ref_to_Member'>procgloballist</span></a> <span class='Operator'>= &</span><a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN239"><span class='Ref_to_Member'>autovacFreeProcs</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN165"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="../../utils/init/globals.c.html#LN126"><span class='Ref_to_Global_Var'>MaxBackends</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* PGPROC for bgworker, add to bgworkerFreeProcs list */ 
</span>            <a href="proc.c.html#LN163"><span class='Ref_To_Local'>procs</span></a><span class='Delimiter'>[</span><a href="proc.c.html#LN165"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/storage/proc.h.html#LN96"><span class='Ref_to_Member'>links</span></a><span class='Operator'>.</span><a href="../../../include/storage/shmem.h.html#LN30"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/shmem.h.html#LN27"><span class='Ref_to_Struct'>SHM_QUEUE</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN241"><span class='Ref_to_Member'>bgworkerFreeProcs</span></a><span class='Delimiter'>; 
</span>            <a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN241"><span class='Ref_to_Member'>bgworkerFreeProcs</span></a> <span class='Operator'>= &</span><a href="proc.c.html#LN163"><span class='Ref_To_Local'>procs</span></a><span class='Delimiter'>[</span><a href="proc.c.html#LN165"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>            <a href="proc.c.html#LN163"><span class='Ref_To_Local'>procs</span></a><span class='Delimiter'>[</span><a href="proc.c.html#LN165"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/storage/proc.h.html#LN97"><span class='Ref_to_Member'>procgloballist</span></a> <span class='Operator'>= &</span><a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN241"><span class='Ref_to_Member'>bgworkerFreeProcs</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Initialize myProcLocks[] shared memory queues. */ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN166"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="proc.c.html#LN166"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>&LT; </span><a href="../../../include/storage/lwlock.h.html#LN116"><span class='Ref_to_Const'>NUM_LOCK_PARTITIONS</span></a><span class='Delimiter'>; </span><a href="proc.c.html#LN166"><span class='Ref_To_Local'>j</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <a href="../ipc/shmqueue.c.html#LN34"><span class='Ref_to_Func'>SHMQueueInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="proc.c.html#LN163"><span class='Ref_To_Local'>procs</span></a><span class='Delimiter'>[</span><a href="proc.c.html#LN165"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/storage/proc.h.html#LN155"><span class='Ref_to_Member'>myProcLocks</span></a><span class='Delimiter'>[</span><a href="proc.c.html#LN166"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Initialize lockGroupMembers list. */ 
</span>        <a href="../../../include/lib/ilist.h.html#LN276"><span class='Ref_to_Func'>dlist_init</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="proc.c.html#LN163"><span class='Ref_To_Local'>procs</span></a><span class='Delimiter'>[</span><a href="proc.c.html#LN165"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/storage/proc.h.html#LN188"><span class='Ref_to_Member'>lockGroupMembers</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;TotalProcs;i++ &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Save pointers to the blocks of PGPROC structures reserved for auxiliary 
     * processes and prepared transactions. 
     */ 
</span>    <a href="proc.c.html#LN80"><span class='Ref_to_Global_Var'>AuxiliaryProcs</span></a> <span class='Operator'>= &</span><a href="proc.c.html#LN163"><span class='Ref_To_Local'>procs</span></a><span class='Delimiter'>[</span><a href="../../utils/init/globals.c.html#LN126"><span class='Ref_to_Global_Var'>MaxBackends</span></a><span class='Delimiter'>]; 
</span>    <a href="proc.c.html#LN81"><span class='Ref_to_Global_Var'>PreparedXactProcs</span></a> <span class='Operator'>= &</span><a href="proc.c.html#LN163"><span class='Ref_To_Local'>procs</span></a><span class='Delimiter'>[</span><a href="../../utils/init/globals.c.html#LN126"><span class='Ref_to_Global_Var'>MaxBackends</span></a> <span class='Operator'>+ </span><a href="../../../include/storage/proc.h.html#LN272"><span class='Ref_to_Const'>NUM_AUXILIARY_PROCS</span></a><span class='Delimiter'>]; 
</span> 
    <span class='Comment_Multi_Line'>/* Create ProcStructLock spinlock, too */ 
</span>    <a href="proc.c.html#LN76"><span class='Ref_to_Global_Var'>ProcStructLock</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/s_lock.h.html#LN137"><span class='Ref_to_Typedef'>slock_t</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/storage/shmem.h.html#LN36"><span class='Ref_to_Proto'>ShmemAlloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/s_lock.h.html#LN137"><span class='Ref_to_Typedef'>slock_t</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN59"><span class='Ref_to_Macro'>SpinLockInit</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN76"><span class='Ref_to_Global_Var'>ProcStructLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end InitProcGlobal &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * InitProcess -- initialize a per-process data structure for this backend 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN286"></a><span class='Declare_Function'>InitProcess</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN288"></a>    <a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a>     <span class='Operator'>*</span><span class='Keyword'>volatile </span><span class='Operator'>* </span><span class='Declare_Local'>procgloballist</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * ProcGlobal should be set up already (if we are a backend, we inherit 
     * this by fork() or EXEC_BACKEND mechanism from the postmaster). 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, </span><span class='String'>"proc header uninitialized"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"you already exist"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Decide which list should supply our PGPROC. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/postmaster/autovacuum.h.html#LN52"><span class='Ref_to_Macro'>IsAnyAutoVacuumProcess</span></a><span class='Parentheses'>())</span> 
        <a href="proc.c.html#LN288"><span class='Ref_To_Local'>procgloballist</span></a> <span class='Operator'>= &</span><a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN239"><span class='Ref_to_Member'>autovacFreeProcs</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../utils/init/globals.c.html#LN102"><span class='Ref_to_Global_Var'>IsBackgroundWorker</span></a><span class='Parentheses'>) 
</span>        <a href="proc.c.html#LN288"><span class='Ref_To_Local'>procgloballist</span></a> <span class='Operator'>= &</span><a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN241"><span class='Ref_to_Member'>bgworkerFreeProcs</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="proc.c.html#LN288"><span class='Ref_To_Local'>procgloballist</span></a> <span class='Operator'>= &</span><a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN237"><span class='Ref_to_Member'>freeProcs</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Try to get a proc struct from the appropriate free list.  If this 
     * fails, we must be out of PGPROC structures (not to mention semaphores). 
     * 
     * While we are holding the ProcStructLock, also copy the current shared 
     * estimate of spins_per_delay to local storage. 
     */ 
</span>    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN76"><span class='Ref_to_Global_Var'>ProcStructLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="s_lock.c.html#LN194"><span class='Ref_to_Func'>set_spins_per_delay</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN249"><span class='Ref_to_Member'>spins_per_delay</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a> <span class='Operator'>= *</span><a href="proc.c.html#LN288"><span class='Ref_To_Local'>procgloballist</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Operator'>*</span><a href="proc.c.html#LN288"><span class='Ref_To_Local'>procgloballist</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN96"><span class='Ref_to_Member'>links</span></a><span class='Operator'>.</span><a href="../../../include/storage/shmem.h.html#LN30"><span class='Ref_to_Member'>next</span></a><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN76"><span class='Ref_to_Global_Var'>ProcStructLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * If we reach here, all the PGPROCs are in use.  This is one of the 
         * possible places to detect "too many backends", so give the standard 
         * error message.  XXX do we need to give a different failure message 
         * in the autovacuum case? 
         */ 
</span>        <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN76"><span class='Ref_to_Global_Var'>ProcStructLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_TOO_MANY_CONNECTIONS<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"sorry, too many clients already"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="proc.c.html#LN67"><span class='Ref_to_Global_Var'>MyPgXact</span></a> <span class='Operator'>= &</span><a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN233"><span class='Ref_to_Member'>allPgXact</span></a><span class='Delimiter'>[</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN108"><span class='Ref_to_Member'>pgprocno</span></a><span class='Delimiter'>]; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Cross-check that the PGPROC is of the type we expect; if this were not 
     * the case, it would get returned to the wrong list. 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN97"><span class='Ref_to_Member'>procgloballist</span></a> <span class='Operator'>== </span><a href="proc.c.html#LN288"><span class='Ref_To_Local'>procgloballist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now that we have a PGPROC, mark ourselves as an active postmaster 
     * child; this is so that the postmaster can detect it if we exit without 
     * cleaning up.  (XXX autovac launcher currently doesn't participate in 
     * this; it probably should.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../utils/init/globals.c.html#LN100"><span class='Ref_to_Global_Var'>IsUnderPostmaster</span></a> <span class='Operator'>&& !</span><a href="../../../include/postmaster/autovacuum.h.html#LN49"><span class='Ref_to_Proto'>IsAutoVacuumLauncherProcess</span></a><span class='Parentheses'>())</span> 
        <a href="../../../include/storage/pmsignal.h.html#LN50"><span class='Ref_to_Proto'>MarkPostmasterChildActive</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Initialize all fields of MyProc, except for those previously 
     * initialized by InitProcGlobal. 
     */ 
</span>    <a href="../ipc/shmqueue.c.html#LN55"><span class='Ref_to_Func'>SHMQueueElemInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN96"><span class='Ref_to_Member'>links</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN100"><span class='Ref_to_Member'>waitStatus</span></a> <span class='Operator'>= </span><a href="../../../include/c.h.html#LN974"><span class='Ref_to_Const'>STATUS_OK</span></a><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN104"><span class='Ref_to_Member'>lxid</span></a> <span class='Operator'>= </span><a href="../../../include/storage/lock.h.html#LN69"><span class='Ref_to_Const'>InvalidLocalTransactionId</span></a><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN179"><span class='Ref_to_Member'>fpVXIDLock</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN180"><span class='Ref_to_Member'>fpLocalTransactionId</span></a> <span class='Operator'>= </span><a href="../../../include/storage/lock.h.html#LN69"><span class='Ref_to_Const'>InvalidLocalTransactionId</span></a><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN67"><span class='Ref_to_Global_Var'>MyPgXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN208"><span class='Ref_to_Member'>xid</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN67"><span class='Ref_to_Global_Var'>MyPgXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN212"><span class='Ref_to_Member'>xmin</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN107"><span class='Ref_to_Member'>pid</span></a> <span class='Operator'>= </span><a href="../../utils/init/globals.c.html#LN38"><span class='Ref_to_Global_Var'>MyProcPid</span></a><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* backendId, databaseId and roleId will be filled in later */ 
</span>    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN111"><span class='Ref_to_Member'>backendId</span></a> <span class='Operator'>= </span><a href="../../../include/storage/backendid.h.html#LN22"><span class='Ref_to_Const'>InvalidBackendId</span></a><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN112"><span class='Ref_to_Member'>databaseId</span></a> <span class='Operator'>= </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN113"><span class='Ref_to_Member'>roleId</span></a> <span class='Operator'>= </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN115"><span class='Ref_to_Member'>isBackgroundWorker</span></a> <span class='Operator'>= </span><a href="../../utils/init/globals.c.html#LN102"><span class='Ref_to_Global_Var'>IsBackgroundWorker</span></a><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN67"><span class='Ref_to_Global_Var'>MyPgXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN219"><span class='Ref_to_Member'>delayChkpt</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN67"><span class='Ref_to_Global_Var'>MyPgXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN217"><span class='Ref_to_Member'>vacuumFlags</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* NB -- autovac launcher intentionally does not set IS_AUTOVACUUM */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/postmaster/autovacuum.h.html#LN50"><span class='Ref_to_Proto'>IsAutoVacuumWorkerProcess</span></a><span class='Parentheses'>())</span> 
        <a href="proc.c.html#LN67"><span class='Ref_to_Global_Var'>MyPgXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN217"><span class='Ref_to_Member'>vacuumFlags</span></a> <span class='Operator'>|= </span><a href="../../../include/storage/proc.h.html#LN51"><span class='Ref_to_Const'>PROC_IS_AUTOVACUUM</span></a><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN125"><span class='Ref_to_Member'>lwWaiting</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN126"><span class='Ref_to_Member'>lwWaitMode</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN134"><span class='Ref_to_Member'>waitLock</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN135"><span class='Ref_to_Member'>waitProcLock</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><span class='Directive'>#ifdef</span> USE_ASSERT_CHECKING 
    <span class='Delimiter'>{ 
</span><a name="LN384"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Last process should have released all locks. */ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN384"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="proc.c.html#LN384"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="../../../include/storage/lwlock.h.html#LN116"><span class='Ref_to_Const'>NUM_LOCK_PARTITIONS</span></a><span class='Delimiter'>; </span><a href="proc.c.html#LN384"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/shmem.h.html#LN76"><span class='Ref_to_Proto'>SHMQueueEmpty</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN155"><span class='Ref_to_Member'>myProcLocks</span></a><span class='Delimiter'>[</span><a href="proc.c.html#LN384"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span><span class='Directive'>#endif</span> 
    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN122"><span class='Ref_to_Member'>recoveryConflictPending</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Initialize fields for sync rep */ 
</span>    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN146"><span class='Ref_to_Member'>waitLSN</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN147"><span class='Ref_to_Member'>syncRepState</span></a> <span class='Operator'>= </span><a href="../../../include/replication/syncrep.h.html#LN30"><span class='Ref_to_Const'>SYNC_REP_NOT_WAITING</span></a><span class='Delimiter'>; 
</span>    <a href="../ipc/shmqueue.c.html#LN55"><span class='Ref_to_Func'>SHMQueueElemInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN148"><span class='Ref_to_Member'>syncRepLinks</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Initialize fields for group XID clearing. */ 
</span>    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN161"><span class='Ref_to_Member'>procArrayGroupMember</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN169"><span class='Ref_to_Member'>procArrayGroupMemberXid</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/port/atomics.h.html#LN232"><span class='Ref_to_Func'>pg_atomic_init_u32</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN163"><span class='Ref_to_Member'>procArrayGroupNext</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/proc.h.html#LN75"><span class='Ref_to_Const'>INVALID_PGPROCNO</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Check that group locking fields are in a proper initial state. */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN187"><span class='Ref_to_Member'>lockGroupLeader</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/lib/ilist.h.html#LN287"><span class='Ref_to_Func'>dlist_is_empty</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN188"><span class='Ref_to_Member'>lockGroupMembers</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Initialize wait event information. */ 
</span>    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN171"><span class='Ref_to_Member'>wait_event_info</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Acquire ownership of the PGPROC's latch, so that we can use WaitLatch 
     * on it.  That allows us to repoint the process latch, which so far 
     * points to process local one, to the shared one. 
     */ 
</span>    <a href="../../../include/storage/latch.h.html#LN149"><span class='Ref_to_Proto'>OwnLatch</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN102"><span class='Ref_to_Member'>procLatch</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../utils/init/miscinit.c.html#LN243"><span class='Ref_to_Func'>SwitchToSharedLatch</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We might be reusing a semaphore that belonged to a failed process. So 
     * be careful and reinitialize its value here.  (This is not strictly 
     * necessary anymore, but seems like a good idea for cleanliness.) 
     */ 
</span>    <a href="../../../include/storage/pg_sema.h.html#LN49"><span class='Ref_to_Proto'>PGSemaphoreReset</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN99"><span class='Ref_to_Member'>sem</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Arrange to clean up at backend exit. 
     */ 
</span>    <a href="../../../include/storage/ipc.h.html#LN69"><span class='Ref_to_Proto'>on_shmem_exit</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN92"><span class='Ref_to_Proto'>ProcKill</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now that we have a PGPROC, we could try to acquire locks, so initialize 
     * local state needed for LWLocks, and the deadlock checker. 
     */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN159"><span class='Ref_to_Proto'>InitLWLockAccess</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="deadlock.c.html#LN141"><span class='Ref_to_Func'>InitDeadLockChecking</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end InitProcess &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * InitProcessPhase2 -- make MyProc visible in the shared ProcArray. 
 * 
 * This is separate from InitProcess because we can't acquire LWLocks until 
 * we've created a PGPROC, but in the EXEC_BACKEND case ProcArrayAdd won't 
 * work until after we've done CreateSharedMemoryAndSemaphores. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN446"></a><span class='Declare_Function'>InitProcessPhase2</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Add our PGPROC to the PGPROC array in shared memory. 
     */ 
</span>    <a href="../../../include/storage/procarray.h.html#LN60"><span class='Ref_to_Proto'>ProcArrayAdd</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Arrange to clean that up at backend exit. 
     */ 
</span>    <a href="../../../include/storage/ipc.h.html#LN69"><span class='Ref_to_Proto'>on_shmem_exit</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN91"><span class='Ref_to_Proto'>RemoveProcFromArray</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * InitAuxiliaryProcess -- create a per-auxiliary-process data structure 
 * 
 * This is called by bgwriter and similar processes so that they will have a 
 * MyProc value that's real enough to let them wait for LWLocks.  The PGPROC 
 * and sema that are assigned are one of the extra ones created during 
 * InitProcGlobal. 
 * 
 * Auxiliary processes are presently not expected to wait for real (lockmgr) 
 * locks, so we need not set up the deadlock checker.  They are never added 
 * to the ProcArray or the sinval messaging mechanism, either.  They also 
 * don't get a VXID assigned, since this is only useful when we actually 
 * hold lockmgr locks. 
 * 
 * Startup process however uses locks but never waits for them in the 
 * normal backend sense. Startup process also takes part in sinval messaging 
 * as a sendOnly process, so never reads messages from sinval queue. So 
 * Startup process does have a VXID and does show up in pg_locks. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN481"></a><span class='Declare_Function'>InitAuxiliaryProcess</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN483"></a>    <a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>auxproc</span><span class='Delimiter'>; 
</span><a name="LN484"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>proctype</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * ProcGlobal should be set up already (if we are a backend, we inherit 
     * this by fork() or EXEC_BACKEND mechanism from the postmaster). 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| </span><a href="proc.c.html#LN80"><span class='Ref_to_Global_Var'>AuxiliaryProcs</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, </span><span class='String'>"proc header uninitialized"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"you already exist"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We use the ProcStructLock to protect assignment and releasing of 
     * AuxiliaryProcs entries. 
     * 
     * While we are holding the ProcStructLock, also copy the current shared 
     * estimate of spins_per_delay to local storage. 
     */ 
</span>    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN76"><span class='Ref_to_Global_Var'>ProcStructLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="s_lock.c.html#LN194"><span class='Ref_to_Func'>set_spins_per_delay</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN249"><span class='Ref_to_Member'>spins_per_delay</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Find a free auxproc ... *big* trouble if there isn't one ... 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN484"><span class='Ref_To_Local'>proctype</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="proc.c.html#LN484"><span class='Ref_To_Local'>proctype</span></a> <span class='Operator'>&LT; </span><a href="../../../include/storage/proc.h.html#LN272"><span class='Ref_to_Const'>NUM_AUXILIARY_PROCS</span></a><span class='Delimiter'>; </span><a href="proc.c.html#LN484"><span class='Ref_To_Local'>proctype</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="proc.c.html#LN483"><span class='Ref_To_Local'>auxproc</span></a> <span class='Operator'>= &</span><a href="proc.c.html#LN80"><span class='Ref_to_Global_Var'>AuxiliaryProcs</span></a><span class='Delimiter'>[</span><a href="proc.c.html#LN484"><span class='Ref_To_Local'>proctype</span></a><span class='Delimiter'>]; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN483"><span class='Ref_To_Local'>auxproc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN107"><span class='Ref_to_Member'>pid</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN484"><span class='Ref_To_Local'>proctype</span></a> <span class='Operator'>&GT;= </span><a href="../../../include/storage/proc.h.html#LN272"><span class='Ref_to_Const'>NUM_AUXILIARY_PROCS</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN76"><span class='Ref_to_Global_Var'>ProcStructLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, </span><span class='String'>"all AuxiliaryProcs are in use"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Mark auxiliary proc as in use by me */ 
</span>    <span class='Comment_Multi_Line'>/* use volatile pointer to prevent code rearrangement */ 
</span>    <span class='Parentheses'>((</span><span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="proc.c.html#LN483"><span class='Ref_To_Local'>auxproc</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN107"><span class='Ref_to_Member'>pid</span></a> <span class='Operator'>= </span><a href="../../utils/init/globals.c.html#LN38"><span class='Ref_to_Global_Var'>MyProcPid</span></a><span class='Delimiter'>; 
</span> 
    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a> <span class='Operator'>= </span><a href="proc.c.html#LN483"><span class='Ref_To_Local'>auxproc</span></a><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN67"><span class='Ref_to_Global_Var'>MyPgXact</span></a> <span class='Operator'>= &</span><a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN233"><span class='Ref_to_Member'>allPgXact</span></a><span class='Delimiter'>[</span><a href="proc.c.html#LN483"><span class='Ref_To_Local'>auxproc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN108"><span class='Ref_to_Member'>pgprocno</span></a><span class='Delimiter'>]; 
</span> 
    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN76"><span class='Ref_to_Global_Var'>ProcStructLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Initialize all fields of MyProc, except for those previously 
     * initialized by InitProcGlobal. 
     */ 
</span>    <a href="../ipc/shmqueue.c.html#LN55"><span class='Ref_to_Func'>SHMQueueElemInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN96"><span class='Ref_to_Member'>links</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN100"><span class='Ref_to_Member'>waitStatus</span></a> <span class='Operator'>= </span><a href="../../../include/c.h.html#LN974"><span class='Ref_to_Const'>STATUS_OK</span></a><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN104"><span class='Ref_to_Member'>lxid</span></a> <span class='Operator'>= </span><a href="../../../include/storage/lock.h.html#LN69"><span class='Ref_to_Const'>InvalidLocalTransactionId</span></a><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN179"><span class='Ref_to_Member'>fpVXIDLock</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN180"><span class='Ref_to_Member'>fpLocalTransactionId</span></a> <span class='Operator'>= </span><a href="../../../include/storage/lock.h.html#LN69"><span class='Ref_to_Const'>InvalidLocalTransactionId</span></a><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN67"><span class='Ref_to_Global_Var'>MyPgXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN208"><span class='Ref_to_Member'>xid</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN67"><span class='Ref_to_Global_Var'>MyPgXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN212"><span class='Ref_to_Member'>xmin</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN111"><span class='Ref_to_Member'>backendId</span></a> <span class='Operator'>= </span><a href="../../../include/storage/backendid.h.html#LN22"><span class='Ref_to_Const'>InvalidBackendId</span></a><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN112"><span class='Ref_to_Member'>databaseId</span></a> <span class='Operator'>= </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN113"><span class='Ref_to_Member'>roleId</span></a> <span class='Operator'>= </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN115"><span class='Ref_to_Member'>isBackgroundWorker</span></a> <span class='Operator'>= </span><a href="../../utils/init/globals.c.html#LN102"><span class='Ref_to_Global_Var'>IsBackgroundWorker</span></a><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN67"><span class='Ref_to_Global_Var'>MyPgXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN219"><span class='Ref_to_Member'>delayChkpt</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN67"><span class='Ref_to_Global_Var'>MyPgXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN217"><span class='Ref_to_Member'>vacuumFlags</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN125"><span class='Ref_to_Member'>lwWaiting</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN126"><span class='Ref_to_Member'>lwWaitMode</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN134"><span class='Ref_to_Member'>waitLock</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN135"><span class='Ref_to_Member'>waitProcLock</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><span class='Directive'>#ifdef</span> USE_ASSERT_CHECKING 
    <span class='Delimiter'>{ 
</span><a name="LN554"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Last process should have released all locks. */ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN554"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="proc.c.html#LN554"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="../../../include/storage/lwlock.h.html#LN116"><span class='Ref_to_Const'>NUM_LOCK_PARTITIONS</span></a><span class='Delimiter'>; </span><a href="proc.c.html#LN554"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/shmem.h.html#LN76"><span class='Ref_to_Proto'>SHMQueueEmpty</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN155"><span class='Ref_to_Member'>myProcLocks</span></a><span class='Delimiter'>[</span><a href="proc.c.html#LN554"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span><span class='Directive'>#endif</span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Acquire ownership of the PGPROC's latch, so that we can use WaitLatch 
     * on it.  That allows us to repoint the process latch, which so far 
     * points to process local one, to the shared one. 
     */ 
</span>    <a href="../../../include/storage/latch.h.html#LN149"><span class='Ref_to_Proto'>OwnLatch</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN102"><span class='Ref_to_Member'>procLatch</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../utils/init/miscinit.c.html#LN243"><span class='Ref_to_Func'>SwitchToSharedLatch</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Check that group locking fields are in a proper initial state. */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN187"><span class='Ref_to_Member'>lockGroupLeader</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/lib/ilist.h.html#LN287"><span class='Ref_to_Func'>dlist_is_empty</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN188"><span class='Ref_to_Member'>lockGroupMembers</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We might be reusing a semaphore that belonged to a failed process. So 
     * be careful and reinitialize its value here.  (This is not strictly 
     * necessary anymore, but seems like a good idea for cleanliness.) 
     */ 
</span>    <a href="../../../include/storage/pg_sema.h.html#LN49"><span class='Ref_to_Proto'>PGSemaphoreReset</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN99"><span class='Ref_to_Member'>sem</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Arrange to clean up at process exit. 
     */ 
</span>    <a href="../../../include/storage/ipc.h.html#LN69"><span class='Ref_to_Proto'>on_shmem_exit</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN93"><span class='Ref_to_Proto'>AuxiliaryProcKill</span></a><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN484"><span class='Ref_to_Macro'>Int32GetDatum</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN484"><span class='Ref_To_Local'>proctype</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end InitAuxiliaryProcess &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Record the PID and PGPROC structures for the Startup process, for use in 
 * ProcSendSignal().  See comments there for further explanation. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN592"></a><span class='Declare_Function'>PublishStartupProcessInformation</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN76"><span class='Ref_to_Global_Var'>ProcStructLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN251"><span class='Ref_to_Member'>startupProc</span></a> <span class='Operator'>= </span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN252"><span class='Ref_to_Member'>startupProcPid</span></a> <span class='Operator'>= </span><a href="../../utils/init/globals.c.html#LN38"><span class='Ref_to_Global_Var'>MyProcPid</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN76"><span class='Ref_to_Global_Var'>ProcStructLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Used from bufgr to share the value of the buffer that Startup waits on, 
 * or to reset the value to "not waiting" (-1). This allows processing 
 * of recovery conflicts for buffer pins. Set is made before backends look 
 * at this value, so locking not required, especially since the set is 
 * an atomic integer set operation. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN610"></a><span class='Declare_Function'>SetStartupBufferPinWaitBufId</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>bufid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* use volatile pointer to prevent code rearrangement */ 
</span><a name="LN613"></a>    <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN228"><span class='Ref_to_Struct'>PROC_HDR</span></a> <span class='Operator'>*</span><span class='Declare_Local'>procglobal</span> <span class='Operator'>= </span><a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Delimiter'>; 
</span> 
    <a href="proc.c.html#LN613"><span class='Ref_To_Local'>procglobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN254"><span class='Ref_to_Member'>startupBufferPinWaitBufId</span></a> <span class='Operator'>= </span><a href="proc.c.html#LN610"><span class='Ref_to_Parameter'>bufid</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Used by backends when they receive a request to check for buffer pin waits. 
 */ 
</span><span class='Keyword'>int 
</span><a name="LN622"></a><span class='Declare_Function'>GetStartupBufferPinWaitBufId</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* use volatile pointer to prevent code rearrangement */ 
</span><a name="LN625"></a>    <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN228"><span class='Ref_to_Struct'>PROC_HDR</span></a> <span class='Operator'>*</span><span class='Declare_Local'>procglobal</span> <span class='Operator'>= </span><a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="proc.c.html#LN625"><span class='Ref_To_Local'>procglobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN254"><span class='Ref_to_Member'>startupBufferPinWaitBufId</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Check whether there are at least N free PGPROC objects. 
 * 
 * Note: this is designed on the assumption that N will generally be small. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN636"></a><span class='Declare_Function'>HaveNFreeProcs</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>n</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN638"></a>    <a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>proc</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN76"><span class='Ref_to_Global_Var'>ProcStructLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="proc.c.html#LN638"><span class='Ref_To_Local'>proc</span></a> <span class='Operator'>= </span><a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN237"><span class='Ref_to_Member'>freeProcs</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN636"><span class='Ref_to_Parameter'>n</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="proc.c.html#LN638"><span class='Ref_To_Local'>proc</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="proc.c.html#LN638"><span class='Ref_To_Local'>proc</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="proc.c.html#LN638"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN96"><span class='Ref_to_Member'>links</span></a><span class='Operator'>.</span><a href="../../../include/storage/shmem.h.html#LN30"><span class='Ref_to_Member'>next</span></a><span class='Delimiter'>; 
</span>        <a href="proc.c.html#LN636"><span class='Ref_to_Parameter'>n</span></a><span class='Operator'>--</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN76"><span class='Ref_to_Global_Var'>ProcStructLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN636"><span class='Ref_to_Parameter'>n</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Check if the current process is awaiting a lock. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN659"></a><span class='Declare_Function'>IsWaitingForLock</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN84"><span class='Ref_to_Global_Var'>lockAwaited</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Cancel any pending wait for lock, when aborting a transaction, and revert 
 * any strong lock count acquisition for a lock being acquired. 
 * 
 * (Normally, this would only happen if we accept a cancel/die 
 * interrupt while waiting; but an ereport(ERROR) before or during the lock 
 * wait is within the realm of possibility, too.) 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN676"></a><span class='Declare_Function'>LockErrorCleanup</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN678"></a>    <a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>partitionLock</span><span class='Delimiter'>; 
</span><a name="LN679"></a>    <a href="../../../include/utils/timeout.h.html#LN62"><span class='Ref_to_Typedef'>DisableTimeoutParams</span></a> <span class='Declare_Local'>timeouts</span><span class='Delimiter'>[</span><span class='Number'>2</span><span class='Delimiter'>]; 
</span> 
    <a href="../../../include/miscadmin.h.html#LN116"><span class='Ref_to_Macro'>HOLD_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lock.h.html#LN532"><span class='Ref_to_Proto'>AbortStrongLockAcquire</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Nothing to do if we weren't waiting for a lock */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN84"><span class='Ref_to_Global_Var'>lockAwaited</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/miscadmin.h.html#LN118"><span class='Ref_to_Macro'>RESUME_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Turn off the deadlock and lock timeout timers, if they are still 
     * running (see ProcSleep).  Note we must preserve the LOCK_TIMEOUT 
     * indicator flag, since this function is executed before 
     * ProcessInterrupts when responding to SIGINT; else we'd lose the 
     * knowledge that the SIGINT came from a lock timeout and not an external 
     * source. 
     */ 
</span>    <a href="proc.c.html#LN679"><span class='Ref_To_Local'>timeouts</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/utils/timeout.h.html#LN64"><span class='Ref_to_Member'>id</span></a> <span class='Operator'>= </span><a href="../../../include/utils/timeout.h.html#LN26"><span class='Ref_to_EnumConst'>DEADLOCK_TIMEOUT</span></a><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN679"><span class='Ref_To_Local'>timeouts</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/utils/timeout.h.html#LN65"><span class='Ref_to_Member'>keep_indicator</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN679"><span class='Ref_To_Local'>timeouts</span></a><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/utils/timeout.h.html#LN64"><span class='Ref_to_Member'>id</span></a> <span class='Operator'>= </span><a href="../../../include/utils/timeout.h.html#LN27"><span class='Ref_to_EnumConst'>LOCK_TIMEOUT</span></a><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN679"><span class='Ref_To_Local'>timeouts</span></a><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/utils/timeout.h.html#LN65"><span class='Ref_to_Member'>keep_indicator</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <a href="../../../include/utils/timeout.h.html#LN78"><span class='Ref_to_Proto'>disable_timeouts</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN679"><span class='Ref_To_Local'>timeouts</span></a><span class='Delimiter'>, </span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Unlink myself from the wait queue, if on it (might not be anymore!) */ 
</span>    <a href="proc.c.html#LN678"><span class='Ref_To_Local'>partitionLock</span></a> <span class='Operator'>= </span><a href="../../../include/storage/lock.h.html#LN497"><span class='Ref_to_Macro'>LockHashPartitionLock</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN84"><span class='Ref_to_Global_Var'>lockAwaited</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN409"><span class='Ref_to_Member'>hashcode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN678"><span class='Ref_To_Local'>partitionLock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN96"><span class='Ref_to_Member'>links</span></a><span class='Operator'>.</span><a href="../../../include/storage/shmem.h.html#LN30"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* We could not have been granted the lock yet */ 
</span>        <a href="../../../include/storage/lock.h.html#LN550"><span class='Ref_to_Proto'>RemoveFromWaitQueue</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN84"><span class='Ref_to_Global_Var'>lockAwaited</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN409"><span class='Ref_to_Member'>hashcode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Somebody kicked us off the lock queue already.  Perhaps they 
         * granted us the lock, or perhaps they detected a deadlock. If they 
         * did grant us the lock, we'd better remember it in our local lock 
         * table. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN100"><span class='Ref_to_Member'>waitStatus</span></a> <span class='Operator'>== </span><a href="../../../include/c.h.html#LN974"><span class='Ref_to_Const'>STATUS_OK</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/storage/lock.h.html#LN549"><span class='Ref_to_Proto'>GrantAwaitedLock</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="proc.c.html#LN84"><span class='Ref_to_Global_Var'>lockAwaited</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN678"><span class='Ref_To_Local'>partitionLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/miscadmin.h.html#LN118"><span class='Ref_to_Macro'>RESUME_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end LockErrorCleanup &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * ProcReleaseLocks() -- release locks associated with current transaction 
 *          at main transaction commit or abort 
 * 
 * At main transaction commit, we release standard locks except session locks. 
 * At main transaction abort, we release all locks including session locks. 
 * 
 * Advisory locks are released only if they are transaction-level; 
 * session-level holds remain, whether this is a commit or not. 
 * 
 * At subtransaction commit, we don't release any locks (so this func is not 
 * needed at all); we will defer the releasing to the parent transaction. 
 * At subtransaction abort, we release all locks held by the subtransaction; 
 * this is implemented by retail releasing of the locks under control of 
 * the ResourceOwner mechanism. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN752"></a><span class='Declare_Function'>ProcReleaseLocks</span><span class='Parentheses'>(</span><span class='Keyword'>bool </span><span class='Declare_Parameter'>isCommit</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* If waiting, get off wait queue (should only be needed after error) */ 
</span>    <a href="../../../include/storage/proc.h.html#LN305"><span class='Ref_to_Proto'>LockErrorCleanup</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* Release standard locks, including session-level if aborting */ 
</span>    <a href="../../../include/storage/lock.h.html#LN535"><span class='Ref_to_Proto'>LockReleaseAll</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/lock.h.html#LN128"><span class='Ref_to_Const'>DEFAULT_LOCKMETHOD</span></a><span class='Delimiter'>, </span><span class='Operator'>!</span><a href="proc.c.html#LN752"><span class='Ref_to_Parameter'>isCommit</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* Release transaction-level advisory locks */ 
</span>    <a href="../../../include/storage/lock.h.html#LN535"><span class='Ref_to_Proto'>LockReleaseAll</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/lock.h.html#LN129"><span class='Ref_to_Const'>USER_LOCKMETHOD</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * RemoveProcFromArray() -- Remove this process from the shared ProcArray. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN769"></a><span class='Declare_Function'>RemoveProcFromArray</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>code</span><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>arg</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/procarray.h.html#LN61"><span class='Ref_to_Proto'>ProcArrayRemove</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Delimiter'>, </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * ProcKill() -- Destroy the per-proc data structure for 
 *      this process. Release any of its held LW locks. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN780"></a><span class='Declare_Function'>ProcKill</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>code</span><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>arg</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN782"></a>    <a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>proc</span><span class='Delimiter'>; 
</span><a name="LN783"></a>    <a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a>     <span class='Operator'>*</span><span class='Keyword'>volatile </span><span class='Operator'>* </span><span class='Declare_Local'>procgloballist</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Make sure we're out of the sync rep lists */ 
</span>    <a href="../../../include/replication/syncrep.h.html#LN69"><span class='Ref_to_Proto'>SyncRepCleanupAtProcExit</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> USE_ASSERT_CHECKING 
    <span class='Delimiter'>{ 
</span><a name="LN792"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Last process should have released all locks. */ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN792"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="proc.c.html#LN792"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="../../../include/storage/lwlock.h.html#LN116"><span class='Ref_to_Const'>NUM_LOCK_PARTITIONS</span></a><span class='Delimiter'>; </span><a href="proc.c.html#LN792"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/shmem.h.html#LN76"><span class='Ref_to_Proto'>SHMQueueEmpty</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN155"><span class='Ref_to_Member'>myProcLocks</span></a><span class='Delimiter'>[</span><a href="proc.c.html#LN792"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span><span class='Directive'>#endif</span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Release any LW locks I am holding.  There really shouldn't be any, but 
     * it's cheap to check again before we cut the knees off the LWLock 
     * facility by releasing our PGPROC ... 
     */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN150"><span class='Ref_to_Proto'>LWLockReleaseAll</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Cancel any pending condition variable sleep, too */ 
</span>    <a href="../../../include/storage/condition_variable.h.html#LN45"><span class='Ref_to_Proto'>ConditionVariableCancelSleep</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Make sure active replication slots are released */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../replication/slot.c.html#LN95"><span class='Ref_to_Global_Var'>MyReplicationSlot</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../../include/replication/slot.h.html#LN167"><span class='Ref_to_Proto'>ReplicationSlotRelease</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Also cleanup all the temporary slots. */ 
</span>    <a href="../../../include/replication/slot.h.html#LN168"><span class='Ref_to_Proto'>ReplicationSlotCleanup</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Detach from any lock group of which we are a member.  If the leader 
     * exist before all other group members, it's PGPROC will remain allocated 
     * until the last group process exits; that process must return the 
     * leader's PGPROC to the appropriate list. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN187"><span class='Ref_to_Member'>lockGroupLeader</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN825"></a>        <a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>leader</span> <span class='Operator'>= </span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN187"><span class='Ref_to_Member'>lockGroupLeader</span></a><span class='Delimiter'>; 
</span><a name="LN826"></a>        <a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>leader_lwlock</span> <span class='Operator'>= </span><a href="../../../include/storage/lock.h.html#LN512"><span class='Ref_to_Macro'>LockHashPartitionLockByProc</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN825"><span class='Ref_To_Local'>leader</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN826"><span class='Ref_To_Local'>leader_lwlock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/lib/ilist.h.html#LN287"><span class='Ref_to_Func'>dlist_is_empty</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="proc.c.html#LN825"><span class='Ref_To_Local'>leader</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN188"><span class='Ref_to_Member'>lockGroupMembers</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="../../../include/lib/ilist.h.html#LN356"><span class='Ref_to_Func'>dlist_delete</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN189"><span class='Ref_to_Member'>lockGroupLink</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/lib/ilist.h.html#LN287"><span class='Ref_to_Func'>dlist_is_empty</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="proc.c.html#LN825"><span class='Ref_To_Local'>leader</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN188"><span class='Ref_to_Member'>lockGroupMembers</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="proc.c.html#LN825"><span class='Ref_To_Local'>leader</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN187"><span class='Ref_to_Member'>lockGroupLeader</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN825"><span class='Ref_To_Local'>leader</span></a> <span class='Operator'>!= </span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="proc.c.html#LN783"><span class='Ref_To_Local'>procgloballist</span></a> <span class='Operator'>= </span><a href="proc.c.html#LN825"><span class='Ref_To_Local'>leader</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN97"><span class='Ref_to_Member'>procgloballist</span></a><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* Leader exited first; return its PGPROC. */ 
</span>                <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN76"><span class='Ref_to_Global_Var'>ProcStructLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="proc.c.html#LN825"><span class='Ref_To_Local'>leader</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN96"><span class='Ref_to_Member'>links</span></a><span class='Operator'>.</span><a href="../../../include/storage/shmem.h.html#LN30"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/shmem.h.html#LN27"><span class='Ref_to_Struct'>SHM_QUEUE</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>*</span><a href="proc.c.html#LN783"><span class='Ref_To_Local'>procgloballist</span></a><span class='Delimiter'>; 
</span>                <span class='Operator'>*</span><a href="proc.c.html#LN783"><span class='Ref_To_Local'>procgloballist</span></a> <span class='Operator'>= </span><a href="proc.c.html#LN825"><span class='Ref_To_Local'>leader</span></a><span class='Delimiter'>; 
</span>                <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN76"><span class='Ref_to_Global_Var'>ProcStructLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN825"><span class='Ref_To_Local'>leader</span></a> <span class='Operator'>!= </span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Parentheses'>) 
</span>            <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN187"><span class='Ref_to_Member'>lockGroupLeader</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN826"><span class='Ref_To_Local'>leader_lwlock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if MyProc-&GT;lockGroupLead... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Reset MyLatch to the process local one.  This is so that signal 
     * handlers et al can continue using the latch after the shared latch 
     * isn't ours anymore. After that clear MyProc and disown the shared 
     * latch. 
     */ 
</span>    <a href="../../utils/init/miscinit.c.html#LN262"><span class='Ref_to_Func'>SwitchBackToLocalLatch</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN782"><span class='Ref_To_Local'>proc</span></a> <span class='Operator'>= </span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/latch.h.html#LN150"><span class='Ref_to_Proto'>DisownLatch</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="proc.c.html#LN782"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN102"><span class='Ref_to_Member'>procLatch</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="proc.c.html#LN783"><span class='Ref_To_Local'>procgloballist</span></a> <span class='Operator'>= </span><a href="proc.c.html#LN782"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN97"><span class='Ref_to_Member'>procgloballist</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN76"><span class='Ref_to_Global_Var'>ProcStructLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we're still a member of a locking group, that means we're a leader 
     * which has somehow exited before its children.  The last remaining child 
     * will release our PGPROC.  Otherwise, release it now. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN782"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN187"><span class='Ref_to_Member'>lockGroupLeader</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Since lockGroupLeader is NULL, lockGroupMembers should be empty. */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/lib/ilist.h.html#LN287"><span class='Ref_to_Func'>dlist_is_empty</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="proc.c.html#LN782"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN188"><span class='Ref_to_Member'>lockGroupMembers</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Return PGPROC structure (and semaphore) to appropriate freelist */ 
</span>        <a href="proc.c.html#LN782"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN96"><span class='Ref_to_Member'>links</span></a><span class='Operator'>.</span><a href="../../../include/storage/shmem.h.html#LN30"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/shmem.h.html#LN27"><span class='Ref_to_Struct'>SHM_QUEUE</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>*</span><a href="proc.c.html#LN783"><span class='Ref_To_Local'>procgloballist</span></a><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="proc.c.html#LN783"><span class='Ref_To_Local'>procgloballist</span></a> <span class='Operator'>= </span><a href="proc.c.html#LN782"><span class='Ref_To_Local'>proc</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Update shared estimate of spins_per_delay */ 
</span>    <a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN249"><span class='Ref_to_Member'>spins_per_delay</span></a> <span class='Operator'>= </span><a href="s_lock.c.html#LN205"><span class='Ref_to_Func'>update_spins_per_delay</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN249"><span class='Ref_to_Member'>spins_per_delay</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN76"><span class='Ref_to_Global_Var'>ProcStructLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * This process is no longer present in shared memory in any meaningful 
     * way, so tell the postmaster we've cleaned up acceptably well. (XXX 
     * autovac launcher should be included here someday) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../utils/init/globals.c.html#LN100"><span class='Ref_to_Global_Var'>IsUnderPostmaster</span></a> <span class='Operator'>&& !</span><a href="../../../include/postmaster/autovacuum.h.html#LN49"><span class='Ref_to_Proto'>IsAutoVacuumLauncherProcess</span></a><span class='Parentheses'>())</span> 
        <a href="../../../include/storage/pmsignal.h.html#LN51"><span class='Ref_to_Proto'>MarkPostmasterChildInactive</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* wake autovac launcher if needed -- see comments in FreeWorkerInfo */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../postmaster/autovacuum.c.html#LN312"><span class='Ref_to_Global_Var'>AutovacuumLauncherPid</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="../../../include/port.h.html#LN210"><span class='Ref_to_Macro'>kill</span></a><span class='Parentheses'>(</span><a href="../../postmaster/autovacuum.c.html#LN312"><span class='Ref_to_Global_Var'>AutovacuumLauncherPid</span></a><span class='Delimiter'>, </span><a href="../../../include/port/win32.h.html#LN202"><span class='Ref_to_Const'>SIGUSR2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ProcKill &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * AuxiliaryProcKill() -- Cut-down version of ProcKill for auxiliary 
 *      processes (bgwriter, etc).  The PGPROC and sema are not released, only 
 *      marked as not-in-use. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN903"></a><span class='Declare_Function'>AuxiliaryProcKill</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>code</span><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>arg</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN905"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>proctype</span> <span class='Operator'>= </span><a href="../../../include/postgres.h.html#LN477"><span class='Ref_to_Macro'>DatumGetInt32</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN903"><span class='Ref_to_Parameter'>arg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN906"></a>    <a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a>     <span class='Operator'>*</span>auxproc <span class='Declare_Local'>PG_USED_FOR_ASSERTS_ONLY</span><span class='Delimiter'>; 
</span><a name="LN907"></a>    <a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>proc</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="proc.c.html#LN905"><span class='Ref_To_Local'>proctype</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="proc.c.html#LN905"><span class='Ref_To_Local'>proctype</span></a> <span class='Operator'>&LT; </span><a href="../../../include/storage/proc.h.html#LN272"><span class='Ref_to_Const'>NUM_AUXILIARY_PROCS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    auxproc <span class='Operator'>= &</span><a href="proc.c.html#LN80"><span class='Ref_to_Global_Var'>AuxiliaryProcs</span></a><span class='Delimiter'>[</span><a href="proc.c.html#LN905"><span class='Ref_To_Local'>proctype</span></a><span class='Delimiter'>]; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a> <span class='Operator'>== </span>auxproc<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Release any LW locks I am holding (see notes above) */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN150"><span class='Ref_to_Proto'>LWLockReleaseAll</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Cancel any pending condition variable sleep, too */ 
</span>    <a href="../../../include/storage/condition_variable.h.html#LN45"><span class='Ref_to_Proto'>ConditionVariableCancelSleep</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Reset MyLatch to the process local one.  This is so that signal 
     * handlers et al can continue using the latch after the shared latch 
     * isn't ours anymore. After that clear MyProc and disown the shared 
     * latch. 
     */ 
</span>    <a href="../../utils/init/miscinit.c.html#LN262"><span class='Ref_to_Func'>SwitchBackToLocalLatch</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN907"><span class='Ref_To_Local'>proc</span></a> <span class='Operator'>= </span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/latch.h.html#LN150"><span class='Ref_to_Proto'>DisownLatch</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="proc.c.html#LN907"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN102"><span class='Ref_to_Member'>procLatch</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN76"><span class='Ref_to_Global_Var'>ProcStructLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Mark auxiliary proc no longer in use */ 
</span>    <a href="proc.c.html#LN907"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN107"><span class='Ref_to_Member'>pid</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Update shared estimate of spins_per_delay */ 
</span>    <a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN249"><span class='Ref_to_Member'>spins_per_delay</span></a> <span class='Operator'>= </span><a href="s_lock.c.html#LN205"><span class='Ref_to_Func'>update_spins_per_delay</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN249"><span class='Ref_to_Member'>spins_per_delay</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN76"><span class='Ref_to_Global_Var'>ProcStructLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end AuxiliaryProcKill &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * AuxiliaryPidGetProc -- get PGPROC for an auxiliary process 
 * given its PID 
 * 
 * Returns NULL if not found. 
 */ 
</span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>* 
</span><a name="LN950"></a><span class='Declare_Function'>AuxiliaryPidGetProc</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>pid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN952"></a>    <a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>result</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN953"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>index</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN950"><span class='Ref_to_Parameter'>pid</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span>               <span class='Comment_Single_Line'>/* never match dummy PGPROCs */ 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN953"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="proc.c.html#LN953"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>&LT; </span><a href="../../../include/storage/proc.h.html#LN272"><span class='Ref_to_Const'>NUM_AUXILIARY_PROCS</span></a><span class='Delimiter'>; </span><a href="proc.c.html#LN953"><span class='Ref_To_Local'>index</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN960"></a>        <a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>proc</span> <span class='Operator'>= &</span><a href="proc.c.html#LN80"><span class='Ref_to_Global_Var'>AuxiliaryProcs</span></a><span class='Delimiter'>[</span><a href="proc.c.html#LN953"><span class='Ref_To_Local'>index</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN960"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN107"><span class='Ref_to_Member'>pid</span></a> <span class='Operator'>== </span><a href="proc.c.html#LN950"><span class='Ref_to_Parameter'>pid</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="proc.c.html#LN952"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="proc.c.html#LN960"><span class='Ref_To_Local'>proc</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <a href="proc.c.html#LN952"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end AuxiliaryPidGetProc &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * ProcQueue package: routines for putting processes to sleep 
 *      and  waking them up 
 */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * ProcQueueAlloc -- alloc/attach to a shared memory process queue 
 * 
 * Returns: a pointer to the queue 
 * Side Effects: Initializes the queue if it wasn't there before 
 */ 
</span><span class='Directive'>#ifdef</span> NOT_USED 
<a href="../../../include/storage/lock.h.html#LN29"><span class='Ref_to_Struct'>PROC_QUEUE</span></a> <span class='Operator'>* 
</span><a name="LN984"></a><span class='Declare_Function'>ProcQueueAlloc</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>name</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN986"></a>    <a href="../../../include/storage/lock.h.html#LN29"><span class='Ref_to_Struct'>PROC_QUEUE</span></a> <span class='Operator'>*</span><span class='Declare_Local'>queue</span><span class='Delimiter'>; 
</span><a name="LN987"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span><span class='Delimiter'>; 
</span> 
    <a href="proc.c.html#LN986"><span class='Ref_To_Local'>queue</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/lock.h.html#LN29"><span class='Ref_to_Struct'>PROC_QUEUE</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/shmem.h.html#LN43"><span class='Ref_to_Proto'>ShmemInitStruct</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN984"><span class='Ref_to_Parameter'>name</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/lock.h.html#LN29"><span class='Ref_to_Struct'>PROC_QUEUE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="proc.c.html#LN987"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="proc.c.html#LN987"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/proc.h.html#LN299"><span class='Ref_to_Proto'>ProcQueueInit</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN986"><span class='Ref_To_Local'>queue</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="proc.c.html#LN986"><span class='Ref_To_Local'>queue</span></a><span class='Delimiter'>; 
} 
</span><span class='Directive'>#endif</span> 
 
<span class='Comment_Multi_Line'>/* 
 * ProcQueueInit -- initialize a shared memory process queue 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1003"></a><span class='Declare_Function'>ProcQueueInit</span><span class='Parentheses'>(</span><a href="../../../include/storage/lock.h.html#LN29"><span class='Ref_to_Struct'>PROC_QUEUE</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>queue</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../ipc/shmqueue.c.html#LN34"><span class='Ref_to_Func'>SHMQueueInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="proc.c.html#LN1003"><span class='Ref_to_Parameter'>queue</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN31"><span class='Ref_to_Member'>links</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN1003"><span class='Ref_to_Parameter'>queue</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN32"><span class='Ref_to_Member'>size</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * ProcSleep -- put a process to sleep on the specified lock 
 * 
 * Caller must have set MyProc-&GT;heldLocks to reflect locks already held 
 * on the lockable object by this process (under all XIDs). 
 * 
 * The lock table's partition lock must be held at entry, and will be held 
 * at exit. 
 * 
 * Result: STATUS_OK if we acquired the lock, STATUS_ERROR if not (deadlock). 
 * 
 * ASSUME: that no one will fiddle with the queue until after 
 *      we release the partition lock. 
 * 
 * NOTES: The process queue is now a priority queue for locking. 
 */ 
</span><span class='Keyword'>int 
</span><a name="LN1027"></a><span class='Declare_Function'>ProcSleep</span><span class='Parentheses'>(</span><a href="../../../include/storage/lock.h.html#LN401"><span class='Ref_to_Struct'>LOCALLOCK</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>locallock</span><span class='Delimiter'>, </span><a href="../../../include/storage/lock.h.html#LN119"><span class='Ref_to_Typedef'>LockMethod</span></a> <span class='Declare_Parameter'>lockMethodTable</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1029"></a>    <a href="../../../include/storage/lockdefs.h.html#LN25"><span class='Ref_to_Typedef'>LOCKMODE</span></a>    <span class='Declare_Local'>lockmode</span> <span class='Operator'>= </span><a href="proc.c.html#LN1027"><span class='Ref_to_Parameter'>locallock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN404"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/lock.h.html#LN386"><span class='Ref_to_Member'>mode</span></a><span class='Delimiter'>; 
</span><a name="LN1030"></a>    <a href="../../../include/storage/lock.h.html#LN284"><span class='Ref_to_Struct'>LOCK</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>lock</span> <span class='Operator'>= </span><a href="proc.c.html#LN1027"><span class='Ref_to_Parameter'>locallock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN407"><span class='Ref_to_Member'>lock</span></a><span class='Delimiter'>; 
</span><a name="LN1031"></a>    <a href="../../../include/storage/lock.h.html#LN344"><span class='Ref_to_Struct'>PROCLOCK</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>proclock</span> <span class='Operator'>= </span><a href="proc.c.html#LN1027"><span class='Ref_to_Parameter'>locallock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN408"><span class='Ref_to_Member'>proclock</span></a><span class='Delimiter'>; 
</span><a name="LN1032"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>hashcode</span> <span class='Operator'>= </span><a href="proc.c.html#LN1027"><span class='Ref_to_Parameter'>locallock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN409"><span class='Ref_to_Member'>hashcode</span></a><span class='Delimiter'>; 
</span><a name="LN1033"></a>    <a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>partitionLock</span> <span class='Operator'>= </span><a href="../../../include/storage/lock.h.html#LN497"><span class='Ref_to_Macro'>LockHashPartitionLock</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN1032"><span class='Ref_To_Local'>hashcode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1034"></a>    <a href="../../../include/storage/lock.h.html#LN29"><span class='Ref_to_Struct'>PROC_QUEUE</span></a> <span class='Operator'>*</span><span class='Declare_Local'>waitQueue</span> <span class='Operator'>= &</span><span class='Parentheses'>(</span><a href="proc.c.html#LN1030"><span class='Ref_To_Local'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN293"><span class='Ref_to_Member'>waitProcs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1035"></a>    <a href="../../../include/storage/lockdefs.h.html#LN24"><span class='Ref_to_Typedef'>LOCKMASK</span></a>    <span class='Declare_Local'>myHeldLocks</span> <span class='Operator'>= </span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN137"><span class='Ref_to_Member'>heldLocks</span></a><span class='Delimiter'>; 
</span><a name="LN1036"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>early_deadlock</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN1037"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>allow_autovacuum_cancel</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span><a name="LN1038"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>myWaitStatus</span><span class='Delimiter'>; 
</span><a name="LN1039"></a>    <a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>proc</span><span class='Delimiter'>; 
</span><a name="LN1040"></a>    <a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>leader</span> <span class='Operator'>= </span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN187"><span class='Ref_to_Member'>lockGroupLeader</span></a><span class='Delimiter'>; 
</span><a name="LN1041"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If group locking is in use, locks held by members of my locking group 
     * need to be included in myHeldLocks. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN1040"><span class='Ref_To_Local'>leader</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1049"></a>        <a href="../../../include/storage/shmem.h.html#LN27"><span class='Ref_to_Struct'>SHM_QUEUE</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>procLocks</span> <span class='Operator'>= &</span><span class='Parentheses'>(</span><a href="proc.c.html#LN1030"><span class='Ref_To_Local'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN292"><span class='Ref_to_Member'>procLocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1050"></a>        <a href="../../../include/storage/lock.h.html#LN344"><span class='Ref_to_Struct'>PROCLOCK</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>otherproclock</span><span class='Delimiter'>; 
</span> 
        <a href="proc.c.html#LN1050"><span class='Ref_To_Local'>otherproclock</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/lock.h.html#LN344"><span class='Ref_to_Struct'>PROCLOCK</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN1049"><span class='Ref_To_Local'>procLocks</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN1049"><span class='Ref_To_Local'>procLocks</span></a><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/lock.h.html#LN344"><span class='Ref_to_Struct'>PROCLOCK</span></a><span class='Delimiter'>, </span>lockLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN1050"><span class='Ref_To_Local'>otherproclock</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN1050"><span class='Ref_To_Local'>otherproclock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN350"><span class='Ref_to_Member'>groupLeader</span></a> <span class='Operator'>== </span><a href="proc.c.html#LN1040"><span class='Ref_To_Local'>leader</span></a><span class='Parentheses'>) 
</span>                <a href="proc.c.html#LN1035"><span class='Ref_To_Local'>myHeldLocks</span></a> <span class='Operator'>|= </span><a href="proc.c.html#LN1050"><span class='Ref_To_Local'>otherproclock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN351"><span class='Ref_to_Member'>holdMask</span></a><span class='Delimiter'>; 
</span>            <a href="proc.c.html#LN1050"><span class='Ref_To_Local'>otherproclock</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/lock.h.html#LN344"><span class='Ref_to_Struct'>PROCLOCK</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                <a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN1049"><span class='Ref_To_Local'>procLocks</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="proc.c.html#LN1050"><span class='Ref_To_Local'>otherproclock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN353"><span class='Ref_to_Member'>lockLink</span></a><span class='Delimiter'>, 
</span>                             <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/lock.h.html#LN344"><span class='Ref_to_Struct'>PROCLOCK</span></a><span class='Delimiter'>, </span>lockLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Determine where to add myself in the wait queue. 
     * 
     * Normally I should go at the end of the queue.  However, if I already 
     * hold locks that conflict with the request of any previous waiter, put 
     * myself in the queue just in front of the first such waiter. This is not 
     * a necessary step, since deadlock detection would move me to before that 
     * waiter anyway; but it's relatively cheap to detect such a conflict 
     * immediately, and avoid delaying till deadlock timeout. 
     * 
     * Special case: if I find I should go in front of some waiter, check to 
     * see if I conflict with already-held locks or the requests before that 
     * waiter.  If not, then just grant myself the requested lock immediately. 
     * This is the same as the test for immediate grant in LockAcquire, except 
     * we are only considering the part of the wait queue before my insertion 
     * point. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN1035"><span class='Ref_To_Local'>myHeldLocks</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1083"></a>        <a href="../../../include/storage/lockdefs.h.html#LN24"><span class='Ref_to_Typedef'>LOCKMASK</span></a>    <span class='Declare_Local'>aheadRequests</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
        <a href="proc.c.html#LN1039"><span class='Ref_To_Local'>proc</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="proc.c.html#LN1034"><span class='Ref_To_Local'>waitQueue</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN31"><span class='Ref_to_Member'>links</span></a><span class='Operator'>.</span><a href="../../../include/storage/shmem.h.html#LN30"><span class='Ref_to_Member'>next</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN1041"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="proc.c.html#LN1041"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="proc.c.html#LN1034"><span class='Ref_To_Local'>waitQueue</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN32"><span class='Ref_to_Member'>size</span></a><span class='Delimiter'>; </span><a href="proc.c.html#LN1041"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * If we're part of the same locking group as this waiter, its 
             * locks neither conflict with ours nor contribute to 
             * aheadRequests. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN1040"><span class='Ref_To_Local'>leader</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL </span><span class='Operator'>&& </span><a href="proc.c.html#LN1040"><span class='Ref_To_Local'>leader</span></a> <span class='Operator'>== </span><a href="proc.c.html#LN1039"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN187"><span class='Ref_to_Member'>lockGroupLeader</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="proc.c.html#LN1039"><span class='Ref_To_Local'>proc</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="proc.c.html#LN1039"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN96"><span class='Ref_to_Member'>links</span></a><span class='Operator'>.</span><a href="../../../include/storage/shmem.h.html#LN30"><span class='Ref_to_Member'>next</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Comment_Multi_Line'>/* Must he wait for me? */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN1027"><span class='Ref_to_Parameter'>lockMethodTable</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN114"><span class='Ref_to_Member'>conflictTab</span></a><span class='Delimiter'>[</span><a href="proc.c.html#LN1039"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN136"><span class='Ref_to_Member'>waitLockMode</span></a><span class='Delimiter'>] </span><span class='Operator'>& </span><a href="proc.c.html#LN1035"><span class='Ref_To_Local'>myHeldLocks</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Must I wait for him ? */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN1027"><span class='Ref_to_Parameter'>lockMethodTable</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN114"><span class='Ref_to_Member'>conflictTab</span></a><span class='Delimiter'>[</span><a href="proc.c.html#LN1029"><span class='Ref_To_Local'>lockmode</span></a><span class='Delimiter'>] </span><span class='Operator'>& </span><a href="proc.c.html#LN1039"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN137"><span class='Ref_to_Member'>heldLocks</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* 
                     * Yes, so we have a deadlock.  Easiest way to clean up 
                     * correctly is to call RemoveFromWaitQueue(), but we 
                     * can't do that until we are *on* the wait queue. So, set 
                     * a flag to check below, and break out of loop.  Also, 
                     * record deadlock info for later message. 
                     */ 
</span>                    <a href="../../../include/storage/lock.h.html#LN570"><span class='Ref_to_Proto'>RememberSimpleDeadLock</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN1029"><span class='Ref_To_Local'>lockmode</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN1030"><span class='Ref_To_Local'>lock</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN1039"><span class='Ref_To_Local'>proc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="proc.c.html#LN1036"><span class='Ref_To_Local'>early_deadlock</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Comment_Multi_Line'>/* I must go before this waiter.  Check special case. */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="proc.c.html#LN1027"><span class='Ref_to_Parameter'>lockMethodTable</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN114"><span class='Ref_to_Member'>conflictTab</span></a><span class='Delimiter'>[</span><a href="proc.c.html#LN1029"><span class='Ref_To_Local'>lockmode</span></a><span class='Delimiter'>] </span><span class='Operator'>& </span><a href="proc.c.html#LN1083"><span class='Ref_To_Local'>aheadRequests</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>&& 
</span>                    <a href="../../../include/storage/lock.h.html#LN545"><span class='Ref_to_Proto'>LockCheckConflicts</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN1027"><span class='Ref_to_Parameter'>lockMethodTable</span></a><span class='Delimiter'>, 
</span>                                       <a href="proc.c.html#LN1029"><span class='Ref_To_Local'>lockmode</span></a><span class='Delimiter'>, 
</span>                                       <a href="proc.c.html#LN1030"><span class='Ref_To_Local'>lock</span></a><span class='Delimiter'>, 
</span>                                       <a href="proc.c.html#LN1031"><span class='Ref_To_Local'>proclock</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="../../../include/c.h.html#LN974"><span class='Ref_to_Const'>STATUS_OK</span></a><span class='Parentheses'>)</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* Skip the wait and just grant myself the lock. */ 
</span>                    <a href="../../../include/storage/lock.h.html#LN548"><span class='Ref_to_Proto'>GrantLock</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN1030"><span class='Ref_To_Local'>lock</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN1031"><span class='Ref_To_Local'>proclock</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN1029"><span class='Ref_To_Local'>lockmode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../../../include/storage/lock.h.html#LN549"><span class='Ref_to_Proto'>GrantAwaitedLock</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>                    <span class='Control'>return</span> <a href="../../../include/c.h.html#LN974"><span class='Ref_to_Const'>STATUS_OK</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Comment_Multi_Line'>/* Break out of loop to put myself before him */ 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if lockMethodTable-&GT;conf... &raquo; </span> 
            <span class='Comment_Multi_Line'>/* Nope, so advance to next waiter */ 
</span>            <a href="proc.c.html#LN1083"><span class='Ref_To_Local'>aheadRequests</span></a> <span class='Operator'>|= </span><a href="../../../include/storage/lock.h.html#LN87"><span class='Ref_to_Macro'>LOCKBIT_ON</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN1039"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN136"><span class='Ref_to_Member'>waitLockMode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="proc.c.html#LN1039"><span class='Ref_To_Local'>proc</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="proc.c.html#LN1039"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN96"><span class='Ref_to_Member'>links</span></a><span class='Operator'>.</span><a href="../../../include/storage/shmem.h.html#LN30"><span class='Ref_to_Member'>next</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;waitQueue-&GT;size... &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* 
         * If we fall out of loop normally, proc points to waitQueue head, so 
         * we will insert at tail of queue as desired. 
         */ 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if myHeldLocks!=0 &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* I hold no locks, so I can't push in front of anyone. */ 
</span>        <a href="proc.c.html#LN1039"><span class='Ref_To_Local'>proc</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="proc.c.html#LN1034"><span class='Ref_To_Local'>waitQueue</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN31"><span class='Ref_to_Member'>links</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Insert self into queue, ahead of the given proc (or at tail of queue). 
     */ 
</span>    <a href="../../../include/storage/shmem.h.html#LN70"><span class='Ref_to_Proto'>SHMQueueInsertBefore</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="proc.c.html#LN1039"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN96"><span class='Ref_to_Member'>links</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN96"><span class='Ref_to_Member'>links</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN1034"><span class='Ref_To_Local'>waitQueue</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN32"><span class='Ref_to_Member'>size</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span> 
    <a href="proc.c.html#LN1030"><span class='Ref_To_Local'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN291"><span class='Ref_to_Member'>waitMask</span></a> <span class='Operator'>|= </span><a href="../../../include/storage/lock.h.html#LN87"><span class='Ref_to_Macro'>LOCKBIT_ON</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN1029"><span class='Ref_To_Local'>lockmode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Set up wait information in PGPROC object, too */ 
</span>    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN134"><span class='Ref_to_Member'>waitLock</span></a> <span class='Operator'>= </span><a href="proc.c.html#LN1030"><span class='Ref_To_Local'>lock</span></a><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN135"><span class='Ref_to_Member'>waitProcLock</span></a> <span class='Operator'>= </span><a href="proc.c.html#LN1031"><span class='Ref_To_Local'>proclock</span></a><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN136"><span class='Ref_to_Member'>waitLockMode</span></a> <span class='Operator'>= </span><a href="proc.c.html#LN1029"><span class='Ref_To_Local'>lockmode</span></a><span class='Delimiter'>; 
</span> 
    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN100"><span class='Ref_to_Member'>waitStatus</span></a> <span class='Operator'>= </span><a href="../../../include/c.h.html#LN978"><span class='Ref_to_Const'>STATUS_WAITING</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we detected deadlock, give up without waiting.  This must agree with 
     * CheckDeadLock's recovery code, except that we shouldn't release the 
     * semaphore since we haven't tried to lock it yet. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN1036"><span class='Ref_To_Local'>early_deadlock</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/storage/lock.h.html#LN550"><span class='Ref_to_Proto'>RemoveFromWaitQueue</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN1032"><span class='Ref_To_Local'>hashcode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <a href="../../../include/c.h.html#LN975"><span class='Ref_to_Const'>STATUS_ERROR</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* mark that we are waiting for a lock */ 
</span>    <a href="proc.c.html#LN84"><span class='Ref_to_Global_Var'>lockAwaited</span></a> <span class='Operator'>= </span><a href="proc.c.html#LN1027"><span class='Ref_to_Parameter'>locallock</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Release the lock table's partition lock. 
     * 
     * NOTE: this may also cause us to exit critical-section state, possibly 
     * allowing a cancel/die interrupt to be accepted. This is OK because we 
     * have recorded the fact that we are waiting for a lock, and so 
     * LockErrorCleanup will clean up if cancel/die happens. 
     */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN1033"><span class='Ref_To_Local'>partitionLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Also, now that we will successfully clean up after an ereport, it's 
     * safe to check to see if there's a buffer pin deadlock against the 
     * Startup process.  Of course, that's only necessary if we're doing Hot 
     * Standby and are not the Startup process ourselves. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN242"><span class='Ref_to_Proto'>RecoveryInProgress</span></a><span class='Parentheses'>() </span><span class='Operator'>&& !</span><a href="../../access/transam/xlog.c.html#LN191"><span class='Ref_to_Global_Var'>InRecovery</span></a><span class='Parentheses'>)</span> 
        <a href="../../../include/storage/standby.h.html#LN36"><span class='Ref_to_Proto'>CheckRecoveryConflictDeadlock</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Reset deadlock_state before enabling the timeout handler */ 
</span>    <a href="proc.c.html#LN86"><span class='Ref_to_Global_Var'>deadlock_state</span></a> <span class='Operator'>= </span><a href="../../../include/storage/lock.h.html#LN481"><span class='Ref_to_EnumConst'>DS_NOT_YET_CHECKED</span></a><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN89"><span class='Ref_to_Global_Var'>got_deadlock_timeout</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Set timer so we can wake up after awhile and check for a deadlock. If a 
     * deadlock is detected, the handler releases the process's semaphore and 
     * sets MyProc-&GT;waitStatus = STATUS_ERROR, allowing us to know that we 
     * must report failure rather than success. 
     * 
     * By delaying the check until we've waited for a bit, we can avoid 
     * running the rather expensive deadlock-check code in most cases. 
     * 
     * If LockTimeout is set, also enable the timeout for that.  We can save a 
     * few cycles by enabling both timeout sources in one call. 
     * 
     * If InHotStandby we set lock waits slightly later for clarity with other 
     * code. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/xlog.h.html#LN73"><span class='Ref_to_Const'>InHotStandby</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN61"><span class='Ref_to_Global_Var'>LockTimeout</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1217"></a>            <a href="../../../include/utils/timeout.h.html#LN51"><span class='Ref_to_Typedef'>EnableTimeoutParams</span></a> <span class='Declare_Local'>timeouts</span><span class='Delimiter'>[</span><span class='Number'>2</span><span class='Delimiter'>]; 
</span> 
            <a href="proc.c.html#LN1217"><span class='Ref_To_Local'>timeouts</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/utils/timeout.h.html#LN53"><span class='Ref_to_Member'>id</span></a> <span class='Operator'>= </span><a href="../../../include/utils/timeout.h.html#LN26"><span class='Ref_to_EnumConst'>DEADLOCK_TIMEOUT</span></a><span class='Delimiter'>; 
</span>            <a href="proc.c.html#LN1217"><span class='Ref_To_Local'>timeouts</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/utils/timeout.h.html#LN54"><span class='Ref_to_Member'>type</span></a> <span class='Operator'>= </span><a href="../../../include/utils/timeout.h.html#LN47"><span class='Ref_to_EnumConst'>TMPARAM_AFTER</span></a><span class='Delimiter'>; 
</span>            <a href="proc.c.html#LN1217"><span class='Ref_To_Local'>timeouts</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/utils/timeout.h.html#LN55"><span class='Ref_to_Member'>delay_ms</span></a> <span class='Operator'>= </span><a href="proc.c.html#LN59"><span class='Ref_to_Global_Var'>DeadlockTimeout</span></a><span class='Delimiter'>; 
</span>            <a href="proc.c.html#LN1217"><span class='Ref_To_Local'>timeouts</span></a><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/utils/timeout.h.html#LN53"><span class='Ref_to_Member'>id</span></a> <span class='Operator'>= </span><a href="../../../include/utils/timeout.h.html#LN27"><span class='Ref_to_EnumConst'>LOCK_TIMEOUT</span></a><span class='Delimiter'>; 
</span>            <a href="proc.c.html#LN1217"><span class='Ref_To_Local'>timeouts</span></a><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/utils/timeout.h.html#LN54"><span class='Ref_to_Member'>type</span></a> <span class='Operator'>= </span><a href="../../../include/utils/timeout.h.html#LN47"><span class='Ref_to_EnumConst'>TMPARAM_AFTER</span></a><span class='Delimiter'>; 
</span>            <a href="proc.c.html#LN1217"><span class='Ref_To_Local'>timeouts</span></a><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/utils/timeout.h.html#LN55"><span class='Ref_to_Member'>delay_ms</span></a> <span class='Operator'>= </span><a href="proc.c.html#LN61"><span class='Ref_to_Global_Var'>LockTimeout</span></a><span class='Delimiter'>; 
</span>            <a href="../../../include/utils/timeout.h.html#LN76"><span class='Ref_to_Proto'>enable_timeouts</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN1217"><span class='Ref_To_Local'>timeouts</span></a><span class='Delimiter'>, </span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <a href="../../../include/utils/timeout.h.html#LN74"><span class='Ref_to_Proto'>enable_timeout_after</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/timeout.h.html#LN26"><span class='Ref_to_EnumConst'>DEADLOCK_TIMEOUT</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN59"><span class='Ref_to_Global_Var'>DeadlockTimeout</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If somebody wakes us between LWLockRelease and WaitLatch, the latch 
     * will not wait. But a set latch does not necessarily mean that the lock 
     * is free now, as there are many other sources for latch sets than 
     * somebody releasing the lock. 
     * 
     * We process interrupts whenever the latch has been set, so cancel/die 
     * interrupts are processed quickly. This means we must not mind losing 
     * control to a cancel/die interrupt here.  We don't, because we have no 
     * shared-state-change work to do after being granted the lock (the 
     * grantor did it all).  We do have to worry about canceling the deadlock 
     * timeout and updating the locallock table, but if we lose control to an 
     * error, LockErrorCleanup will fix that up. 
     */ 
</span>    <span class='Control'>do</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN73"><span class='Ref_to_Const'>InHotStandby</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Set a timer and wait for that or for the Lock to be granted */ 
</span>            <a href="../../../include/storage/standby.h.html#LN34"><span class='Ref_to_Proto'>ResolveRecoveryConflictWithLock</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN1027"><span class='Ref_to_Parameter'>locallock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN404"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/lock.h.html#LN385"><span class='Ref_to_Member'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../../include/storage/latch.h.html#LN163"><span class='Ref_to_Proto'>WaitLatch</span></a><span class='Parentheses'>(</span><a href="../../utils/init/globals.c.html#LN51"><span class='Ref_to_Global_Var'>MyLatch</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/latch.h.html#LN123"><span class='Ref_to_Const'>WL_LATCH_SET</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, 
</span>                      <a href="../../../include/pgstat.h.html#LN737"><span class='Ref_to_Const'>PG_WAIT_LOCK</span></a> <span class='Operator'>| </span><a href="proc.c.html#LN1027"><span class='Ref_to_Parameter'>locallock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN404"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/lock.h.html#LN385"><span class='Ref_to_Member'>lock</span></a><span class='Operator'>.</span><a href="../../../include/storage/lock.h.html#LN184"><span class='Ref_to_Member'>locktag_type</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/storage/latch.h.html#LN152"><span class='Ref_to_Proto'>ResetLatch</span></a><span class='Parentheses'>(</span><a href="../../utils/init/globals.c.html#LN51"><span class='Ref_to_Global_Var'>MyLatch</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* check for deadlocks first, as that's probably log-worthy */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN89"><span class='Ref_to_Global_Var'>got_deadlock_timeout</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="proc.c.html#LN94"><span class='Ref_to_Proto'>CheckDeadLock</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>                <a href="proc.c.html#LN89"><span class='Ref_to_Global_Var'>got_deadlock_timeout</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <a href="../../../include/miscadmin.h.html#LN99"><span class='Ref_to_Macro'>CHECK_FOR_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * waitStatus could change from STATUS_WAITING to something else 
         * asynchronously.  Read it just once per loop to prevent surprising 
         * behavior (such as missing log messages). 
         */ 
</span>        <a href="proc.c.html#LN1038"><span class='Ref_To_Local'>myWaitStatus</span></a> <span class='Operator'>= *</span><span class='Parentheses'>((</span><span class='Keyword'>volatile int </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN100"><span class='Ref_to_Member'>waitStatus</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If we are not deadlocked, but are waiting on an autovacuum-induced 
         * task, send a signal to interrupt it. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN86"><span class='Ref_to_Global_Var'>deadlock_state</span></a> <span class='Operator'>== </span><a href="../../../include/storage/lock.h.html#LN485"><span class='Ref_to_EnumConst'>DS_BLOCKED_BY_AUTOVACUUM</span></a> <span class='Operator'>&& </span><a href="proc.c.html#LN1037"><span class='Ref_To_Local'>allow_autovacuum_cancel</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1279"></a>            <a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>autovac</span> <span class='Operator'>= </span><a href="deadlock.c.html#LN291"><span class='Ref_to_Func'>GetBlockingAutoVacuumPgproc</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span><a name="LN1280"></a>            <a href="../../../include/storage/proc.h.html#LN206"><span class='Ref_to_Struct'>PGXACT</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>autovac_pgxact</span> <span class='Operator'>= &</span><a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN233"><span class='Ref_to_Member'>allPgXact</span></a><span class='Delimiter'>[</span><a href="proc.c.html#LN1279"><span class='Ref_To_Local'>autovac</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN108"><span class='Ref_to_Member'>pgprocno</span></a><span class='Delimiter'>]; 
</span> 
            <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Only do it if the worker is not working to protect against Xid 
             * wraparound. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="proc.c.html#LN1280"><span class='Ref_To_Local'>autovac_pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN217"><span class='Ref_to_Member'>vacuumFlags</span></a> <span class='Operator'>& </span><a href="../../../include/storage/proc.h.html#LN51"><span class='Ref_to_Const'>PROC_IS_AUTOVACUUM</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                <span class='Operator'>!</span><span class='Parentheses'>(</span><a href="proc.c.html#LN1280"><span class='Ref_To_Local'>autovac_pgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN217"><span class='Ref_to_Member'>vacuumFlags</span></a> <span class='Operator'>& </span><a href="../../../include/storage/proc.h.html#LN54"><span class='Ref_to_Const'>PROC_VACUUM_FOR_WRAPAROUND</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span><a name="LN1291"></a>                <span class='Keyword'>int</span>         <span class='Declare_Local'>pid</span> <span class='Operator'>= </span><a href="proc.c.html#LN1279"><span class='Ref_To_Local'>autovac</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN107"><span class='Ref_to_Member'>pid</span></a><span class='Delimiter'>; 
</span><a name="LN1292"></a>                <a href="../../../include/lib/stringinfo.h.html#LN34"><span class='Ref_to_Struct'>StringInfoData</span></a> <span class='Declare_Local'>locktagbuf</span><span class='Delimiter'>; 
</span><a name="LN1293"></a>                <a href="../../../include/lib/stringinfo.h.html#LN34"><span class='Ref_to_Struct'>StringInfoData</span></a> <span class='Declare_Local'>logbuf</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* errdetail for server log */ 
</span> 
                <a href="../../lib/stringinfo.c.html#LN44"><span class='Ref_to_Func'>initStringInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="proc.c.html#LN1292"><span class='Ref_To_Local'>locktagbuf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../lib/stringinfo.c.html#LN44"><span class='Ref_to_Func'>initStringInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="proc.c.html#LN1293"><span class='Ref_To_Local'>logbuf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../include/storage/lmgr.h.html#LN104"><span class='Ref_to_Proto'>DescribeLockTag</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="proc.c.html#LN1292"><span class='Ref_To_Local'>locktagbuf</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="proc.c.html#LN1030"><span class='Ref_To_Local'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN287"><span class='Ref_to_Member'>tag</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../bin/pg_waldump/compat.c.html#LN69"><span class='Ref_to_Func'>appendStringInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="proc.c.html#LN1293"><span class='Ref_To_Local'>logbuf</span></a><span class='Delimiter'>, 
</span>                                 _<span class='Parentheses'>(</span><span class='String'>"Process %d waits for %s on %s."</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                 <a href="../../utils/init/globals.c.html#LN38"><span class='Ref_to_Global_Var'>MyProcPid</span></a><span class='Delimiter'>, 
</span>                              <a href="../../../include/storage/lock.h.html#LN556"><span class='Ref_to_Proto'>GetLockmodeName</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN1030"><span class='Ref_To_Local'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN287"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span>locktag_lockmethodid<span class='Delimiter'>, 
</span>                                              <a href="proc.c.html#LN1029"><span class='Ref_To_Local'>lockmode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                 <a href="proc.c.html#LN1292"><span class='Ref_To_Local'>locktagbuf</span></a><span class='Operator'>.</span><a href="../../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* release lock as quickly as possible */ 
</span>                <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* send the autovacuum worker Back to Old Kent Road */ 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Delimiter'>, 
</span>                      <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"sending cancel to blocking autovacuum PID %d"</span><span class='Delimiter'>, 
</span>                              <a href="proc.c.html#LN1291"><span class='Ref_To_Local'>pid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                       <a href="../../utils/error/elog.c.html#LN919"><span class='Ref_to_Func'>errdetail_log</span></a><span class='Parentheses'>(</span><span class='String'>"%s"</span><span class='Delimiter'>, </span><a href="proc.c.html#LN1293"><span class='Ref_To_Local'>logbuf</span></a><span class='Operator'>.</span><a href="../../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/port.h.html#LN210"><span class='Ref_to_Macro'>kill</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN1291"><span class='Ref_To_Local'>pid</span></a><span class='Delimiter'>, </span>SIGINT<span class='Parentheses'>) </span><span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* 
                     * There's a race condition here: once we release the 
                     * ProcArrayLock, it's possible for the autovac worker to 
                     * close up shop and exit before we can do the kill(). 
                     * Therefore, we do not whinge about no-such-process. 
                     * Other errors such as EPERM could conceivably happen if 
                     * the kernel recycles the PID fast enough, but such cases 
                     * seem improbable enough that it's probably best to issue 
                     * a warning if we see some other errno. 
                     */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span>errno <span class='Operator'>!= </span>ESRCH<span class='Parentheses'>) 
</span>                        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN39"><span class='Ref_to_Const'>WARNING</span></a><span class='Delimiter'>, 
</span>                           <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not send signal to process %d: %m"</span><span class='Delimiter'>, 
</span>                                   <a href="proc.c.html#LN1291"><span class='Ref_To_Local'>pid</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
                <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN1293"><span class='Ref_To_Local'>logbuf</span></a><span class='Operator'>.</span><a href="../../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN1292"><span class='Ref_To_Local'>locktagbuf</span></a><span class='Operator'>.</span><a href="../../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if (autovac_pgxact-&GT;vacu... &raquo; </span> 
            <span class='Control'>else</span> 
                <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* prevent signal from being resent more than once */ 
</span>            <a href="proc.c.html#LN1037"><span class='Ref_To_Local'>allow_autovacuum_cancel</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if deadlock_state==DS_BL... &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* 
         * If awoken after the deadlock check interrupt has run, and 
         * log_lock_waits is on, then report about the wait. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN63"><span class='Ref_to_Global_Var'>log_lock_waits</span></a> <span class='Operator'>&& </span><a href="proc.c.html#LN86"><span class='Ref_to_Global_Var'>deadlock_state</span></a> <span class='Operator'>!= </span><a href="../../../include/storage/lock.h.html#LN481"><span class='Ref_to_EnumConst'>DS_NOT_YET_CHECKED</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1348"></a>            <a href="../../../include/lib/stringinfo.h.html#LN34"><span class='Ref_to_Struct'>StringInfoData</span></a> <span class='Declare_Local'>buf</span><span class='Delimiter'>, 
</span><a name="LN1349"></a>                        <span class='Declare_Local'>lock_waiters_sbuf</span><span class='Delimiter'>, 
</span><a name="LN1350"></a>                        <span class='Declare_Local'>lock_holders_sbuf</span><span class='Delimiter'>; 
</span><a name="LN1351"></a>            <span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Local'>modename</span><span class='Delimiter'>; 
</span><a name="LN1352"></a>            <span class='Keyword'>long</span>        <span class='Declare_Local'>secs</span><span class='Delimiter'>; 
</span><a name="LN1353"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>usecs</span><span class='Delimiter'>; 
</span><a name="LN1354"></a>            <span class='Keyword'>long</span>        <span class='Declare_Local'>msecs</span><span class='Delimiter'>; 
</span><a name="LN1355"></a>            <a href="../../../include/storage/shmem.h.html#LN27"><span class='Ref_to_Struct'>SHM_QUEUE</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>procLocks</span><span class='Delimiter'>; 
</span><a name="LN1356"></a>            <a href="../../../include/storage/lock.h.html#LN344"><span class='Ref_to_Struct'>PROCLOCK</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>proclock</span><span class='Delimiter'>; 
</span><a name="LN1357"></a>            <span class='Keyword'>bool</span>        <span class='Declare_Local'>first_holder</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>, 
</span><a name="LN1358"></a>                        <span class='Declare_Local'>first_waiter</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span><a name="LN1359"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>lockHoldersNum</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
            <a href="../../lib/stringinfo.c.html#LN44"><span class='Ref_to_Func'>initStringInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="proc.c.html#LN1348"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../lib/stringinfo.c.html#LN44"><span class='Ref_to_Func'>initStringInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="proc.c.html#LN1349"><span class='Ref_To_Local'>lock_waiters_sbuf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../lib/stringinfo.c.html#LN44"><span class='Ref_to_Func'>initStringInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="proc.c.html#LN1350"><span class='Ref_To_Local'>lock_holders_sbuf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/storage/lmgr.h.html#LN104"><span class='Ref_to_Proto'>DescribeLockTag</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="proc.c.html#LN1348"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="proc.c.html#LN1027"><span class='Ref_to_Parameter'>locallock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN404"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/lock.h.html#LN385"><span class='Ref_to_Member'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="proc.c.html#LN1351"><span class='Ref_To_Local'>modename</span></a> <span class='Operator'>= </span><a href="../../../include/storage/lock.h.html#LN556"><span class='Ref_to_Proto'>GetLockmodeName</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN1027"><span class='Ref_to_Parameter'>locallock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN404"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span><a href="../../../include/storage/lock.h.html#LN385"><span class='Ref_to_Member'>lock</span></a><span class='Operator'>.</span><a href="../../../include/storage/lock.h.html#LN185"><span class='Ref_to_Member'>locktag_lockmethodid</span></a><span class='Delimiter'>, 
</span>                                       <a href="proc.c.html#LN1029"><span class='Ref_To_Local'>lockmode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/utils/timestamp.h.html#LN72"><span class='Ref_to_Proto'>TimestampDifference</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/timeout.h.html#LN83"><span class='Ref_to_Proto'>get_timeout_start_time</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/timeout.h.html#LN26"><span class='Ref_to_EnumConst'>DEADLOCK_TIMEOUT</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                <a href="../../../include/utils/timestamp.h.html#LN69"><span class='Ref_to_Proto'>GetCurrentTimestamp</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                                <span class='Operator'>&</span><a href="proc.c.html#LN1352"><span class='Ref_To_Local'>secs</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="proc.c.html#LN1353"><span class='Ref_To_Local'>usecs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="proc.c.html#LN1354"><span class='Ref_To_Local'>msecs</span></a> <span class='Operator'>= </span><a href="proc.c.html#LN1352"><span class='Ref_To_Local'>secs</span></a> <span class='Operator'>* </span><span class='Number'>1000</span> <span class='Operator'>+ </span><a href="proc.c.html#LN1353"><span class='Ref_To_Local'>usecs</span></a> <span class='Operator'>/ </span><span class='Number'>1000</span><span class='Delimiter'>; 
</span>            <a href="proc.c.html#LN1353"><span class='Ref_To_Local'>usecs</span></a> <span class='Operator'>= </span><a href="proc.c.html#LN1353"><span class='Ref_To_Local'>usecs</span></a> <span class='Operator'>% </span><span class='Number'>1000</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * we loop over the lock's procLocks to gather a list of all 
             * holders and waiters. Thus we will be able to provide more 
             * detailed information for lock debugging purposes. 
             * 
             * lock-&GT;procLocks contains all processes which hold or wait for 
             * this lock. 
             */ 
</span> 
            <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN1033"><span class='Ref_To_Local'>partitionLock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="proc.c.html#LN1355"><span class='Ref_To_Local'>procLocks</span></a> <span class='Operator'>= &</span><span class='Parentheses'>(</span><a href="proc.c.html#LN1030"><span class='Ref_To_Local'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN292"><span class='Ref_to_Member'>procLocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="proc.c.html#LN1356"><span class='Ref_To_Local'>proclock</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/lock.h.html#LN344"><span class='Ref_to_Struct'>PROCLOCK</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN1355"><span class='Ref_To_Local'>procLocks</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN1355"><span class='Ref_To_Local'>procLocks</span></a><span class='Delimiter'>, 
</span>                                               <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/lock.h.html#LN344"><span class='Ref_to_Struct'>PROCLOCK</span></a><span class='Delimiter'>, </span>lockLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN1356"><span class='Ref_To_Local'>proclock</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * we are a waiter if myProc-&GT;waitProcLock == proclock; we are 
                 * a holder if it is NULL or something different 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN1356"><span class='Ref_To_Local'>proclock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN347"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span>myProc<span class='Operator'>-&GT;</span>waitProcLock <span class='Operator'>== </span><a href="proc.c.html#LN1356"><span class='Ref_To_Local'>proclock</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN1358"><span class='Ref_To_Local'>first_waiter</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <a href="../../../bin/pg_waldump/compat.c.html#LN69"><span class='Ref_to_Func'>appendStringInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="proc.c.html#LN1349"><span class='Ref_To_Local'>lock_waiters_sbuf</span></a><span class='Delimiter'>, </span><span class='String'>"%d"</span><span class='Delimiter'>, 
</span>                                         <a href="proc.c.html#LN1356"><span class='Ref_To_Local'>proclock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN347"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span>myProc<span class='Operator'>-&GT;</span>pid<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <a href="proc.c.html#LN1358"><span class='Ref_To_Local'>first_waiter</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <span class='Control'>else</span> 
                        <a href="../../../bin/pg_waldump/compat.c.html#LN69"><span class='Ref_to_Func'>appendStringInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="proc.c.html#LN1349"><span class='Ref_To_Local'>lock_waiters_sbuf</span></a><span class='Delimiter'>, </span><span class='String'>", %d"</span><span class='Delimiter'>, 
</span>                                         <a href="proc.c.html#LN1356"><span class='Ref_To_Local'>proclock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN347"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span>myProc<span class='Operator'>-&GT;</span>pid<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>else</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN1357"><span class='Ref_To_Local'>first_holder</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <a href="../../../bin/pg_waldump/compat.c.html#LN69"><span class='Ref_to_Func'>appendStringInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="proc.c.html#LN1350"><span class='Ref_To_Local'>lock_holders_sbuf</span></a><span class='Delimiter'>, </span><span class='String'>"%d"</span><span class='Delimiter'>, 
</span>                                         <a href="proc.c.html#LN1356"><span class='Ref_To_Local'>proclock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN347"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span>myProc<span class='Operator'>-&GT;</span>pid<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <a href="proc.c.html#LN1357"><span class='Ref_To_Local'>first_holder</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <span class='Control'>else</span> 
                        <a href="../../../bin/pg_waldump/compat.c.html#LN69"><span class='Ref_to_Func'>appendStringInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="proc.c.html#LN1350"><span class='Ref_To_Local'>lock_holders_sbuf</span></a><span class='Delimiter'>, </span><span class='String'>", %d"</span><span class='Delimiter'>, 
</span>                                         <a href="proc.c.html#LN1356"><span class='Ref_To_Local'>proclock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN347"><span class='Ref_to_Member'>tag</span></a><span class='Operator'>.</span>myProc<span class='Operator'>-&GT;</span>pid<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <a href="proc.c.html#LN1359"><span class='Ref_To_Local'>lockHoldersNum</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
                <a href="proc.c.html#LN1356"><span class='Ref_To_Local'>proclock</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/lock.h.html#LN344"><span class='Ref_to_Struct'>PROCLOCK</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/storage/shmem.h.html#LN72"><span class='Ref_to_Proto'>SHMQueueNext</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN1355"><span class='Ref_To_Local'>procLocks</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="proc.c.html#LN1356"><span class='Ref_To_Local'>proclock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN353"><span class='Ref_to_Member'>lockLink</span></a><span class='Delimiter'>, 
</span>                                               <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/lock.h.html#LN344"><span class='Ref_to_Struct'>PROCLOCK</span></a><span class='Delimiter'>, </span>lockLink<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while proclock &raquo; </span> 
 
            <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN1033"><span class='Ref_To_Local'>partitionLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN86"><span class='Ref_to_Global_Var'>deadlock_state</span></a> <span class='Operator'>== </span><a href="../../../include/storage/lock.h.html#LN483"><span class='Ref_to_EnumConst'>DS_SOFT_DEADLOCK</span></a><span class='Parentheses'>) 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"process %d avoided deadlock for %s on %s by rearranging queue order after %ld.%03d ms"</span><span class='Delimiter'>, 
</span>                                <a href="../../utils/init/globals.c.html#LN38"><span class='Ref_to_Global_Var'>MyProcPid</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN1351"><span class='Ref_To_Local'>modename</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN1348"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>.</span><a href="../../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN1354"><span class='Ref_To_Local'>msecs</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN1353"><span class='Ref_To_Local'>usecs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN940"><span class='Ref_to_Func'>errdetail_log_plural</span></a><span class='Parentheses'>(</span><span class='String'>"Process holding the lock: %s. Wait queue: %s."</span><span class='Delimiter'>, 
</span>                           <span class='String'>"Processes holding the lock: %s. Wait queue: %s."</span><span class='Delimiter'>, 
</span>                                               <a href="proc.c.html#LN1359"><span class='Ref_To_Local'>lockHoldersNum</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN1350"><span class='Ref_To_Local'>lock_holders_sbuf</span></a><span class='Operator'>.</span><a href="../../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN1349"><span class='Ref_To_Local'>lock_waiters_sbuf</span></a><span class='Operator'>.</span><a href="../../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN86"><span class='Ref_to_Global_Var'>deadlock_state</span></a> <span class='Operator'>== </span><a href="../../../include/storage/lock.h.html#LN484"><span class='Ref_to_EnumConst'>DS_HARD_DEADLOCK</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * This message is a bit redundant with the error that will be 
                 * reported subsequently, but in some cases the error report 
                 * might not make it to the log (eg, if it's caught by an 
                 * exception handler), and we want to ensure all long-wait 
                 * events get logged. 
                 */ 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"process %d detected deadlock while waiting for %s on %s after %ld.%03d ms"</span><span class='Delimiter'>, 
</span>                                <a href="../../utils/init/globals.c.html#LN38"><span class='Ref_to_Global_Var'>MyProcPid</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN1351"><span class='Ref_To_Local'>modename</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN1348"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>.</span><a href="../../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN1354"><span class='Ref_To_Local'>msecs</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN1353"><span class='Ref_To_Local'>usecs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN940"><span class='Ref_to_Func'>errdetail_log_plural</span></a><span class='Parentheses'>(</span><span class='String'>"Process holding the lock: %s. Wait queue: %s."</span><span class='Delimiter'>, 
</span>                           <span class='String'>"Processes holding the lock: %s. Wait queue: %s."</span><span class='Delimiter'>, 
</span>                                               <a href="proc.c.html#LN1359"><span class='Ref_To_Local'>lockHoldersNum</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN1350"><span class='Ref_To_Local'>lock_holders_sbuf</span></a><span class='Operator'>.</span><a href="../../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN1349"><span class='Ref_To_Local'>lock_waiters_sbuf</span></a><span class='Operator'>.</span><a href="../../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN1038"><span class='Ref_To_Local'>myWaitStatus</span></a> <span class='Operator'>== </span><a href="../../../include/c.h.html#LN978"><span class='Ref_to_Const'>STATUS_WAITING</span></a><span class='Parentheses'>) 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"process %d still waiting for %s on %s after %ld.%03d ms"</span><span class='Delimiter'>, 
</span>                                <a href="../../utils/init/globals.c.html#LN38"><span class='Ref_to_Global_Var'>MyProcPid</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN1351"><span class='Ref_To_Local'>modename</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN1348"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>.</span><a href="../../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN1354"><span class='Ref_To_Local'>msecs</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN1353"><span class='Ref_To_Local'>usecs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN940"><span class='Ref_to_Func'>errdetail_log_plural</span></a><span class='Parentheses'>(</span><span class='String'>"Process holding the lock: %s. Wait queue: %s."</span><span class='Delimiter'>, 
</span>                           <span class='String'>"Processes holding the lock: %s. Wait queue: %s."</span><span class='Delimiter'>, 
</span>                                               <a href="proc.c.html#LN1359"><span class='Ref_To_Local'>lockHoldersNum</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN1350"><span class='Ref_To_Local'>lock_holders_sbuf</span></a><span class='Operator'>.</span><a href="../../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN1349"><span class='Ref_To_Local'>lock_waiters_sbuf</span></a><span class='Operator'>.</span><a href="../../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN1038"><span class='Ref_To_Local'>myWaitStatus</span></a> <span class='Operator'>== </span><a href="../../../include/c.h.html#LN974"><span class='Ref_to_Const'>STATUS_OK</span></a><span class='Parentheses'>) 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"process %d acquired %s on %s after %ld.%03d ms"</span><span class='Delimiter'>, 
</span>                            <a href="../../utils/init/globals.c.html#LN38"><span class='Ref_to_Global_Var'>MyProcPid</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN1351"><span class='Ref_To_Local'>modename</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN1348"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>.</span><a href="../../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN1354"><span class='Ref_To_Local'>msecs</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN1353"><span class='Ref_To_Local'>usecs</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="proc.c.html#LN1038"><span class='Ref_To_Local'>myWaitStatus</span></a> <span class='Operator'>== </span><a href="../../../include/c.h.html#LN975"><span class='Ref_to_Const'>STATUS_ERROR</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Currently, the deadlock checker always kicks its own 
                 * process, which means that we'll only see STATUS_ERROR when 
                 * deadlock_state == DS_HARD_DEADLOCK, and there's no need to 
                 * print redundant messages.  But for completeness and 
                 * future-proofing, print a message if it looks like someone 
                 * else kicked us off the lock. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN86"><span class='Ref_to_Global_Var'>deadlock_state</span></a> <span class='Operator'>!= </span><a href="../../../include/storage/lock.h.html#LN484"><span class='Ref_to_EnumConst'>DS_HARD_DEADLOCK</span></a><span class='Parentheses'>) 
</span>                    <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"process %d failed to acquire %s on %s after %ld.%03d ms"</span><span class='Delimiter'>, 
</span>                                <a href="../../utils/init/globals.c.html#LN38"><span class='Ref_to_Global_Var'>MyProcPid</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN1351"><span class='Ref_To_Local'>modename</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN1348"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>.</span><a href="../../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN1354"><span class='Ref_To_Local'>msecs</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN1353"><span class='Ref_To_Local'>usecs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN940"><span class='Ref_to_Func'>errdetail_log_plural</span></a><span class='Parentheses'>(</span><span class='String'>"Process holding the lock: %s. Wait queue: %s."</span><span class='Delimiter'>, 
</span>                           <span class='String'>"Processes holding the lock: %s. Wait queue: %s."</span><span class='Delimiter'>, 
</span>                                                   <a href="proc.c.html#LN1359"><span class='Ref_To_Local'>lockHoldersNum</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN1350"><span class='Ref_To_Local'>lock_holders_sbuf</span></a><span class='Operator'>.</span><a href="../../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN1349"><span class='Ref_To_Local'>lock_waiters_sbuf</span></a><span class='Operator'>.</span><a href="../../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
            <span class='Comment_Multi_Line'>/* 
             * At this point we might still need to wait for the lock. Reset 
             * state so we don't print the above messages again. 
             */ 
</span>            <a href="proc.c.html#LN86"><span class='Ref_to_Global_Var'>deadlock_state</span></a> <span class='Operator'>= </span><a href="../../../include/storage/lock.h.html#LN482"><span class='Ref_to_EnumConst'>DS_NO_DEADLOCK</span></a><span class='Delimiter'>; 
</span> 
            <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN1348"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>.</span><a href="../../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN1350"><span class='Ref_To_Local'>lock_holders_sbuf</span></a><span class='Operator'>.</span><a href="../../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN1349"><span class='Ref_To_Local'>lock_waiters_sbuf</span></a><span class='Operator'>.</span><a href="../../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if log_lock_waits&&deadl... &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end do &raquo; </span> <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN1038"><span class='Ref_To_Local'>myWaitStatus</span></a> <span class='Operator'>== </span><a href="../../../include/c.h.html#LN978"><span class='Ref_to_Const'>STATUS_WAITING</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Disable the timers, if they are still running.  As in LockErrorCleanup, 
     * we must preserve the LOCK_TIMEOUT indicator flag: if a lock timeout has 
     * already caused QueryCancelPending to become set, we want the cancel to 
     * be reported as a lock timeout, not a user cancel. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/xlog.h.html#LN73"><span class='Ref_to_Const'>InHotStandby</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN61"><span class='Ref_to_Global_Var'>LockTimeout</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1506"></a>            <a href="../../../include/utils/timeout.h.html#LN62"><span class='Ref_to_Typedef'>DisableTimeoutParams</span></a> <span class='Declare_Local'>timeouts</span><span class='Delimiter'>[</span><span class='Number'>2</span><span class='Delimiter'>]; 
</span> 
            <a href="proc.c.html#LN1506"><span class='Ref_To_Local'>timeouts</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/utils/timeout.h.html#LN64"><span class='Ref_to_Member'>id</span></a> <span class='Operator'>= </span><a href="../../../include/utils/timeout.h.html#LN26"><span class='Ref_to_EnumConst'>DEADLOCK_TIMEOUT</span></a><span class='Delimiter'>; 
</span>            <a href="proc.c.html#LN1506"><span class='Ref_To_Local'>timeouts</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/utils/timeout.h.html#LN65"><span class='Ref_to_Member'>keep_indicator</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="proc.c.html#LN1506"><span class='Ref_To_Local'>timeouts</span></a><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/utils/timeout.h.html#LN64"><span class='Ref_to_Member'>id</span></a> <span class='Operator'>= </span><a href="../../../include/utils/timeout.h.html#LN27"><span class='Ref_to_EnumConst'>LOCK_TIMEOUT</span></a><span class='Delimiter'>; 
</span>            <a href="proc.c.html#LN1506"><span class='Ref_To_Local'>timeouts</span></a><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/utils/timeout.h.html#LN65"><span class='Ref_to_Member'>keep_indicator</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="../../../include/utils/timeout.h.html#LN78"><span class='Ref_to_Proto'>disable_timeouts</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN1506"><span class='Ref_To_Local'>timeouts</span></a><span class='Delimiter'>, </span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <a href="../../../include/utils/timeout.h.html#LN77"><span class='Ref_to_Proto'>disable_timeout</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/timeout.h.html#LN26"><span class='Ref_to_EnumConst'>DEADLOCK_TIMEOUT</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Re-acquire the lock table's partition lock.  We have to do this to hold 
     * off cancel/die interrupts before we can mess with lockAwaited (else we 
     * might have a missed or duplicated locallock update). 
     */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN1033"><span class='Ref_To_Local'>partitionLock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We no longer want LockErrorCleanup to do anything. 
     */ 
</span>    <a href="proc.c.html#LN84"><span class='Ref_to_Global_Var'>lockAwaited</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we got the lock, be sure to remember it in the locallock table. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN100"><span class='Ref_to_Member'>waitStatus</span></a> <span class='Operator'>== </span><a href="../../../include/c.h.html#LN974"><span class='Ref_to_Const'>STATUS_OK</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/lock.h.html#LN549"><span class='Ref_to_Proto'>GrantAwaitedLock</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We don't have to do anything else, because the awaker did all the 
     * necessary update of the lock table and MyProc. 
     */ 
</span>    <span class='Control'>return</span> <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN100"><span class='Ref_to_Member'>waitStatus</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ProcSleep &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * ProcWakeup -- wake up a process by releasing its private semaphore. 
 * 
 *   Also remove the process from the wait queue and set its links invalid. 
 *   RETURN: the next process in the wait queue. 
 * 
 * The appropriate lock partition lock must be held by caller. 
 * 
 * XXX: presently, this code is only used for the "success" case, and only 
 * works correctly for that case.  To clean up in failure case, would need 
 * to twiddle the lock's request counts too --- see RemoveFromWaitQueue. 
 * Hence, in practice the waitStatus parameter must be STATUS_OK. 
 */ 
</span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>* 
</span><a name="LN1558"></a><span class='Declare_Function'>ProcWakeup</span><span class='Parentheses'>(</span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>proc</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>waitStatus</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1560"></a>    <a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>retProc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Proc should be sleeping ... */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN1558"><span class='Ref_to_Parameter'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN96"><span class='Ref_to_Member'>links</span></a><span class='Operator'>.</span><a href="../../../include/storage/shmem.h.html#LN29"><span class='Ref_to_Member'>prev</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| 
</span>        <a href="proc.c.html#LN1558"><span class='Ref_to_Parameter'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN96"><span class='Ref_to_Member'>links</span></a><span class='Operator'>.</span><a href="../../../include/storage/shmem.h.html#LN30"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="proc.c.html#LN1558"><span class='Ref_to_Parameter'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN100"><span class='Ref_to_Member'>waitStatus</span></a> <span class='Operator'>== </span><a href="../../../include/c.h.html#LN978"><span class='Ref_to_Const'>STATUS_WAITING</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Save next process before we zap the list link */ 
</span>    <a href="proc.c.html#LN1560"><span class='Ref_To_Local'>retProc</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="proc.c.html#LN1558"><span class='Ref_to_Parameter'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN96"><span class='Ref_to_Member'>links</span></a><span class='Operator'>.</span><a href="../../../include/storage/shmem.h.html#LN30"><span class='Ref_to_Member'>next</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Remove process from wait queue */ 
</span>    <a href="../ipc/shmqueue.c.html#LN66"><span class='Ref_to_Func'>SHMQueueDelete</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="proc.c.html#LN1558"><span class='Ref_to_Parameter'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN96"><span class='Ref_to_Member'>links</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Parentheses'>(</span><a href="proc.c.html#LN1558"><span class='Ref_to_Parameter'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN134"><span class='Ref_to_Member'>waitLock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN293"><span class='Ref_to_Member'>waitProcs</span></a><span class='Operator'>.</span><a href="../../../include/storage/lock.h.html#LN32"><span class='Ref_to_Member'>size</span></a><span class='Parentheses'>)</span><span class='Operator'>--</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Clean up process' state and pass it the ok/fail signal */ 
</span>    <a href="proc.c.html#LN1558"><span class='Ref_to_Parameter'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN134"><span class='Ref_to_Member'>waitLock</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN1558"><span class='Ref_to_Parameter'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN135"><span class='Ref_to_Member'>waitProcLock</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN1558"><span class='Ref_to_Parameter'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN100"><span class='Ref_to_Member'>waitStatus</span></a> <span class='Operator'>= </span><a href="proc.c.html#LN1558"><span class='Ref_to_Parameter'>waitStatus</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* And awaken it */ 
</span>    <a href="../../../include/storage/latch.h.html#LN151"><span class='Ref_to_Proto'>SetLatch</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="proc.c.html#LN1558"><span class='Ref_to_Parameter'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN102"><span class='Ref_to_Member'>procLatch</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="proc.c.html#LN1560"><span class='Ref_To_Local'>retProc</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ProcWakeup &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * ProcLockWakeup -- routine for waking up processes when a lock is 
 *      released (or a prior waiter is aborted).  Scan all waiters 
 *      for lock, waken any that are no longer blocked. 
 * 
 * The appropriate lock partition lock must be held by caller. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1594"></a><span class='Declare_Function'>ProcLockWakeup</span><span class='Parentheses'>(</span><a href="../../../include/storage/lock.h.html#LN119"><span class='Ref_to_Typedef'>LockMethod</span></a> <span class='Declare_Parameter'>lockMethodTable</span><span class='Delimiter'>, </span><a href="../../../include/storage/lock.h.html#LN284"><span class='Ref_to_Struct'>LOCK</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>lock</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1596"></a>    <a href="../../../include/storage/lock.h.html#LN29"><span class='Ref_to_Struct'>PROC_QUEUE</span></a> <span class='Operator'>*</span><span class='Declare_Local'>waitQueue</span> <span class='Operator'>= &</span><span class='Parentheses'>(</span><a href="proc.c.html#LN1594"><span class='Ref_to_Parameter'>lock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN293"><span class='Ref_to_Member'>waitProcs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1597"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>queue_size</span> <span class='Operator'>= </span><a href="proc.c.html#LN1596"><span class='Ref_To_Local'>waitQueue</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN32"><span class='Ref_to_Member'>size</span></a><span class='Delimiter'>; 
</span><a name="LN1598"></a>    <a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>proc</span><span class='Delimiter'>; 
</span><a name="LN1599"></a>    <a href="../../../include/storage/lockdefs.h.html#LN24"><span class='Ref_to_Typedef'>LOCKMASK</span></a>    <span class='Declare_Local'>aheadRequests</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="proc.c.html#LN1597"><span class='Ref_To_Local'>queue_size</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN1597"><span class='Ref_To_Local'>queue_size</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <a href="proc.c.html#LN1598"><span class='Ref_To_Local'>proc</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="proc.c.html#LN1596"><span class='Ref_To_Local'>waitQueue</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN31"><span class='Ref_to_Member'>links</span></a><span class='Operator'>.</span><a href="../../../include/storage/shmem.h.html#LN30"><span class='Ref_to_Member'>next</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN1597"><span class='Ref_To_Local'>queue_size</span></a><span class='Operator'>-- &GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1610"></a>        <a href="../../../include/storage/lockdefs.h.html#LN25"><span class='Ref_to_Typedef'>LOCKMODE</span></a>    <span class='Declare_Local'>lockmode</span> <span class='Operator'>= </span><a href="proc.c.html#LN1598"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN136"><span class='Ref_to_Member'>waitLockMode</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Waken if (a) doesn't conflict with requests of earlier waiters, and 
         * (b) doesn't conflict with already-held locks. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="proc.c.html#LN1594"><span class='Ref_to_Parameter'>lockMethodTable</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN114"><span class='Ref_to_Member'>conflictTab</span></a><span class='Delimiter'>[</span><a href="proc.c.html#LN1610"><span class='Ref_To_Local'>lockmode</span></a><span class='Delimiter'>] </span><span class='Operator'>& </span><a href="proc.c.html#LN1599"><span class='Ref_To_Local'>aheadRequests</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>&& 
</span>            <a href="../../../include/storage/lock.h.html#LN545"><span class='Ref_to_Proto'>LockCheckConflicts</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN1594"><span class='Ref_to_Parameter'>lockMethodTable</span></a><span class='Delimiter'>, 
</span>                               <a href="proc.c.html#LN1610"><span class='Ref_To_Local'>lockmode</span></a><span class='Delimiter'>, 
</span>                               <a href="proc.c.html#LN1594"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>, 
</span>                               <a href="proc.c.html#LN1598"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN135"><span class='Ref_to_Member'>waitProcLock</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="../../../include/c.h.html#LN974"><span class='Ref_to_Const'>STATUS_OK</span></a><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* OK to waken */ 
</span>            <a href="../../../include/storage/lock.h.html#LN548"><span class='Ref_to_Proto'>GrantLock</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN1594"><span class='Ref_to_Parameter'>lock</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN1598"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN135"><span class='Ref_to_Member'>waitProcLock</span></a><span class='Delimiter'>, </span><a href="proc.c.html#LN1610"><span class='Ref_To_Local'>lockmode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="proc.c.html#LN1598"><span class='Ref_To_Local'>proc</span></a> <span class='Operator'>= </span><a href="../../../include/storage/proc.h.html#LN301"><span class='Ref_to_Proto'>ProcWakeup</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN1598"><span class='Ref_To_Local'>proc</span></a><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN974"><span class='Ref_to_Const'>STATUS_OK</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * ProcWakeup removes proc from the lock's waiting process queue 
             * and returns the next proc in chain; don't use proc's next-link, 
             * because it's been cleared. 
             */ 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Cannot wake this guy. Remember his request for later checks. 
             */ 
</span>            <a href="proc.c.html#LN1599"><span class='Ref_To_Local'>aheadRequests</span></a> <span class='Operator'>|= </span><a href="../../../include/storage/lock.h.html#LN87"><span class='Ref_to_Macro'>LOCKBIT_ON</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN1610"><span class='Ref_To_Local'>lockmode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="proc.c.html#LN1598"><span class='Ref_To_Local'>proc</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="proc.c.html#LN1598"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN96"><span class='Ref_to_Member'>links</span></a><span class='Operator'>.</span><a href="../../../include/storage/shmem.h.html#LN30"><span class='Ref_to_Member'>next</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while queue_size--&GT;0 &raquo; </span> 
 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="proc.c.html#LN1596"><span class='Ref_To_Local'>waitQueue</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN32"><span class='Ref_to_Member'>size</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ProcLockWakeup &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * CheckDeadLock 
 * 
 * We only get to this routine, if DEADLOCK_TIMEOUT fired while waiting for a 
 * lock to be released by some other process.  Check if there's a deadlock; if 
 * not, just return.  (But signal ProcSleep to log a message, if 
 * log_lock_waits is true.)  If we have a real deadlock, remove ourselves from 
 * the lock's wait queue and signal an error to ProcSleep. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1655"></a><span class='Declare_Function'>CheckDeadLock</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1657"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Acquire exclusive lock on the entire shared lock data structures. Must 
     * grab LWLocks in partition-number order to avoid LWLock deadlock. 
     * 
     * Note that the deadlock check interrupt had better not be enabled 
     * anywhere that this process itself holds lock partition locks, else this 
     * will wait forever.  Also note that LWLockAcquire creates a critical 
     * section, so that this routine cannot be interrupted by cancel/die 
     * interrupts. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN1657"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="proc.c.html#LN1657"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="../../../include/storage/lwlock.h.html#LN116"><span class='Ref_to_Const'>NUM_LOCK_PARTITIONS</span></a><span class='Delimiter'>; </span><a href="proc.c.html#LN1657"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/lock.h.html#LN500"><span class='Ref_to_Macro'>LockHashPartitionLockByIndex</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN1657"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Check to see if we've been awoken by anyone in the interim. 
     * 
     * If we have, we can return and resume our transaction -- happy day. 
     * Before we are awoken the process releasing the lock grants it to us so 
     * we know that we don't have to wait anymore. 
     * 
     * We check by looking to see if we've been unlinked from the wait queue. 
     * This is quicker than checking our semaphore's state, since no kernel 
     * call is needed, and it is safe because we hold the lock partition lock. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN96"><span class='Ref_to_Member'>links</span></a><span class='Operator'>.</span><a href="../../../include/storage/shmem.h.html#LN29"><span class='Ref_to_Member'>prev</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| 
</span>        <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN96"><span class='Ref_to_Member'>links</span></a><span class='Operator'>.</span><a href="../../../include/storage/shmem.h.html#LN30"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="proc.c.html#LN1731"><span class='Ref_to_Label'>check_done</span></a><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> LOCK_DEBUG 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="lock.c.html#LN286"><span class='Ref_to_Global_Var'>Debug_deadlocks</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/lock.h.html#LN580"><span class='Ref_to_Proto'>DumpAllLocks</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
    <span class='Comment_Multi_Line'>/* Run the deadlock check, and set deadlock_state for use by ProcSleep */ 
</span>    <a href="proc.c.html#LN86"><span class='Ref_to_Global_Var'>deadlock_state</span></a> <span class='Operator'>= </span><a href="deadlock.c.html#LN215"><span class='Ref_to_Func'>DeadLockCheck</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN86"><span class='Ref_to_Global_Var'>deadlock_state</span></a> <span class='Operator'>== </span><a href="../../../include/storage/lock.h.html#LN484"><span class='Ref_to_EnumConst'>DS_HARD_DEADLOCK</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Oops.  We have a deadlock. 
         * 
         * Get this process out of wait state. (Note: we could do this more 
         * efficiently by relying on lockAwaited, but use this coding to 
         * preserve the flexibility to kill some other transaction than the 
         * one detecting the deadlock.) 
         * 
         * RemoveFromWaitQueue sets MyProc-&GT;waitStatus to STATUS_ERROR, so 
         * ProcSleep will report an error after we return from the signal 
         * handler. 
         */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN134"><span class='Ref_to_Member'>waitLock</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lock.h.html#LN550"><span class='Ref_to_Proto'>RemoveFromWaitQueue</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Delimiter'>, </span><a href="lock.c.html#LN488"><span class='Ref_to_Func'>LockTagHashCode</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN134"><span class='Ref_to_Member'>waitLock</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/lock.h.html#LN287"><span class='Ref_to_Member'>tag</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We're done here.  Transaction abort caused by the error that 
         * ProcSleep will raise will cause any other locks we hold to be 
         * released, thus allowing other processes to wake up; we don't need 
         * to do that here.  NOTE: an exception is that releasing locks we 
         * hold doesn't consider the possibility of waiters that were blocked 
         * behind us on the lock we just failed to get, and might now be 
         * wakable because we're not in front of them anymore.  However, 
         * RemoveFromWaitQueue took care of waking up any such processes. 
         */ 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if deadlock_state==DS_HA... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * And release locks.  We do this in reverse order for two reasons: (1) 
     * Anyone else who needs more than one of the locks will be trying to lock 
     * them in increasing order; we don't want to release the other process 
     * until it can get all the locks it needs. (2) This avoids O(N^2) 
     * behavior inside LWLockRelease. 
     */ 
</span><a name="LN1731"></a><span class='Label'>check_done</span><span class='Operator'>: 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN1657"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><a href="../../../include/storage/lwlock.h.html#LN116"><span class='Ref_to_Const'>NUM_LOCK_PARTITIONS</span></a><span class='Delimiter'>; </span><span class='Operator'>--</span><a href="proc.c.html#LN1657"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Delimiter'>;</span><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/lock.h.html#LN500"><span class='Ref_to_Macro'>LockHashPartitionLockByIndex</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN1657"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end CheckDeadLock &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * CheckDeadLockAlert - Handle the expiry of deadlock_timeout. 
 * 
 * NB: Runs inside a signal handler, be careful. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1742"></a><span class='Declare_Function'>CheckDeadLockAlert</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1744"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>save_errno</span> <span class='Operator'>= </span>errno<span class='Delimiter'>; 
</span> 
    <a href="proc.c.html#LN89"><span class='Ref_to_Global_Var'>got_deadlock_timeout</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Have to set the latch again, even if handle_sig_alarm already did. Back 
     * then got_deadlock_timeout wasn't yet set... It's unlikely that this 
     * ever would be a problem, but setting a set latch again is cheap. 
     */ 
</span>    <a href="../../../include/storage/latch.h.html#LN151"><span class='Ref_to_Proto'>SetLatch</span></a><span class='Parentheses'>(</span><a href="../../utils/init/globals.c.html#LN51"><span class='Ref_to_Global_Var'>MyLatch</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    errno <span class='Operator'>= </span><a href="proc.c.html#LN1744"><span class='Ref_To_Local'>save_errno</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * ProcWaitForSignal - wait for a signal from another backend. 
 * 
 * As this uses the generic process latch the caller has to be robust against 
 * unrelated wakeups: Always check that the desired state has occurred, and 
 * wait again if not. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1765"></a><span class='Declare_Function'>ProcWaitForSignal</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Parameter'>wait_event_info</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/storage/latch.h.html#LN163"><span class='Ref_to_Proto'>WaitLatch</span></a><span class='Parentheses'>(</span><a href="../../utils/init/globals.c.html#LN51"><span class='Ref_to_Global_Var'>MyLatch</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/latch.h.html#LN123"><span class='Ref_to_Const'>WL_LATCH_SET</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><a href="proc.c.html#LN1765"><span class='Ref_to_Parameter'>wait_event_info</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/latch.h.html#LN152"><span class='Ref_to_Proto'>ResetLatch</span></a><span class='Parentheses'>(</span><a href="../../utils/init/globals.c.html#LN51"><span class='Ref_to_Global_Var'>MyLatch</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/miscadmin.h.html#LN99"><span class='Ref_to_Macro'>CHECK_FOR_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * ProcSendSignal - send a signal to a backend identified by PID 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1776"></a><span class='Declare_Function'>ProcSendSignal</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>pid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1778"></a>    <a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>proc</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN242"><span class='Ref_to_Proto'>RecoveryInProgress</span></a><span class='Parentheses'>())</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN76"><span class='Ref_to_Global_Var'>ProcStructLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Check to see whether it is the Startup process we wish to signal. 
         * This call is made by the buffer manager when it wishes to wake up a 
         * process that has been waiting for a pin in so it can obtain a 
         * cleanup lock using LockBufferForCleanup(). Startup is not a normal 
         * backend, so BackendPidGetProc() will not return any pid at all. So 
         * we remember the information for this special case. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN1776"><span class='Ref_to_Parameter'>pid</span></a> <span class='Operator'>== </span><a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN252"><span class='Ref_to_Member'>startupProcPid</span></a><span class='Parentheses'>) 
</span>            <a href="proc.c.html#LN1778"><span class='Ref_To_Local'>proc</span></a> <span class='Operator'>= </span><a href="proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN251"><span class='Ref_to_Member'>startupProc</span></a><span class='Delimiter'>; 
</span> 
        <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN76"><span class='Ref_to_Global_Var'>ProcStructLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN1778"><span class='Ref_To_Local'>proc</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="proc.c.html#LN1778"><span class='Ref_To_Local'>proc</span></a> <span class='Operator'>= </span><a href="../../../include/storage/procarray.h.html#LN98"><span class='Ref_to_Proto'>BackendPidGetProc</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN1776"><span class='Ref_to_Parameter'>pid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN1778"><span class='Ref_To_Local'>proc</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/storage/latch.h.html#LN151"><span class='Ref_to_Proto'>SetLatch</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="proc.c.html#LN1778"><span class='Ref_To_Local'>proc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN102"><span class='Ref_to_Member'>procLatch</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end ProcSendSignal &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * BecomeLockGroupLeader - designate process as lock group leader 
 * 
 * Once this function has returned, other processes can join the lock group 
 * by calling BecomeLockGroupMember. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1814"></a><span class='Declare_Function'>BecomeLockGroupLeader</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1816"></a>    <a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>leader_lwlock</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If we already did it, we don't need to do it again. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN187"><span class='Ref_to_Member'>lockGroupLeader</span></a> <span class='Operator'>== </span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* We had better not be a follower. */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN187"><span class='Ref_to_Member'>lockGroupLeader</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Create single-member group, containing only ourselves. */ 
</span>    <a href="proc.c.html#LN1816"><span class='Ref_To_Local'>leader_lwlock</span></a> <span class='Operator'>= </span><a href="../../../include/storage/lock.h.html#LN512"><span class='Ref_to_Macro'>LockHashPartitionLockByProc</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN1816"><span class='Ref_To_Local'>leader_lwlock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN187"><span class='Ref_to_Member'>lockGroupLeader</span></a> <span class='Operator'>= </span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/lib/ilist.h.html#LN298"><span class='Ref_to_Func'>dlist_push_head</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN188"><span class='Ref_to_Member'>lockGroupMembers</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN189"><span class='Ref_to_Member'>lockGroupLink</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN1816"><span class='Ref_To_Local'>leader_lwlock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * BecomeLockGroupMember - designate process as lock group member 
 * 
 * This is pretty straightforward except for the possibility that the leader 
 * whose group we're trying to join might exit before we manage to do so; 
 * and the PGPROC might get recycled for an unrelated process.  To avoid 
 * that, we require the caller to pass the PID of the intended PGPROC as 
 * an interlock.  Returns true if we successfully join the intended lock 
 * group, and false if not. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN1844"></a><span class='Declare_Function'>BecomeLockGroupMember</span><span class='Parentheses'>(</span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>leader</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>pid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1846"></a>    <a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>leader_lwlock</span><span class='Delimiter'>; 
</span><a name="LN1847"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>ok</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Group leader can't become member of group */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a> <span class='Operator'>!= </span><a href="proc.c.html#LN1844"><span class='Ref_to_Parameter'>leader</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Can't already be a member of a group */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN187"><span class='Ref_to_Member'>lockGroupLeader</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* PID must be valid. */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="proc.c.html#LN1844"><span class='Ref_to_Parameter'>pid</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Get lock protecting the group fields.  Note LockHashPartitionLockByProc 
     * accesses leader-&GT;pgprocno in a PGPROC that might be free.  This is safe 
     * because all PGPROCs' pgprocno fields are set during shared memory 
     * initialization and never change thereafter; so we will acquire the 
     * correct lock even if the leader PGPROC is in process of being recycled. 
     */ 
</span>    <a href="proc.c.html#LN1846"><span class='Ref_To_Local'>leader_lwlock</span></a> <span class='Operator'>= </span><a href="../../../include/storage/lock.h.html#LN512"><span class='Ref_to_Macro'>LockHashPartitionLockByProc</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN1844"><span class='Ref_to_Parameter'>leader</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN1846"><span class='Ref_To_Local'>leader_lwlock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Is this the leader we're looking for? */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="proc.c.html#LN1844"><span class='Ref_to_Parameter'>leader</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN107"><span class='Ref_to_Member'>pid</span></a> <span class='Operator'>== </span><a href="proc.c.html#LN1844"><span class='Ref_to_Parameter'>pid</span></a> <span class='Operator'>&& </span><a href="proc.c.html#LN1844"><span class='Ref_to_Parameter'>leader</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN187"><span class='Ref_to_Member'>lockGroupLeader</span></a> <span class='Operator'>== </span><a href="proc.c.html#LN1844"><span class='Ref_to_Parameter'>leader</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* OK, join the group */ 
</span>        <a href="proc.c.html#LN1847"><span class='Ref_To_Local'>ok</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN187"><span class='Ref_to_Member'>lockGroupLeader</span></a> <span class='Operator'>= </span><a href="proc.c.html#LN1844"><span class='Ref_to_Parameter'>leader</span></a><span class='Delimiter'>; 
</span>        <a href="../../../include/lib/ilist.h.html#LN315"><span class='Ref_to_Func'>dlist_push_tail</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="proc.c.html#LN1844"><span class='Ref_to_Parameter'>leader</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN188"><span class='Ref_to_Member'>lockGroupMembers</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN189"><span class='Ref_to_Member'>lockGroupLink</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><a href="proc.c.html#LN1846"><span class='Ref_To_Local'>leader_lwlock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="proc.c.html#LN1847"><span class='Ref_To_Local'>ok</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end BecomeLockGroupMember &raquo; </span> 
</pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>