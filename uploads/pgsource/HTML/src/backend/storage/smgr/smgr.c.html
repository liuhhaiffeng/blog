<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\storage\smgr\smgr.c</title>
<LINK REL=StyleSheet HREF="../../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\storage\smgr\smgr.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:49 2017
</td></tr>
<tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
</span><span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * smgr.c 
 *    public interface routines to storage manager switch. 
 * 
 *    All file system operations in POSTGRES dispatch through these 
 *    routines. 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * 
 * IDENTIFICATION 
 *    src/backend/storage/smgr/smgr.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"commands/tablespace.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/bufmgr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/ipc.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/smgr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/hsearch.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/inval.h"</span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * This struct of function pointers defines the API between smgr.c and 
 * any individual storage manager module.  Note that smgr subfunctions are 
 * generally expected to report problems via elog(ERROR).  An exception is 
 * that smgr_unlink should use elog(WARNING), rather than erroring out, 
 * because we normally unlink relations during post-commit/abort cleanup, 
 * and so it's too late to raise an error.  Also, various conditions that 
 * would normally be errors should be allowed during bootstrap and/or WAL 
 * recovery --- see comments in md.c for details. 
 */ 
</span><a name="LN37"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>f_smgr</span> 
<span class='Delimiter'>{ 
</span><a name="LN39"></a>    <span class='Keyword'>void</span>        <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Declare_Member'>smgr_init</span><span class='Parentheses'>) (</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* may be NULL */ 
</span><a name="LN40"></a>    <span class='Keyword'>void</span>        <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Declare_Member'>smgr_shutdown</span><span class='Parentheses'>) (</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* may be NULL */ 
</span><a name="LN41"></a>    <span class='Keyword'>void</span>        <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Declare_Member'>smgr_close</span><span class='Parentheses'>) (</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> reln<span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a> forknum<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN42"></a>    <span class='Keyword'>void</span>        <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Declare_Member'>smgr_create</span><span class='Parentheses'>) (</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> reln<span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a> forknum<span class='Delimiter'>, 
</span>                                            <span class='Keyword'>bool </span>isRedo<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN44"></a>    <span class='Keyword'>bool</span>        <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Declare_Member'>smgr_exists</span><span class='Parentheses'>) (</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> reln<span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a> forknum<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN45"></a>    <span class='Keyword'>void</span>        <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Declare_Member'>smgr_unlink</span><span class='Parentheses'>) (</span><a href="../../../include/storage/relfilenode.h.html#LN71"><span class='Ref_to_Struct'>RelFileNodeBackend</span></a> rnode<span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a> forknum<span class='Delimiter'>, 
</span>                                            <span class='Keyword'>bool </span>isRedo<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN47"></a>    <span class='Keyword'>void</span>        <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Declare_Member'>smgr_extend</span><span class='Parentheses'>) (</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> reln<span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a> forknum<span class='Delimiter'>, 
</span>                         <a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> blocknum<span class='Delimiter'>, </span><span class='Keyword'>char </span><span class='Operator'>*</span>buffer<span class='Delimiter'>, </span><span class='Keyword'>bool </span>skipFsync<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN49"></a>    <span class='Keyword'>void</span>        <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Declare_Member'>smgr_prefetch</span><span class='Parentheses'>) (</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> reln<span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a> forknum<span class='Delimiter'>, 
</span>                                              <a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> blocknum<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN51"></a>    <span class='Keyword'>void</span>        <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Declare_Member'>smgr_read</span><span class='Parentheses'>) (</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> reln<span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a> forknum<span class='Delimiter'>, 
</span>                                          <a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> blocknum<span class='Delimiter'>, </span><span class='Keyword'>char </span><span class='Operator'>*</span>buffer<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN53"></a>    <span class='Keyword'>void</span>        <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Declare_Member'>smgr_write</span><span class='Parentheses'>) (</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> reln<span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a> forknum<span class='Delimiter'>, 
</span>                         <a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> blocknum<span class='Delimiter'>, </span><span class='Keyword'>char </span><span class='Operator'>*</span>buffer<span class='Delimiter'>, </span><span class='Keyword'>bool </span>skipFsync<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN55"></a>    <span class='Keyword'>void</span>        <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Declare_Member'>smgr_writeback</span><span class='Parentheses'>) (</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> reln<span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a> forknum<span class='Delimiter'>, 
</span>                                  <a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> blocknum<span class='Delimiter'>, </span><a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> nblocks<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN57"></a>    <a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Declare_Member'>smgr_nblocks</span><span class='Parentheses'>) (</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> reln<span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a> forknum<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN58"></a>    <span class='Keyword'>void</span>        <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Declare_Member'>smgr_truncate</span><span class='Parentheses'>) (</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> reln<span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a> forknum<span class='Delimiter'>, 
</span>                                              <a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> nblocks<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN60"></a>    <span class='Keyword'>void</span>        <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Declare_Member'>smgr_immedsync</span><span class='Parentheses'>) (</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> reln<span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a> forknum<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN61"></a>    <span class='Keyword'>void</span>        <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Declare_Member'>smgr_pre_ckpt</span><span class='Parentheses'>) (</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* may be NULL */ 
</span><a name="LN62"></a>    <span class='Keyword'>void</span>        <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Declare_Member'>smgr_sync</span><span class='Parentheses'>) (</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* may be NULL */ 
</span><a name="LN63"></a>    <span class='Keyword'>void</span>        <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Declare_Member'>smgr_post_ckpt</span><span class='Parentheses'>) (</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* may be NULL */ 
</span><a name="LN64"></a><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end f_smgr &raquo; </span> <span class='Declare_Typedef'>f_smgr</span><span class='Delimiter'>; 
</span> 
 
<a name="LN67"></a><span class='Keyword'>static const </span><a href="smgr.c.html#LN37"><span class='Ref_to_Struct'>f_smgr</span></a> <span class='Declare_Var'>smgrsw</span><span class='Delimiter'>[] </span><span class='Operator'>= </span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* magnetic disk */ 
</span>    <span class='Delimiter'>{</span><a href="../../../include/storage/smgr.h.html#LN117"><span class='Ref_to_Proto'>mdinit</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><a href="../../../include/storage/smgr.h.html#LN118"><span class='Ref_to_Proto'>mdclose</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/smgr.h.html#LN119"><span class='Ref_to_Proto'>mdcreate</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/smgr.h.html#LN120"><span class='Ref_to_Proto'>mdexists</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/smgr.h.html#LN121"><span class='Ref_to_Proto'>mdunlink</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/smgr.h.html#LN122"><span class='Ref_to_Proto'>mdextend</span></a><span class='Delimiter'>, 
</span>        <a href="../../../include/storage/smgr.h.html#LN124"><span class='Ref_to_Proto'>mdprefetch</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/smgr.h.html#LN126"><span class='Ref_to_Proto'>mdread</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/smgr.h.html#LN128"><span class='Ref_to_Proto'>mdwrite</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/smgr.h.html#LN130"><span class='Ref_to_Proto'>mdwriteback</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/smgr.h.html#LN132"><span class='Ref_to_Proto'>mdnblocks</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/smgr.h.html#LN133"><span class='Ref_to_Proto'>mdtruncate</span></a><span class='Delimiter'>, 
</span>        <a href="../../../include/storage/smgr.h.html#LN135"><span class='Ref_to_Proto'>mdimmedsync</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/smgr.h.html#LN136"><span class='Ref_to_Proto'>mdpreckpt</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/smgr.h.html#LN137"><span class='Ref_to_Proto'>mdsync</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/smgr.h.html#LN138"><span class='Ref_to_Proto'>mdpostckpt</span></a> 
    <span class='Delimiter'>} 
}; 
</span> 
<a name="LN75"></a><span class='Keyword'>static const int </span><span class='Declare_Var'>NSmgr</span> <span class='Operator'>= </span><a href="../../../include/c.h.html#LN561"><span class='Ref_to_Macro'>lengthof</span></a><span class='Parentheses'>(</span><a href="smgr.c.html#LN67"><span class='Ref_to_Global_Var'>smgrsw</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Each backend has a hashtable that stores all extant SMgrRelation objects. 
 * In addition, "unowned" SMgrRelation objects are chained together in a list. 
 */ 
</span><a name="LN82"></a><span class='Keyword'>static </span><a href="../../utils/hash/dynahash.c.html#LN192"><span class='Ref_to_Struct'>HTAB</span></a> <span class='Operator'>*</span><span class='Declare_Var'>SMgrRelationHash</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
<a name="LN84"></a><span class='Keyword'>static </span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> <span class='Declare_Var'>first_unowned_reln</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* local function prototypes */ 
</span><a name="LN87"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>smgrshutdown</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>code</span><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>arg</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN88"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>add_to_unowned_list</span><span class='Parentheses'>(</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> <span class='Declare_Parameter'>reln</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN89"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>remove_from_unowned_list</span><span class='Parentheses'>(</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> <span class='Declare_Parameter'>reln</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 *  smgrinit(), smgrshutdown() -- Initialize or shut down storage 
 *                                managers. 
 * 
 * Note: smgrinit is called during backend startup (normal or standalone 
 * case), *not* during postmaster start.  Therefore, any resources created 
 * here or destroyed in smgrshutdown are backend-local. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN101"></a><span class='Declare_Function'>smgrinit</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN103"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN103"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="smgr.c.html#LN103"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="smgr.c.html#LN75"><span class='Ref_to_Global_Var'>NSmgr</span></a><span class='Delimiter'>; </span><a href="smgr.c.html#LN103"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN67"><span class='Ref_to_Global_Var'>smgrsw</span></a><span class='Delimiter'>[</span><a href="smgr.c.html#LN103"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="smgr.c.html#LN39"><span class='Ref_to_Member'>smgr_init</span></a><span class='Parentheses'>) 
</span>            <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Parentheses'>(</span><a href="smgr.c.html#LN67"><span class='Ref_to_Global_Var'>smgrsw</span></a><span class='Delimiter'>[</span><a href="smgr.c.html#LN103"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="smgr.c.html#LN39"><span class='Ref_to_Member'>smgr_init</span></a><span class='Parentheses'>))</span> <span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* register the shutdown proc */ 
</span>    <a href="../../../include/storage/ipc.h.html#LN68"><span class='Ref_to_Proto'>on_proc_exit</span></a><span class='Parentheses'>(</span><a href="smgr.c.html#LN87"><span class='Ref_to_Proto'>smgrshutdown</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * on_proc_exit hook for smgr cleanup during backend shutdown 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN119"></a><span class='Declare_Function'>smgrshutdown</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>code</span><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>arg</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN121"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN121"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="smgr.c.html#LN121"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="smgr.c.html#LN75"><span class='Ref_to_Global_Var'>NSmgr</span></a><span class='Delimiter'>; </span><a href="smgr.c.html#LN121"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN67"><span class='Ref_to_Global_Var'>smgrsw</span></a><span class='Delimiter'>[</span><a href="smgr.c.html#LN121"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="smgr.c.html#LN40"><span class='Ref_to_Member'>smgr_shutdown</span></a><span class='Parentheses'>) 
</span>            <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Parentheses'>(</span><a href="smgr.c.html#LN67"><span class='Ref_to_Global_Var'>smgrsw</span></a><span class='Delimiter'>[</span><a href="smgr.c.html#LN121"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="smgr.c.html#LN40"><span class='Ref_to_Member'>smgr_shutdown</span></a><span class='Parentheses'>))</span> <span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *  smgropen() -- Return an SMgrRelation object, creating it if need be. 
 * 
 *      This does not attempt to actually open the underlying file. 
 */ 
</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> 
<a name="LN136"></a><span class='Declare_Function'>smgropen</span><span class='Parentheses'>(</span><a href="../../../include/storage/relfilenode.h.html#LN56"><span class='Ref_to_Struct'>RelFileNode</span></a> <span class='Declare_Parameter'>rnode</span><span class='Delimiter'>, </span><a href="../../../include/storage/backendid.h.html#LN20"><span class='Ref_to_Typedef'>BackendId</span></a> <span class='Declare_Parameter'>backend</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN138"></a>    <a href="../../../include/storage/relfilenode.h.html#LN71"><span class='Ref_to_Struct'>RelFileNodeBackend</span></a> <span class='Declare_Local'>brnode</span><span class='Delimiter'>; 
</span><a name="LN139"></a>    <a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> <span class='Declare_Local'>reln</span><span class='Delimiter'>; 
</span><a name="LN140"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN82"><span class='Ref_to_Global_Var'>SMgrRelationHash</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* First time through: initialize the hash table */ 
</span><a name="LN145"></a>        <a href="../../../include/utils/hsearch.h.html#LN64"><span class='Ref_to_Struct'>HASHCTL</span></a>     <span class='Declare_Local'>ctl</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="smgr.c.html#LN145"><span class='Ref_To_Local'>ctl</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="smgr.c.html#LN145"><span class='Ref_To_Local'>ctl</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="smgr.c.html#LN145"><span class='Ref_To_Local'>ctl</span></a><span class='Operator'>.</span><a href="../../../include/utils/hsearch.h.html#LN71"><span class='Ref_to_Member'>keysize</span></a> <span class='Operator'>= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/relfilenode.h.html#LN71"><span class='Ref_to_Struct'>RelFileNodeBackend</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="smgr.c.html#LN145"><span class='Ref_To_Local'>ctl</span></a><span class='Operator'>.</span><a href="../../../include/utils/hsearch.h.html#LN72"><span class='Ref_to_Member'>entrysize</span></a> <span class='Operator'>= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/smgr.h.html#LN39"><span class='Ref_to_Struct'>SMgrRelationData</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="smgr.c.html#LN82"><span class='Ref_to_Global_Var'>SMgrRelationHash</span></a> <span class='Operator'>= </span><a href="../../../include/utils/hsearch.h.html#LN121"><span class='Ref_to_Proto'>hash_create</span></a><span class='Parentheses'>(</span><span class='String'>"smgr relation table"</span><span class='Delimiter'>, </span><span class='Number'>400</span><span class='Delimiter'>, 
</span>                                       <span class='Operator'>&</span><a href="smgr.c.html#LN145"><span class='Ref_To_Local'>ctl</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/hsearch.h.html#LN86"><span class='Ref_to_Const'>HASH_ELEM</span></a> <span class='Operator'>| </span><a href="../../../include/utils/hsearch.h.html#LN87"><span class='Ref_to_Const'>HASH_BLOBS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="smgr.c.html#LN84"><span class='Ref_to_Global_Var'>first_unowned_reln</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Look up or create an entry */ 
</span>    <a href="smgr.c.html#LN138"><span class='Ref_To_Local'>brnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN73"><span class='Ref_to_Member'>node</span></a> <span class='Operator'>= </span><a href="smgr.c.html#LN136"><span class='Ref_to_Parameter'>rnode</span></a><span class='Delimiter'>; 
</span>    <a href="smgr.c.html#LN138"><span class='Ref_To_Local'>brnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN74"><span class='Ref_to_Member'>backend</span></a> <span class='Operator'>= </span><a href="smgr.c.html#LN136"><span class='Ref_to_Parameter'>backend</span></a><span class='Delimiter'>; 
</span>    <a href="smgr.c.html#LN139"><span class='Ref_To_Local'>reln</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a><span class='Parentheses'>) </span><a href="../../../include/utils/hsearch.h.html#LN125"><span class='Ref_to_Proto'>hash_search</span></a><span class='Parentheses'>(</span><a href="smgr.c.html#LN82"><span class='Ref_to_Global_Var'>SMgrRelationHash</span></a><span class='Delimiter'>, 
</span>                                      <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="smgr.c.html#LN138"><span class='Ref_To_Local'>brnode</span></a><span class='Delimiter'>, 
</span>                                      <a href="../../../include/utils/hsearch.h.html#LN105"><span class='Ref_to_EnumConst'>HASH_ENTER</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="smgr.c.html#LN140"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Initialize it if not present before */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="smgr.c.html#LN140"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN165"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>forknum</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* hash_search already filled in the lookup key */ 
</span>        <a href="smgr.c.html#LN139"><span class='Ref_To_Local'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN45"><span class='Ref_to_Member'>smgr_owner</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <a href="smgr.c.html#LN139"><span class='Ref_To_Local'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN54"><span class='Ref_to_Member'>smgr_targblock</span></a> <span class='Operator'>= </span><a href="../../../include/storage/block.h.html#LN32"><span class='Ref_to_Const'>InvalidBlockNumber</span></a><span class='Delimiter'>; 
</span>        <a href="smgr.c.html#LN139"><span class='Ref_To_Local'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN55"><span class='Ref_to_Member'>smgr_fsm_nblocks</span></a> <span class='Operator'>= </span><a href="../../../include/storage/block.h.html#LN32"><span class='Ref_to_Const'>InvalidBlockNumber</span></a><span class='Delimiter'>; 
</span>        <a href="smgr.c.html#LN139"><span class='Ref_To_Local'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN56"><span class='Ref_to_Member'>smgr_vm_nblocks</span></a> <span class='Operator'>= </span><a href="../../../include/storage/block.h.html#LN32"><span class='Ref_to_Const'>InvalidBlockNumber</span></a><span class='Delimiter'>; 
</span>        <a href="smgr.c.html#LN139"><span class='Ref_To_Local'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN64"><span class='Ref_to_Member'>smgr_which</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* we only have md.c at present */ 
</span> 
        <span class='Comment_Multi_Line'>/* mark it not open */ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN165"><span class='Ref_To_Local'>forknum</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="smgr.c.html#LN165"><span class='Ref_To_Local'>forknum</span></a> <span class='Operator'>&LT;= </span><a href="../../../include/common/relpath.h.html#LN38"><span class='Ref_to_Const'>MAX_FORKNUM</span></a><span class='Delimiter'>; </span><a href="smgr.c.html#LN165"><span class='Ref_To_Local'>forknum</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <a href="smgr.c.html#LN139"><span class='Ref_To_Local'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN70"><span class='Ref_to_Member'>md_num_open_segs</span></a><span class='Delimiter'>[</span><a href="smgr.c.html#LN165"><span class='Ref_To_Local'>forknum</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* it has no owner yet */ 
</span>        <a href="smgr.c.html#LN88"><span class='Ref_to_Proto'>add_to_unowned_list</span></a><span class='Parentheses'>(</span><a href="smgr.c.html#LN139"><span class='Ref_To_Local'>reln</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="smgr.c.html#LN139"><span class='Ref_To_Local'>reln</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end smgropen &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * smgrsetowner() -- Establish a long-lived reference to an SMgrRelation object 
 * 
 * There can be only one owner at a time; this is sufficient since currently 
 * the only such owners exist in the relcache. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN192"></a><span class='Declare_Function'>smgrsetowner</span><span class='Parentheses'>(</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>owner</span><span class='Delimiter'>, </span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> <span class='Declare_Parameter'>reln</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* We don't support "disowning" an SMgrRelation here, use smgrclearowner */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="smgr.c.html#LN192"><span class='Ref_to_Parameter'>owner</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * First, unhook any old owner.  (Normally there shouldn't be any, but it 
     * seems possible that this can happen during swap_relation_files() 
     * depending on the order of processing.  It's ok to close the old 
     * relcache entry early in that case.) 
     * 
     * If there isn't an old owner, then the reln should be in the unowned 
     * list, and we need to remove it. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN192"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN45"><span class='Ref_to_Member'>smgr_owner</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>*</span><span class='Parentheses'>(</span><a href="smgr.c.html#LN192"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN45"><span class='Ref_to_Member'>smgr_owner</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="smgr.c.html#LN89"><span class='Ref_to_Proto'>remove_from_unowned_list</span></a><span class='Parentheses'>(</span><a href="smgr.c.html#LN192"><span class='Ref_to_Parameter'>reln</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Now establish the ownership relationship. */ 
</span>    <a href="smgr.c.html#LN192"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN45"><span class='Ref_to_Member'>smgr_owner</span></a> <span class='Operator'>= </span><a href="smgr.c.html#LN192"><span class='Ref_to_Parameter'>owner</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="smgr.c.html#LN192"><span class='Ref_to_Parameter'>owner</span></a> <span class='Operator'>= </span><a href="smgr.c.html#LN192"><span class='Ref_to_Parameter'>reln</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end smgrsetowner &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * smgrclearowner() -- Remove long-lived reference to an SMgrRelation object 
 *                     if one exists 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN221"></a><span class='Declare_Function'>smgrclearowner</span><span class='Parentheses'>(</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>owner</span><span class='Delimiter'>, </span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> <span class='Declare_Parameter'>reln</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* Do nothing if the SMgrRelation object is not owned by the owner */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN221"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN45"><span class='Ref_to_Member'>smgr_owner</span></a> <span class='Operator'>!= </span><a href="smgr.c.html#LN221"><span class='Ref_to_Parameter'>owner</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* unset the owner's reference */ 
</span>    <span class='Operator'>*</span><a href="smgr.c.html#LN221"><span class='Ref_to_Parameter'>owner</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* unset our reference to the owner */ 
</span>    <a href="smgr.c.html#LN221"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN45"><span class='Ref_to_Member'>smgr_owner</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <a href="smgr.c.html#LN88"><span class='Ref_to_Proto'>add_to_unowned_list</span></a><span class='Parentheses'>(</span><a href="smgr.c.html#LN221"><span class='Ref_to_Parameter'>reln</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * add_to_unowned_list -- link an SMgrRelation onto the unowned list 
 * 
 * Check remove_from_unowned_list()'s comments for performance 
 * considerations. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN243"></a><span class='Declare_Function'>add_to_unowned_list</span><span class='Parentheses'>(</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> <span class='Declare_Parameter'>reln</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* place it at head of the list (to make smgrsetowner cheap) */ 
</span>    <a href="smgr.c.html#LN243"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN74"><span class='Ref_to_Member'>next_unowned_reln</span></a> <span class='Operator'>= </span><a href="smgr.c.html#LN84"><span class='Ref_to_Global_Var'>first_unowned_reln</span></a><span class='Delimiter'>; 
</span>    <a href="smgr.c.html#LN84"><span class='Ref_to_Global_Var'>first_unowned_reln</span></a> <span class='Operator'>= </span><a href="smgr.c.html#LN243"><span class='Ref_to_Parameter'>reln</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * remove_from_unowned_list -- unlink an SMgrRelation from the unowned list 
 * 
 * If the reln is not present in the list, nothing happens.  Typically this 
 * would be caller error, but there seems no reason to throw an error. 
 * 
 * In the worst case this could be rather slow; but in all the cases that seem 
 * likely to be performance-critical, the reln being sought will actually be 
 * first in the list.  Furthermore, the number of unowned relns touched in any 
 * one transaction shouldn't be all that high typically.  So it doesn't seem 
 * worth expending the additional space and management logic needed for a 
 * doubly-linked list. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN264"></a><span class='Declare_Function'>remove_from_unowned_list</span><span class='Parentheses'>(</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> <span class='Declare_Parameter'>reln</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN266"></a>    <a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> <span class='Operator'>*</span><span class='Declare_Local'>link</span><span class='Delimiter'>; 
</span><a name="LN267"></a>    <a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> <span class='Declare_Local'>cur</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN266"><span class='Ref_To_Local'>link</span></a> <span class='Operator'>= &</span><a href="smgr.c.html#LN84"><span class='Ref_to_Global_Var'>first_unowned_reln</span></a><span class='Delimiter'>, </span><a href="smgr.c.html#LN267"><span class='Ref_To_Local'>cur</span></a> <span class='Operator'>= *</span><a href="smgr.c.html#LN266"><span class='Ref_To_Local'>link</span></a><span class='Delimiter'>; 
</span>         <a href="smgr.c.html#LN267"><span class='Ref_To_Local'>cur</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>         <a href="smgr.c.html#LN266"><span class='Ref_To_Local'>link</span></a> <span class='Operator'>= &</span><a href="smgr.c.html#LN267"><span class='Ref_To_Local'>cur</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN74"><span class='Ref_to_Member'>next_unowned_reln</span></a><span class='Delimiter'>, </span><a href="smgr.c.html#LN267"><span class='Ref_To_Local'>cur</span></a> <span class='Operator'>= *</span><a href="smgr.c.html#LN266"><span class='Ref_To_Local'>link</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN267"><span class='Ref_To_Local'>cur</span></a> <span class='Operator'>== </span><a href="smgr.c.html#LN264"><span class='Ref_to_Parameter'>reln</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Operator'>*</span><a href="smgr.c.html#LN266"><span class='Ref_To_Local'>link</span></a> <span class='Operator'>= </span><a href="smgr.c.html#LN267"><span class='Ref_To_Local'>cur</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN74"><span class='Ref_to_Member'>next_unowned_reln</span></a><span class='Delimiter'>; 
</span>            <a href="smgr.c.html#LN267"><span class='Ref_To_Local'>cur</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN74"><span class='Ref_to_Member'>next_unowned_reln</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *  smgrexists() -- Does the underlying file for a fork exist? 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN286"></a><span class='Declare_Function'>smgrexists</span><span class='Parentheses'>(</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> <span class='Declare_Parameter'>reln</span><span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a> <span class='Declare_Parameter'>forknum</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Parentheses'>(</span><a href="smgr.c.html#LN67"><span class='Ref_to_Global_Var'>smgrsw</span></a><span class='Delimiter'>[</span><a href="smgr.c.html#LN286"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN64"><span class='Ref_to_Member'>smgr_which</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="smgr.c.html#LN44"><span class='Ref_to_Member'>smgr_exists</span></a><span class='Parentheses'>))</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN286"><span class='Ref_to_Parameter'>reln</span></a><span class='Delimiter'>, </span><a href="smgr.c.html#LN286"><span class='Ref_to_Parameter'>forknum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *  smgrclose() -- Close and delete an SMgrRelation object. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN295"></a><span class='Declare_Function'>smgrclose</span><span class='Parentheses'>(</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> <span class='Declare_Parameter'>reln</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN297"></a>    <a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> <span class='Operator'>*</span><span class='Declare_Local'>owner</span><span class='Delimiter'>; 
</span><a name="LN298"></a>    <a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a>  <span class='Declare_Local'>forknum</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN298"><span class='Ref_To_Local'>forknum</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="smgr.c.html#LN298"><span class='Ref_To_Local'>forknum</span></a> <span class='Operator'>&LT;= </span><a href="../../../include/common/relpath.h.html#LN38"><span class='Ref_to_Const'>MAX_FORKNUM</span></a><span class='Delimiter'>; </span><a href="smgr.c.html#LN298"><span class='Ref_To_Local'>forknum</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Parentheses'>(</span><a href="smgr.c.html#LN67"><span class='Ref_to_Global_Var'>smgrsw</span></a><span class='Delimiter'>[</span><a href="smgr.c.html#LN295"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN64"><span class='Ref_to_Member'>smgr_which</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="smgr.c.html#LN41"><span class='Ref_to_Member'>smgr_close</span></a><span class='Parentheses'>))</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN295"><span class='Ref_to_Parameter'>reln</span></a><span class='Delimiter'>, </span><a href="smgr.c.html#LN298"><span class='Ref_To_Local'>forknum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="smgr.c.html#LN297"><span class='Ref_To_Local'>owner</span></a> <span class='Operator'>= </span><a href="smgr.c.html#LN295"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN45"><span class='Ref_to_Member'>smgr_owner</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="smgr.c.html#LN297"><span class='Ref_To_Local'>owner</span></a><span class='Parentheses'>) 
</span>        <a href="smgr.c.html#LN89"><span class='Ref_to_Proto'>remove_from_unowned_list</span></a><span class='Parentheses'>(</span><a href="smgr.c.html#LN295"><span class='Ref_to_Parameter'>reln</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/hsearch.h.html#LN125"><span class='Ref_to_Proto'>hash_search</span></a><span class='Parentheses'>(</span><a href="smgr.c.html#LN82"><span class='Ref_to_Global_Var'>SMgrRelationHash</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="smgr.c.html#LN295"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN42"><span class='Ref_to_Member'>smgr_rnode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                    <a href="../../../include/utils/hsearch.h.html#LN106"><span class='Ref_to_EnumConst'>HASH_REMOVE</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"SMgrRelation hashtable corrupted"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Unhook the owner pointer, if any.  We do this last since in the remote 
     * possibility of failure above, the SMgrRelation object will still exist. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN297"><span class='Ref_To_Local'>owner</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>*</span><a href="smgr.c.html#LN297"><span class='Ref_To_Local'>owner</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end smgrclose &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *  smgrcloseall() -- Close all existing SMgrRelation objects. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN325"></a><span class='Declare_Function'>smgrcloseall</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN327"></a>    <a href="../../../include/utils/hsearch.h.html#LN111"><span class='Ref_to_Typedef'>HASH_SEQ_STATUS</span></a> <span class='Declare_Local'>status</span><span class='Delimiter'>; 
</span><a name="LN328"></a>    <a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> <span class='Declare_Local'>reln</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Nothing to do if hashtable not set up */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN82"><span class='Ref_to_Global_Var'>SMgrRelationHash</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/hsearch.h.html#LN134"><span class='Ref_to_Proto'>hash_seq_init</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="smgr.c.html#LN327"><span class='Ref_To_Local'>status</span></a><span class='Delimiter'>, </span><a href="smgr.c.html#LN82"><span class='Ref_to_Global_Var'>SMgrRelationHash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>while</span> <span class='Parentheses'>((</span><a href="smgr.c.html#LN328"><span class='Ref_To_Local'>reln</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a><span class='Parentheses'>) </span><a href="../../../include/utils/hsearch.h.html#LN135"><span class='Ref_to_Proto'>hash_seq_search</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="smgr.c.html#LN327"><span class='Ref_To_Local'>status</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
        <a href="../../../include/storage/smgr.h.html#LN87"><span class='Ref_to_Proto'>smgrclose</span></a><span class='Parentheses'>(</span><a href="smgr.c.html#LN328"><span class='Ref_To_Local'>reln</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *  smgrclosenode() -- Close SMgrRelation object for given RelFileNode, 
 *                     if one exists. 
 * 
 * This has the same effects as smgrclose(smgropen(rnode)), but it avoids 
 * uselessly creating a hashtable entry only to drop it again when no 
 * such entry exists already. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN349"></a><span class='Declare_Function'>smgrclosenode</span><span class='Parentheses'>(</span><a href="../../../include/storage/relfilenode.h.html#LN71"><span class='Ref_to_Struct'>RelFileNodeBackend</span></a> <span class='Declare_Parameter'>rnode</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN351"></a>    <a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> <span class='Declare_Local'>reln</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Nothing to do if hashtable not set up */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN82"><span class='Ref_to_Global_Var'>SMgrRelationHash</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <a href="smgr.c.html#LN351"><span class='Ref_To_Local'>reln</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a><span class='Parentheses'>) </span><a href="../../../include/utils/hsearch.h.html#LN125"><span class='Ref_to_Proto'>hash_search</span></a><span class='Parentheses'>(</span><a href="smgr.c.html#LN82"><span class='Ref_to_Global_Var'>SMgrRelationHash</span></a><span class='Delimiter'>, 
</span>                                      <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="smgr.c.html#LN349"><span class='Ref_to_Parameter'>rnode</span></a><span class='Delimiter'>, 
</span>                                      <a href="../../../include/utils/hsearch.h.html#LN104"><span class='Ref_to_EnumConst'>HASH_FIND</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN351"><span class='Ref_To_Local'>reln</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/smgr.h.html#LN87"><span class='Ref_to_Proto'>smgrclose</span></a><span class='Parentheses'>(</span><a href="smgr.c.html#LN351"><span class='Ref_To_Local'>reln</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *  smgrcreate() -- Create a new relation. 
 * 
 *      Given an already-created (but presumably unused) SMgrRelation, 
 *      cause the underlying disk file or other storage for the fork 
 *      to be created. 
 * 
 *      If isRedo is true, it is okay for the underlying file to exist 
 *      already because we are in a WAL replay sequence. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN375"></a><span class='Declare_Function'>smgrcreate</span><span class='Parentheses'>(</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> <span class='Declare_Parameter'>reln</span><span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a> <span class='Declare_Parameter'>forknum</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>isRedo</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * Exit quickly in WAL replay mode if we've already opened the file. If 
     * it's open, it surely must exist. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN375"><span class='Ref_to_Parameter'>isRedo</span></a> <span class='Operator'>&& </span><a href="smgr.c.html#LN375"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN70"><span class='Ref_to_Member'>md_num_open_segs</span></a><span class='Delimiter'>[</span><a href="smgr.c.html#LN375"><span class='Ref_to_Parameter'>forknum</span></a><span class='Delimiter'>] </span><span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We may be using the target table space for the first time in this 
     * database, so create a per-database subdirectory if needed. 
     * 
     * XXX this is a fairly ugly violation of module layering, but this seems 
     * to be the best place to put the check.  Maybe TablespaceCreateDbspace 
     * should be here and not in commands/tablespace.c?  But that would imply 
     * importing a lot of stuff that smgr.c oughtn't know, either. 
     */ 
</span>    <a href="../../../include/commands/tablespace.h.html#LN49"><span class='Ref_to_Proto'>TablespaceCreateDbspace</span></a><span class='Parentheses'>(</span><a href="smgr.c.html#LN375"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN42"><span class='Ref_to_Member'>smgr_rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN73"><span class='Ref_to_Member'>node</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN58"><span class='Ref_to_Member'>spcNode</span></a><span class='Delimiter'>, 
</span>                            <a href="smgr.c.html#LN375"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN42"><span class='Ref_to_Member'>smgr_rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN73"><span class='Ref_to_Member'>node</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN59"><span class='Ref_to_Member'>dbNode</span></a><span class='Delimiter'>, 
</span>                            <a href="smgr.c.html#LN375"><span class='Ref_to_Parameter'>isRedo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Parentheses'>(</span><a href="smgr.c.html#LN67"><span class='Ref_to_Global_Var'>smgrsw</span></a><span class='Delimiter'>[</span><a href="smgr.c.html#LN375"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN64"><span class='Ref_to_Member'>smgr_which</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="smgr.c.html#LN42"><span class='Ref_to_Member'>smgr_create</span></a><span class='Parentheses'>))</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN375"><span class='Ref_to_Parameter'>reln</span></a><span class='Delimiter'>, </span><a href="smgr.c.html#LN375"><span class='Ref_to_Parameter'>forknum</span></a><span class='Delimiter'>, </span><a href="smgr.c.html#LN375"><span class='Ref_to_Parameter'>isRedo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end smgrcreate &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *  smgrdounlink() -- Immediately unlink all forks of a relation. 
 * 
 *      All forks of the relation are removed from the store.  This should 
 *      not be used during transactional operations, since it can't be undone. 
 * 
 *      If isRedo is true, it is okay for the underlying file(s) to be gone 
 *      already. 
 * 
 *      This is equivalent to calling smgrdounlinkfork for each fork, but 
 *      it's significantly quicker so should be preferred when possible. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN413"></a><span class='Declare_Function'>smgrdounlink</span><span class='Parentheses'>(</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> <span class='Declare_Parameter'>reln</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>isRedo</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN415"></a>    <a href="../../../include/storage/relfilenode.h.html#LN71"><span class='Ref_to_Struct'>RelFileNodeBackend</span></a> <span class='Declare_Local'>rnode</span> <span class='Operator'>= </span><a href="smgr.c.html#LN413"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN42"><span class='Ref_to_Member'>smgr_rnode</span></a><span class='Delimiter'>; 
</span><a name="LN416"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>which</span> <span class='Operator'>= </span><a href="smgr.c.html#LN413"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN64"><span class='Ref_to_Member'>smgr_which</span></a><span class='Delimiter'>; 
</span><a name="LN417"></a>    <a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a>  <span class='Declare_Local'>forknum</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Close the forks at smgr level */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN417"><span class='Ref_To_Local'>forknum</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="smgr.c.html#LN417"><span class='Ref_To_Local'>forknum</span></a> <span class='Operator'>&LT;= </span><a href="../../../include/common/relpath.h.html#LN38"><span class='Ref_to_Const'>MAX_FORKNUM</span></a><span class='Delimiter'>; </span><a href="smgr.c.html#LN417"><span class='Ref_To_Local'>forknum</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Parentheses'>(</span><a href="smgr.c.html#LN67"><span class='Ref_to_Global_Var'>smgrsw</span></a><span class='Delimiter'>[</span><a href="smgr.c.html#LN416"><span class='Ref_To_Local'>which</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="smgr.c.html#LN41"><span class='Ref_to_Member'>smgr_close</span></a><span class='Parentheses'>))</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN413"><span class='Ref_to_Parameter'>reln</span></a><span class='Delimiter'>, </span><a href="smgr.c.html#LN417"><span class='Ref_To_Local'>forknum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Get rid of any remaining buffers for the relation.  bufmgr will just 
     * drop them without bothering to write the contents. 
     */ 
</span>    <a href="../../../include/storage/bufmgr.h.html#LN195"><span class='Ref_to_Proto'>DropRelFileNodesAllBuffers</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="smgr.c.html#LN415"><span class='Ref_To_Local'>rnode</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * It'd be nice to tell the stats collector to forget it immediately, too. 
     * But we can't because we don't know the OID (and in cases involving 
     * relfilenode swaps, it's not always clear which table OID to forget, 
     * anyway). 
     */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Send a shared-inval message to force other backends to close any 
     * dangling smgr references they may have for this rel.  We should do this 
     * before starting the actual unlinking, in case we fail partway through 
     * that step.  Note that the sinval message will eventually come back to 
     * this backend, too, and thereby provide a backstop that we closed our 
     * own smgr rel. 
     */ 
</span>    <a href="../../../include/utils/inval.h.html#LN51"><span class='Ref_to_Proto'>CacheInvalidateSmgr</span></a><span class='Parentheses'>(</span><a href="smgr.c.html#LN415"><span class='Ref_To_Local'>rnode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Delete the physical file(s). 
     * 
     * Note: smgr_unlink must treat deletion failure as a WARNING, not an 
     * ERROR, because we've already decided to commit or abort the current 
     * xact. 
     */ 
</span>    <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Parentheses'>(</span><a href="smgr.c.html#LN67"><span class='Ref_to_Global_Var'>smgrsw</span></a><span class='Delimiter'>[</span><a href="smgr.c.html#LN416"><span class='Ref_To_Local'>which</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="smgr.c.html#LN45"><span class='Ref_to_Member'>smgr_unlink</span></a><span class='Parentheses'>))</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN415"><span class='Ref_To_Local'>rnode</span></a><span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN25"><span class='Ref_to_EnumConst'>InvalidForkNumber</span></a><span class='Delimiter'>, </span><a href="smgr.c.html#LN413"><span class='Ref_to_Parameter'>isRedo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end smgrdounlink &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *  smgrdounlinkall() -- Immediately unlink all forks of all given relations 
 * 
 *      All forks of all given relations are removed from the store.  This 
 *      should not be used during transactional operations, since it can't be 
 *      undone. 
 * 
 *      If isRedo is true, it is okay for the underlying file(s) to be gone 
 *      already. 
 * 
 *      This is equivalent to calling smgrdounlink for each relation, but it's 
 *      significantly quicker so should be preferred when possible. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN470"></a><span class='Declare_Function'>smgrdounlinkall</span><span class='Parentheses'>(</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rels</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>nrels</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>isRedo</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN472"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN473"></a>    <a href="../../../include/storage/relfilenode.h.html#LN71"><span class='Ref_to_Struct'>RelFileNodeBackend</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rnodes</span><span class='Delimiter'>; 
</span><a name="LN474"></a>    <a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a>  <span class='Declare_Local'>forknum</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN470"><span class='Ref_to_Parameter'>nrels</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * create an array which contains all relations to be dropped, and close 
     * each relation's forks at the smgr level while at it 
     */ 
</span>    <a href="smgr.c.html#LN473"><span class='Ref_To_Local'>rnodes</span></a> <span class='Operator'>= </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/relfilenode.h.html#LN71"><span class='Ref_to_Struct'>RelFileNodeBackend</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="smgr.c.html#LN470"><span class='Ref_to_Parameter'>nrels</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN472"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="smgr.c.html#LN472"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="smgr.c.html#LN470"><span class='Ref_to_Parameter'>nrels</span></a><span class='Delimiter'>; </span><a href="smgr.c.html#LN472"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN486"></a>        <a href="../../../include/storage/relfilenode.h.html#LN71"><span class='Ref_to_Struct'>RelFileNodeBackend</span></a> <span class='Declare_Local'>rnode</span> <span class='Operator'>= </span><a href="smgr.c.html#LN470"><span class='Ref_to_Parameter'>rels</span></a><span class='Delimiter'>[</span><a href="smgr.c.html#LN472"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN42"><span class='Ref_to_Member'>smgr_rnode</span></a><span class='Delimiter'>; 
</span><a name="LN487"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>which</span> <span class='Operator'>= </span><a href="smgr.c.html#LN470"><span class='Ref_to_Parameter'>rels</span></a><span class='Delimiter'>[</span><a href="smgr.c.html#LN472"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN64"><span class='Ref_to_Member'>smgr_which</span></a><span class='Delimiter'>; 
</span> 
        <a href="smgr.c.html#LN473"><span class='Ref_To_Local'>rnodes</span></a><span class='Delimiter'>[</span><a href="smgr.c.html#LN472"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="smgr.c.html#LN486"><span class='Ref_To_Local'>rnode</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Close the forks at smgr level */ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN474"><span class='Ref_To_Local'>forknum</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="smgr.c.html#LN474"><span class='Ref_To_Local'>forknum</span></a> <span class='Operator'>&LT;= </span><a href="../../../include/common/relpath.h.html#LN38"><span class='Ref_to_Const'>MAX_FORKNUM</span></a><span class='Delimiter'>; </span><a href="smgr.c.html#LN474"><span class='Ref_To_Local'>forknum</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Parentheses'>(</span><a href="smgr.c.html#LN67"><span class='Ref_to_Global_Var'>smgrsw</span></a><span class='Delimiter'>[</span><a href="smgr.c.html#LN487"><span class='Ref_To_Local'>which</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="smgr.c.html#LN41"><span class='Ref_to_Member'>smgr_close</span></a><span class='Parentheses'>))</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN470"><span class='Ref_to_Parameter'>rels</span></a><span class='Delimiter'>[</span><a href="smgr.c.html#LN472"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], </span><a href="smgr.c.html#LN474"><span class='Ref_To_Local'>forknum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Get rid of any remaining buffers for the relations.  bufmgr will just 
     * drop them without bothering to write the contents. 
     */ 
</span>    <a href="../../../include/storage/bufmgr.h.html#LN195"><span class='Ref_to_Proto'>DropRelFileNodesAllBuffers</span></a><span class='Parentheses'>(</span><a href="smgr.c.html#LN473"><span class='Ref_To_Local'>rnodes</span></a><span class='Delimiter'>, </span><a href="smgr.c.html#LN470"><span class='Ref_to_Parameter'>nrels</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * It'd be nice to tell the stats collector to forget them immediately, 
     * too. But we can't because we don't know the OIDs. 
     */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Send a shared-inval message to force other backends to close any 
     * dangling smgr references they may have for these rels.  We should do 
     * this before starting the actual unlinking, in case we fail partway 
     * through that step.  Note that the sinval messages will eventually come 
     * back to this backend, too, and thereby provide a backstop that we 
     * closed our own smgr rel. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN472"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="smgr.c.html#LN472"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="smgr.c.html#LN470"><span class='Ref_to_Parameter'>nrels</span></a><span class='Delimiter'>; </span><a href="smgr.c.html#LN472"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/inval.h.html#LN51"><span class='Ref_to_Proto'>CacheInvalidateSmgr</span></a><span class='Parentheses'>(</span><a href="smgr.c.html#LN473"><span class='Ref_To_Local'>rnodes</span></a><span class='Delimiter'>[</span><a href="smgr.c.html#LN472"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Delete the physical file(s). 
     * 
     * Note: smgr_unlink must treat deletion failure as a WARNING, not an 
     * ERROR, because we've already decided to commit or abort the current 
     * xact. 
     */ 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN472"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="smgr.c.html#LN472"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="smgr.c.html#LN470"><span class='Ref_to_Parameter'>nrels</span></a><span class='Delimiter'>; </span><a href="smgr.c.html#LN472"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN528"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>which</span> <span class='Operator'>= </span><a href="smgr.c.html#LN470"><span class='Ref_to_Parameter'>rels</span></a><span class='Delimiter'>[</span><a href="smgr.c.html#LN472"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN64"><span class='Ref_to_Member'>smgr_which</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN474"><span class='Ref_To_Local'>forknum</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="smgr.c.html#LN474"><span class='Ref_To_Local'>forknum</span></a> <span class='Operator'>&LT;= </span><a href="../../../include/common/relpath.h.html#LN38"><span class='Ref_to_Const'>MAX_FORKNUM</span></a><span class='Delimiter'>; </span><a href="smgr.c.html#LN474"><span class='Ref_To_Local'>forknum</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Parentheses'>(</span><a href="smgr.c.html#LN67"><span class='Ref_to_Global_Var'>smgrsw</span></a><span class='Delimiter'>[</span><a href="smgr.c.html#LN528"><span class='Ref_To_Local'>which</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="smgr.c.html#LN45"><span class='Ref_to_Member'>smgr_unlink</span></a><span class='Parentheses'>))</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN473"><span class='Ref_To_Local'>rnodes</span></a><span class='Delimiter'>[</span><a href="smgr.c.html#LN472"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], </span><a href="smgr.c.html#LN474"><span class='Ref_To_Local'>forknum</span></a><span class='Delimiter'>, </span><a href="smgr.c.html#LN470"><span class='Ref_to_Parameter'>isRedo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="smgr.c.html#LN473"><span class='Ref_To_Local'>rnodes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end smgrdounlinkall &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *  smgrdounlinkfork() -- Immediately unlink one fork of a relation. 
 * 
 *      The specified fork of the relation is removed from the store.  This 
 *      should not be used during transactional operations, since it can't be 
 *      undone. 
 * 
 *      If isRedo is true, it is okay for the underlying file to be gone 
 *      already. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN548"></a><span class='Declare_Function'>smgrdounlinkfork</span><span class='Parentheses'>(</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> <span class='Declare_Parameter'>reln</span><span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a> <span class='Declare_Parameter'>forknum</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>isRedo</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN550"></a>    <a href="../../../include/storage/relfilenode.h.html#LN71"><span class='Ref_to_Struct'>RelFileNodeBackend</span></a> <span class='Declare_Local'>rnode</span> <span class='Operator'>= </span><a href="smgr.c.html#LN548"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN42"><span class='Ref_to_Member'>smgr_rnode</span></a><span class='Delimiter'>; 
</span><a name="LN551"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>which</span> <span class='Operator'>= </span><a href="smgr.c.html#LN548"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN64"><span class='Ref_to_Member'>smgr_which</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Close the fork at smgr level */ 
</span>    <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Parentheses'>(</span><a href="smgr.c.html#LN67"><span class='Ref_to_Global_Var'>smgrsw</span></a><span class='Delimiter'>[</span><a href="smgr.c.html#LN551"><span class='Ref_To_Local'>which</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="smgr.c.html#LN41"><span class='Ref_to_Member'>smgr_close</span></a><span class='Parentheses'>))</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN548"><span class='Ref_to_Parameter'>reln</span></a><span class='Delimiter'>, </span><a href="smgr.c.html#LN548"><span class='Ref_to_Parameter'>forknum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Get rid of any remaining buffers for the fork.  bufmgr will just drop 
     * them without bothering to write the contents. 
     */ 
</span>    <a href="../../../include/storage/bufmgr.h.html#LN193"><span class='Ref_to_Proto'>DropRelFileNodeBuffers</span></a><span class='Parentheses'>(</span><a href="smgr.c.html#LN550"><span class='Ref_To_Local'>rnode</span></a><span class='Delimiter'>, </span><a href="smgr.c.html#LN548"><span class='Ref_to_Parameter'>forknum</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * It'd be nice to tell the stats collector to forget it immediately, too. 
     * But we can't because we don't know the OID (and in cases involving 
     * relfilenode swaps, it's not always clear which table OID to forget, 
     * anyway). 
     */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Send a shared-inval message to force other backends to close any 
     * dangling smgr references they may have for this rel.  We should do this 
     * before starting the actual unlinking, in case we fail partway through 
     * that step.  Note that the sinval message will eventually come back to 
     * this backend, too, and thereby provide a backstop that we closed our 
     * own smgr rel. 
     */ 
</span>    <a href="../../../include/utils/inval.h.html#LN51"><span class='Ref_to_Proto'>CacheInvalidateSmgr</span></a><span class='Parentheses'>(</span><a href="smgr.c.html#LN550"><span class='Ref_To_Local'>rnode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Delete the physical file(s). 
     * 
     * Note: smgr_unlink must treat deletion failure as a WARNING, not an 
     * ERROR, because we've already decided to commit or abort the current 
     * xact. 
     */ 
</span>    <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Parentheses'>(</span><a href="smgr.c.html#LN67"><span class='Ref_to_Global_Var'>smgrsw</span></a><span class='Delimiter'>[</span><a href="smgr.c.html#LN551"><span class='Ref_To_Local'>which</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="smgr.c.html#LN45"><span class='Ref_to_Member'>smgr_unlink</span></a><span class='Parentheses'>))</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN550"><span class='Ref_To_Local'>rnode</span></a><span class='Delimiter'>, </span><a href="smgr.c.html#LN548"><span class='Ref_to_Parameter'>forknum</span></a><span class='Delimiter'>, </span><a href="smgr.c.html#LN548"><span class='Ref_to_Parameter'>isRedo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end smgrdounlinkfork &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *  smgrextend() -- Add a new block to a file. 
 * 
 *      The semantics are nearly the same as smgrwrite(): write at the 
 *      specified position.  However, this is to be used for the case of 
 *      extending a relation (i.e., blocknum is at or beyond the current 
 *      EOF).  Note that we assume writing a block beyond current EOF 
 *      causes intervening file space to become filled with zeroes. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN599"></a><span class='Declare_Function'>smgrextend</span><span class='Parentheses'>(</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> <span class='Declare_Parameter'>reln</span><span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a> <span class='Declare_Parameter'>forknum</span><span class='Delimiter'>, </span><a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Parameter'>blocknum</span><span class='Delimiter'>, 
</span><a name="LN600"></a>           <span class='Keyword'>char </span><span class='Operator'>*</span><span class='Declare_Parameter'>buffer</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>skipFsync</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Parentheses'>(</span><a href="smgr.c.html#LN67"><span class='Ref_to_Global_Var'>smgrsw</span></a><span class='Delimiter'>[</span><a href="smgr.c.html#LN599"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN64"><span class='Ref_to_Member'>smgr_which</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="smgr.c.html#LN47"><span class='Ref_to_Member'>smgr_extend</span></a><span class='Parentheses'>))</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN599"><span class='Ref_to_Parameter'>reln</span></a><span class='Delimiter'>, </span><a href="smgr.c.html#LN599"><span class='Ref_to_Parameter'>forknum</span></a><span class='Delimiter'>, </span><a href="smgr.c.html#LN599"><span class='Ref_to_Parameter'>blocknum</span></a><span class='Delimiter'>, 
</span>                                               <a href="smgr.c.html#LN600"><span class='Ref_to_Parameter'>buffer</span></a><span class='Delimiter'>, </span><a href="smgr.c.html#LN600"><span class='Ref_to_Parameter'>skipFsync</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *  smgrprefetch() -- Initiate asynchronous read of the specified block of a relation. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN610"></a><span class='Declare_Function'>smgrprefetch</span><span class='Parentheses'>(</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> <span class='Declare_Parameter'>reln</span><span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a> <span class='Declare_Parameter'>forknum</span><span class='Delimiter'>, </span><a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Parameter'>blocknum</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Parentheses'>(</span><a href="smgr.c.html#LN67"><span class='Ref_to_Global_Var'>smgrsw</span></a><span class='Delimiter'>[</span><a href="smgr.c.html#LN610"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN64"><span class='Ref_to_Member'>smgr_which</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="smgr.c.html#LN49"><span class='Ref_to_Member'>smgr_prefetch</span></a><span class='Parentheses'>))</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN610"><span class='Ref_to_Parameter'>reln</span></a><span class='Delimiter'>, </span><a href="smgr.c.html#LN610"><span class='Ref_to_Parameter'>forknum</span></a><span class='Delimiter'>, </span><a href="smgr.c.html#LN610"><span class='Ref_to_Parameter'>blocknum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *  smgrread() -- read a particular block from a relation into the supplied 
 *                buffer. 
 * 
 *      This routine is called from the buffer manager in order to 
 *      instantiate pages in the shared buffer cache.  All storage managers 
 *      return pages in the format that POSTGRES expects. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN624"></a><span class='Declare_Function'>smgrread</span><span class='Parentheses'>(</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> <span class='Declare_Parameter'>reln</span><span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a> <span class='Declare_Parameter'>forknum</span><span class='Delimiter'>, </span><a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Parameter'>blocknum</span><span class='Delimiter'>, 
</span><a name="LN625"></a>         <span class='Keyword'>char </span><span class='Operator'>*</span><span class='Declare_Parameter'>buffer</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Parentheses'>(</span><a href="smgr.c.html#LN67"><span class='Ref_to_Global_Var'>smgrsw</span></a><span class='Delimiter'>[</span><a href="smgr.c.html#LN624"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN64"><span class='Ref_to_Member'>smgr_which</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="smgr.c.html#LN51"><span class='Ref_to_Member'>smgr_read</span></a><span class='Parentheses'>))</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN624"><span class='Ref_to_Parameter'>reln</span></a><span class='Delimiter'>, </span><a href="smgr.c.html#LN624"><span class='Ref_to_Parameter'>forknum</span></a><span class='Delimiter'>, </span><a href="smgr.c.html#LN624"><span class='Ref_to_Parameter'>blocknum</span></a><span class='Delimiter'>, </span><a href="smgr.c.html#LN625"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *  smgrwrite() -- Write the supplied buffer out. 
 * 
 *      This is to be used only for updating already-existing blocks of a 
 *      relation (ie, those before the current EOF).  To extend a relation, 
 *      use smgrextend(). 
 * 
 *      This is not a synchronous write -- the block is not necessarily 
 *      on disk at return, only dumped out to the kernel.  However, 
 *      provisions will be made to fsync the write before the next checkpoint. 
 * 
 *      skipFsync indicates that the caller will make other provisions to 
 *      fsync the relation, so we needn't bother.  Temporary relations also 
 *      do not require fsync. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN646"></a><span class='Declare_Function'>smgrwrite</span><span class='Parentheses'>(</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> <span class='Declare_Parameter'>reln</span><span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a> <span class='Declare_Parameter'>forknum</span><span class='Delimiter'>, </span><a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Parameter'>blocknum</span><span class='Delimiter'>, 
</span><a name="LN647"></a>          <span class='Keyword'>char </span><span class='Operator'>*</span><span class='Declare_Parameter'>buffer</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>skipFsync</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Parentheses'>(</span><a href="smgr.c.html#LN67"><span class='Ref_to_Global_Var'>smgrsw</span></a><span class='Delimiter'>[</span><a href="smgr.c.html#LN646"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN64"><span class='Ref_to_Member'>smgr_which</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="smgr.c.html#LN53"><span class='Ref_to_Member'>smgr_write</span></a><span class='Parentheses'>))</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN646"><span class='Ref_to_Parameter'>reln</span></a><span class='Delimiter'>, </span><a href="smgr.c.html#LN646"><span class='Ref_to_Parameter'>forknum</span></a><span class='Delimiter'>, </span><a href="smgr.c.html#LN646"><span class='Ref_to_Parameter'>blocknum</span></a><span class='Delimiter'>, 
</span>                                              <a href="smgr.c.html#LN647"><span class='Ref_to_Parameter'>buffer</span></a><span class='Delimiter'>, </span><a href="smgr.c.html#LN647"><span class='Ref_to_Parameter'>skipFsync</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 *  smgrwriteback() -- Trigger kernel writeback for the supplied range of 
 *                     blocks. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN659"></a><span class='Declare_Function'>smgrwriteback</span><span class='Parentheses'>(</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> <span class='Declare_Parameter'>reln</span><span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a> <span class='Declare_Parameter'>forknum</span><span class='Delimiter'>, </span><a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Parameter'>blocknum</span><span class='Delimiter'>, 
</span><a name="LN660"></a>              <a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Parameter'>nblocks</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Parentheses'>(</span><a href="smgr.c.html#LN67"><span class='Ref_to_Global_Var'>smgrsw</span></a><span class='Delimiter'>[</span><a href="smgr.c.html#LN659"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN64"><span class='Ref_to_Member'>smgr_which</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="smgr.c.html#LN55"><span class='Ref_to_Member'>smgr_writeback</span></a><span class='Parentheses'>))</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN659"><span class='Ref_to_Parameter'>reln</span></a><span class='Delimiter'>, </span><a href="smgr.c.html#LN659"><span class='Ref_to_Parameter'>forknum</span></a><span class='Delimiter'>, </span><a href="smgr.c.html#LN659"><span class='Ref_to_Parameter'>blocknum</span></a><span class='Delimiter'>, 
</span>                                                  <a href="smgr.c.html#LN660"><span class='Ref_to_Parameter'>nblocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *  smgrnblocks() -- Calculate the number of blocks in the 
 *                   supplied relation. 
 */ 
</span><a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> 
<a name="LN671"></a><span class='Declare_Function'>smgrnblocks</span><span class='Parentheses'>(</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> <span class='Declare_Parameter'>reln</span><span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a> <span class='Declare_Parameter'>forknum</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Parentheses'>(</span><a href="smgr.c.html#LN67"><span class='Ref_to_Global_Var'>smgrsw</span></a><span class='Delimiter'>[</span><a href="smgr.c.html#LN671"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN64"><span class='Ref_to_Member'>smgr_which</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="smgr.c.html#LN57"><span class='Ref_to_Member'>smgr_nblocks</span></a><span class='Parentheses'>))</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN671"><span class='Ref_to_Parameter'>reln</span></a><span class='Delimiter'>, </span><a href="smgr.c.html#LN671"><span class='Ref_to_Parameter'>forknum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *  smgrtruncate() -- Truncate supplied relation to the specified number 
 *                    of blocks 
 * 
 * The truncation is done immediately, so this can't be rolled back. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN683"></a><span class='Declare_Function'>smgrtruncate</span><span class='Parentheses'>(</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> <span class='Declare_Parameter'>reln</span><span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a> <span class='Declare_Parameter'>forknum</span><span class='Delimiter'>, </span><a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Parameter'>nblocks</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * Get rid of any buffers for the about-to-be-deleted blocks. bufmgr will 
     * just drop them without bothering to write the contents. 
     */ 
</span>    <a href="../../../include/storage/bufmgr.h.html#LN193"><span class='Ref_to_Proto'>DropRelFileNodeBuffers</span></a><span class='Parentheses'>(</span><a href="smgr.c.html#LN683"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN42"><span class='Ref_to_Member'>smgr_rnode</span></a><span class='Delimiter'>, </span><a href="smgr.c.html#LN683"><span class='Ref_to_Parameter'>forknum</span></a><span class='Delimiter'>, </span><a href="smgr.c.html#LN683"><span class='Ref_to_Parameter'>nblocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Send a shared-inval message to force other backends to close any smgr 
     * references they may have for this rel.  This is useful because they 
     * might have open file pointers to segments that got removed, and/or 
     * smgr_targblock variables pointing past the new rel end.  (The inval 
     * message will come back to our backend, too, causing a 
     * probably-unnecessary local smgr flush.  But we don't expect that this 
     * is a performance-critical path.)  As in the unlink code, we want to be 
     * sure the message is sent before we start changing things on-disk. 
     */ 
</span>    <a href="../../../include/utils/inval.h.html#LN51"><span class='Ref_to_Proto'>CacheInvalidateSmgr</span></a><span class='Parentheses'>(</span><a href="smgr.c.html#LN683"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN42"><span class='Ref_to_Member'>smgr_rnode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Do the truncation. 
     */ 
</span>    <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Parentheses'>(</span><a href="smgr.c.html#LN67"><span class='Ref_to_Global_Var'>smgrsw</span></a><span class='Delimiter'>[</span><a href="smgr.c.html#LN683"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN64"><span class='Ref_to_Member'>smgr_which</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="smgr.c.html#LN58"><span class='Ref_to_Member'>smgr_truncate</span></a><span class='Parentheses'>))</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN683"><span class='Ref_to_Parameter'>reln</span></a><span class='Delimiter'>, </span><a href="smgr.c.html#LN683"><span class='Ref_to_Parameter'>forknum</span></a><span class='Delimiter'>, </span><a href="smgr.c.html#LN683"><span class='Ref_to_Parameter'>nblocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end smgrtruncate &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *  smgrimmedsync() -- Force the specified relation to stable storage. 
 * 
 *      Synchronously force all previous writes to the specified relation 
 *      down to disk. 
 * 
 *      This is useful for building completely new relations (eg, new 
 *      indexes).  Instead of incrementally WAL-logging the index build 
 *      steps, we can just write completed index pages to disk with smgrwrite 
 *      or smgrextend, and then fsync the completed index file before 
 *      committing the transaction.  (This is sufficient for purposes of 
 *      crash recovery, since it effectively duplicates forcing a checkpoint 
 *      for the completed index.  But it is *not* sufficient if one wishes 
 *      to use the WAL log for PITR or replication purposes: in that case 
 *      we have to make WAL entries as well.) 
 * 
 *      The preceding writes should specify skipFsync = true to avoid 
 *      duplicative fsyncs. 
 * 
 *      Note that you need to do FlushRelationBuffers() first if there is 
 *      any possibility that there are dirty buffers for the relation; 
 *      otherwise the sync is not very meaningful. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN733"></a><span class='Declare_Function'>smgrimmedsync</span><span class='Parentheses'>(</span><a href="../../../include/storage/smgr.h.html#LN77"><span class='Ref_to_Typedef'>SMgrRelation</span></a> <span class='Declare_Parameter'>reln</span><span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a> <span class='Declare_Parameter'>forknum</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Parentheses'>(</span><a href="smgr.c.html#LN67"><span class='Ref_to_Global_Var'>smgrsw</span></a><span class='Delimiter'>[</span><a href="smgr.c.html#LN733"><span class='Ref_to_Parameter'>reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN64"><span class='Ref_to_Member'>smgr_which</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="smgr.c.html#LN60"><span class='Ref_to_Member'>smgr_immedsync</span></a><span class='Parentheses'>))</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN733"><span class='Ref_to_Parameter'>reln</span></a><span class='Delimiter'>, </span><a href="smgr.c.html#LN733"><span class='Ref_to_Parameter'>forknum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 *  smgrpreckpt() -- Prepare for checkpoint. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN743"></a><span class='Declare_Function'>smgrpreckpt</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN745"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN745"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="smgr.c.html#LN745"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="smgr.c.html#LN75"><span class='Ref_to_Global_Var'>NSmgr</span></a><span class='Delimiter'>; </span><a href="smgr.c.html#LN745"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN67"><span class='Ref_to_Global_Var'>smgrsw</span></a><span class='Delimiter'>[</span><a href="smgr.c.html#LN745"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="smgr.c.html#LN61"><span class='Ref_to_Member'>smgr_pre_ckpt</span></a><span class='Parentheses'>) 
</span>            <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Parentheses'>(</span><a href="smgr.c.html#LN67"><span class='Ref_to_Global_Var'>smgrsw</span></a><span class='Delimiter'>[</span><a href="smgr.c.html#LN745"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="smgr.c.html#LN61"><span class='Ref_to_Member'>smgr_pre_ckpt</span></a><span class='Parentheses'>))</span> <span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *  smgrsync() -- Sync files to disk during checkpoint. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN758"></a><span class='Declare_Function'>smgrsync</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN760"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN760"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="smgr.c.html#LN760"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="smgr.c.html#LN75"><span class='Ref_to_Global_Var'>NSmgr</span></a><span class='Delimiter'>; </span><a href="smgr.c.html#LN760"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN67"><span class='Ref_to_Global_Var'>smgrsw</span></a><span class='Delimiter'>[</span><a href="smgr.c.html#LN760"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="smgr.c.html#LN62"><span class='Ref_to_Member'>smgr_sync</span></a><span class='Parentheses'>) 
</span>            <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Parentheses'>(</span><a href="smgr.c.html#LN67"><span class='Ref_to_Global_Var'>smgrsw</span></a><span class='Delimiter'>[</span><a href="smgr.c.html#LN760"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="smgr.c.html#LN62"><span class='Ref_to_Member'>smgr_sync</span></a><span class='Parentheses'>))</span> <span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *  smgrpostckpt() -- Post-checkpoint cleanup. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN773"></a><span class='Declare_Function'>smgrpostckpt</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN775"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN775"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="smgr.c.html#LN775"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="smgr.c.html#LN75"><span class='Ref_to_Global_Var'>NSmgr</span></a><span class='Delimiter'>; </span><a href="smgr.c.html#LN775"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN67"><span class='Ref_to_Global_Var'>smgrsw</span></a><span class='Delimiter'>[</span><a href="smgr.c.html#LN775"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="smgr.c.html#LN63"><span class='Ref_to_Member'>smgr_post_ckpt</span></a><span class='Parentheses'>) 
</span>            <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Parentheses'>(</span><a href="smgr.c.html#LN67"><span class='Ref_to_Global_Var'>smgrsw</span></a><span class='Delimiter'>[</span><a href="smgr.c.html#LN775"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="smgr.c.html#LN63"><span class='Ref_to_Member'>smgr_post_ckpt</span></a><span class='Parentheses'>))</span> <span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * AtEOXact_SMgr 
 * 
 * This routine is called during transaction commit or abort (it doesn't 
 * particularly care which).  All transient SMgrRelation objects are closed. 
 * 
 * We do this as a compromise between wanting transient SMgrRelations to 
 * live awhile (to amortize the costs of blind writes of multiple blocks) 
 * and needing them to not live forever (since we're probably holding open 
 * a kernel file descriptor for the underlying file, and we need to ensure 
 * that gets closed reasonably soon if the file gets deleted). 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN797"></a><span class='Declare_Function'>AtEOXact_SMgr</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * Zap all unowned SMgrRelations.  We rely on smgrclose() to remove each 
     * one from the list. 
     */ 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="smgr.c.html#LN84"><span class='Ref_to_Global_Var'>first_unowned_reln</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="smgr.c.html#LN84"><span class='Ref_to_Global_Var'>first_unowned_reln</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN45"><span class='Ref_to_Member'>smgr_owner</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/smgr.h.html#LN87"><span class='Ref_to_Proto'>smgrclose</span></a><span class='Parentheses'>(</span><a href="smgr.c.html#LN84"><span class='Ref_to_Global_Var'>first_unowned_reln</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
} 
</span></pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>