<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\tsearch\ts_typanalyze.c</title>
<LINK REL=StyleSheet HREF="../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\tsearch\ts_typanalyze.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:50 2017
</td></tr>
<tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * ts_typanalyze.c 
 *    functions for gathering statistics from tsvector columns 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * 
 * 
 * IDENTIFICATION 
 *    src/backend/tsearch/ts_typanalyze.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/hash.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_operator.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"commands/vacuum.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"tsearch/ts_type.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/builtins.h"</span> 
 
 
<span class='Comment_Multi_Line'>/* A hash key for lexemes */ 
</span><span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN25"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>lexeme</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* lexeme (not NULL terminated!) */ 
</span><a name="LN26"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>length</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* its length in bytes */ 
</span><a name="LN27"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>LexemeHashKey</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* A hash table entry for the Lossy Counting algorithm */ 
</span><span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN32"></a>    <a href="ts_typanalyze.c.html#LN23"><span class='Ref_to_Typedef'>LexemeHashKey</span></a> <span class='Declare_Member'>key</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* This is 'e' from the LC algorithm. */ 
</span><a name="LN33"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>frequency</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* This is 'f'. */ 
</span><a name="LN34"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>delta</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* And this is 'delta'. */ 
</span><a name="LN35"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>TrackItem</span><span class='Delimiter'>; 
</span> 
<a name="LN37"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>compute_tsvector_stats</span><span class='Parentheses'>(</span><a href="../../include/commands/vacuum.h.html#LN68"><span class='Ref_to_Struct'>VacAttrStats</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stats</span><span class='Delimiter'>, 
</span><a name="LN38"></a>                       <a href="../../include/commands/vacuum.h.html#LN60"><span class='Ref_to_Typedef'>AnalyzeAttrFetchFunc</span></a> <span class='Declare_Parameter'>fetchfunc</span><span class='Delimiter'>, 
</span><a name="LN39"></a>                       <span class='Keyword'>int </span><span class='Declare_Parameter'>samplerows</span><span class='Delimiter'>, 
</span><a name="LN40"></a>                       <span class='Keyword'>double </span><span class='Declare_Parameter'>totalrows</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN41"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>prune_lexemes_hashtable</span><span class='Parentheses'>(</span><a href="../utils/hash/dynahash.c.html#LN192"><span class='Ref_to_Struct'>HTAB</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>lexemes_tab</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>b_current</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN42"></a><span class='Keyword'>static </span><a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Prototype'>lexeme_hash</span><span class='Parentheses'>(</span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>key</span><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a> <span class='Declare_Parameter'>keysize</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN43"></a><span class='Keyword'>static int</span>  <span class='Declare_Prototype'>lexeme_match</span><span class='Parentheses'>(</span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>key1</span><span class='Delimiter'>, </span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>key2</span><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a> <span class='Declare_Parameter'>keysize</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN44"></a><span class='Keyword'>static int</span>  <span class='Declare_Prototype'>lexeme_compare</span><span class='Parentheses'>(</span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>key1</span><span class='Delimiter'>, </span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>key2</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN45"></a><span class='Keyword'>static int</span>  <span class='Declare_Prototype'>trackitem_compare_frequencies_desc</span><span class='Parentheses'>(</span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>e1</span><span class='Delimiter'>, </span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>e2</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN46"></a><span class='Keyword'>static int</span>  <span class='Declare_Prototype'>trackitem_compare_lexemes</span><span class='Parentheses'>(</span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>e1</span><span class='Delimiter'>, </span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>e2</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 *  ts_typanalyze -- a custom typanalyze function for tsvector columns 
 */ 
</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN53"></a><span class='Declare_Function'>ts_typanalyze</span><span class='Parentheses'>(</span><a href="../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN55"></a>    <a href="../../include/commands/vacuum.h.html#LN68"><span class='Ref_to_Struct'>VacAttrStats</span></a> <span class='Operator'>*</span><span class='Declare_Local'>stats</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/commands/vacuum.h.html#LN68"><span class='Ref_to_Struct'>VacAttrStats</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/fmgr.h.html#LN240"><span class='Ref_to_Macro'>PG_GETARG_POINTER</span></a><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN56"></a>    <a href="../../include/catalog/pg_attribute.h.html#LN186"><span class='Ref_to_Typedef'>Form_pg_attribute</span></a> <span class='Declare_Local'>attr</span> <span class='Operator'>= </span><a href="ts_typanalyze.c.html#LN55"><span class='Ref_To_Local'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/vacuum.h.html#LN80"><span class='Ref_to_Member'>attr</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If the attstattarget column is negative, use the default value */ 
</span>    <span class='Comment_Multi_Line'>/* NB: it is okay to scribble on stats-&GT;attr since it's a copy */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="ts_typanalyze.c.html#LN56"><span class='Ref_To_Local'>attr</span></a><span class='Operator'>-&GT;</span>attstattarget <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="ts_typanalyze.c.html#LN56"><span class='Ref_To_Local'>attr</span></a><span class='Operator'>-&GT;</span>attstattarget <span class='Operator'>= </span><a href="../commands/analyze.c.html#LN76"><span class='Ref_to_Global_Var'>default_statistics_target</span></a><span class='Delimiter'>; 
</span> 
    <a href="ts_typanalyze.c.html#LN55"><span class='Ref_To_Local'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/vacuum.h.html#LN90"><span class='Ref_to_Member'>compute_stats</span></a> <span class='Operator'>= </span><a href="ts_typanalyze.c.html#LN37"><span class='Ref_to_Proto'>compute_tsvector_stats</span></a><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* see comment about the choice of minrows in commands/analyze.c */ 
</span>    <a href="ts_typanalyze.c.html#LN55"><span class='Ref_To_Local'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/vacuum.h.html#LN91"><span class='Ref_to_Member'>minrows</span></a> <span class='Operator'>= </span><span class='Number'>300</span> <span class='Operator'>* </span><a href="ts_typanalyze.c.html#LN56"><span class='Ref_To_Local'>attr</span></a><span class='Operator'>-&GT;</span>attstattarget<span class='Delimiter'>; 
</span> 
    <a href="../../include/fmgr.h.html#LN318"><span class='Ref_to_Macro'>PG_RETURN_BOOL</span></a><span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *  compute_tsvector_stats() -- compute statistics for a tsvector column 
 * 
 *  This functions computes statistics that are useful for determining @@ 
 *  operations' selectivity, along with the fraction of non-null rows and 
 *  average width. 
 * 
 *  Instead of finding the most common values, as we do for most datatypes, 
 *  we're looking for the most common lexemes. This is more useful, because 
 *  there most probably won't be any two rows with the same tsvector and thus 
 *  the notion of a MCV is a bit bogus with this datatype. With a list of the 
 *  most common lexemes we can do a better job at figuring out @@ selectivity. 
 * 
 *  For the same reasons we assume that tsvector columns are unique when 
 *  determining the number of distinct values. 
 * 
 *  The algorithm used is Lossy Counting, as proposed in the paper "Approximate 
 *  frequency counts over data streams" by G. S. Manku and R. Motwani, in 
 *  Proceedings of the 28th International Conference on Very Large Data Bases, 
 *  Hong Kong, China, August 2002, section 4.2. The paper is available at 
 *  http://www.vldb.org/conf/2002/S10P03.pdf 
 * 
 *  The Lossy Counting (aka LC) algorithm goes like this: 
 *  Let s be the threshold frequency for an item (the minimum frequency we 
 *  are interested in) and epsilon the error margin for the frequency. Let D 
 *  be a set of triples (e, f, delta), where e is an element value, f is that 
 *  element's frequency (actually, its current occurrence count) and delta is 
 *  the maximum error in f. We start with D empty and process the elements in 
 *  batches of size w. (The batch size is also known as "bucket size" and is 
 *  equal to 1/epsilon.) Let the current batch number be b_current, starting 
 *  with 1. For each element e we either increment its f count, if it's 
 *  already in D, or insert a new triple into D with values (e, 1, b_current 
 *  - 1). After processing each batch we prune D, by removing from it all 
 *  elements with f + delta &LT;= b_current.  After the algorithm finishes we 
 *  suppress all elements from D that do not satisfy f &GT;= (s - epsilon) * N, 
 *  where N is the total number of elements in the input.  We emit the 
 *  remaining elements with estimated frequency f/N.  The LC paper proves 
 *  that this algorithm finds all elements with true frequency at least s, 
 *  and that no frequency is overestimated or is underestimated by more than 
 *  epsilon.  Furthermore, given reasonable assumptions about the input 
 *  distribution, the required table size is no more than about 7 times w. 
 * 
 *  We set s to be the estimated frequency of the K'th word in a natural 
 *  language's frequency table, where K is the target number of entries in 
 *  the MCELEM array plus an arbitrary constant, meant to reflect the fact 
 *  that the most common words in any language would usually be stopwords 
 *  so we will not actually see them in the input.  We assume that the 
 *  distribution of word frequencies (including the stopwords) follows Zipf's 
 *  law with an exponent of 1. 
 * 
 *  Assuming Zipfian distribution, the frequency of the K'th word is equal 
 *  to 1/(K * H(W)) where H(n) is 1/2 + 1/3 + ... + 1/n and W is the number of 
 *  words in the language.  Putting W as one million, we get roughly 0.07/K. 
 *  Assuming top 10 words are stopwords gives s = 0.07/(K + 10).  We set 
 *  epsilon = s/10, which gives bucket width w = (K + 10)/0.007 and 
 *  maximum expected hashtable size of about 1000 * (K + 10). 
 * 
 *  Note: in the above discussion, s, epsilon, and f/N are in terms of a 
 *  lexeme's frequency as a fraction of all lexemes seen in the input. 
 *  However, what we actually want to store in the finished pg_statistic 
 *  entry is each lexeme's frequency as a fraction of all rows that it occurs 
 *  in.  Assuming that the input tsvectors are correctly constructed, no 
 *  lexeme occurs more than once per tsvector, so the final count f is a 
 *  correct estimate of the number of input tsvectors it occurs in, and we 
 *  need only change the divisor from N to nonnull_cnt to get the number we 
 *  want. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN138"></a><span class='Declare_Function'>compute_tsvector_stats</span><span class='Parentheses'>(</span><a href="../../include/commands/vacuum.h.html#LN68"><span class='Ref_to_Struct'>VacAttrStats</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stats</span><span class='Delimiter'>, 
</span><a name="LN139"></a>                       <a href="../../include/commands/vacuum.h.html#LN60"><span class='Ref_to_Typedef'>AnalyzeAttrFetchFunc</span></a> <span class='Declare_Parameter'>fetchfunc</span><span class='Delimiter'>, 
</span><a name="LN140"></a>                       <span class='Keyword'>int </span><span class='Declare_Parameter'>samplerows</span><span class='Delimiter'>, 
</span><a name="LN141"></a>                       <span class='Keyword'>double </span><span class='Declare_Parameter'>totalrows</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN143"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>num_mcelem</span><span class='Delimiter'>; 
</span><a name="LN144"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>null_cnt</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN145"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>total_width</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* This is D from the LC algorithm. */ 
</span><a name="LN148"></a>    <a href="../utils/hash/dynahash.c.html#LN192"><span class='Ref_to_Struct'>HTAB</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>lexemes_tab</span><span class='Delimiter'>; 
</span><a name="LN149"></a>    <a href="../../include/utils/hsearch.h.html#LN64"><span class='Ref_to_Struct'>HASHCTL</span></a>     <span class='Declare_Local'>hash_ctl</span><span class='Delimiter'>; 
</span><a name="LN150"></a>    <a href="../../include/utils/hsearch.h.html#LN111"><span class='Ref_to_Typedef'>HASH_SEQ_STATUS</span></a> <span class='Declare_Local'>scan_status</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* This is the current bucket number from the LC algorithm */ 
</span><a name="LN153"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>b_current</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* This is 'w' from the LC algorithm */ 
</span><a name="LN156"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>bucket_width</span><span class='Delimiter'>; 
</span><a name="LN157"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>vector_no</span><span class='Delimiter'>, 
</span><a name="LN158"></a>                <span class='Declare_Local'>lexeme_no</span><span class='Delimiter'>; 
</span><a name="LN159"></a>    <a href="ts_typanalyze.c.html#LN23"><span class='Ref_to_Typedef'>LexemeHashKey</span></a> <span class='Declare_Local'>hash_key</span><span class='Delimiter'>; 
</span><a name="LN160"></a>    <a href="../utils/adt/array_typanalyze.c.html#LN67"><span class='Ref_to_Typedef'>TrackItem</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>item</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We want statistics_target * 10 lexemes in the MCELEM array.  This 
     * multiplier is pretty arbitrary, but is meant to reflect the fact that 
     * the number of individual lexeme values tracked in pg_statistic ought to 
     * be more than the number of values for a simple scalar column. 
     */ 
</span>    <a href="ts_typanalyze.c.html#LN143"><span class='Ref_To_Local'>num_mcelem</span></a> <span class='Operator'>= </span><a href="ts_typanalyze.c.html#LN138"><span class='Ref_to_Parameter'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/vacuum.h.html#LN80"><span class='Ref_to_Member'>attr</span></a><span class='Operator'>-&GT;</span>attstattarget <span class='Operator'>* </span><span class='Number'>10</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We set bucket width equal to (num_mcelem + 10) / 0.007 as per the 
     * comment above. 
     */ 
</span>    <a href="ts_typanalyze.c.html#LN156"><span class='Ref_To_Local'>bucket_width</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="ts_typanalyze.c.html#LN143"><span class='Ref_To_Local'>num_mcelem</span></a> <span class='Operator'>+ </span><span class='Number'>10</span><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Number'>1000</span> <span class='Operator'>/ </span><span class='Number'>7</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Create the hashtable. It will be in local memory, so we don't need to 
     * worry about overflowing the initial size. Also we don't need to pay any 
     * attention to locking and memory management. 
     */ 
</span>    <a href="../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="ts_typanalyze.c.html#LN149"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="ts_typanalyze.c.html#LN149"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="ts_typanalyze.c.html#LN149"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Operator'>.</span><a href="../../include/utils/hsearch.h.html#LN71"><span class='Ref_to_Member'>keysize</span></a> <span class='Operator'>= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="ts_typanalyze.c.html#LN23"><span class='Ref_to_Typedef'>LexemeHashKey</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="ts_typanalyze.c.html#LN149"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Operator'>.</span><a href="../../include/utils/hsearch.h.html#LN72"><span class='Ref_to_Member'>entrysize</span></a> <span class='Operator'>= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../utils/adt/array_typanalyze.c.html#LN67"><span class='Ref_to_Typedef'>TrackItem</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="ts_typanalyze.c.html#LN149"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Operator'>.</span><a href="../../include/utils/hsearch.h.html#LN73"><span class='Ref_to_Member'>hash</span></a> <span class='Operator'>= </span><a href="ts_typanalyze.c.html#LN42"><span class='Ref_to_Proto'>lexeme_hash</span></a><span class='Delimiter'>; 
</span>    <a href="ts_typanalyze.c.html#LN149"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Operator'>.</span><a href="../../include/utils/hsearch.h.html#LN74"><span class='Ref_to_Member'>match</span></a> <span class='Operator'>= </span><a href="ts_typanalyze.c.html#LN43"><span class='Ref_to_Proto'>lexeme_match</span></a><span class='Delimiter'>; 
</span>    <a href="ts_typanalyze.c.html#LN149"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Operator'>.</span><a href="../../include/utils/hsearch.h.html#LN77"><span class='Ref_to_Member'>hcxt</span></a> <span class='Operator'>= </span><a href="../utils/mmgr/mcxt.c.html#LN36"><span class='Ref_to_Global_Var'>CurrentMemoryContext</span></a><span class='Delimiter'>; 
</span>    <a href="ts_typanalyze.c.html#LN148"><span class='Ref_To_Local'>lexemes_tab</span></a> <span class='Operator'>= </span><a href="../../include/utils/hsearch.h.html#LN121"><span class='Ref_to_Proto'>hash_create</span></a><span class='Parentheses'>(</span><span class='String'>"Analyzed lexemes table"</span><span class='Delimiter'>, 
</span>                              <a href="ts_typanalyze.c.html#LN143"><span class='Ref_To_Local'>num_mcelem</span></a><span class='Delimiter'>, 
</span>                              <span class='Operator'>&</span><a href="ts_typanalyze.c.html#LN149"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Delimiter'>, 
</span>                    <a href="../../include/utils/hsearch.h.html#LN86"><span class='Ref_to_Const'>HASH_ELEM</span></a> <span class='Operator'>| </span><a href="../../include/utils/hsearch.h.html#LN88"><span class='Ref_to_Const'>HASH_FUNCTION</span></a> <span class='Operator'>| </span><a href="../../include/utils/hsearch.h.html#LN89"><span class='Ref_to_Const'>HASH_COMPARE</span></a> <span class='Operator'>| </span><a href="../../include/utils/hsearch.h.html#LN92"><span class='Ref_to_Const'>HASH_CONTEXT</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Initialize counters. */ 
</span>    <a href="ts_typanalyze.c.html#LN153"><span class='Ref_To_Local'>b_current</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <a href="ts_typanalyze.c.html#LN158"><span class='Ref_To_Local'>lexeme_no</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Loop over the tsvectors. */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="ts_typanalyze.c.html#LN157"><span class='Ref_To_Local'>vector_no</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="ts_typanalyze.c.html#LN157"><span class='Ref_To_Local'>vector_no</span></a> <span class='Operator'>&LT; </span><a href="ts_typanalyze.c.html#LN140"><span class='Ref_to_Parameter'>samplerows</span></a><span class='Delimiter'>; </span><a href="ts_typanalyze.c.html#LN157"><span class='Ref_To_Local'>vector_no</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN199"></a>        <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>value</span><span class='Delimiter'>; 
</span><a name="LN200"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>isnull</span><span class='Delimiter'>; 
</span><a name="LN201"></a>        <a href="../../include/tsearch/ts_type.h.html#LN106"><span class='Ref_to_Typedef'>TSVector</span></a>    <span class='Declare_Local'>vector</span><span class='Delimiter'>; 
</span><a name="LN202"></a>        <a href="../../include/tsearch/ts_type.h.html#LN40"><span class='Ref_to_Typedef'>WordEntry</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>curentryptr</span><span class='Delimiter'>; 
</span><a name="LN203"></a>        <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>lexemesptr</span><span class='Delimiter'>; 
</span><a name="LN204"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>j</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/commands/vacuum.h.html#LN188"><span class='Ref_to_Proto'>vacuum_delay_point</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Keyword'>value </span><span class='Operator'>= </span><a href="ts_typanalyze.c.html#LN139"><span class='Ref_to_Parameter'>fetchfunc</span></a><span class='Parentheses'>(</span><a href="ts_typanalyze.c.html#LN138"><span class='Ref_to_Parameter'>stats</span></a><span class='Delimiter'>, </span><a href="ts_typanalyze.c.html#LN157"><span class='Ref_To_Local'>vector_no</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="ts_typanalyze.c.html#LN200"><span class='Ref_To_Local'>isnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Check for null/nonnull. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="ts_typanalyze.c.html#LN200"><span class='Ref_To_Local'>isnull</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="ts_typanalyze.c.html#LN144"><span class='Ref_To_Local'>null_cnt</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Add up widths for average-width calculation.  Since it's a 
         * tsvector, we know it's varlena.  As in the regular 
         * compute_minimal_stats function, we use the toasted width for this 
         * calculation. 
         */ 
</span>        <a href="ts_typanalyze.c.html#LN145"><span class='Ref_To_Local'>total_width</span></a> <span class='Operator'>+= </span><a href="../../include/postgres.h.html#LN333"><span class='Ref_to_Macro'>VARSIZE_ANY</span></a><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><span class='Keyword'>value</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Now detoast the tsvector if needed. 
         */ 
</span>        <a href="ts_typanalyze.c.html#LN201"><span class='Ref_To_Local'>vector</span></a> <span class='Operator'>= </span><a href="../../include/tsearch/ts_type.h.html#LN125"><span class='Ref_to_Macro'>DatumGetTSVector</span></a><span class='Parentheses'>(</span><span class='Keyword'>value</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We loop through the lexemes in the tsvector and add them to our 
         * tracking hashtable.  Note: the hashtable entries will point into 
         * the (detoasted) tsvector value, therefore we cannot free that 
         * storage until we're done. 
         */ 
</span>        <a href="ts_typanalyze.c.html#LN203"><span class='Ref_To_Local'>lexemesptr</span></a> <span class='Operator'>= </span><a href="../../../contrib/hstore/hstore.h.html#LN75"><span class='Ref_to_Macro'>STRPTR</span></a><span class='Parentheses'>(</span><a href="ts_typanalyze.c.html#LN201"><span class='Ref_To_Local'>vector</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="ts_typanalyze.c.html#LN202"><span class='Ref_To_Local'>curentryptr</span></a> <span class='Operator'>= </span><a href="../../../contrib/intarray/_int.h.html#LN13"><span class='Ref_to_Macro'>ARRPTR</span></a><span class='Parentheses'>(</span><a href="ts_typanalyze.c.html#LN201"><span class='Ref_To_Local'>vector</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="ts_typanalyze.c.html#LN204"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="ts_typanalyze.c.html#LN204"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>&LT; </span><a href="ts_typanalyze.c.html#LN201"><span class='Ref_To_Local'>vector</span></a><span class='Operator'>-&GT;</span><a href="../../include/tsearch/ts_type.h.html#LN101"><span class='Ref_to_Member'>size</span></a><span class='Delimiter'>; </span><a href="ts_typanalyze.c.html#LN204"><span class='Ref_To_Local'>j</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN242"></a>            <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Construct a hash key */ 
</span>            <a href="ts_typanalyze.c.html#LN159"><span class='Ref_To_Local'>hash_key</span></a><span class='Operator'>.</span><a href="ts_typanalyze.c.html#LN25"><span class='Ref_to_Member'>lexeme</span></a> <span class='Operator'>= </span><a href="ts_typanalyze.c.html#LN203"><span class='Ref_To_Local'>lexemesptr</span></a> <span class='Operator'>+ </span><a href="ts_typanalyze.c.html#LN202"><span class='Ref_To_Local'>curentryptr</span></a><span class='Operator'>-&GT;</span><a href="../../include/tsearch/ts_type.h.html#LN45"><span class='Ref_to_Member'>pos</span></a><span class='Delimiter'>; 
</span>            <a href="ts_typanalyze.c.html#LN159"><span class='Ref_To_Local'>hash_key</span></a><span class='Operator'>.</span><a href="ts_typanalyze.c.html#LN26"><span class='Ref_to_Member'>length</span></a> <span class='Operator'>= </span><a href="ts_typanalyze.c.html#LN202"><span class='Ref_To_Local'>curentryptr</span></a><span class='Operator'>-&GT;</span><a href="../../include/tsearch/ts_type.h.html#LN44"><span class='Ref_to_Member'>len</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Lookup current lexeme in hashtable, adding it if new */ 
</span>            <a href="ts_typanalyze.c.html#LN160"><span class='Ref_To_Local'>item</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../utils/adt/array_typanalyze.c.html#LN67"><span class='Ref_to_Typedef'>TrackItem</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/utils/hsearch.h.html#LN125"><span class='Ref_to_Proto'>hash_search</span></a><span class='Parentheses'>(</span><a href="ts_typanalyze.c.html#LN148"><span class='Ref_To_Local'>lexemes_tab</span></a><span class='Delimiter'>, 
</span>                                             <span class='Parentheses'>(</span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="ts_typanalyze.c.html#LN159"><span class='Ref_To_Local'>hash_key</span></a><span class='Delimiter'>, 
</span>                                             <a href="../../include/utils/hsearch.h.html#LN105"><span class='Ref_to_EnumConst'>HASH_ENTER</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="ts_typanalyze.c.html#LN242"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="ts_typanalyze.c.html#LN242"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* The lexeme is already on the tracking list */ 
</span>                <a href="ts_typanalyze.c.html#LN160"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><a href="ts_typanalyze.c.html#LN33"><span class='Ref_to_Member'>frequency</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Initialize new tracking list element */ 
</span>                <a href="ts_typanalyze.c.html#LN160"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><a href="ts_typanalyze.c.html#LN33"><span class='Ref_to_Member'>frequency</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>                <a href="ts_typanalyze.c.html#LN160"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><a href="ts_typanalyze.c.html#LN34"><span class='Ref_to_Member'>delta</span></a> <span class='Operator'>= </span><a href="ts_typanalyze.c.html#LN153"><span class='Ref_To_Local'>b_current</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* lexeme_no is the number of elements processed (ie N) */ 
</span>            <a href="ts_typanalyze.c.html#LN158"><span class='Ref_To_Local'>lexeme_no</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* We prune the D structure after processing each bucket */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="ts_typanalyze.c.html#LN158"><span class='Ref_To_Local'>lexeme_no</span></a> <span class='Operator'>% </span><a href="ts_typanalyze.c.html#LN156"><span class='Ref_To_Local'>bucket_width</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="ts_typanalyze.c.html#LN41"><span class='Ref_to_Proto'>prune_lexemes_hashtable</span></a><span class='Parentheses'>(</span><a href="ts_typanalyze.c.html#LN148"><span class='Ref_To_Local'>lexemes_tab</span></a><span class='Delimiter'>, </span><a href="ts_typanalyze.c.html#LN153"><span class='Ref_To_Local'>b_current</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="ts_typanalyze.c.html#LN153"><span class='Ref_To_Local'>b_current</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* Advance to the next WordEntry in the tsvector */ 
</span>            <a href="ts_typanalyze.c.html#LN202"><span class='Ref_To_Local'>curentryptr</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for j=0;j&LT;vector-&GT;size;j+... &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for vector_no=0;vector_no... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* We can only compute real stats if we found some non-null values. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="ts_typanalyze.c.html#LN144"><span class='Ref_To_Local'>null_cnt</span></a> <span class='Operator'>&LT; </span><a href="ts_typanalyze.c.html#LN140"><span class='Ref_to_Parameter'>samplerows</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN283"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>nonnull_cnt</span> <span class='Operator'>= </span><a href="ts_typanalyze.c.html#LN140"><span class='Ref_to_Parameter'>samplerows</span></a> <span class='Operator'>- </span><a href="ts_typanalyze.c.html#LN144"><span class='Ref_To_Local'>null_cnt</span></a><span class='Delimiter'>; 
</span><a name="LN284"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN285"></a>        <a href="../utils/adt/array_typanalyze.c.html#LN67"><span class='Ref_to_Typedef'>TrackItem</span></a> <span class='Operator'>**</span><span class='Declare_Local'>sort_table</span><span class='Delimiter'>; 
</span><a name="LN286"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>track_len</span><span class='Delimiter'>; 
</span><a name="LN287"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>cutoff_freq</span><span class='Delimiter'>; 
</span><a name="LN288"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>minfreq</span><span class='Delimiter'>, 
</span><a name="LN289"></a>                    <span class='Declare_Local'>maxfreq</span><span class='Delimiter'>; 
</span> 
        <a href="ts_typanalyze.c.html#LN138"><span class='Ref_to_Parameter'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/vacuum.h.html#LN98"><span class='Ref_to_Member'>stats_valid</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Do the simple null-frac and average width stats */ 
</span>        <a href="ts_typanalyze.c.html#LN138"><span class='Ref_to_Parameter'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/vacuum.h.html#LN99"><span class='Ref_to_Member'>stanullfrac</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="ts_typanalyze.c.html#LN144"><span class='Ref_To_Local'>null_cnt</span></a> <span class='Operator'>/ </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="ts_typanalyze.c.html#LN140"><span class='Ref_to_Parameter'>samplerows</span></a><span class='Delimiter'>; 
</span>        <a href="ts_typanalyze.c.html#LN138"><span class='Ref_to_Parameter'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/vacuum.h.html#LN100"><span class='Ref_to_Member'>stawidth</span></a> <span class='Operator'>= </span><a href="ts_typanalyze.c.html#LN145"><span class='Ref_To_Local'>total_width</span></a> <span class='Operator'>/ </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="ts_typanalyze.c.html#LN283"><span class='Ref_To_Local'>nonnull_cnt</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Assume it's a unique column (see notes above) */ 
</span>        <a href="ts_typanalyze.c.html#LN138"><span class='Ref_to_Parameter'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/vacuum.h.html#LN101"><span class='Ref_to_Member'>stadistinct</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>* </span><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="ts_typanalyze.c.html#LN138"><span class='Ref_to_Parameter'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/vacuum.h.html#LN99"><span class='Ref_to_Member'>stanullfrac</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Construct an array of the interesting hashtable items, that is, 
         * those meeting the cutoff frequency (s - epsilon)*N.  Also identify 
         * the minimum and maximum frequencies among these items. 
         * 
         * Since epsilon = s/10 and bucket_width = 1/epsilon, the cutoff 
         * frequency is 9*N / bucket_width. 
         */ 
</span>        <a href="ts_typanalyze.c.html#LN287"><span class='Ref_To_Local'>cutoff_freq</span></a> <span class='Operator'>= </span><span class='Number'>9</span> <span class='Operator'>* </span><a href="ts_typanalyze.c.html#LN158"><span class='Ref_To_Local'>lexeme_no</span></a> <span class='Operator'>/ </span><a href="ts_typanalyze.c.html#LN156"><span class='Ref_To_Local'>bucket_width</span></a><span class='Delimiter'>; 
</span> 
        <a href="ts_typanalyze.c.html#LN284"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><a href="../../include/utils/hsearch.h.html#LN133"><span class='Ref_to_Proto'>hash_get_num_entries</span></a><span class='Parentheses'>(</span><a href="ts_typanalyze.c.html#LN148"><span class='Ref_To_Local'>lexemes_tab</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* surely enough space */ 
</span>        <a href="ts_typanalyze.c.html#LN285"><span class='Ref_To_Local'>sort_table</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../utils/adt/array_typanalyze.c.html#LN67"><span class='Ref_to_Typedef'>TrackItem</span></a> <span class='Operator'>**</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../utils/adt/array_typanalyze.c.html#LN67"><span class='Ref_to_Typedef'>TrackItem</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="ts_typanalyze.c.html#LN284"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/utils/hsearch.h.html#LN134"><span class='Ref_to_Proto'>hash_seq_init</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="ts_typanalyze.c.html#LN150"><span class='Ref_To_Local'>scan_status</span></a><span class='Delimiter'>, </span><a href="ts_typanalyze.c.html#LN148"><span class='Ref_To_Local'>lexemes_tab</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="ts_typanalyze.c.html#LN286"><span class='Ref_To_Local'>track_len</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="ts_typanalyze.c.html#LN288"><span class='Ref_To_Local'>minfreq</span></a> <span class='Operator'>= </span><a href="ts_typanalyze.c.html#LN158"><span class='Ref_To_Local'>lexeme_no</span></a><span class='Delimiter'>; 
</span>        <a href="ts_typanalyze.c.html#LN289"><span class='Ref_To_Local'>maxfreq</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <span class='Control'>while</span> <span class='Parentheses'>((</span><a href="ts_typanalyze.c.html#LN160"><span class='Ref_To_Local'>item</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../utils/adt/array_typanalyze.c.html#LN67"><span class='Ref_to_Typedef'>TrackItem</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/utils/hsearch.h.html#LN135"><span class='Ref_to_Proto'>hash_seq_search</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="ts_typanalyze.c.html#LN150"><span class='Ref_To_Local'>scan_status</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="ts_typanalyze.c.html#LN160"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><a href="ts_typanalyze.c.html#LN33"><span class='Ref_to_Member'>frequency</span></a> <span class='Operator'>&GT; </span><a href="ts_typanalyze.c.html#LN287"><span class='Ref_To_Local'>cutoff_freq</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="ts_typanalyze.c.html#LN285"><span class='Ref_To_Local'>sort_table</span></a><span class='Delimiter'>[</span><a href="ts_typanalyze.c.html#LN286"><span class='Ref_To_Local'>track_len</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="ts_typanalyze.c.html#LN160"><span class='Ref_To_Local'>item</span></a><span class='Delimiter'>; 
</span>                <a href="ts_typanalyze.c.html#LN288"><span class='Ref_To_Local'>minfreq</span></a> <span class='Operator'>= </span><a href="../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN11"><span class='Ref_to_Macro'>Min</span></a><span class='Parentheses'>(</span><a href="ts_typanalyze.c.html#LN288"><span class='Ref_To_Local'>minfreq</span></a><span class='Delimiter'>, </span><a href="ts_typanalyze.c.html#LN160"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><a href="ts_typanalyze.c.html#LN33"><span class='Ref_to_Member'>frequency</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="ts_typanalyze.c.html#LN289"><span class='Ref_To_Local'>maxfreq</span></a> <span class='Operator'>= </span><a href="../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN10"><span class='Ref_to_Macro'>Max</span></a><span class='Parentheses'>(</span><a href="ts_typanalyze.c.html#LN289"><span class='Ref_To_Local'>maxfreq</span></a><span class='Delimiter'>, </span><a href="ts_typanalyze.c.html#LN160"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><a href="ts_typanalyze.c.html#LN33"><span class='Ref_to_Member'>frequency</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="ts_typanalyze.c.html#LN286"><span class='Ref_To_Local'>track_len</span></a> <span class='Operator'>&LT;= </span><a href="ts_typanalyze.c.html#LN284"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* emit some statistics for debug purposes */ 
</span>        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN22"><span class='Ref_to_Const'>DEBUG3</span></a><span class='Delimiter'>, </span><span class='String'>"tsvector_stats: target # mces = %d, bucket width = %d, "</span> 
             <span class='String'>"# lexemes = %d, hashtable size = %d, usable entries = %d"</span><span class='Delimiter'>, 
</span>             <a href="ts_typanalyze.c.html#LN143"><span class='Ref_To_Local'>num_mcelem</span></a><span class='Delimiter'>, </span><a href="ts_typanalyze.c.html#LN156"><span class='Ref_To_Local'>bucket_width</span></a><span class='Delimiter'>, </span><a href="ts_typanalyze.c.html#LN158"><span class='Ref_To_Local'>lexeme_no</span></a><span class='Delimiter'>, </span><a href="ts_typanalyze.c.html#LN284"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>, </span><a href="ts_typanalyze.c.html#LN286"><span class='Ref_To_Local'>track_len</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If we obtained more lexemes than we really want, get rid of those 
         * with least frequencies.  The easiest way is to qsort the array into 
         * descending frequency order and truncate the array. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="ts_typanalyze.c.html#LN143"><span class='Ref_To_Local'>num_mcelem</span></a> <span class='Operator'>&LT; </span><a href="ts_typanalyze.c.html#LN286"><span class='Ref_To_Local'>track_len</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../include/port.h.html#LN439"><span class='Ref_to_Macro'>qsort</span></a><span class='Parentheses'>(</span><a href="ts_typanalyze.c.html#LN285"><span class='Ref_To_Local'>sort_table</span></a><span class='Delimiter'>, </span><a href="ts_typanalyze.c.html#LN286"><span class='Ref_To_Local'>track_len</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../utils/adt/array_typanalyze.c.html#LN67"><span class='Ref_to_Typedef'>TrackItem</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                  <a href="ts_typanalyze.c.html#LN45"><span class='Ref_to_Proto'>trackitem_compare_frequencies_desc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* reset minfreq to the smallest frequency we're keeping */ 
</span>            <a href="ts_typanalyze.c.html#LN288"><span class='Ref_To_Local'>minfreq</span></a> <span class='Operator'>= </span><a href="ts_typanalyze.c.html#LN285"><span class='Ref_To_Local'>sort_table</span></a><span class='Delimiter'>[</span><a href="ts_typanalyze.c.html#LN143"><span class='Ref_To_Local'>num_mcelem</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Operator'>-&GT;</span><a href="ts_typanalyze.c.html#LN33"><span class='Ref_to_Member'>frequency</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <a href="ts_typanalyze.c.html#LN143"><span class='Ref_To_Local'>num_mcelem</span></a> <span class='Operator'>= </span><a href="ts_typanalyze.c.html#LN286"><span class='Ref_To_Local'>track_len</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Generate MCELEM slot entry */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="ts_typanalyze.c.html#LN143"><span class='Ref_To_Local'>num_mcelem</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN350"></a>            <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>old_context</span><span class='Delimiter'>; 
</span><a name="LN351"></a>            <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>mcelem_values</span><span class='Delimiter'>; 
</span><a name="LN352"></a>            <a href="../../include/c.h.html#LN379"><span class='Ref_to_Typedef'>float4</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>mcelem_freqs</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * We want to store statistics sorted on the lexeme value using 
             * first length, then byte-for-byte comparison. The reason for 
             * doing length comparison first is that we don't care about the 
             * ordering so long as it's consistent, and comparing lengths 
             * first gives us a chance to avoid a strncmp() call. 
             * 
             * This is different from what we do with scalar statistics -- 
             * they get sorted on frequencies. The rationale is that we 
             * usually search through most common elements looking for a 
             * specific value, so we can grab its frequency.  When values are 
             * presorted we can employ binary search for that.  See 
             * ts_selfuncs.c for a real usage scenario. 
             */ 
</span>            <a href="../../include/port.h.html#LN439"><span class='Ref_to_Macro'>qsort</span></a><span class='Parentheses'>(</span><a href="ts_typanalyze.c.html#LN285"><span class='Ref_To_Local'>sort_table</span></a><span class='Delimiter'>, </span><a href="ts_typanalyze.c.html#LN143"><span class='Ref_To_Local'>num_mcelem</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../utils/adt/array_typanalyze.c.html#LN67"><span class='Ref_to_Typedef'>TrackItem</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                  <a href="ts_typanalyze.c.html#LN46"><span class='Ref_to_Proto'>trackitem_compare_lexemes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Must copy the target values into anl_context */ 
</span>            <a href="ts_typanalyze.c.html#LN350"><span class='Ref_To_Local'>old_context</span></a> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="ts_typanalyze.c.html#LN138"><span class='Ref_to_Parameter'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/vacuum.h.html#LN84"><span class='Ref_to_Member'>anl_context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * We sorted statistics on the lexeme value, but we want to be 
             * able to find out the minimal and maximal frequency without 
             * going through all the values.  We keep those two extra 
             * frequencies in two extra cells in mcelem_freqs. 
             * 
             * (Note: the MCELEM statistics slot definition allows for a third 
             * extra number containing the frequency of nulls, but we don't 
             * create that for a tsvector column, since null elements aren't 
             * possible.) 
             */ 
</span>            <a href="ts_typanalyze.c.html#LN351"><span class='Ref_To_Local'>mcelem_values</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="ts_typanalyze.c.html#LN143"><span class='Ref_To_Local'>num_mcelem</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="ts_typanalyze.c.html#LN352"><span class='Ref_To_Local'>mcelem_freqs</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN379"><span class='Ref_to_Typedef'>float4</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>((</span><a href="ts_typanalyze.c.html#LN143"><span class='Ref_To_Local'>num_mcelem</span></a> <span class='Operator'>+ </span><span class='Number'>2</span><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN379"><span class='Ref_to_Typedef'>float4</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * See comments above about use of nonnull_cnt as the divisor for 
             * the final frequency estimates. 
             */ 
</span>            <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="ts_typanalyze.c.html#LN284"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="ts_typanalyze.c.html#LN284"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="ts_typanalyze.c.html#LN143"><span class='Ref_To_Local'>num_mcelem</span></a><span class='Delimiter'>; </span><a href="ts_typanalyze.c.html#LN284"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN394"></a>                <a href="../utils/adt/array_typanalyze.c.html#LN67"><span class='Ref_to_Typedef'>TrackItem</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>item</span> <span class='Operator'>= </span><a href="ts_typanalyze.c.html#LN285"><span class='Ref_To_Local'>sort_table</span></a><span class='Delimiter'>[</span><a href="ts_typanalyze.c.html#LN284"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
                <a href="ts_typanalyze.c.html#LN351"><span class='Ref_To_Local'>mcelem_values</span></a><span class='Delimiter'>[</span><a href="ts_typanalyze.c.html#LN284"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= 
</span>                    <a href="../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="../../include/utils/builtins.h.html#LN86"><span class='Ref_to_Proto'>cstring_to_text_with_len</span></a><span class='Parentheses'>(</span><a href="ts_typanalyze.c.html#LN394"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><a href="ts_typanalyze.c.html#LN32"><span class='Ref_to_Member'>key</span></a><span class='Operator'>.</span><a href="ts_typanalyze.c.html#LN25"><span class='Ref_to_Member'>lexeme</span></a><span class='Delimiter'>, 
</span>                                                          <a href="ts_typanalyze.c.html#LN394"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><a href="ts_typanalyze.c.html#LN32"><span class='Ref_to_Member'>key</span></a><span class='Operator'>.</span><a href="ts_typanalyze.c.html#LN26"><span class='Ref_to_Member'>length</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <a href="ts_typanalyze.c.html#LN352"><span class='Ref_To_Local'>mcelem_freqs</span></a><span class='Delimiter'>[</span><a href="ts_typanalyze.c.html#LN284"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="ts_typanalyze.c.html#LN394"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><a href="ts_typanalyze.c.html#LN33"><span class='Ref_to_Member'>frequency</span></a> <span class='Operator'>/ </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="ts_typanalyze.c.html#LN283"><span class='Ref_To_Local'>nonnull_cnt</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <a href="ts_typanalyze.c.html#LN352"><span class='Ref_To_Local'>mcelem_freqs</span></a><span class='Delimiter'>[</span><a href="ts_typanalyze.c.html#LN284"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="ts_typanalyze.c.html#LN288"><span class='Ref_To_Local'>minfreq</span></a> <span class='Operator'>/ </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="ts_typanalyze.c.html#LN283"><span class='Ref_To_Local'>nonnull_cnt</span></a><span class='Delimiter'>; 
</span>            <a href="ts_typanalyze.c.html#LN352"><span class='Ref_To_Local'>mcelem_freqs</span></a><span class='Delimiter'>[</span><a href="ts_typanalyze.c.html#LN284"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="ts_typanalyze.c.html#LN289"><span class='Ref_To_Local'>maxfreq</span></a> <span class='Operator'>/ </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="ts_typanalyze.c.html#LN283"><span class='Ref_To_Local'>nonnull_cnt</span></a><span class='Delimiter'>; 
</span>            <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="ts_typanalyze.c.html#LN350"><span class='Ref_To_Local'>old_context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="ts_typanalyze.c.html#LN138"><span class='Ref_to_Parameter'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/vacuum.h.html#LN102"><span class='Ref_to_Member'>stakind</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/catalog/pg_statistic.h.html#LN256"><span class='Ref_to_Const'>STATISTIC_KIND_MCELEM</span></a><span class='Delimiter'>; 
</span>            <a href="ts_typanalyze.c.html#LN138"><span class='Ref_to_Parameter'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/vacuum.h.html#LN103"><span class='Ref_to_Member'>staop</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/catalog/pg_operator.h.html#LN135"><span class='Ref_to_Const'>TextEqualOperator</span></a><span class='Delimiter'>; 
</span>            <a href="ts_typanalyze.c.html#LN138"><span class='Ref_to_Parameter'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/vacuum.h.html#LN105"><span class='Ref_to_Member'>stanumbers</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="ts_typanalyze.c.html#LN352"><span class='Ref_To_Local'>mcelem_freqs</span></a><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* See above comment about two extra frequency fields */ 
</span>            <a href="ts_typanalyze.c.html#LN138"><span class='Ref_to_Parameter'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/vacuum.h.html#LN104"><span class='Ref_to_Member'>numnumbers</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="ts_typanalyze.c.html#LN143"><span class='Ref_To_Local'>num_mcelem</span></a> <span class='Operator'>+ </span><span class='Number'>2</span><span class='Delimiter'>; 
</span>            <a href="ts_typanalyze.c.html#LN138"><span class='Ref_to_Parameter'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/vacuum.h.html#LN107"><span class='Ref_to_Member'>stavalues</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="ts_typanalyze.c.html#LN351"><span class='Ref_To_Local'>mcelem_values</span></a><span class='Delimiter'>; 
</span>            <a href="ts_typanalyze.c.html#LN138"><span class='Ref_to_Parameter'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/vacuum.h.html#LN106"><span class='Ref_to_Member'>numvalues</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="ts_typanalyze.c.html#LN143"><span class='Ref_To_Local'>num_mcelem</span></a><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* We are storing text values */ 
</span>            <a href="ts_typanalyze.c.html#LN138"><span class='Ref_to_Parameter'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/vacuum.h.html#LN115"><span class='Ref_to_Member'>statypid</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN26"><span class='Ref_to_Const'>TEXTOID</span></a><span class='Delimiter'>; 
</span>            <a href="ts_typanalyze.c.html#LN138"><span class='Ref_to_Parameter'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/vacuum.h.html#LN116"><span class='Ref_to_Member'>statyplen</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* typlen, -1 for varlena */ 
</span>            <a href="ts_typanalyze.c.html#LN138"><span class='Ref_to_Parameter'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/vacuum.h.html#LN117"><span class='Ref_to_Member'>statypbyval</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="ts_typanalyze.c.html#LN138"><span class='Ref_to_Parameter'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/vacuum.h.html#LN118"><span class='Ref_to_Member'>statypalign</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='String'>'i'</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if num_mcelem&GT;0 &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if null_cnt&LT;samplerows &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* We found only nulls; assume the column is entirely null */ 
</span>        <a href="ts_typanalyze.c.html#LN138"><span class='Ref_to_Parameter'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/vacuum.h.html#LN98"><span class='Ref_to_Member'>stats_valid</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <a href="ts_typanalyze.c.html#LN138"><span class='Ref_to_Parameter'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/vacuum.h.html#LN99"><span class='Ref_to_Member'>stanullfrac</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="ts_typanalyze.c.html#LN138"><span class='Ref_to_Parameter'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/vacuum.h.html#LN100"><span class='Ref_to_Member'>stawidth</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* "unknown" */ 
</span>        <a href="ts_typanalyze.c.html#LN138"><span class='Ref_to_Parameter'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/vacuum.h.html#LN101"><span class='Ref_to_Member'>stadistinct</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* "unknown" */ 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We don't need to bother cleaning up any of our temporary palloc's. The 
     * hashtable should also go away, as it used a child memory context. 
     */ 
</span><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end compute_tsvector_stats &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *  A function to prune the D structure from the Lossy Counting algorithm. 
 *  Consult compute_tsvector_stats() for wider explanation. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN439"></a><span class='Declare_Function'>prune_lexemes_hashtable</span><span class='Parentheses'>(</span><a href="../utils/hash/dynahash.c.html#LN192"><span class='Ref_to_Struct'>HTAB</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>lexemes_tab</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>b_current</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN441"></a>    <a href="../../include/utils/hsearch.h.html#LN111"><span class='Ref_to_Typedef'>HASH_SEQ_STATUS</span></a> <span class='Declare_Local'>scan_status</span><span class='Delimiter'>; 
</span><a name="LN442"></a>    <a href="../utils/adt/array_typanalyze.c.html#LN67"><span class='Ref_to_Typedef'>TrackItem</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>item</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/utils/hsearch.h.html#LN134"><span class='Ref_to_Proto'>hash_seq_init</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="ts_typanalyze.c.html#LN441"><span class='Ref_To_Local'>scan_status</span></a><span class='Delimiter'>, </span><a href="ts_typanalyze.c.html#LN439"><span class='Ref_to_Parameter'>lexemes_tab</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>((</span><a href="ts_typanalyze.c.html#LN442"><span class='Ref_To_Local'>item</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../utils/adt/array_typanalyze.c.html#LN67"><span class='Ref_to_Typedef'>TrackItem</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/utils/hsearch.h.html#LN135"><span class='Ref_to_Proto'>hash_seq_search</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="ts_typanalyze.c.html#LN441"><span class='Ref_To_Local'>scan_status</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="ts_typanalyze.c.html#LN442"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><a href="ts_typanalyze.c.html#LN33"><span class='Ref_to_Member'>frequency</span></a> <span class='Operator'>+ </span><a href="ts_typanalyze.c.html#LN442"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><a href="ts_typanalyze.c.html#LN34"><span class='Ref_to_Member'>delta</span></a> <span class='Operator'>&LT;= </span><a href="ts_typanalyze.c.html#LN439"><span class='Ref_to_Parameter'>b_current</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/utils/hsearch.h.html#LN125"><span class='Ref_to_Proto'>hash_search</span></a><span class='Parentheses'>(</span><a href="ts_typanalyze.c.html#LN439"><span class='Ref_to_Parameter'>lexemes_tab</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="ts_typanalyze.c.html#LN442"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><a href="ts_typanalyze.c.html#LN32"><span class='Ref_to_Member'>key</span></a><span class='Delimiter'>, 
</span>                            <a href="../../include/utils/hsearch.h.html#LN106"><span class='Ref_to_EnumConst'>HASH_REMOVE</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
                <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"hash table corrupted"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Hash functions for lexemes. They are strings, but not NULL terminated, 
 * so we need a special hash function. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> 
<a name="LN461"></a><span class='Declare_Function'>lexeme_hash</span><span class='Parentheses'>(</span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>key</span><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a> <span class='Declare_Parameter'>keysize</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN463"></a>    <span class='Keyword'>const </span><a href="ts_typanalyze.c.html#LN23"><span class='Ref_to_Typedef'>LexemeHashKey</span></a> <span class='Operator'>*</span><span class='Declare_Local'>l</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="ts_typanalyze.c.html#LN23"><span class='Ref_to_Typedef'>LexemeHashKey</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="ts_typanalyze.c.html#LN461"><span class='Ref_to_Parameter'>key</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="../../include/postgres.h.html#LN491"><span class='Ref_to_Macro'>DatumGetUInt32</span></a><span class='Parentheses'>(</span><a href="../access/hash/hashfunc.c.html#LN305"><span class='Ref_to_Func'>hash_any</span></a><span class='Parentheses'>((</span><span class='Keyword'>const unsigned char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="ts_typanalyze.c.html#LN463"><span class='Ref_To_Local'>l</span></a><span class='Operator'>-&GT;</span><a href="ts_typanalyze.c.html#LN25"><span class='Ref_to_Member'>lexeme</span></a><span class='Delimiter'>, 
</span>                                   <a href="ts_typanalyze.c.html#LN463"><span class='Ref_To_Local'>l</span></a><span class='Operator'>-&GT;</span><a href="ts_typanalyze.c.html#LN26"><span class='Ref_to_Member'>length</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *  Matching function for lexemes, to be used in hashtable lookups. 
 */ 
</span><span class='Keyword'>static int 
</span><a name="LN473"></a><span class='Declare_Function'>lexeme_match</span><span class='Parentheses'>(</span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>key1</span><span class='Delimiter'>, </span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>key2</span><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a> <span class='Declare_Parameter'>keysize</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* The keysize parameter is superfluous, the keys store their lengths */ 
</span>    <span class='Control'>return</span> <a href="ts_typanalyze.c.html#LN44"><span class='Ref_to_Proto'>lexeme_compare</span></a><span class='Parentheses'>(</span><a href="ts_typanalyze.c.html#LN473"><span class='Ref_to_Parameter'>key1</span></a><span class='Delimiter'>, </span><a href="ts_typanalyze.c.html#LN473"><span class='Ref_to_Parameter'>key2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *  Comparison function for lexemes. 
 */ 
</span><span class='Keyword'>static int 
</span><a name="LN483"></a><span class='Declare_Function'>lexeme_compare</span><span class='Parentheses'>(</span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>key1</span><span class='Delimiter'>, </span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>key2</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN485"></a>    <span class='Keyword'>const </span><a href="ts_typanalyze.c.html#LN23"><span class='Ref_to_Typedef'>LexemeHashKey</span></a> <span class='Operator'>*</span><span class='Declare_Local'>d1</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="ts_typanalyze.c.html#LN23"><span class='Ref_to_Typedef'>LexemeHashKey</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="ts_typanalyze.c.html#LN483"><span class='Ref_to_Parameter'>key1</span></a><span class='Delimiter'>; 
</span><a name="LN486"></a>    <span class='Keyword'>const </span><a href="ts_typanalyze.c.html#LN23"><span class='Ref_to_Typedef'>LexemeHashKey</span></a> <span class='Operator'>*</span><span class='Declare_Local'>d2</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="ts_typanalyze.c.html#LN23"><span class='Ref_to_Typedef'>LexemeHashKey</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="ts_typanalyze.c.html#LN483"><span class='Ref_to_Parameter'>key2</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* First, compare by length */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="ts_typanalyze.c.html#LN485"><span class='Ref_To_Local'>d1</span></a><span class='Operator'>-&GT;</span><a href="ts_typanalyze.c.html#LN26"><span class='Ref_to_Member'>length</span></a> <span class='Operator'>&GT; </span><a href="ts_typanalyze.c.html#LN486"><span class='Ref_To_Local'>d2</span></a><span class='Operator'>-&GT;</span><a href="ts_typanalyze.c.html#LN26"><span class='Ref_to_Member'>length</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="ts_typanalyze.c.html#LN485"><span class='Ref_To_Local'>d1</span></a><span class='Operator'>-&GT;</span><a href="ts_typanalyze.c.html#LN26"><span class='Ref_to_Member'>length</span></a> <span class='Operator'>&LT; </span><a href="ts_typanalyze.c.html#LN486"><span class='Ref_To_Local'>d2</span></a><span class='Operator'>-&GT;</span><a href="ts_typanalyze.c.html#LN26"><span class='Ref_to_Member'>length</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* Lengths are equal, do a byte-by-byte comparison */ 
</span>    <span class='Control'>return</span> strncmp<span class='Parentheses'>(</span><a href="ts_typanalyze.c.html#LN485"><span class='Ref_To_Local'>d1</span></a><span class='Operator'>-&GT;</span><a href="ts_typanalyze.c.html#LN25"><span class='Ref_to_Member'>lexeme</span></a><span class='Delimiter'>, </span><a href="ts_typanalyze.c.html#LN486"><span class='Ref_To_Local'>d2</span></a><span class='Operator'>-&GT;</span><a href="ts_typanalyze.c.html#LN25"><span class='Ref_to_Member'>lexeme</span></a><span class='Delimiter'>, </span><a href="ts_typanalyze.c.html#LN485"><span class='Ref_To_Local'>d1</span></a><span class='Operator'>-&GT;</span><a href="ts_typanalyze.c.html#LN26"><span class='Ref_to_Member'>length</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *  qsort() comparator for sorting TrackItems on frequencies (descending sort) 
 */ 
</span><span class='Keyword'>static int 
</span><a name="LN501"></a><span class='Declare_Function'>trackitem_compare_frequencies_desc</span><span class='Parentheses'>(</span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>e1</span><span class='Delimiter'>, </span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>e2</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN503"></a>    <span class='Keyword'>const </span><a href="../utils/adt/array_typanalyze.c.html#LN67"><span class='Ref_to_Typedef'>TrackItem</span></a> <span class='Operator'>*</span><span class='Keyword'>const </span><span class='Operator'>* </span><span class='Declare_Local'>t1</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../utils/adt/array_typanalyze.c.html#LN67"><span class='Ref_to_Typedef'>TrackItem</span></a> <span class='Operator'>*</span><span class='Keyword'>const </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="ts_typanalyze.c.html#LN501"><span class='Ref_to_Parameter'>e1</span></a><span class='Delimiter'>; 
</span><a name="LN504"></a>    <span class='Keyword'>const </span><a href="../utils/adt/array_typanalyze.c.html#LN67"><span class='Ref_to_Typedef'>TrackItem</span></a> <span class='Operator'>*</span><span class='Keyword'>const </span><span class='Operator'>* </span><span class='Declare_Local'>t2</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../utils/adt/array_typanalyze.c.html#LN67"><span class='Ref_to_Typedef'>TrackItem</span></a> <span class='Operator'>*</span><span class='Keyword'>const </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="ts_typanalyze.c.html#LN501"><span class='Ref_to_Parameter'>e2</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="ts_typanalyze.c.html#LN504"><span class='Ref_To_Local'>t2</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>frequency <span class='Operator'>- </span><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="ts_typanalyze.c.html#LN503"><span class='Ref_To_Local'>t1</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span><a href="ts_typanalyze.c.html#LN33"><span class='Ref_to_Member'>frequency</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *  qsort() comparator for sorting TrackItems on lexemes 
 */ 
</span><span class='Keyword'>static int 
</span><a name="LN513"></a><span class='Declare_Function'>trackitem_compare_lexemes</span><span class='Parentheses'>(</span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>e1</span><span class='Delimiter'>, </span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>e2</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN515"></a>    <span class='Keyword'>const </span><a href="../utils/adt/array_typanalyze.c.html#LN67"><span class='Ref_to_Typedef'>TrackItem</span></a> <span class='Operator'>*</span><span class='Keyword'>const </span><span class='Operator'>* </span><span class='Declare_Local'>t1</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../utils/adt/array_typanalyze.c.html#LN67"><span class='Ref_to_Typedef'>TrackItem</span></a> <span class='Operator'>*</span><span class='Keyword'>const </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="ts_typanalyze.c.html#LN513"><span class='Ref_to_Parameter'>e1</span></a><span class='Delimiter'>; 
</span><a name="LN516"></a>    <span class='Keyword'>const </span><a href="../utils/adt/array_typanalyze.c.html#LN67"><span class='Ref_to_Typedef'>TrackItem</span></a> <span class='Operator'>*</span><span class='Keyword'>const </span><span class='Operator'>* </span><span class='Declare_Local'>t2</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../utils/adt/array_typanalyze.c.html#LN67"><span class='Ref_to_Typedef'>TrackItem</span></a> <span class='Operator'>*</span><span class='Keyword'>const </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="ts_typanalyze.c.html#LN513"><span class='Ref_to_Parameter'>e2</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="ts_typanalyze.c.html#LN44"><span class='Ref_to_Proto'>lexeme_compare</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="ts_typanalyze.c.html#LN515"><span class='Ref_To_Local'>t1</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span><a href="ts_typanalyze.c.html#LN32"><span class='Ref_to_Member'>key</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="ts_typanalyze.c.html#LN516"><span class='Ref_To_Local'>t2</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span><a href="ts_typanalyze.c.html#LN32"><span class='Ref_to_Member'>key</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span></pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>